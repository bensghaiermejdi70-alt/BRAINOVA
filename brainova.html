          9: { title: '🔮 Cyber Checker', desc: 'Kleines Logik-Minispiel.' },
          10: { title: '🚀 Demo Playground', desc: 'Demo-Bereich — spielerische Prototypen.' },
          11: { title: 'Quantum Monopoly', desc: 'Brettspiel neu gedacht mit Quanten-Transaktionen.' },
          12: { title: 'Quantum Poker', desc: 'Futuristisches Poker — Einsätze und Wahrscheinlichkeiten.' },
          13: { title: 'Blackjack Quantum', desc: 'Quantum Blackjack — Einsätze und Strategie.' },
          14: { title: 'Solitaire Fusion', desc: 'Solitaire Fusion — Stapel kombinieren, um zu gewinnen.' },
          15: { title: 'NeuroSynth Explorer', desc: 'Erkunde neuronale Synths — Premium-Inhalte.' },
          16: { title: 'Enigma Hunter', desc: 'Rätseljagd — Rätsel und Hinweise.' },
          17: { title: 'CyberRace Nexus', desc: 'Futuristische Rennen — 3D-Prototypen.' },
          18: { title: 'QUANTUM WARFARE 2.0', desc: 'Weltraumkampf — Echtzeit-Strategie.' },
          19: { title: 'Quantum Dots', desc: 'Punkte-Puzzle — verbinde die Quantenpunkte.' },
          20: { title: 'AI Sudoku', desc: 'Sudoku mit KI-Unterstützung — verschiedene Schwierigkeitsgrade.' },
          21: { title: 'Pharaoh Cyber', desc: 'Ägypten-Abenteuer — historische Rätsel.' },
          22: { title: 'Quantum Pipes', desc: 'Verbinde die Quantenrohre.' },
          23: { title: 'Neural Slot', desc: 'KI-Spielautomat — Freispiele & Boni.' },
          24: { title: 'Neural Dice', desc: 'Futuristisches Würfelspiel — schnelle Würfe.' },
          25: { title: 'Quantum Bubbles', desc: 'Quantenblasen platzen lassen, um Punkte zu erzielen.' },
          26: { title: 'Cyber Defense AI', desc: 'Verteidige das Netzwerk — Cyberabwehrstrategie.' },
          27: { title: 'Cyber Pool', desc: 'Futuristisches Billard — Solo- & Mehrspielermodi.' },
          28: { title: 'Quantum Tiles', desc: 'Kachel-Puzzle — kombinieren, um zu löschen.' },
          29: { title: 'Genius Quest', desc: 'Mehrsprachiges Quiz — teste dein Wissen.' },
          30: { title: 'Space Explorer', desc: 'Weltraumabenteuer — erkunde Planeten.' },
          31: { title: 'NeuroSphere', desc: 'KI-Brettspiel — kooperiere oder konkurriere.' },
          32: { title: 'Skyjo Futuristic', desc: 'Futuristische Skyjo-Variante.' },
          33: { title: 'STELLAR NEXUS', desc: 'Interaktives Weltraumspiel — Kämpfe & Erkundung.' },
          34: { title: 'Dixit Futuristic', desc: 'Phantasiereise — narrative Karten.' },
          35: { title: 'Cyber Warrior', desc: 'Futuristisches RPG — Missionen & Levelaufstieg.' },
          36: { title: 'Crystal Quest', desc: 'Rätsel im Raum — sammle Kristalle.' }
        },
        zh: {
          0: { title: '🧪 智商测试', desc: '智商测试 — 验证卡' },
          1: { title: '🧩 量子俄罗斯方块', desc: '量子俄罗斯方块 — 排列方块并利用叠加得分。' },
          2: { title: '🧠 量子记忆', desc: '量子记忆 — 翻牌并找出匹配的量子状态。' },
          3: { title: '🧩 神经谜题大师', desc: '神经谜题 — 挑战你的逻辑。' },
          4: { title: '♛ 量子国际象棋', desc: '量子国际象棋 — 策略与叠加机制。' },
          5: { title: '🔥 量子跳棋', desc: '未来跳棋 — 经典规则与高级AI。' },
          6: { title: '🌟 量子吃豆人', desc: '吃豆人重制版，带有量子幽灵。' },
          7: { title: '🎮 西蒙说', desc: '重复序列 — 测试你的记忆。' },
          8: { title: '🚀 速度挑战', desc: '速度挑战 — 反应与反射。' },
          9: { title: '🔮 网络检查器', desc: '智能检查 — 小型逻辑小游戏。' },
          10: { title: '🚀 演示游乐场', desc: '演示区 — 有趣的原型。' },
          11: { title: '量子大富翁', desc: '采用量子交易的桌游重制版。' },
          12: { title: '量子扑克', desc: '未来扑克 — 赌注与量子概率。' },
          13: { title: '量子二十一点', desc: '量子二十一点 — 赌注与策略。' },
          14: { title: '融合纸牌', desc: '融合纸牌 — 合并牌堆以获胜。' },
          15: { title: '神经合成探索者', desc: '探索神经合成 — 高级内容。' },
          16: { title: '谜题猎人', desc: '谜题狩猎 — 线索与谜题。' },
          17: { title: '网络赛道枢纽', desc: '未来赛道 — 3D 原型。' },
          18: { title: '量子战争 2.0', desc: '太空战 — 实时策略。' },
          19: { title: '量子点', desc: '点点拼图 — 连接量子点。' },
          20: { title: 'AI 数独', desc: '由 AI 协助的数独 — 多个难度级别。' },
          21: { title: '法老网络', desc: '埃及冒险 — 历史谜题。' },
          22: { title: '量子管道', desc: '连接量子管道。' },
          23: { title: '神经老虎机', desc: 'AI 老虎机 — 免费旋转与奖励。' },
          24: { title: '神经骰子', desc: '未来骰子游戏 — 快速掷骰。' },
          25: { title: '量子泡泡', desc: '炸掉量子泡泡以得分。' },
          26: { title: '网络防御 AI', desc: '保护网络 — 网络防御策略。' },
          27: { title: '网络台球', desc: '未来台球 — 单人与多人模式。' },
          28: { title: '量子瓦片', desc: '瓦片拼图 — 组合以清除。' },
          29: { title: '天才任务', desc: '多语言测验 — 测试你的知识。' },
          30: { title: '太空探险者', desc: '太空冒险 — 探索行星。' },
          31: { title: '神经球体', desc: 'AI 桌游 — 合作或竞争。' },
          32: { title: '未来 Skyjo', desc: '未来版 Skyjo 变体。' },
          33: { title: 'STELLAR NEXUS', desc: '互动太空游戏 — 战斗与探索。' },
          34: { title: '未来 Dixit', desc: '想象之旅 — 叙事卡牌。' },
          35: { title: '网络战士', desc: '未来 RPG — 任务与升级。' },
          36: { title: '水晶探险', desc: '空间谜题 — 收集水晶。' }
        }
      };

      function getGameMeta(i, lang){
        const base = gameMap[i] || { file: null, title: `Jeu ${i}`, desc: 'Cliquez pour ouvrir', icon: '🎮' };
        const overrides = (gameTranslations[lang] && gameTranslations[lang][i]) ? gameTranslations[lang][i] : {};
        return Object.assign({}, base, overrides);
      }

      // Build a card using GamesIndex when available, otherwise fall back to inline gameMap
      function makeCard(i){
        const div = document.createElement('div'); div.className='game-card'; div.dataset.gameId=i; div.style.position='relative';
        // If GamesIndex is available prefer its markup and helpers
        try{
          if(window.GamesIndex && typeof window.GamesIndex.getCardHTML === 'function'){
            const html = window.GamesIndex.getCardHTML(String(i)) || '';
            div.innerHTML = html || '';
            // allow GamesIndex to provide outer style
            if(typeof window.GamesIndex.getCardStyle === 'function'){
              const styleText = window.GamesIndex.getCardStyle(String(i)) || '';
              if(styleText) div.style.cssText += styleText;
            }
            // Attach launch handler
            div.addEventListener('click', ()=>{ try{ window.GamesIndex.launch(Number(i)); }catch(e){ openGame(i); } });
            return div;
          }
        }catch(e){ /* ignore and fallback to inline rendering */ }

        // Fallback: use local gameMap rendering
        const meta = getGameMeta(i, currentLang);
        div.dataset.file = (gameMap[i] && gameMap[i].file) ? gameMap[i].file : '';
        // Ensure card 0 has the special cyan/teal accent even if GamesIndex failed to load.
        try{ if(Number(i) === 0){ const accent = 'background:linear-gradient(180deg,#cceff7,#33c9ff);border-color:#33c9ff;color:#001;box-shadow:0 10px 30px rgba(51,201,255,0.22);border-radius:10px;'; div.style.cssText += accent; } }catch(e){}
        div.innerHTML = `
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
            <div class="game-number">${String(i).padStart(2,'0')}</div>
            <div class="game-status">--</div>
          </div>
          <div class="game-icon">${meta.icon || '🎮'}</div>
          <h3>${meta.title}</h3>
          <p style="text-align:center;color:#cfefff">${meta.desc || 'Cliquez pour ouvrir'}</p>
        `;
  // premium badge for card 11..36 (remove badge for card 0)
  try{ const idn = Number(i); if(idn >= 11 && idn <= 36){ const badge = document.createElement('div'); badge.className = 'game-badge'; badge.title = 'Premium'; badge.innerHTML = '👑'; div.appendChild(badge); } }catch(e){}
        try{ if(Number(i) === 0){ div.style.color = '#000'; const p = div.querySelector('p'); if(p) p.style.color = '#000'; } }catch(e){}
        div.addEventListener('click', ()=>openGame(i));
        
        return div;
      }

      // Re-render the entire grid (used when language changes)
      function renderGrid(){
        grid.innerHTML = '';
        // include 0..total so Test QI (id 0) appears before the other games
        for(let i=0;i<=total;i++) grid.appendChild(makeCard(i));
      }

  // initial render (0..total)
  for(let i=0;i<=total;i++) grid.appendChild(makeCard(i));

  // Apply the saved/initial language and make header visible
  try{ applyLanguage(currentLang); }catch(e){}
  try{ const hdr = document.getElementById('header'); if(hdr) hdr.style.display = 'flex'; }catch(e){}

  // Default: enable no-server only when opened via file://; when served over HTTP use iframe overlay by default
  let noServerMode = (location.protocol === 'file:');
      const noServerBtn = document.getElementById('noServerBtn');
      function updateNoServerUI(){
        noServerBtn.style.background = noServerMode ? 'linear-gradient(45deg,#ffd700,#00ff88)' : '';
        noServerBtn.textContent = noServerMode ? 'Mode sans serveur (ON)' : 'Mode sans serveur';
      }
  updateNoServerUI();
  // If we are running via file://, keep no-server; if we are running via http and user wants iframe, they can toggle off
      noServerBtn.addEventListener('click', ()=>{ noServerMode = !noServerMode; updateNoServerUI(); });

      function openGame(id){
        const meta = gameMap[id] || {};
        // resolve filename: prefer explicit file, else fallbacks
        const candidates = [];
        if(meta.file) candidates.push(meta.file);
        candidates.push(`./jeux${id}.html`);
        candidates.push(`./jeux${id}.html.html`);
        const chosen = (cardFileExists => cardFileExists)();
        // If no-server or file protocol, open in new tab using first candidate
        const finalFile = meta.file || `./jeux${id}.html`;
        if(noServerMode){
          window.open(finalFile,'_blank');
          return;
        }
        // When running via server, try to load the first candidate that responds
        titleEl.textContent = meta.title || `Jeu ${id}`;
        // Try to set iframe src to meta.file first
          // Resolve relative URL to absolute for clearer logs and normalize it
            let resolvedUrl = meta.file || `./jeux${id}.html`;
            try{
              resolvedUrl = new URL(resolvedUrl, window.location.href).href;
            }catch(err){ /* keep raw */ }
            const safeUrl = normalizeUrl(resolvedUrl);
            console.debug(`global_platform.openGame id=${id} resolved='${resolvedUrl}' safe='${safeUrl}'`);

            // Try setting src first
            try{ iframe.src = safeUrl; }catch(e){ console.warn('iframe.src assignment failed', e); }

            // Also attempt a quick HEAD to detect 404 and fallback if necessary
            fetch(safeUrl, { method: 'HEAD' }).then(r=>{
              if(!r.ok){
                // fallback: fetch html and set srcdoc with <base>
                return fetch(safeUrl).then(r2=>{ if(!r2.ok) throw new Error('HTTP '+r2.status); return r2.text(); }).then(html=>{
                  const dir = safeUrl.split('/').slice(0,-1).join('/') || '.';
                  const base = `<base href="${dir}/">`;
                  iframe.srcdoc = base + html;
                  console.debug(`global_platform.openGame id=${id} srcdoc fallback set`);
                });
              }
            }).catch(err=>{
              console.warn('Setting iframe.src or HEAD check failed, trying fetch+srcdoc fallback', err);
              fetch(safeUrl).then(r=>{ if(!r.ok) throw new Error('HTTP '+r.status); return r.text(); }).then(html=>{
                const dir = safeUrl.split('/').slice(0,-1).join('/') || '.';
                const base = `<base href="${dir}/">`;
                iframe.srcdoc = base + html;
                console.debug(`global_platform.openGame id=${id} srcdoc fallback set`);
              }).catch(err2=>{
                console.error('Failed to fetch game HTML for overlay', safeUrl, err2);
                showOverlayError('Impossible de charger le jeu dans l’overlay. Ouvrir dans un nouvel onglet.');
              });
            });
        // If opening game 1 (custom page with its own exit UI), hide the platform close button
        try{ if(Number(id) === 1){ closeBtn.style.display = 'none'; } else { closeBtn.style.display = ''; } }catch(e){}
        overlay.classList.add('active');
        document.addEventListener('keydown', escClose);
      }

      // Open authentication page (mode = 'login' or 'signup') in overlay
      async function openAuth(mode){
        const target = './connexion et profil.html' + (mode ? `?mode=${encodeURIComponent(mode)}` : '');
        if(noServerMode){ window.open(target, '_blank'); return; }
        titleEl.textContent = (mode === 'signup') ? 'Inscription' : 'Connexion';
        // quick HEAD check to ensure reachable
        try{
          const r = await fetch(target, { method: 'HEAD' });
          if(!r.ok) throw new Error('HTTP '+r.status);
          // reachable -> set iframe.src (percent-encode to handle spaces)
          try{
            const tgt = new URL(target, window.location.href).href;
            iframe.src = normalizeUrl(tgt);
          }catch(e){ try{ iframe.src = normalizeUrl(target); }catch(_){} }
          overlay.classList.add('active');
          document.addEventListener('keydown', escClose);
          return;
        }catch(err){
          console.warn('Auth target unreachable in overlay, opening new tab', err);
          // fallback to new tab
          window.open(target, '_blank');
          return;
        }
      }

      function closeGame(){
        try{ document.removeEventListener('keydown', escClose); }catch(e){}
        try{ overlay.classList.remove('active'); }catch(e){}
        try{ iframe.src = 'about:blank'; }catch(e){}
        try{ iframe.srcdoc = ''; iframe.removeAttribute('srcdoc'); }catch(e){}
        try{ document.getElementById('loader').style.display = 'none'; }catch(e){}
        try{ document.getElementById('header').style.display = 'flex'; }catch(e){}
        try{ closeBtn.style.display = ''; }catch(e){}
        try{ window.scrollTo(0,0); }catch(e){}
      }

      function showOverlayError(msg){
        try{
          // show a simple HTML error message in the iframe so user sees why it failed
          const errHtml = `<div style="display:flex;flex-direction:column;align-items:center;justify-content:center;height:100%;color:#fff;background:#111;padding:20px;font-family:Rajdhani,Segoe UI,Arial">
            <h2>Erreur de chargement</h2>
            <p style="max-width:800px;text-align:center">${String(msg)}</p>
            <p style="margin-top:12px"><button onclick="window.parent.postMessage({action:'close'},'*')" style="padding:8px 12px;border-radius:6px;border:0;cursor:pointer;background:#00d4ff;color:#000;font-weight:700">Fermer</button></p>
          </div>`;
          iframe.srcdoc = errHtml;
        }catch(e){/* ignore */}
      }

      function escClose(e){ if(e.key==="Escape") closeGame(); }

      closeBtn.addEventListener('click', closeGame);
      overlay.addEventListener('click', (e)=>{ if(e.target===overlay) closeGame(); });

      // Provide a lightweight OverlayManager API so games loaded in iframe
      // can request the parent to open/close the overlay via postMessage.
      // This ensures third-party game pages can call window.parent.postMessage({action:'close'})
      // and the platform will close the iframe properly.
      window.OverlayManager = window.OverlayManager || {
        open: function(url, title){
          try{
            // If caller passed a numeric id (or a numeric string), delegate to openGame
            if(typeof url === 'number' || (/^\d+$/.test(String(url)))){
              try{ openGame(Number(url)); return; }catch(e){}
            }
            // If caller passed a path/URL (contains '.html' or starts with ./ or / or http), set iframe.src directly
            if(typeof url === 'string' && (url.indexOf('.html') !== -1 || url.startsWith('./') || url.startsWith('/') || url.startsWith('http'))){
              try{
                if(title) try{ titleEl.textContent = title; }catch(e){}
                overlay.classList.add('active');
                console.debug('OverlayManager.open: setting iframe.src =', url);
                iframe.src = url;
                return;
              }catch(e){}
            }
            // Fallback: try openGame (may accept id)
            try{ openGame(url, title); }catch(e){ /* ignore */ }
          }catch(e){
            try{ overlay.classList.add('active'); iframe.src = url; }catch(e2){}
          }
        },
        close: function(){ try{ closeGame(); }catch(e){} }
      };

      // Listen for postMessage from iframe children. Expected payload examples:
      // { action: 'close', reason: 'user-initiated', source: 'jeux2' }
      // { action: 'go-home', source: 'jeux2' }
      window.addEventListener('message', function(ev){
        try{
          const data = ev && ev.data;
          if(!data || typeof data !== 'object') return;
          // close action => close overlay; optionally navigate if child asks to go home
          if(data.action === 'close' || data.action === 'close-overlay'){
            try{ closeGame(); }catch(e){}
            return;
          }
          if(data.action === 'go-home' || data.action === 'navigate-home'){
            try{ closeGame(); }catch(e){}
            try{ window.location.href = new URL('./brainova.html', window.location.href).href; }catch(e){}
            return;
          }
          // other actions can be handled here in the future
        }catch(e){ /* ignore malformed messages */ }
      });

      // Robust iframe load handler — diagnose and detect platform pages loaded inside iframe
      iframe.addEventListener('load', ()=>{
        try{
          const src = String(iframe.src || '');
          console.debug('overlay iframe loaded', { src });

          // Quick URL-based heuristic
          const looksLikePlatformURL = (u)=> !!(u && (u.indexOf('global_platform.html') !== -1 || u.indexOf('global_platform_correct.html') !== -1 || u.indexOf('/global/') !== -1));
          if(looksLikePlatformURL(src)){
            console.debug('iframe.src looks like platform -> closing overlay');
            try{ closeGame(); }catch(e){}
            try{ window.location.href = new URL('./brainova.html', window.location.href).href; }catch(e){}
            showAutoCloseToast();
            return;
          }

          // If same-origin, inspect the iframe's document for platform markers
          try{
            const cw = iframe.contentWindow;
            if(cw && cw.document){
              const title = String(cw.document.title || '');
              const bodyText = (cw.document.body && cw.document.body.innerText) ? cw.document.body.innerText : '';
              console.debug('iframe document title:', title);
              // marker: hero title or gamesGrid element
              const hasGamesGrid = !!cw.document.getElementById('gamesGrid');
              const looksLikePlatformDoc = hasGamesGrid || /Catalogue Brainova|36 JEUX|Catalogue Brainova/i.test(title + '\n' + bodyText);
              if(looksLikePlatformDoc){
                console.debug('iframe document looks like platform (title/body/selector match) -> closing overlay');
                try{ closeGame(); }catch(e){}
                try{ window.location.href = new URL('./brainova.html', window.location.href).href; }catch(e){}
                showAutoCloseToast();
                return;
              }
            }
          }catch(e){ console.debug('iframe doc inspection failed (cross-origin?)', e); }

        }catch(e){ console.warn('Error in iframe load handler', e); }
      });

      // Small non-blocking toast to inform user the overlay was auto-closed
      function showAutoCloseToast(){
        try{
          const id = 'autoCloseToast';
          if(document.getElementById(id)) return;
          const div = document.createElement('div');
          div.id = id;
          div.textContent = 'Retour à la plateforme';
          div.style.cssText = 'position:fixed;bottom:18px;left:50%;transform:translateX(-50%);background:linear-gradient(90deg,#00d4ff,#00ff88);color:#001;padding:8px 12px;border-radius:8px;z-index:10005;font-weight:700;box-shadow:0 8px 24px rgba(0,0,0,0.4);';
          document.body.appendChild(div);
          setTimeout(()=>{ try{ div.style.transition='opacity .4s'; div.style.opacity='0'; setTimeout(()=>div.remove(),450); }catch(e){} }, 900);
        }catch(e){}
      }
      iframe.addEventListener('error', (ev)=>{
        try{ console.error('overlay iframe error loading', iframe.src, ev); }catch(e){}
      });

      // Allow games inside the iframe to communicate with the parent page using postMessage.
      // For example the game can call: window.parent.postMessage({ action: 'close' }, '*')
      // or { action: 'home' } to request closing the overlay / returning to the platform.
      window.addEventListener('message', (ev)=>{
        try{
          // Normalize payload: many games send either objects or JSON strings
          let data = ev && ev.data ? ev.data : null;
          if(!data) return;
          if(typeof data === 'string'){
            try{ data = JSON.parse(data); }catch(_){ /* not JSON - ignore */ }
          }
          if(!data || typeof data !== 'object') return;
          const action = data.action && String(data.action).toLowerCase();
          if(!action) return;
          if(action === 'close' || action === 'exit' || action === 'home' || action === 'go-home'){
            try{ closeGame(); }catch(e){}
            try{ /* also return to platform home (reload) for a clear UX) */ window.location.href = new URL('./brainova.html', window.location.href).href; }catch(e){}
            return;
          }
          if(action === 'open' && data.url){
            try{ window.open(String(data.url), '_blank'); }catch(e){}
            return;
          }
          if(action === 'navigate' && data.url){
            try{ window.location.href = String(data.url); }catch(e){}
            return;
          }
        }catch(err){ /* ignore malformed messages */ }
      });

      // show header after load
      window.addEventListener('load', ()=>{
        document.getElementById('loader').style.display='none';
        document.getElementById('header').style.display='flex';
        // wire auth buttons
        const b1 = document.getElementById('btnLogin'); if(b1) b1.addEventListener('click', ()=>openAuth('login'));
        const b2 = document.getElementById('btnSignup'); if(b2) b2.addEventListener('click', ()=>openAuth('signup'));
  // show saved sigle if user already logged in
        try{
          const saved = localStorage.getItem('brainovaUser');
          if(saved){
            const u = JSON.parse(saved);
            const sig = (u.avatar && u.avatar.length>0) ? u.avatar : (u.name?u.name.split(' ').map(n=>n.charAt(0)).join('').toUpperCase():'');
            const sigEl = document.getElementById('userSigle');
            if(sigEl && sig){ sigEl.textContent = sig; sigEl.style.display='flex'; }
          }
        }catch(e){/* ignore */}
        // populate the local state bar (helps in file:// mode)
        try{
          function updateLocalStateBar(){
            const txt = document.getElementById('localStateText'); if(!txt) return;
            try{
              const bundle = localStorage.getItem('bundlePurchased') === '1';
              const parts = [];
              if(bundle) parts.push('bundlePurchased=1');
              for(let i=0;i<=36;i++){ if(localStorage.getItem('purchased_game_'+i) === '1') parts.push('purchased_game_'+i+'=1'); }
              txt.textContent = parts.length ? ('État local: ' + parts.join(' | ')) : 'État local: aucun achat détecté';
            }catch(e){ txt.textContent = 'État local: erreur de lecture'; }
          }
          const rbtn = document.getElementById('localStateRefresh'); if(rbtn) rbtn.addEventListener('click', updateLocalStateBar);
          const cbtn = document.getElementById('localStateClear'); if(cbtn) cbtn.addEventListener('click', ()=>{ if(!confirm('Supprimer bundlePurchased et tous les flags purchased_game_* ?')) return; localStorage.removeItem('bundlePurchased'); for(let i=0;i<=36;i++) localStorage.removeItem('purchased_game_'+i); updateLocalStateBar(); alert('Flags supprimés'); });
          updateLocalStateBar();
        }catch(e){}
        // initialize single language select
        const langSelect = document.getElementById('langSelect');
        const LangMeta = { fr:{emoji:'🇫🇷', label:'FR'}, en:{emoji:'🇬🇧', label:'EN'}, ar:{emoji:'🇸🇦', label:'AR'}, es:{emoji:'🇪🇸', label:'ES'}, de:{emoji:'🇩🇪', label:'DE'}, zh:{emoji:'🇨🇳', label:'中文'} };

        function updateLangPickerUI(lang){
          try{
            if(langSelect) {
              langSelect.value = lang;
              // update visible label is already handled by the select's option text
            }
          }catch(e){/* ignore */}
        }

        // handle selection
        if(langSelect){
          langSelect.addEventListener('change', function(){ selectLang(this.value); });
        }

        function selectLang(L){ if(!L) return; applyLanguage(L); updateLangPickerUI(L); localStorage.setItem('brainovaLang', L); 
          // notify children frames (so embedded games update immediately)
          try{ window.frames && Array.from(document.getElementsByTagName('iframe')).forEach(f=>{ try{ f.contentWindow.postMessage({ action:'set-language', lang: L }, '*'); }catch(e){} }); }catch(e){}
        }
  // set initial label and apply language
  updateLangPickerUI(currentLang);
  applyLanguage(currentLang);
        // settings menu
        const sBtn = document.getElementById('settingsBtn'); const sMenu = document.getElementById('settingsMenu');
        if(sBtn && sMenu){ sBtn.addEventListener('click', ()=>{ sMenu.style.display = (sMenu.style.display === 'block') ? 'none' : 'block'; }); }
        document.getElementById('settingsEditProfile').addEventListener('click', ()=>{ sMenu.style.display='none'; openAuth('profile'); });
        document.getElementById('settingsHistory').addEventListener('click', ()=>{ sMenu.style.display='none'; openAuth('history'); });
      });

      // Fallback: listen to localStorage events so a standalone auth page can notify the platform
      // Some environments (file://, cross-origin) may not allow postMessage or direct API calls.
      // Auth pages write 'brainova_temp_user' as a one-time signal; react to it and then remove the key.
      window.addEventListener('storage', function(e){
        try{
          if(!e) return;
          if(e.key === 'brainova_temp_user' && e.newValue){
            try{ closeGame(); }catch(_){}
            try{ // reload to pick up new user state or navigate to home
              window.location.href = new URL('./brainova.html', window.location.href).href;
            }catch(e2){ try{ window.location.reload(); }catch(_){} }
            // remove the temp key to avoid re-triggering
            try{ localStorage.removeItem('brainova_temp_user'); }catch(_){}
          }
        }catch(err){}
      });

      // Listen to messages from iframes so games can ask the platform to close the overlay
      window.addEventListener('message', (e)=>{
        try{
          // Accept object payloads and JSON strings from older pages
          let data = e.data || null;
          if(!data) return;
          if(typeof data === 'string'){
            try{ data = JSON.parse(data); }catch(_){ /* ignore non-json */ }
          }
          if(!data || typeof data !== 'object') return;
          if(data && data.action === 'close'){
            closeGame();
            try{ window.location.href = new URL('./brainova.html', window.location.href).href; }catch(e){}
          }
          if(data && data.action === 'login-success'){
            console.debug('Received login-success from iframe', data.user);
            // Close overlay then reload or navigate to homepage
            closeGame();
            try{
              try{
                const u = data.user || {};
                const sig = (u.avatar && u.avatar.length>0) ? u.avatar : (u.name?u.name.split(' ').map(n=>n.charAt(0)).join('').toUpperCase():'');
                const sigEl = document.getElementById('userSigle');
                if(sigEl && sig){ sigEl.textContent = sig; sigEl.style.display='flex'; }
              }catch(e){}
              window.location.href = new URL('./brainova.html', window.location.href).href; // go to brainova home
            }catch(err){
              window.location.reload();
            }
          }
          // Message from embedded game asking to return to platform home
          if(data && (data.action === 'go-home' || data.action === 'home')){
            console.debug('Received go-home from iframe');
            try{ closeGame(); window.location.href = new URL('./brainova.html', window.location.href).href; }catch(err){ window.location.reload(); }
          }
        }catch(err){/* ignore */}
      });

      // Tester tous les jeux : vérifie chaque jeuxN.html et met à jour le statut
      const checkBtn = document.getElementById('checkAllBtn');
      const checkStatus = document.getElementById('checkStatus');
      checkBtn.addEventListener('click', async ()=>{
        checkBtn.disabled = true; checkStatus.textContent = 'Test en cours...';
        let ok = 0, fail = 0;
          for(let i=0;i<=total;i++){
          const meta = gameMap[i] || {};
          const candidates = [];
          if(meta.file) candidates.push(meta.file);
          candidates.push(`./jeux${i}.html`);
          candidates.push(`./jeux${i}.html.html`);
          const card = grid.querySelector(`.game-card[data-game-id="${i}"]`);
          const statusEl = card.querySelector('.game-status');
          let found = false;
          for(const url of candidates){
            if(!url) continue;
            try{
              const safe = normalizeUrl(new URL(url, window.location.href).href);
              const r = await fetch(safe, {method:'HEAD'});
              if(r.ok){ statusEl.textContent = 'OK'; statusEl.style.background = 'linear-gradient(45deg,#00ff88,#ffd700)'; statusEl.style.color = '#000'; ok++; found = true; break; }
            }catch(e){ /* try next */ }
          }
          if(!found){ statusEl.textContent = 'N/D'; statusEl.style.background = 'rgba(255,0,0,0.12)'; fail++; }
        }
        checkStatus.textContent = `Résultat : ${ok} OK / ${fail} FAIL`;
        checkBtn.disabled = false;
      });

    })();
  </script>
  <script>
    // Wire category buttons to filter the games grid by meta.tags
    (function(){
      const hero = document.getElementById('catalog-hero');
      if(!hero) return;
      const buttons = hero.querySelectorAll('.cat');
      const grid = document.getElementById('gamesGrid');
      if(!buttons.length || !grid) return;
      buttons.forEach(b=>{
        b.addEventListener('click', ()=>{
          const filter = (b.dataset.filter||'').toString().toLowerCase();
          const cards = grid.querySelectorAll('.game-card');
          cards.forEach(c=>{
            const id = Number(c.dataset.gameId);
            const meta = (window.gameMap && window.gameMap[id]) ? window.gameMap[id] : null;
            const tags = (meta && meta.tags) ? meta.tags.map(t=>t.toString().toLowerCase()) : [];
            if(!filter || tags.includes(filter)) c.style.display='block'; else c.style.display='none';
          });
        });
      });
    })();
  </script>
  <script>
    // Debug panel wiring (temporary)
    (function(){
      function safe(id){ try{ return document.getElementById(id); }catch(e){ return null; } }
      function updateDebug(){
        const g = safe('dbgGamesIndex'); if(g) g.textContent = (window.GamesIndex ? 'loaded' : 'missing');
        const o = safe('dbgOverlay'); if(o) o.textContent = (window.OverlayManager ? 'present' : 'missing');
        // If GamesIndex exposes a lastResolvedUrl helper, use it; otherwise keep previous value
        const last = safe('dbgLastUrl'); if(last){
          if(window.GamesIndex && typeof window.GamesIndex._lastResolved === 'string') last.textContent = window.GamesIndex._lastResolved;
        }
      }
      updateDebug();
      // Poll a few times in case GamesIndex/OverlayManager load after initial run
      let pollCount = 0; const pollMax = 6;
      const pollInterval = setInterval(()=>{
        pollCount++; updateDebug();
        if(window.GamesIndex || window.OverlayManager || pollCount>=pollMax){ clearInterval(pollInterval); }
      }, 1000);
      // Buttons
      const btnOpen2 = safe('dbgOpen2');
      const btnSet2 = safe('dbgSet2');
      const btnOpenNew = safe('dbgOpenNew');
      if(btnOpen2) btnOpen2.addEventListener('click', ()=>{
        try{
          if(window.GamesIndex && typeof window.GamesIndex.launch === 'function'){
            GamesIndex.launch(2);
          }else{
            // fallback: try platform openGame function
            try{ openGame(2); }catch(e){ window.open('./jeux2brainova.html','_blank'); }
          }
        }catch(e){ console.error(e); }
        updateDebug();
      });
      if(btnOpenNew) btnOpenNew.addEventListener('click', ()=>{ window.open('./jeux2brainova.html','_blank'); });
      if(btnSet2) btnSet2.addEventListener('click', ()=>{
        try{
          const iframe = document.getElementById('overlayIframe');
          if(iframe){ iframe.src = './jeux2brainova.html'; }
          const ov = document.getElementById('overlay'); if(ov) ov.classList.add('active');
          const title = document.getElementById('overlayTitle'); if(title) title.textContent = 'Jeu 2';
          const last = safe('dbgLastUrl'); if(last) last.textContent = './jeux2brainova.html';
        }catch(e){ console.error(e); }
        updateDebug();
      });
      // Reload GamesIndex on demand
      const btnReload = safe('dbgReloadIndex');
      const errBox = safe('dbgError');
      if(btnReload) btnReload.addEventListener('click', async ()=>{
        try{ if(typeof window.tryLoadGamesIndex === 'function'){ errBox.textContent = 'Rechargement...'; const ok = await window.tryLoadGamesIndex(); if(ok) errBox.textContent = 'Chargé'; else errBox.textContent = (window.__gamesIndexError||'Erreur inconnue'); } else { errBox.textContent = 'Pas de fonction de rechargement exposée'; } }catch(e){ errBox.textContent = e && e.message ? e.message : String(e); }
        updateDebug();
      });
      if(errBox && window.__gamesIndexError) errBox.textContent = window.__gamesIndexError;
      // Refresh status a few times in case GamesIndex/OverlayManager load later
      setTimeout(updateDebug, 500);
      setTimeout(updateDebug, 2000);
    })();
  </script>
</body>
</html>

