<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ”¥ Brainova Quantum Dames - IA Futuriste</title>
    <script>
        (function(){
            if(window.__platform_nonblocking_dialogs) return; window.__platform_nonblocking_dialogs=true;
            try{
                const _alert = window.alert.bind(window);
                const _confirm = window.confirm.bind(window);
                const _prompt = window.prompt.bind(window);
                function send(type,text){ try{ if(window.parent && window.parent!==window) parent.postMessage({action:'dialog', dialogType:type, text:String(text||'')}, '*'); }catch(e){} }
                window.alert = function(msg){ if(window.parent && window.parent!==window){ send('alert', msg); } else { _alert(msg); } };
                window.confirm = function(msg){ if(window.parent && window.parent!==window){ send('confirm', msg); return true; } else { return _confirm(msg); } };
                window.prompt = function(msg, def){ if(window.parent && window.parent!==window){ send('prompt', msg+'\n(default: '+(def||'')+')'); return def||null; } else { return _prompt(msg, def); } };
            }catch(e){ }
        })();
    </script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            box-sizing: border-box;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a3a 30%, #2d1b69 70%, #4c1d95 100%);
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }

        /* Particules quantiques d'arriÃ¨re-plan */
        .quantum-particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .quantum-particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: #ff6b35;
            border-radius: 50%;
            animation: quantumFloat 15s infinite linear;
            box-shadow: 0 0 12px #ff6b35, 0 0 24px #ff6b35;
        }

        @keyframes quantumFloat {
            0% {
                transform: translateY(100vh) translateX(0) rotate(0deg) scale(0);
                opacity: 0;
            }
            10% {
                opacity: 1;
                transform: translateY(90vh) translateX(30px) rotate(45deg) scale(1);
            }
            50% {
                transform: translateY(50vh) translateX(-40px) rotate(180deg) scale(1.8);
            }
            90% {
                opacity: 1;
                transform: translateY(10vh) translateX(60px) rotate(315deg) scale(1);
            }
            100% {
                transform: translateY(-10vh) translateX(120px) rotate(360deg) scale(0);
                opacity: 0;
            }
        }

        /* Lignes d'Ã©nergie futuristes */
        .energy-lines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
            overflow: hidden;
        }

        .energy-line {
            position: absolute;
            height: 3px;
            background: linear-gradient(90deg, transparent, #ff6b35, transparent);
            animation: energyFlow 10s infinite linear;
            box-shadow: 0 0 15px #ff6b35;
        }

        @keyframes energyFlow {
            0% {
                transform: translateX(-100%);
                opacity: 0;
            }
            10% {
                opacity: 1;
            }
            90% {
                opacity: 1;
            }
            100% {
                transform: translateX(100vw);
                opacity: 0;
            }
        }

        /* Cercles d'Ã©nergie pulsants */
        .energy-circles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .energy-circle {
            position: absolute;
            border: 3px solid rgba(255, 107, 53, 0.4);
            border-radius: 50%;
            animation: energyPulse 8s infinite ease-in-out;
        }

        @keyframes energyPulse {
            0% {
                transform: scale(0) rotate(0deg);
                opacity: 1;
                border-color: rgba(255, 107, 53, 0.9);
            }
            50% {
                transform: scale(1.2) rotate(180deg);
                opacity: 0.6;
                border-color: rgba(255, 107, 53, 0.5);
            }
            100% {
                transform: scale(2.5) rotate(360deg);
                opacity: 0;
                border-color: rgba(255, 107, 53, 0.1);
            }
        }

        /* Grille quantique de fond */
        .quantum-grid {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(255, 107, 53, 0.15) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 107, 53, 0.15) 1px, transparent 1px);
            background-size: 80px 80px;
            animation: quantumGridMove 30s linear infinite;
            z-index: 1;
        }

        @keyframes quantumGridMove {
            0% { transform: translate(0, 0) rotate(0deg); }
            50% { transform: translate(40px, 40px) rotate(2deg); }
            100% { transform: translate(80px, 80px) rotate(0deg); }
        }

        /* Rayons laser */
        .laser-beams {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .laser-beam {
            position: absolute;
            width: 3px;
            height: 100vh;
            background: linear-gradient(to bottom, 
                transparent 0%, 
                rgba(255, 107, 53, 0.9) 20%, 
                rgba(255, 107, 53, 0.5) 50%, 
                rgba(255, 107, 53, 0.9) 80%, 
                transparent 100%);
            animation: laserScan 15s infinite linear;
            box-shadow: 0 0 25px rgba(255, 107, 53, 0.7);
        }

        @keyframes laserScan {
            0% {
                transform: translateX(-15px);
                opacity: 0;
            }
            10% {
                opacity: 1;
            }
            90% {
                opacity: 1;
            }
            100% {
                transform: translateX(100vw);
                opacity: 0;
            }
        }

        /* Container principal */
        .quantum-dames-container {
            position: relative;
            z-index: 10;
            display: grid;
            grid-template-columns: 180px 1fr 180px;
            gap: 12px;
            min-height: 100vh;
            padding: 10px;
            max-width: 1200px;
            margin: 0 auto;
            padding-top: 15px;
        }

        .left-panel, .right-panel {
            background: linear-gradient(145deg, 
                rgba(30, 30, 58, 0.95) 0%,
                rgba(45, 27, 105, 0.95) 50%,
                rgba(76, 29, 149, 0.95) 100%);
            backdrop-filter: blur(30px);
            border-radius: 15px;
            padding: 12px;
            height: fit-content;
            box-shadow: 
                0 15px 30px rgba(0, 0, 0, 0.7),
                0 0 60px rgba(255, 107, 53, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 107, 53, 0.5);
            animation: quantumPanelGlow 5s ease-in-out infinite alternate;
        }

        .game-panel {
            background: linear-gradient(145deg, 
                rgba(30, 30, 58, 0.95) 0%,
                rgba(45, 27, 105, 0.95) 50%,
                rgba(76, 29, 149, 0.95) 100%);
            backdrop-filter: blur(30px);
            border-radius: 20px;
            padding: 20px;
            width: 100%;
            height: fit-content;
            box-shadow: 
                0 25px 50px rgba(0, 0, 0, 0.7),
                0 0 100px rgba(255, 107, 53, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 107, 53, 0.5);
            animation: quantumPanelGlow 5s ease-in-out infinite alternate;
        }

        @keyframes quantumPanelGlow {
            from { 
                box-shadow: 
                    0 25px 50px rgba(0, 0, 0, 0.7),
                    0 0 100px rgba(255, 107, 53, 0.2),
                    inset 0 1px 0 rgba(255, 255, 255, 0.1);
            }
            to { 
                box-shadow: 
                    0 30px 60px rgba(0, 0, 0, 0.7),
                    0 0 120px rgba(255, 107, 53, 0.3),
                    inset 0 1px 0 rgba(255, 255, 255, 0.2);
            }
        }

        /* En-tÃªte du jeu */
        .quantum-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid rgba(255, 107, 53, 0.5);
        }

        .quantum-title {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .quantum-title h1 {
            color: #ff6b35;
            margin: 0;
            font-size: 18px;
            font-weight: 700;
            text-shadow: 0 0 30px rgba(255, 107, 53, 0.9);
            animation: quantumTitlePulse 4s infinite alternate;
        }

        @keyframes quantumTitlePulse {
            from { 
                text-shadow: 0 0 30px rgba(255, 107, 53, 0.9);
                transform: scale(1);
            }
            to { 
                text-shadow: 0 0 40px rgba(255, 107, 53, 1);
                transform: scale(1.03);
            }
        }

        .quantum-icon {
            font-size: 28px;
            animation: quantumIconSpin 8s linear infinite;
            filter: drop-shadow(0 0 20px #ff6b35);
            color: #fbbf24;
            text-shadow: 
                0 0 15px rgba(251, 191, 36, 0.9),
                0 0 30px rgba(251, 191, 36, 0.7),
                0 0 45px rgba(251, 191, 36, 0.5);
        }

        @keyframes quantumIconSpin {
            0% { transform: rotate(0deg) scale(1); }
            25% { transform: rotate(90deg) scale(1.15); }
            50% { transform: rotate(180deg) scale(1); }
            75% { transform: rotate(270deg) scale(1.15); }
            100% { transform: rotate(360deg) scale(1); }
        }

        .quantum-badge {
            background: linear-gradient(45deg, #ff6b35, #f59e0b, #ef4444, #8b5cf6);
            background-size: 400% 400%;
            color: white;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 10px;
            font-weight: bold;
            animation: quantumBadgeShine 5s ease-in-out infinite;
            box-shadow: 0 0 25px rgba(255, 107, 53, 0.7);
        }

        @keyframes quantumBadgeShine {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .close-btn {
            background: rgba(255, 0, 0, 0.25);
            border: 2px solid rgba(255, 0, 0, 0.6);
            color: #ff4757;
            width: 45px;
            height: 45px;
            border-radius: 50%;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .close-btn:hover {
            background: rgba(255, 0, 0, 0.5);
            transform: scale(1.15) rotate(90deg);
            box-shadow: 0 0 30px rgba(255, 71, 87, 0.9);
        }

        /* SÃ©lecteur de langue */
        .language-selector {
            background: linear-gradient(145deg, #ff6b35, #f59e0b);
            color: white;
            border: 2px solid rgba(255, 107, 53, 0.5);
            border-radius: 15px;
            padding: 12px 18px;
            font-weight: bold;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.3s ease;
            box-shadow: 0 0 25px rgba(255, 107, 53, 0.5);
            backdrop-filter: blur(15px);
            min-width: 160px;
            max-height: 220px;
            overflow-y: auto;
        }

        .language-selector:hover {
            background: linear-gradient(145deg, #ff8c42, #fbbf24);
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(255, 107, 53, 0.7);
            border-color: rgba(255, 107, 53, 0.7);
        }

        .language-selector:focus {
            outline: none;
            box-shadow: 0 0 35px rgba(255, 107, 53, 0.9);
            border-color: rgba(255, 107, 53, 0.9);
        }

        .language-selector option {
            background: #1e1e3a;
            color: white;
            padding: 10px 15px;
            border: none;
            font-size: 13px;
        }

        .language-selector option:hover {
            background: #ff6b35;
        }

        /* ContrÃ´les de mode de jeu */
        .game-mode-controls {
            display: flex;
            justify-content: center;
            gap: 12px;
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 12px;
            border: 2px solid rgba(255, 107, 53, 0.4);
        }

        .mode-btn {
            padding: 12px 20px;
            background: linear-gradient(145deg, #ff6b35, #f59e0b);
            color: white;
            border: none;
            border-radius: 12px;
            font-weight: bold;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 1.2px;
            min-width: 130px;
        }

        .mode-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.5), transparent);
            transition: left 0.6s ease;
        }

        .mode-btn:hover::before {
            left: 100%;
        }

        .mode-btn:hover {
            transform: translateY(-4px);
            box-shadow: 0 12px 35px rgba(255, 107, 53, 0.6);
            background: linear-gradient(145deg, #ff8c42, #fbbf24);
        }

        .mode-btn.active {
            background: linear-gradient(145deg, #8b5cf6, #7c3aed);
            box-shadow: 0 0 30px rgba(139, 92, 246, 0.7);
        }

        .mode-btn.active:hover {
            background: linear-gradient(145deg, #a78bfa, #8b5cf6);
        }

        /* Plateau de dames quantique */
        .quantum-dameboard-container {
            display: flex;
            justify-content: center;
            margin-bottom: 15px;
            position: relative;
            margin-top: 15px;
        }

        .quantum-dameboard {
            width: 480px;
            height: 480px;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            border: 4px solid rgba(255, 107, 53, 0.9);
            border-radius: 18px;
            box-shadow: 
                0 0 35px rgba(255, 107, 53, 0.7),
                0 0 70px rgba(255, 107, 53, 0.4),
                inset 0 0 25px rgba(255, 107, 53, 0.25);
            animation: quantumBoardGlow 6s ease-in-out infinite alternate;
            position: relative;
            overflow: hidden;
        }

        @keyframes quantumBoardGlow {
            from { 
                box-shadow: 
                    0 0 30px rgba(255, 107, 53, 0.5),
                    0 0 60px rgba(255, 107, 53, 0.3),
                    inset 0 0 20px rgba(255, 107, 53, 0.2);
            }
            to { 
                box-shadow: 
                    0 0 40px rgba(255, 107, 53, 0.7),
                    0 0 80px rgba(255, 107, 53, 0.4),
                    inset 0 0 30px rgba(255, 107, 53, 0.25);
            }
        }

        .dame-square {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 107, 53, 0.4);
            box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.2);
        }

        .dame-square.light {
            background: linear-gradient(145deg, #f3f4f6, #d1d5db);
            box-shadow: 
                inset 0 0 20px rgba(255, 255, 255, 0.5),
                inset 0 0 12px rgba(255, 107, 53, 0.2);
        }

        .dame-square.dark {
            background: linear-gradient(145deg, #374151, #1f2937);
            box-shadow: 
                inset 0 0 20px rgba(0, 0, 0, 0.7),
                inset 0 0 12px rgba(255, 107, 53, 0.3);
        }

        .dame-square:hover {
            transform: scale(1.08);
            z-index: 15;
            box-shadow: 
                0 0 30px rgba(255, 107, 53, 0.9),
                inset 0 0 25px rgba(255, 107, 53, 0.3);
            border: 2px solid rgba(255, 107, 53, 0.7);
        }

        .dame-square.selected {
            background: linear-gradient(145deg, #fbbf24, #f59e0b) !important;
            box-shadow: 
                0 0 35px rgba(251, 191, 36, 1),
                inset 0 0 25px rgba(251, 191, 36, 0.4),
                0 0 60px rgba(251, 191, 36, 0.6);
            transform: scale(1.12);
            z-index: 25;
            border: 3px solid #fbbf24;
            animation: selectedPulse 2s ease-in-out infinite alternate;
        }

        @keyframes selectedPulse {
            from { 
                box-shadow: 
                    0 0 35px rgba(251, 191, 36, 1),
                    inset 0 0 25px rgba(251, 191, 36, 0.4),
                    0 0 60px rgba(251, 191, 36, 0.6);
            }
            to { 
                box-shadow: 
                    0 0 45px rgba(251, 191, 36, 1),
                    inset 0 0 35px rgba(251, 191, 36, 0.5),
                    0 0 80px rgba(251, 191, 36, 0.8);
            }
        }

        .dame-square.possible-move {
            background: linear-gradient(145deg, #10b981, #059669) !important;
            box-shadow: 
                0 0 25px rgba(16, 185, 129, 0.9),
                inset 0 0 20px rgba(16, 185, 129, 0.3);
            border: 2px solid #10b981;
            animation: possibleMovePulse 2.5s ease-in-out infinite alternate;
        }

        @keyframes possibleMovePulse {
            from { 
                box-shadow: 
                    0 0 25px rgba(16, 185, 129, 0.9),
                    inset 0 0 20px rgba(16, 185, 129, 0.3);
            }
            to { 
                box-shadow: 
                    0 0 35px rgba(16, 185, 129, 1),
                    inset 0 0 30px rgba(16, 185, 129, 0.4);
            }
        }

        .dame-square.quantum-state {
            background: linear-gradient(145deg, #ec4899, #db2777) !important;
            box-shadow: 
                0 0 30px rgba(236, 72, 153, 1),
                inset 0 0 25px rgba(236, 72, 153, 0.4);
            animation: quantumPulse 1.2s infinite alternate;
            border: 2px solid #ec4899;
        }

        @keyframes quantumPulse {
            from { transform: scale(1); }
            to { transform: scale(1.08); }
        }

        /* Pions de dames */
        .dame-piece {
            width: 42px;
            height: 42px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: 900;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            z-index: 10;
            border: 2px solid rgba(0, 0, 0, 0.3);
            box-shadow: 
                0 6px 12px rgba(0, 0, 0, 0.4),
                inset 0 2px 4px rgba(255, 255, 255, 0.3);
        }

        .dame-piece:hover {
            transform: scale(1.2);
            z-index: 20;
            box-shadow: 
                0 12px 24px rgba(0, 0, 0, 0.5),
                0 0 25px currentColor,
                inset 0 2px 4px rgba(255, 255, 255, 0.4);
            animation: pieceGlow 0.6s ease-in-out;
        }

        @keyframes pieceGlow {
            0% { transform: scale(1.2); }
            50% { transform: scale(1.25); }
            100% { transform: scale(1.2); }
        }

        .dame-piece.white {
            background: linear-gradient(145deg, #fbbf24, #f59e0b);
            color: #1f2937;
            text-shadow: 
                2px 2px 4px rgba(0, 0, 0, 0.3),
                0 0 15px rgba(251, 191, 36, 0.8);
            border-color: rgba(31, 41, 55, 0.4);
        }

        .dame-piece.white:hover {
            background: linear-gradient(145deg, #fcd34d, #fbbf24);
            text-shadow: 
                2px 2px 4px rgba(0, 0, 0, 0.4),
                0 0 20px rgba(252, 211, 77, 1);
        }

        .dame-piece.black {
            background: linear-gradient(145deg, #ef4444, #dc2626);
            color: #f9fafb;
            text-shadow: 
                2px 2px 4px rgba(0, 0, 0, 0.6),
                0 0 15px rgba(239, 68, 68, 0.8);
            border-color: rgba(249, 250, 251, 0.4);
        }

        .dame-piece.black:hover {
            background: linear-gradient(145deg, #f87171, #ef4444);
            text-shadow: 
                2px 2px 4px rgba(0, 0, 0, 0.7),
                0 0 20px rgba(248, 113, 113, 1);
        }

        .dame-piece.king {
            font-size: 24px;
            border-width: 3px;
            box-shadow: 
                0 8px 16px rgba(0, 0, 0, 0.5),
                0 0 25px currentColor,
                inset 0 3px 6px rgba(255, 255, 255, 0.4);
        }

        /* Panneau de titre des sections */
        .panel-title {
            color: #ff6b35;
            font-size: 13px;
            font-weight: bold;
            margin-bottom: 12px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            text-shadow: 0 0 15px rgba(255, 107, 53, 0.9);
            border-bottom: 2px solid rgba(255, 107, 53, 0.5);
            padding-bottom: 8px;
        }

        /* ContrÃ´les quantiques */
        .quantum-controls {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px;
            margin-bottom: 12px;
        }

        .quantum-btn {
            padding: 10px 14px;
            background: linear-gradient(145deg, #ff6b35, #f59e0b);
            color: white;
            border: none;
            border-radius: 10px;
            font-weight: bold;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 0.6px;
        }

        .quantum-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            transition: left 0.6s ease;
        }

        .quantum-btn:hover::before {
            left: 100%;
        }

        .quantum-btn:hover {
            transform: translateY(-4px);
            box-shadow: 0 10px 30px rgba(255, 107, 53, 0.5);
            background: linear-gradient(145deg, #ff8c42, #fbbf24);
        }

        .quantum-btn:active {
            transform: translateY(-2px);
        }

        .quantum-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        /* Boutons spÃ©cialisÃ©s */
        .ai-btn {
            background: linear-gradient(145deg, #8b5cf6, #7c3aed);
        }

        .ai-btn:hover {
            background: linear-gradient(145deg, #a78bfa, #8b5cf6);
        }

        .reset-btn {
            background: linear-gradient(145deg, #ef4444, #dc2626);
        }

        .reset-btn:hover {
            background: linear-gradient(145deg, #f87171, #ef4444);
        }

        .quantum-special-btn {
            background: linear-gradient(145deg, #ec4899, #db2777);
        }

        .quantum-special-btn:hover {
            background: linear-gradient(145deg, #f472b6, #ec4899);
        }

        /* Bouton statut du joueur */
        .player-status-btn {
            display: inline-flex;
            align-items: center;
            gap: 12px;
            padding: 12px 18px;
            background: linear-gradient(145deg, #ff6b35, #f59e0b);
            color: white;
            border: none;
            border-radius: 15px;
            font-weight: bold;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            box-shadow: 0 4px 12px rgba(255, 107, 53, 0.5);
            border: 2px solid rgba(255, 107, 53, 0.4);
        }

        .player-status-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            transition: left 0.6s ease;
        }

        .player-status-btn:hover::before {
            left: 100%;
        }

        .player-status-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(255, 107, 53, 0.7);
            background: linear-gradient(145deg, #ff8c42, #fbbf24);
            border-color: rgba(255, 107, 53, 0.6);
        }

        .player-status-btn:active {
            transform: translateY(-1px);
        }

        .player-status-btn.yellow-player {
            background: linear-gradient(145deg, #fef08a, #fbbf24);
            border-color: rgba(254, 240, 138, 0.6);
            color: #1f2937;
            text-shadow: 0 0 10px rgba(254, 240, 138, 0.9);
        }

        .player-status-btn.yellow-player:hover {
            background: linear-gradient(145deg, #fefce8, #fef08a);
            border-color: rgba(254, 240, 138, 0.8);
            box-shadow: 0 10px 30px rgba(254, 240, 138, 0.7);
        }

        .player-status-btn.red-player {
            background: linear-gradient(145deg, #ef4444, #dc2626);
            border-color: rgba(239, 68, 68, 0.6);
            color: white;
        }

        .player-status-btn.red-player:hover {
            background: linear-gradient(145deg, #f87171, #ef4444);
            border-color: rgba(239, 68, 68, 0.8);
            box-shadow: 0 10px 30px rgba(239, 68, 68, 0.7);
        }

        .player-status-btn #currentPlayer {
            font-size: 18px;
            text-shadow: 0 0 12px rgba(255, 255, 255, 0.9);
        }

        /* IA Quantique Status */
        .quantum-ai-status {
            margin-bottom: 18px;
            text-align: center;
            min-height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .ai-thinking {
            display: inline-flex;
            align-items: center;
            gap: 15px;
            color: #ff6b35;
            font-size: 15px;
            opacity: 0;
            transition: opacity 0.6s ease;
            background: rgba(255, 107, 53, 0.2);
            padding: 12px 25px;
            border-radius: 30px;
            border: 1px solid rgba(255, 107, 53, 0.5);
        }

        .ai-thinking.active {
            opacity: 1;
        }

        .quantum-pulse {
            width: 15px;
            height: 15px;
            background: #ff6b35;
            border-radius: 50%;
            animation: quantumAIPulse 2.5s infinite;
            box-shadow: 0 0 20px #ff6b35;
        }

        @keyframes quantumAIPulse {
            0%, 100% { 
                transform: scale(1); 
                opacity: 1; 
            }
            50% { 
                transform: scale(2); 
                opacity: 0.4; 
            }
        }

        /* Statistiques du jeu */
        .game-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 12px;
        }

        .stat-item {
            background: rgba(255, 107, 53, 0.15);
            padding: 8px;
            border-radius: 12px;
            text-align: center;
            border: 2px solid rgba(255, 107, 53, 0.4);
            position: relative;
            overflow: hidden;
        }

        .stat-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 107, 53, 0.3), transparent);
            animation: statQuantumScan 5s linear infinite;
        }

        @keyframes statQuantumScan {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .stat-label {
            display: block;
            color: #9ca3af;
            font-size: 10px;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 1.2px;
        }

        .stat-value {
            display: block;
            color: #ff6b35;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 0 0 15px rgba(255, 107, 53, 0.9);
            position: relative;
            z-index: 1;
        }

        /* Historique des coups */
        .move-history {
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid rgba(255, 107, 53, 0.4);
            border-radius: 12px;
            padding: 10px;
            max-height: 150px;
            overflow-y: auto;
        }

        .move-item {
            color: #ff6b35;
            font-size: 12px;
            padding: 5px 10px;
            margin-bottom: 5px;
            background: rgba(255, 107, 53, 0.15);
            border-radius: 8px;
            border-left: 3px solid #ff6b35;
        }

        /* Responsive */
        @media (max-width: 1100px) {
            .quantum-dames-container {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .left-panel, .right-panel {
                display: none;
            }
            
            .quantum-dameboard {
                width: 450px;
                height: 450px;
            }
            
            .dame-piece {
                width: 38px;
                height: 38px;
                font-size: 18px;
            }
        }

        @media (max-width: 768px) {
            .game-panel {
                padding: 15px;
                margin: 8px;
            }
            
            .game-mode-controls {
                flex-direction: column;
                gap: 12px;
            }
            
            .quantum-title h1 {
                font-size: 16px;
            }
            
            .quantum-dameboard {
                width: 480px;
                height: 480px;
            }
            
            .dame-piece {
                width: 40px;
                height: 40px;
                font-size: 20px;
            }
        }

        @media (max-width: 520px) {
            .quantum-dameboard {
                width: 400px;
                height: 400px;
            }
            
            .dame-piece {
                width: 35px;
                height: 35px;
                font-size: 18px;
            }
            
            .game-stats {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <!-- Particules quantiques d'arriÃ¨re-plan -->
    <div class="quantum-particles" id="quantumParticles"></div>
    
    <!-- Grille quantique -->
    <div class="quantum-grid"></div>
    
    <!-- Lignes d'Ã©nergie futuristes -->
    <div class="energy-lines" id="energyLines"></div>
    
    <!-- Cercles d'Ã©nergie pulsants -->
    <div class="energy-circles" id="energyCircles"></div>
    
    <!-- Rayons laser -->
    <div class="laser-beams" id="laserBeams"></div>
    
    <!-- Container principal -->
    <div class="quantum-dames-container">
        <!-- Panneau gauche -->
        <div class="left-panel">
            <div class="panel-section">
                <div class="panel-title" id="controlsTitle">ğŸ® ContrÃ´les Quantiques</div>
                <div class="quantum-controls">
                    <button class="quantum-btn" onclick="undoMove()" id="undoBtn">
                        â†¶ <span id="undoText">Annuler Coup</span>
                    </button>
                    <button class="quantum-btn quantum-special-btn" onclick="activateQuantumMode()" id="quantumBtn">
                        âš›ï¸ <span id="quantumModeText">Mode Quantique</span>
                    </button>
                    <button class="quantum-btn reset-btn" onclick="resetGame()">
                        ğŸ”„ <span id="newGameText">Nouvelle Partie</span>
                    </button>
                </div>
            </div>

            <div class="panel-section">
                <div class="panel-title" id="statsTitle">ğŸ“Š Statistiques</div>
                <div class="game-stats">
                    <div class="stat-item">
                        <span class="stat-label" id="movesLabel">Coups JouÃ©s</span>
                        <span class="stat-value" id="moveCount">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label" id="aiLevelLabel">Niveau IA</span>
                        <span class="stat-value" id="aiLevel">5</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label" id="timeLabel">Temps</span>
                        <span class="stat-value" id="gameTime">00:00</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label" id="scoreLabel">Score</span>
                        <span class="stat-value" id="gameScore">0</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Panneau central -->
        <div class="game-panel">
            <!-- En-tÃªte -->
            <div class="quantum-header">
                <div class="quantum-title">
                    <span class="quantum-icon">ğŸ”¥</span>
                    <h1 id="gameTitle">Brainova Quantum Dames</h1>
                    <span class="quantum-badge" id="quantumBadge">ğŸš€ IA QUANTIQUE</span>
                </div>
                <div style="display: flex; align-items: center; gap: 18px;">
                    <select id="languageSelector" onchange="changeLanguage()" class="language-selector">
                        <option value="fr">ğŸ‡«ğŸ‡· FranÃ§ais</option>
                        <option value="en">ğŸ‡ºğŸ‡¸ English</option>
                        <option value="ar">ğŸ‡¸ğŸ‡¦ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©</option>
                        <option value="es">ğŸ‡ªğŸ‡¸ EspaÃ±ol</option>
                        <option value="de">ğŸ‡©ğŸ‡ª Deutsch</option>
                        <option value="zh">ğŸ‡¨ğŸ‡³ ä¸­æ–‡</option>
                    </select>
                    <button class="close-btn" onclick="window.close()" id="closeBtn" title="Fermer">âœ•</button>
                </div>
            </div>



            <!-- ContrÃ´les de jeu en haut -->
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <!-- Bouton Pause/Reprendre Ã  gauche -->
                <button class="quantum-btn" id="pauseBtn" onclick="togglePause()" style="background: linear-gradient(145deg, #8b5cf6, #7c3aed);">
                    â¸ï¸ <span id="pauseText">Pause</span>
                </button>
                
                <!-- Bouton statut du joueur au centre -->
                <button class="player-status-btn yellow-player" id="playerStatusBtn" onclick="switchPlayer()">
                    <span id="currentPlayer">ğŸ”¥</span>
                    <span id="playerName">Joueur Jaune</span>
                </button>
                
                <!-- Bouton IA Quantique Ã  droite -->
                <button class="quantum-btn ai-btn" onclick="makeAIMove()" id="aiMoveBtn">
                    ğŸ¤– <span id="aiMoveText">Coup IA Quantique</span>
                </button>
            </div>

            <!-- Plateau de dames quantique -->
            <div class="quantum-dameboard-container" style="margin-top: 5px;">
                <div class="quantum-dameboard" id="dameboard">
                    <!-- Les cases seront gÃ©nÃ©rÃ©es dynamiquement -->
                </div>
            </div>

            <!-- Statut IA Quantique -->
            <div class="quantum-ai-status">
                <div class="ai-thinking" id="aiThinking">
                    <span class="quantum-pulse"></span>
                    <span id="aiMessage">IA Quantique en analyse...</span>
                </div>
            </div>
        </div>

        <!-- Panneau droit -->
        <div class="right-panel">
            <div class="panel-section">
                <div class="panel-title" id="historyTitle">ğŸ“œ Historique</div>
                <div class="move-history" id="moveHistory">
                    <div class="move-item" id="gameStarted"></div>
                </div>
            </div>

            <div class="panel-section">
                <div class="panel-title" id="gameModeTitle">ğŸ® Mode de Jeu</div>
                <div class="quantum-controls">
                    <button class="mode-btn active" onclick="setGameMode('ai')" id="aiModeBtn">
                        ğŸ¤– <span id="aiModeText">Jouer vs IA</span>
                    </button>
                    <button class="mode-btn" onclick="setGameMode('human')" id="humanModeBtn">
                        ğŸ‘¥ <span id="humanModeText">2 Joueurs</span>
                    </button>
                </div>
            </div>

            <div class="panel-section">
                <div class="panel-title" id="optionsTitle">âš™ï¸ Options IA</div>
                <div class="quantum-controls">
                    <button class="quantum-btn" onclick="changeDifficulty()" id="difficultyBtn">
                        ğŸ¯ <span id="difficultyText">DifficultÃ©: Expert</span>
                    </button>
                    <button class="quantum-btn ai-btn" onclick="toggleAIAnalysis()" id="analysisBtn">
                        ğŸ” <span id="analysisText">Analyse IA</span>
                    </button>
                    <button class="quantum-btn quantum-special-btn" onclick="showBestMoves()" id="hintBtn">
                        ğŸ’¡ <span id="hintText">Meilleurs Coups</span>
                    </button>
                    <button class="quantum-btn" onclick="saveGame()" id="saveBtn">
                        ğŸ’¾ <span id="saveText">Sauvegarder</span>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Traductions multilingues
        const translations = {
            fr: {
                gameTitle: "Brainova Quantum Dames",
                quantumBadge: "ğŸš€ IA QUANTIQUE",
                controlsTitle: "ğŸ® ContrÃ´les Quantiques",
                gameModeTitle: "ğŸ® Mode de Jeu",
                aiMoveText: "Coup IA Quantique",
                undoText: "Annuler Coup",
                quantumModeText: "Mode Quantique",
                newGameText: "Nouvelle Partie",
                statsTitle: "ğŸ“Š Statistiques",
                movesLabel: "Coups JouÃ©s",
                aiLevelLabel: "Niveau IA",
                timeLabel: "Temps",
                scoreLabel: "Score",
                aiModeText: "Jouer vs IA",
                humanModeText: "2 Joueurs",
                gameStatus: "Nouvelle partie - Jaunes commencent",
                playerYellow: "Joueur Jaune",
                playerRed: "Joueur Rouge",
                aiPlayer: "IA Quantique",
                historyTitle: "ğŸ“œ Historique",
                gameStarted: "Partie commencÃ©e",
                optionsTitle: "âš™ï¸ Options IA",
                difficultyText: "DifficultÃ©: Expert",
                analysisText: "Analyse IA",
                hintText: "Meilleurs Coups",
                saveText: "Sauvegarder",
                aiThinking: "IA Quantique en analyse...",
                closeBtn: "Fermer",
                turnOf: "Tour du",
                gameEnded: "Partie terminÃ©e",
                newGameStarted: "Nouvelle partie commencÃ©e",
                quantumActivated: "Mode Quantique activÃ© ! Les pions peuvent se tÃ©lÃ©porter !",
                quantumDeactivated: "Mode Quantique dÃ©sactivÃ©",
                gameSaved: "Partie sauvegardÃ©e !",
                gameLoaded: "Partie chargÃ©e !",
                loadSavedGame: "Voulez-vous charger la partie sauvegardÃ©e ?",
                welcome: "Bienvenue dans Brainova Quantum Dames ! Choisissez votre mode de jeu.",
                aiCalculating: "IA Quantique calcule le meilleur coup...",
                undoInDevelopment: "Fonction d'annulation en dÃ©veloppement",
                aiAnalyzing: "Analyse IA en cours...",
                bestMovesCalculating: "Calcul des meilleurs coups...",
                suggestion: "Suggestion:",
                noMovesAvailable: "Aucun coup disponible",
                difficultyChanged: "DifficultÃ© changÃ©e:",
                yellowAdvantage: "Avantage significatif aux Jaunes",
                redAdvantage: "Avantage significatif aux Rouges",
                slightYellowAdvantage: "LÃ©ger avantage aux Jaunes",
                slightRedAdvantage: "LÃ©ger avantage aux Rouges",
                balancedPosition: "Position Ã©quilibrÃ©e",
                victory: "Victoire des",
                yellows: "Jaunes",
                reds: "Rouges",
                difficulties: {
                    easy: "facile",
                    normal: "normal",
                    hard: "difficile",
                    expert: "expert"
                },
                mustCapture: "Vous devez prendre un pion adverse !",
                invalidMove: "Mouvement invalide !",
                piecePromoted: "Pion promu en Dame !",
                multipleCaptures: "Captures multiples possibles !",
                allPiecesCaptured: "Toutes les piÃ¨ces capturÃ©es",
                noMovesLeft: "Aucun mouvement possible",
                morePieces: "Plus de piÃ¨ces restantes",
                strategicAdvantage: "Avantage stratÃ©gique",
                reason: "Raison",
                finalScore: "Score Final",
                totalMoves: "Total Coups",
                pauseText: "Pause",
                resumeText: "Reprendre",
                gamePaused: "Jeu en pause",
                gameResumed: "Jeu repris"
            },
            en: {
                gameTitle: "Brainova Quantum Checkers",
                quantumBadge: "ğŸš€ QUANTUM AI",
                controlsTitle: "ğŸ® Quantum Controls",
                gameModeTitle: "ğŸ® Game Mode",
                aiMoveText: "Quantum AI Move",
                undoText: "Undo Move",
                quantumModeText: "Quantum Mode",
                newGameText: "New Game",
                statsTitle: "ğŸ“Š Statistics",
                movesLabel: "Moves Played",
                aiLevelLabel: "AI Level",
                timeLabel: "Time",
                scoreLabel: "Score",
                aiModeText: "Play vs AI",
                humanModeText: "2 Players",
                gameStatus: "New game - Yellow starts",
                playerYellow: "Yellow Player",
                playerRed: "Red Player",
                aiPlayer: "Quantum AI",
                historyTitle: "ğŸ“œ History",
                gameStarted: "Game started",
                optionsTitle: "âš™ï¸ AI Options",
                difficultyText: "Difficulty: Expert",
                analysisText: "AI Analysis",
                hintText: "Best Moves",
                saveText: "Save Game",
                aiThinking: "Quantum AI analyzing...",
                closeBtn: "Close",
                turnOf: "Turn of",
                gameEnded: "Game ended",
                newGameStarted: "New game started",
                quantumActivated: "Quantum Mode activated! Pieces can teleport!",
                quantumDeactivated: "Quantum Mode deactivated",
                gameSaved: "Game saved!",
                gameLoaded: "Game loaded!",
                loadSavedGame: "Do you want to load the saved game?",
                welcome: "Welcome to Brainova Quantum Checkers! Choose your game mode.",
                aiCalculating: "Quantum AI calculating best move...",
                undoInDevelopment: "Undo function in development",
                aiAnalyzing: "AI analysis in progress...",
                bestMovesCalculating: "Calculating best moves...",
                suggestion: "Suggestion:",
                noMovesAvailable: "No moves available",
                difficultyChanged: "Difficulty changed:",
                yellowAdvantage: "Significant advantage to Yellow",
                redAdvantage: "Significant advantage to Red",
                slightYellowAdvantage: "Slight advantage to Yellow",
                slightRedAdvantage: "Slight advantage to Red",
                balancedPosition: "Balanced position",
                victory: "Victory for",
                yellows: "Yellow",
                reds: "Red",
                difficulties: {
                    easy: "easy",
                    normal: "normal",
                    hard: "hard",
                    expert: "expert"
                },
                mustCapture: "You must capture an opponent piece!",
                invalidMove: "Invalid move!",
                piecePromoted: "Piece promoted to King!",
                multipleCaptures: "Multiple captures possible!",
                allPiecesCaptured: "All pieces captured",
                noMovesLeft: "No moves left",
                morePieces: "More pieces remaining",
                strategicAdvantage: "Strategic advantage",
                reason: "Reason",
                finalScore: "Final Score",
                totalMoves: "Total Moves",
                pauseText: "Pause",
                resumeText: "Resume",
                gamePaused: "Game paused",
                gameResumed: "Game resumed"
            },
            ar: {
                gameTitle: "Ø¨Ø±ÙŠÙ†ÙˆÙØ§ Ø§Ù„Ø¯Ø§Ù…Ø§ Ø§Ù„ÙƒÙ…ÙŠØ©",
                quantumBadge: "ğŸš€ Ø°ÙƒØ§Ø¡ ÙƒÙ…ÙŠ",
                controlsTitle: "ğŸ® ØªØ­ÙƒÙ… ÙƒÙ…ÙŠ",
                gameModeTitle: "ğŸ® ÙˆØ¶Ø¹ Ø§Ù„Ù„Ø¹Ø¨",
                aiMoveText: "Ø­Ø±ÙƒØ© Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„ÙƒÙ…ÙŠ",
                undoText: "ØªØ±Ø§Ø¬Ø¹ Ø¹Ù† Ø§Ù„Ø­Ø±ÙƒØ©",
                quantumModeText: "Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„ÙƒÙ…ÙŠ",
                newGameText: "Ù„Ø¹Ø¨Ø© Ø¬Ø¯ÙŠØ¯Ø©",
                statsTitle: "ğŸ“Š Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª",
                movesLabel: "Ø§Ù„Ø­Ø±ÙƒØ§Øª Ø§Ù„Ù…ÙÙ„Ø¹Ø¨Ø©",
                aiLevelLabel: "Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø°ÙƒØ§Ø¡",
                timeLabel: "Ø§Ù„ÙˆÙ‚Øª",
                scoreLabel: "Ø§Ù„Ù†Ù‚Ø§Ø·",
                aiModeText: "Ø§Ù„Ø¹Ø¨ Ø¶Ø¯ Ø§Ù„Ø°ÙƒØ§Ø¡",
                humanModeText: "Ù„Ø§Ø¹Ø¨Ø§Ù†",
                gameStatus: "Ù„Ø¹Ø¨Ø© Ø¬Ø¯ÙŠØ¯Ø© - Ø§Ù„Ø£ØµÙØ± ÙŠØ¨Ø¯Ø£",
                playerYellow: "Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø§Ù„Ø£ØµÙØ±",
                playerRed: "Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø§Ù„Ø£Ø­Ù…Ø±",
                aiPlayer: "Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„ÙƒÙ…ÙŠ",
                historyTitle: "ğŸ“œ Ø§Ù„ØªØ§Ø±ÙŠØ®",
                gameStarted: "Ø¨Ø¯Ø£Øª Ø§Ù„Ù„Ø¹Ø¨Ø©",
                optionsTitle: "âš™ï¸ Ø®ÙŠØ§Ø±Ø§Øª Ø§Ù„Ø°ÙƒØ§Ø¡",
                difficultyText: "Ø§Ù„ØµØ¹ÙˆØ¨Ø©: Ø®Ø¨ÙŠØ±",
                analysisText: "ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø°ÙƒØ§Ø¡",
                hintText: "Ø£ÙØ¶Ù„ Ø§Ù„Ø­Ø±ÙƒØ§Øª",
                saveText: "Ø­ÙØ¸ Ø§Ù„Ù„Ø¹Ø¨Ø©",
                aiThinking: "Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„ÙƒÙ…ÙŠ ÙŠØ­Ù„Ù„...",
                closeBtn: "Ø¥ØºÙ„Ø§Ù‚",
                turnOf: "Ø¯ÙˆØ±",
                gameEnded: "Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù„Ø¹Ø¨Ø©",
                newGameStarted: "Ø¨Ø¯Ø£Øª Ù„Ø¹Ø¨Ø© Ø¬Ø¯ÙŠØ¯Ø©",
                quantumActivated: "ØªÙ… ØªÙØ¹ÙŠÙ„ Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„ÙƒÙ…ÙŠ! ÙŠÙ…ÙƒÙ† Ù„Ù„Ù‚Ø·Ø¹ Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ø§Ù„ÙÙˆØ±ÙŠ!",
                quantumDeactivated: "ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„ÙƒÙ…ÙŠ",
                gameSaved: "ØªÙ… Ø­ÙØ¸ Ø§Ù„Ù„Ø¹Ø¨Ø©!",
                gameLoaded: "ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù„Ø¹Ø¨Ø©!",
                loadSavedGame: "Ù‡Ù„ ØªØ±ÙŠØ¯ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù„Ø¹Ø¨Ø© Ø§Ù„Ù…Ø­ÙÙˆØ¸Ø©ØŸ",
                welcome: "Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ ÙÙŠ Ø¨Ø±ÙŠÙ†ÙˆÙØ§ Ø§Ù„Ø¯Ø§Ù…Ø§ Ø§Ù„ÙƒÙ…ÙŠØ©! Ø§Ø®ØªØ± ÙˆØ¶Ø¹ Ø§Ù„Ù„Ø¹Ø¨.",
                aiCalculating: "Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„ÙƒÙ…ÙŠ ÙŠØ­Ø³Ø¨ Ø£ÙØ¶Ù„ Ø­Ø±ÙƒØ©...",
                undoInDevelopment: "ÙˆØ¸ÙŠÙØ© Ø§Ù„ØªØ±Ø§Ø¬Ø¹ Ù‚ÙŠØ¯ Ø§Ù„ØªØ·ÙˆÙŠØ±",
                aiAnalyzing: "ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø°ÙƒØ§Ø¡ Ø¬Ø§Ø±ÙŠ...",
                bestMovesCalculating: "Ø­Ø³Ø§Ø¨ Ø£ÙØ¶Ù„ Ø§Ù„Ø­Ø±ÙƒØ§Øª...",
                suggestion: "Ø§Ù‚ØªØ±Ø§Ø­:",
                noMovesAvailable: "Ù„Ø§ ØªÙˆØ¬Ø¯ Ø­Ø±ÙƒØ§Øª Ù…ØªØ§Ø­Ø©",
                difficultyChanged: "ØªÙ… ØªØºÙŠÙŠØ± Ø§Ù„ØµØ¹ÙˆØ¨Ø©:",
                yellowAdvantage: "Ù…ÙŠØ²Ø© ÙƒØ¨ÙŠØ±Ø© Ù„Ù„Ø£ØµÙØ±",
                redAdvantage: "Ù…ÙŠØ²Ø© ÙƒØ¨ÙŠØ±Ø© Ù„Ù„Ø£Ø­Ù…Ø±",
                slightYellowAdvantage: "Ù…ÙŠØ²Ø© Ø·ÙÙŠÙØ© Ù„Ù„Ø£ØµÙØ±",
                slightRedAdvantage: "Ù…ÙŠØ²Ø© Ø·ÙÙŠÙØ© Ù„Ù„Ø£Ø­Ù…Ø±",
                balancedPosition: "Ù…ÙˆÙ‚Ù Ù…ØªÙˆØ§Ø²Ù†",
                victory: "Ø§Ù†ØªØµØ§Ø±",
                yellows: "Ø§Ù„Ø£ØµÙØ±",
                reds: "Ø§Ù„Ø£Ø­Ù…Ø±",
                difficulties: {
                    easy: "Ø³Ù‡Ù„",
                    normal: "Ø¹Ø§Ø¯ÙŠ",
                    hard: "ØµØ¹Ø¨",
                    expert: "Ø®Ø¨ÙŠØ±"
                },
                mustCapture: "ÙŠØ¬Ø¨ Ø£Ù† ØªØ£Ø®Ø° Ù‚Ø·Ø¹Ø© Ø§Ù„Ø®ØµÙ…!",
                invalidMove: "Ø­Ø±ÙƒØ© ØºÙŠØ± ØµØ­ÙŠØ­Ø©!",
                piecePromoted: "ØªÙ… ØªØ±Ù‚ÙŠØ© Ø§Ù„Ù‚Ø·Ø¹Ø© Ø¥Ù„Ù‰ Ù…Ù„Ùƒ!",
                multipleCaptures: "Ø¹Ø¯Ø© Ø§Ù„ØªÙ‚Ø§Ø·Ø§Øª Ù…Ù…ÙƒÙ†Ø©!",
                allPiecesCaptured: "ØªÙ… Ø£Ø³Ø± Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù‚Ø·Ø¹",
                noMovesLeft: "Ù„Ø§ ØªÙˆØ¬Ø¯ Ø­Ø±ÙƒØ§Øª Ù…ØªØ¨Ù‚ÙŠØ©",
                morePieces: "Ù‚Ø·Ø¹ Ø£ÙƒØ«Ø± Ù…ØªØ¨Ù‚ÙŠØ©",
                strategicAdvantage: "Ù…ÙŠØ²Ø© Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ©",
                reason: "Ø§Ù„Ø³Ø¨Ø¨",
                finalScore: "Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©",
                totalMoves: "Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø­Ø±ÙƒØ§Øª",
                pauseText: "Ø¥ÙŠÙ‚Ø§Ù",
                resumeText: "Ø§Ø³ØªØ¦Ù†Ø§Ù",
                gamePaused: "Ø§Ù„Ù„Ø¹Ø¨Ø© Ù…ØªÙˆÙ‚ÙØ©",
                gameResumed: "ØªÙ… Ø§Ø³ØªØ¦Ù†Ø§Ù Ø§Ù„Ù„Ø¹Ø¨Ø©"
            },
            es: {
                gameTitle: "Brainova Damas CuÃ¡nticas",
                quantumBadge: "ğŸš€ IA CUÃNTICA",
                controlsTitle: "ğŸ® Controles CuÃ¡nticos",
                gameModeTitle: "ğŸ® Modo de Juego",
                aiMoveText: "Movimiento IA CuÃ¡ntica",
                undoText: "Deshacer Movimiento",
                quantumModeText: "Modo CuÃ¡ntico",
                newGameText: "Nueva Partida",
                statsTitle: "ğŸ“Š EstadÃ­sticas",
                movesLabel: "Movimientos Jugados",
                aiLevelLabel: "Nivel IA",
                timeLabel: "Tiempo",
                scoreLabel: "PuntuaciÃ³n",
                aiModeText: "Jugar vs IA",
                humanModeText: "2 Jugadores",
                gameStatus: "Nueva partida - Amarillo empieza",
                playerYellow: "Jugador Amarillo",
                playerRed: "Jugador Rojo",
                aiPlayer: "IA CuÃ¡ntica",
                historyTitle: "ğŸ“œ Historial",
                gameStarted: "Partida iniciada",
                optionsTitle: "âš™ï¸ Opciones IA",
                difficultyText: "Dificultad: Experto",
                analysisText: "AnÃ¡lisis IA",
                hintText: "Mejores Movimientos",
                saveText: "Guardar Partida",
                aiThinking: "IA CuÃ¡ntica analizando...",
                closeBtn: "Cerrar",
                turnOf: "Turno de",
                gameEnded: "Partida terminada",
                newGameStarted: "Nueva partida iniciada",
                quantumActivated: "Â¡Modo CuÃ¡ntico activado! Â¡Las piezas pueden teletransportarse!",
                quantumDeactivated: "Modo CuÃ¡ntico desactivado",
                gameSaved: "Â¡Partida guardada!",
                gameLoaded: "Â¡Partida cargada!",
                loadSavedGame: "Â¿Quieres cargar la partida guardada?",
                welcome: "Â¡Bienvenido a Brainova Damas CuÃ¡nticas! Elige tu modo de juego.",
                aiCalculating: "IA CuÃ¡ntica calculando mejor movimiento...",
                undoInDevelopment: "FunciÃ³n de deshacer en desarrollo",
                aiAnalyzing: "AnÃ¡lisis IA en progreso...",
                bestMovesCalculating: "Calculando mejores movimientos...",
                suggestion: "Sugerencia:",
                noMovesAvailable: "No hay movimientos disponibles",
                difficultyChanged: "Dificultad cambiada:",
                yellowAdvantage: "Ventaja significativa para Amarillo",
                redAdvantage: "Ventaja significativa para Rojo",
                slightYellowAdvantage: "Ligera ventaja para Amarillo",
                slightRedAdvantage: "Ligera ventaja para Rojo",
                balancedPosition: "PosiciÃ³n equilibrada",
                victory: "Victoria de",
                yellows: "Amarillo",
                reds: "Rojo",
                difficulties: {
                    easy: "fÃ¡cil",
                    normal: "normal",
                    hard: "difÃ­cil",
                    expert: "experto"
                },
                mustCapture: "Â¡Debes capturar una pieza oponente!",
                invalidMove: "Â¡Movimiento invÃ¡lido!",
                piecePromoted: "Â¡Pieza promovida a Rey!",
                multipleCaptures: "Â¡MÃºltiples capturas posibles!",
                allPiecesCaptured: "Todas las piezas capturadas",
                noMovesLeft: "No quedan movimientos",
                morePieces: "MÃ¡s piezas restantes",
                strategicAdvantage: "Ventaja estratÃ©gica",
                reason: "RazÃ³n",
                finalScore: "PuntuaciÃ³n Final",
                totalMoves: "Movimientos Totales",
                pauseText: "Pausa",
                resumeText: "Reanudar",
                gamePaused: "Juego pausado",
                gameResumed: "Juego reanudado"
            },
            de: {
                gameTitle: "Brainova Quanten-Dame",
                quantumBadge: "ğŸš€ QUANTEN-KI",
                controlsTitle: "ğŸ® Quanten-Steuerung",
                gameModeTitle: "ğŸ® Spielmodus",
                aiMoveText: "Quanten-KI Zug",
                undoText: "Zug rÃ¼ckgÃ¤ngig",
                quantumModeText: "Quanten-Modus",
                newGameText: "Neues Spiel",
                statsTitle: "ğŸ“Š Statistiken",
                movesLabel: "Gespielte ZÃ¼ge",
                aiLevelLabel: "KI-Level",
                timeLabel: "Zeit",
                scoreLabel: "Punkte",
                aiModeText: "Gegen KI spielen",
                humanModeText: "2 Spieler",
                gameStatus: "Neues Spiel - Gelb beginnt",
                playerYellow: "Gelber Spieler",
                playerRed: "Roter Spieler",
                aiPlayer: "Quanten-KI",
                historyTitle: "ğŸ“œ Verlauf",
                gameStarted: "Spiel gestartet",
                optionsTitle: "âš™ï¸ KI-Optionen",
                difficultyText: "Schwierigkeit: Experte",
                analysisText: "KI-Analyse",
                hintText: "Beste ZÃ¼ge",
                saveText: "Spiel speichern",
                aiThinking: "Quanten-KI analysiert...",
                closeBtn: "SchlieÃŸen",
                turnOf: "Zug von",
                gameEnded: "Spiel beendet",
                newGameStarted: "Neues Spiel gestartet",
                quantumActivated: "Quanten-Modus aktiviert! Figuren kÃ¶nnen sich teleportieren!",
                quantumDeactivated: "Quanten-Modus deaktiviert",
                gameSaved: "Spiel gespeichert!",
                gameLoaded: "Spiel geladen!",
                loadSavedGame: "MÃ¶chten Sie das gespeicherte Spiel laden?",
                welcome: "Willkommen bei Brainova Quanten-Dame! WÃ¤hlen Sie Ihren Spielmodus.",
                aiCalculating: "Quanten-KI berechnet besten Zug...",
                undoInDevelopment: "RÃ¼ckgÃ¤ngig-Funktion in Entwicklung",
                aiAnalyzing: "KI-Analyse lÃ¤uft...",
                bestMovesCalculating: "Berechne beste ZÃ¼ge...",
                suggestion: "Vorschlag:",
                noMovesAvailable: "Keine ZÃ¼ge verfÃ¼gbar",
                difficultyChanged: "Schwierigkeit geÃ¤ndert:",
                yellowAdvantage: "Signifikanter Vorteil fÃ¼r Gelb",
                redAdvantage: "Signifikanter Vorteil fÃ¼r Rot",
                slightYellowAdvantage: "Leichter Vorteil fÃ¼r Gelb",
                slightRedAdvantage: "Leichter Vorteil fÃ¼r Rot",
                balancedPosition: "Ausgeglichene Position",
                victory: "Sieg fÃ¼r",
                yellows: "Gelb",
                reds: "Rot",
                difficulties: {
                    easy: "einfach",
                    normal: "normal",
                    hard: "schwer",
                    expert: "experte"
                },
                mustCapture: "Sie mÃ¼ssen eine gegnerische Figur schlagen!",
                invalidMove: "UngÃ¼ltiger Zug!",
                piecePromoted: "Figur zur Dame befÃ¶rdert!",
                multipleCaptures: "Mehrere SchlÃ¤ge mÃ¶glich!",
                allPiecesCaptured: "Alle Figuren geschlagen",
                noMovesLeft: "Keine ZÃ¼ge Ã¼brig",
                morePieces: "Mehr Figuren Ã¼brig",
                strategicAdvantage: "Strategischer Vorteil",
                reason: "Grund",
                finalScore: "Endpunktzahl",
                totalMoves: "GesamtzÃ¼ge",
                pauseText: "Pause",
                resumeText: "Fortsetzen",
                gamePaused: "Spiel pausiert",
                gameResumed: "Spiel fortgesetzt"
            },
            zh: {
                gameTitle: "è„‘è¯ºç“¦é‡å­è·³æ£‹",
                quantumBadge: "ğŸš€ é‡å­äººå·¥æ™ºèƒ½",
                controlsTitle: "ğŸ® é‡å­æ§åˆ¶",
                gameModeTitle: "ğŸ® æ¸¸æˆæ¨¡å¼",
                aiMoveText: "é‡å­AIèµ°æ£‹",
                undoText: "æ’¤é”€èµ°æ£‹",
                quantumModeText: "é‡å­æ¨¡å¼",
                newGameText: "æ–°æ¸¸æˆ",
                statsTitle: "ğŸ“Š ç»Ÿè®¡æ•°æ®",
                movesLabel: "å·²èµ°æ­¥æ•°",
                aiLevelLabel: "AIç­‰çº§",
                timeLabel: "æ—¶é—´",
                scoreLabel: "å¾—åˆ†",
                aiModeText: "å¯¹æˆ˜AI",
                humanModeText: "åŒäººå¯¹æˆ˜",
                gameStatus: "æ–°æ¸¸æˆ - é»„æ–¹å…ˆè¡Œ",
                playerYellow: "é»„æ–¹ç©å®¶",
                playerRed: "çº¢æ–¹ç©å®¶",
                aiPlayer: "é‡å­AI",
                historyTitle: "ğŸ“œ å†å²è®°å½•",
                gameStarted: "æ¸¸æˆå¼€å§‹",
                optionsTitle: "âš™ï¸ AIé€‰é¡¹",
                difficultyText: "éš¾åº¦ï¼šä¸“å®¶",
                analysisText: "AIåˆ†æ",
                hintText: "æœ€ä½³èµ°æ³•",
                saveText: "ä¿å­˜æ¸¸æˆ",
                aiThinking: "é‡å­AIåˆ†æä¸­...",
                closeBtn: "å…³é—­",
                turnOf: "è½®åˆ°",
                gameEnded: "æ¸¸æˆç»“æŸ",
                newGameStarted: "æ–°æ¸¸æˆå¼€å§‹",
                quantumActivated: "é‡å­æ¨¡å¼å·²æ¿€æ´»ï¼æ£‹å­å¯ä»¥ç¬ç§»ï¼",
                quantumDeactivated: "é‡å­æ¨¡å¼å·²å…³é—­",
                gameSaved: "æ¸¸æˆå·²ä¿å­˜ï¼",
                gameLoaded: "æ¸¸æˆå·²åŠ è½½ï¼",
                loadSavedGame: "æ‚¨è¦åŠ è½½ä¿å­˜çš„æ¸¸æˆå—ï¼Ÿ",
                welcome: "æ¬¢è¿æ¥åˆ°è„‘è¯ºç“¦é‡å­è·³æ£‹ï¼é€‰æ‹©æ‚¨çš„æ¸¸æˆæ¨¡å¼ã€‚",
                aiCalculating: "é‡å­AIæ­£åœ¨è®¡ç®—æœ€ä½³èµ°æ³•...",
                undoInDevelopment: "æ’¤é”€åŠŸèƒ½å¼€å‘ä¸­",
                aiAnalyzing: "AIåˆ†æè¿›è¡Œä¸­...",
                bestMovesCalculating: "è®¡ç®—æœ€ä½³èµ°æ³•ä¸­...",
                suggestion: "å»ºè®®ï¼š",
                noMovesAvailable: "æ— å¯ç”¨èµ°æ³•",
                difficultyChanged: "éš¾åº¦å·²æ›´æ”¹ï¼š",
                yellowAdvantage: "é»„æ–¹æ˜¾è‘—ä¼˜åŠ¿",
                redAdvantage: "çº¢æ–¹æ˜¾è‘—ä¼˜åŠ¿",
                slightYellowAdvantage: "é»„æ–¹è½»å¾®ä¼˜åŠ¿",
                slightRedAdvantage: "çº¢æ–¹è½»å¾®ä¼˜åŠ¿",
                balancedPosition: "å¹³è¡¡å±€é¢",
                victory: "è·èƒœæ–¹",
                yellows: "é»„æ–¹",
                reds: "çº¢æ–¹",
                difficulties: {
                    easy: "ç®€å•",
                    normal: "æ™®é€š",
                    hard: "å›°éš¾",
                    expert: "ä¸“å®¶"
                },
                mustCapture: "æ‚¨å¿…é¡»åƒæ‰å¯¹æ–¹æ£‹å­ï¼",
                invalidMove: "æ— æ•ˆç§»åŠ¨ï¼",
                piecePromoted: "æ£‹å­å‡çº§ä¸ºç‹ï¼",
                multipleCaptures: "å¯ä»¥è¿ç»­åƒå­ï¼",
                allPiecesCaptured: "æ‰€æœ‰æ£‹å­è¢«åƒ",
                noMovesLeft: "æ— å‰©ä½™èµ°æ³•",
                morePieces: "å‰©ä½™æ£‹å­æ›´å¤š",
                strategicAdvantage: "æˆ˜ç•¥ä¼˜åŠ¿",
                reason: "åŸå› ",
                finalScore: "æœ€ç»ˆå¾—åˆ†",
                totalMoves: "æ€»æ­¥æ•°",
                pauseText: "æš‚åœ",
                resumeText: "ç»§ç»­",
                gamePaused: "æ¸¸æˆå·²æš‚åœ",
                gameResumed: "æ¸¸æˆå·²ç»§ç»­"
            }
        };

        // Ã‰tat du jeu
        let gameState = {
            board: [],
            currentPlayer: 'yellow',
            gameMode: 'ai', // 'ai' ou 'human'
            selectedSquare: null,
            possibleMoves: [],
            moveHistory: [],
            moveCount: 0,
            startTime: null,
            timer: null,
            aiLevel: 5,
            score: 0,
            isGameActive: true,
            quantumMode: false,
            aiThinking: false,
            difficulty: 'expert',
            capturedPieces: { yellow: [], red: [] },
            currentLanguage: 'fr',
            mustCapture: false,
            captureSequence: [],
            isPaused: false
        };

        // Position initiale des pions
        const initialBoard = [
            [null, 'ğŸ”´', null, 'ğŸ”´', null, 'ğŸ”´', null, 'ğŸ”´'],
            ['ğŸ”´', null, 'ğŸ”´', null, 'ğŸ”´', null, 'ğŸ”´', null],
            [null, 'ğŸ”´', null, 'ğŸ”´', null, 'ğŸ”´', null, 'ğŸ”´'],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            ['ğŸŸ¡', null, 'ğŸŸ¡', null, 'ğŸŸ¡', null, 'ğŸŸ¡', null],
            [null, 'ğŸŸ¡', null, 'ğŸŸ¡', null, 'ğŸŸ¡', null, 'ğŸŸ¡'],
            ['ğŸŸ¡', null, 'ğŸŸ¡', null, 'ğŸŸ¡', null, 'ğŸŸ¡', null]
        ];

        // Fonction de changement de langue
        function changeLanguage() {
            const selector = document.getElementById('languageSelector');
            const selectedLang = selector.value;
            gameState.currentLanguage = selectedLang;
            
            const t = translations[selectedLang];
            
            // Mettre Ã  jour tous les textes
            document.getElementById('gameTitle').textContent = t.gameTitle;
            document.getElementById('quantumBadge').textContent = t.quantumBadge;
            document.getElementById('controlsTitle').textContent = t.controlsTitle;
            if(document.getElementById('gameModeTitle')) {
                document.getElementById('gameModeTitle').textContent = t.gameModeTitle;
            }
            document.getElementById('aiMoveText').textContent = t.aiMoveText;
            document.getElementById('undoText').textContent = t.undoText;
            document.getElementById('quantumModeText').textContent = t.quantumModeText;
            document.getElementById('newGameText').textContent = t.newGameText;
            document.getElementById('statsTitle').textContent = t.statsTitle;
            document.getElementById('movesLabel').textContent = t.movesLabel;
            document.getElementById('aiLevelLabel').textContent = t.aiLevelLabel;
            document.getElementById('timeLabel').textContent = t.timeLabel;
            document.getElementById('scoreLabel').textContent = t.scoreLabel;
            document.getElementById('aiModeText').textContent = t.aiModeText;
            document.getElementById('humanModeText').textContent = t.humanModeText;
            document.getElementById('historyTitle').textContent = t.historyTitle;
            document.getElementById('optionsTitle').textContent = t.optionsTitle;
            document.getElementById('analysisText').textContent = t.analysisText;
            document.getElementById('hintText').textContent = t.hintText;
            document.getElementById('saveText').textContent = t.saveText;
            document.getElementById('closeBtn').title = t.closeBtn;
            
            // Mettre Ã  jour le texte de difficultÃ©
            const diffText = t.difficultyText.replace('Expert', t.difficulties[gameState.difficulty]);
            document.getElementById('difficultyText').textContent = diffText;
            
            // Mettre Ã  jour le message "Partie commencÃ©e" dans l'historique
            const gameStartedElement = document.getElementById('gameStarted');
            if(gameStartedElement) {
                gameStartedElement.textContent = t.gameStarted;
            }
            
            // Mettre Ã  jour le bouton pause
            const pauseTextElement = document.getElementById('pauseText');
            if(pauseTextElement) {
                pauseTextElement.textContent = gameState.isPaused ? t.resumeText : t.pauseText;
            }
            
            updateUI();
        }

        // CrÃ©er les particules quantiques
        function createQuantumParticles() {
            const container = document.getElementById('quantumParticles');
            
            for(let i = 0; i < 35; i++) {
                const particle = document.createElement('div');
                particle.className = 'quantum-particle';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.animationDelay = Math.random() * 15 + 's';
                particle.style.animationDuration = (15 + Math.random() * 8) + 's';
                container.appendChild(particle);
            }
        }

        // CrÃ©er les lignes d'Ã©nergie
        function createEnergyLines() {
            const container = document.getElementById('energyLines');
            
            for(let i = 0; i < 10; i++) {
                const line = document.createElement('div');
                line.className = 'energy-line';
                line.style.top = Math.random() * 100 + '%';
                line.style.width = (250 + Math.random() * 500) + 'px';
                line.style.animationDelay = Math.random() * 10 + 's';
                line.style.animationDuration = (10 + Math.random() * 5) + 's';
                container.appendChild(line);
            }
        }

        // CrÃ©er les cercles d'Ã©nergie
        function createEnergyCircles() {
            const container = document.getElementById('energyCircles');
            
            for(let i = 0; i < 8; i++) {
                const circle = document.createElement('div');
                circle.className = 'energy-circle';
                circle.style.left = Math.random() * 100 + '%';
                circle.style.top = Math.random() * 100 + '%';
                circle.style.width = (60 + Math.random() * 120) + 'px';
                circle.style.height = circle.style.width;
                circle.style.animationDelay = Math.random() * 8 + 's';
                circle.style.animationDuration = (8 + Math.random() * 4) + 's';
                container.appendChild(circle);
            }
        }

        // CrÃ©er les rayons laser
        function createLaserBeams() {
            const container = document.getElementById('laserBeams');
            
            for(let i = 0; i < 6; i++) {
                const beam = document.createElement('div');
                beam.className = 'laser-beam';
                beam.style.left = Math.random() * 100 + '%';
                beam.style.animationDelay = Math.random() * 15 + 's';
                beam.style.animationDuration = (15 + Math.random() * 8) + 's';
                container.appendChild(beam);
            }
        }

        // Initialiser tous les effets futuristes
        function initFuturisticEffects() {
            createQuantumParticles();
            createEnergyLines();
            createEnergyCircles();
            createLaserBeams();
        }

        // Initialiser le jeu
        function initGame() {
            gameState.board = initialBoard.map(row => [...row]);
            gameState.currentPlayer = 'yellow';
            gameState.selectedSquare = null;
            gameState.possibleMoves = [];
            gameState.moveHistory = [];
            gameState.moveCount = 0;
            gameState.startTime = Date.now();
            gameState.isGameActive = true;
            gameState.quantumMode = false;
            gameState.mustCapture = false;
            gameState.captureSequence = [];
            
            createDameboard();
            updateUI();
            startTimer();
            
            const t = translations[gameState.currentLanguage];
            
            // Vider l'historique et ajouter le message de dÃ©but
            const historyElement = document.getElementById('moveHistory');
            historyElement.innerHTML = '';
            const gameStartedElement = document.createElement('div');
            gameStartedElement.className = 'move-item';
            gameStartedElement.id = 'gameStarted';
            gameStartedElement.textContent = t.gameStarted;
            historyElement.appendChild(gameStartedElement);
        }

        // CrÃ©er le plateau de dames
        function createDameboard() {
            const dameboard = document.getElementById('dameboard');
            dameboard.innerHTML = '';
            
            for(let row = 0; row < 8; row++) {
                for(let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = `dame-square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                    square.dataset.row = row;
                    square.dataset.col = col;
                    square.onclick = () => handleSquareClick(row, col);
                    
                    const piece = gameState.board[row][col];
                    if(piece) {
                        const pieceElement = document.createElement('div');
                        pieceElement.className = `dame-piece ${getPieceColor(piece)} ${isKing(piece) ? 'king' : ''}`;
                        pieceElement.textContent = piece;
                        square.appendChild(pieceElement);
                    }
                    
                    dameboard.appendChild(square);
                }
            }
        }

        // Obtenir la couleur d'une piÃ¨ce
        function getPieceColor(piece) {
            if(piece === 'ğŸŸ¡' || piece === 'ğŸ‘‘') return 'yellow';
            if(piece === 'ğŸ”´' || piece === 'â™›') return 'red';
            return null;
        }

        // VÃ©rifier si une piÃ¨ce est un roi/dame
        function isKing(piece) {
            return piece === 'ğŸ‘‘' || piece === 'â™›';
        }

        // GÃ©rer le clic sur une case
        function handleSquareClick(row, col) {
            if(!gameState.isGameActive || gameState.aiThinking || gameState.isPaused) return;
            
            const piece = gameState.board[row][col];
            
            // Si on est en mode capture multiple, seul le pion qui capture peut bouger
            if(gameState.mustCapture && gameState.captureSequence.length > 0) {
                const lastCapture = gameState.captureSequence[gameState.captureSequence.length - 1];
                
                // Si on clique sur une case de mouvement possible pour continuer la capture
                if(gameState.selectedSquare && 
                   gameState.selectedSquare.row === lastCapture.row && 
                   gameState.selectedSquare.col === lastCapture.col &&
                   gameState.possibleMoves.some(move => move.row === row && move.col === col)) {
                    makeMove(gameState.selectedSquare.row, gameState.selectedSquare.col, row, col);
                    return;
                }
                
                // Sinon, on ne peut sÃ©lectionner que le pion qui doit continuer Ã  capturer
                if(row === lastCapture.row && col === lastCapture.col) {
                    selectSquare(row, col);
                } else {
                    // Message d'erreur si on essaie de sÃ©lectionner autre chose
                    const t = translations[gameState.currentLanguage];
                    showAIMessage(t.mustCapture || "Vous devez continuer avec le mÃªme pion !", 2000);
                }
                return;
            }
            
            // Si aucune piÃ¨ce n'est sÃ©lectionnÃ©e
            if(!gameState.selectedSquare) {
                if(piece && getPieceColor(piece) === gameState.currentPlayer) {
                    selectSquare(row, col);
                }
                return;
            }
            
            // Si on clique sur la mÃªme case
            if(gameState.selectedSquare.row === row && gameState.selectedSquare.col === col) {
                deselectSquare();
                return;
            }
            
            // Si on clique sur une case de mouvement possible
            if(gameState.possibleMoves.some(move => move.row === row && move.col === col)) {
                makeMove(gameState.selectedSquare.row, gameState.selectedSquare.col, row, col);
                return;
            }
            
            // Si on clique sur une autre piÃ¨ce de la mÃªme couleur (et pas en capture multiple)
            if(piece && getPieceColor(piece) === gameState.currentPlayer && !gameState.mustCapture) {
                deselectSquare();
                selectSquare(row, col);
                return;
            }
            
            // Sinon, dÃ©sÃ©lectionner
            deselectSquare();
        }

        // SÃ©lectionner une case
        function selectSquare(row, col) {
            gameState.selectedSquare = { row, col };
            gameState.possibleMoves = calculatePossibleMoves(row, col);
            
            // Mettre en Ã©vidence la case sÃ©lectionnÃ©e
            const square = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            square.classList.add('selected');
            
            // Mettre en Ã©vidence les mouvements possibles
            gameState.possibleMoves.forEach(move => {
                const moveSquare = document.querySelector(`[data-row="${move.row}"][data-col="${move.col}"]`);
                moveSquare.classList.add('possible-move');
            });
        }

        // DÃ©sÃ©lectionner une case
        function deselectSquare() {
            if(gameState.selectedSquare) {
                const square = document.querySelector(`[data-row="${gameState.selectedSquare.row}"][data-col="${gameState.selectedSquare.col}"]`);
                square.classList.remove('selected');
            }
            
            // Enlever la mise en Ã©vidence des mouvements possibles
            document.querySelectorAll('.possible-move').forEach(square => {
                square.classList.remove('possible-move');
            });
            
            gameState.selectedSquare = null;
            gameState.possibleMoves = [];
        }

        // Calculer les mouvements possibles pour une piÃ¨ce
        function calculatePossibleMoves(row, col) {
            const piece = gameState.board[row][col];
            if(!piece) return [];
            
            const moves = [];
            const color = getPieceColor(piece);
            const king = isKing(piece);
            
            // Directions de mouvement
            let directions = [];
            if(king) {
                directions = [[-1, -1], [-1, 1], [1, -1], [1, 1]]; // Toutes les diagonales
            } else if(color === 'yellow') {
                directions = [[-1, -1], [-1, 1]]; // Vers le haut
            } else {
                directions = [[1, -1], [1, 1]]; // Vers le bas
            }
            
            // VÃ©rifier les captures obligatoires d'abord
            const captures = [];
            for(let [drow, dcol] of directions) {
                if(king) {
                    // Pour les dames : vÃ©rifier les captures Ã  longue distance
                    const longCaptures = checkLongRangeCapture(row, col, drow, dcol);
                    captures.push(...longCaptures);
                } else {
                    // Pour les pions : capture simple
                    const captureMove = checkCapture(row, col, drow, dcol);
                    if(captureMove) {
                        captures.push(captureMove);
                    }
                }
            }
            
            // Si des captures sont possibles, elles sont obligatoires
            if(captures.length > 0) {
                return captures;
            }
            
            // Sinon, mouvements normaux
            if(king) {
                // Les dames peuvent se dÃ©placer sur toute la diagonale
                for(let [drow, dcol] of directions) {
                    for(let distance = 1; distance < 8; distance++) {
                        const newRow = row + drow * distance;
                        const newCol = col + dcol * distance;
                        
                        if(newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                            if(!gameState.board[newRow][newCol]) {
                                moves.push({ row: newRow, col: newCol, type: 'move' });
                            } else {
                                break; // ArrÃªter si on rencontre une piÃ¨ce
                            }
                        } else {
                            break; // ArrÃªter si on sort du plateau
                        }
                    }
                }
            } else {
                // Les pions ne peuvent se dÃ©placer que d'une case
                for(let [drow, dcol] of directions) {
                    const newRow = row + drow;
                    const newCol = col + dcol;
                    
                    if(newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                        if(!gameState.board[newRow][newCol]) {
                            moves.push({ row: newRow, col: newCol, type: 'move' });
                        }
                    }
                }
            }
            
            return moves;
        }

        // VÃ©rifier une capture possible (pour les pions)
        function checkCapture(row, col, drow, dcol) {
            const jumpRow = row + drow;
            const jumpCol = col + dcol;
            const landRow = row + 2 * drow;
            const landCol = col + 2 * dcol;
            
            // VÃ©rifier les limites
            if(landRow < 0 || landRow >= 8 || landCol < 0 || landCol >= 8) return null;
            
            const jumpPiece = gameState.board[jumpRow][jumpCol];
            const landSquare = gameState.board[landRow][landCol];
            
            // Il doit y avoir une piÃ¨ce adverse Ã  sauter et une case vide pour atterrir
            if(jumpPiece && getPieceColor(jumpPiece) !== gameState.currentPlayer && !landSquare) {
                return { 
                    row: landRow, 
                    col: landCol, 
                    type: 'capture',
                    capturedRow: jumpRow,
                    capturedCol: jumpCol
                };
            }
            
            return null;
        }

        // VÃ©rifier les captures Ã  longue distance (pour les dames)
        function checkLongRangeCapture(row, col, drow, dcol) {
            const captures = [];
            let foundEnemy = false;
            let enemyRow = -1;
            let enemyCol = -1;
            let capturedPieces = [];
            
            // Parcourir la diagonale
            for(let distance = 1; distance < 8; distance++) {
                const checkRow = row + drow * distance;
                const checkCol = col + dcol * distance;
                
                // VÃ©rifier les limites
                if(checkRow < 0 || checkRow >= 8 || checkCol < 0 || checkCol >= 8) break;
                
                const piece = gameState.board[checkRow][checkCol];
                
                if(piece) {
                    if(getPieceColor(piece) !== gameState.currentPlayer) {
                        // PiÃ¨ce ennemie trouvÃ©e
                        if(foundEnemy) {
                            // DÃ©jÃ  une piÃ¨ce ennemie trouvÃ©e, arrÃªter
                            break;
                        }
                        foundEnemy = true;
                        enemyRow = checkRow;
                        enemyCol = checkCol;
                        capturedPieces.push({ row: checkRow, col: checkCol });
                    } else {
                        // PiÃ¨ce alliÃ©e, arrÃªter
                        break;
                    }
                } else if(foundEnemy) {
                    // Case vide aprÃ¨s une piÃ¨ce ennemie = capture possible
                    // Continuer Ã  chercher d'autres cases vides
                    captures.push({
                        row: checkRow,
                        col: checkCol,
                        type: 'capture',
                        capturedPieces: [...capturedPieces]
                    });
                }
            }
            
            return captures;
        }

        // Effectuer un mouvement
        function makeMove(fromRow, fromCol, toRow, toCol) {
            const piece = gameState.board[fromRow][fromCol];
            const move = gameState.possibleMoves.find(m => m.row === toRow && m.col === toCol);
            
            if(!move) return;
            
            // Effectuer le mouvement
            gameState.board[toRow][toCol] = piece;
            gameState.board[fromRow][fromCol] = null;
            
            let moveNotation = `${piece} ${String.fromCharCode(97 + fromCol)}${8 - fromRow} â†’ ${String.fromCharCode(97 + toCol)}${8 - toRow}`;
            let continueCapturing = false;
            
            // GÃ©rer les captures
            if(move.type === 'capture') {
                // Capturer toutes les piÃ¨ces dans le chemin (pour les dames)
                if(move.capturedPieces) {
                    move.capturedPieces.forEach(captured => {
                        const capturedPiece = gameState.board[captured.row][captured.col];
                        gameState.board[captured.row][captured.col] = null;
                        
                        const capturedColor = getPieceColor(capturedPiece);
                        gameState.capturedPieces[capturedColor].push(capturedPiece);
                        gameState.score += isKing(capturedPiece) ? 3 : 1;
                        moveNotation += ` (capture ${capturedPiece})`;
                    });
                } else {
                    // Capture simple (pion normal)
                    const capturedPiece = gameState.board[move.capturedRow][move.capturedCol];
                    gameState.board[move.capturedRow][move.capturedCol] = null;
                    
                    const capturedColor = getPieceColor(capturedPiece);
                    gameState.capturedPieces[capturedColor].push(capturedPiece);
                    gameState.score += isKing(capturedPiece) ? 3 : 1;
                    moveNotation += ` (capture ${capturedPiece})`;
                }
                
                // VÃ©rifier les captures multiples avec LE MÃŠME PION
                const additionalCaptures = calculatePossibleMoves(toRow, toCol).filter(m => m.type === 'capture');
                if(additionalCaptures.length > 0) {
                    gameState.mustCapture = true;
                    gameState.captureSequence.push({ row: toRow, col: toCol });
                    continueCapturing = true;
                    
                    // SÃ©lectionner automatiquement LA MÃŠME piÃ¨ce pour continuer
                    setTimeout(() => {
                        selectSquare(toRow, toCol);
                        const t = translations[gameState.currentLanguage];
                        showAIMessage(t.multipleCaptures, 2500);
                    }, 300);
                }
            }
            
            // Promotion en dame/roi
            if(!isKing(piece)) {
                if((getPieceColor(piece) === 'yellow' && toRow === 0) || 
                   (getPieceColor(piece) === 'red' && toRow === 7)) {
                    gameState.board[toRow][toCol] = getPieceColor(piece) === 'yellow' ? 'ğŸ‘‘' : 'â™›';
                    const t = translations[gameState.currentLanguage];
                    showAIMessage(t.piecePromoted, 2000);
                }
            }
            
            // Ajouter Ã  l'historique
            addMoveToHistory(moveNotation);
            gameState.moveCount++;
            
            // Si pas de capture multiple, terminer le tour
            if(!continueCapturing) {
                gameState.mustCapture = false;
                gameState.captureSequence = [];
                deselectSquare();
                
                // Changer de joueur seulement si pas de capture multiple
                gameState.currentPlayer = gameState.currentPlayer === 'yellow' ? 'red' : 'yellow';
            } else {
                // Ne pas dÃ©sÃ©lectionner si capture multiple avec LE MÃŠME PION
                // Le joueur actuel garde la main avec le mÃªme pion
            }
            
            createDameboard();
            
            // VÃ©rifier la fin de partie
            if(isGameOver()) {
                endGame();
                return;
            }
            
            updateUI();
            
            // Si c'est le tour de l'IA en mode IA ET pas de capture multiple
            if(gameState.gameMode === 'ai' && gameState.currentPlayer === 'red' && gameState.isGameActive && !continueCapturing) {
                setTimeout(() => {
                    if(gameState.isGameActive && gameState.currentPlayer === 'red') {
                        makeAIMove();
                    }
                }, 1200);
            }
            
            // Si l'IA doit continuer une capture multiple avec le mÃªme pion
            if(gameState.gameMode === 'ai' && gameState.currentPlayer === 'red' && gameState.isGameActive && continueCapturing) {
                setTimeout(() => {
                    if(gameState.isGameActive && gameState.currentPlayer === 'red' && gameState.mustCapture) {
                        makeAIMove();
                    }
                }, 1500);
            }
        }

        // Ajouter un coup Ã  l'historique
        function addMoveToHistory(move) {
            gameState.moveHistory.push(move);
            const historyElement = document.getElementById('moveHistory');
            const moveElement = document.createElement('div');
            moveElement.className = 'move-item';
            moveElement.textContent = `${gameState.moveHistory.length}. ${move}`;
            historyElement.appendChild(moveElement);
            historyElement.scrollTop = historyElement.scrollHeight;
        }

        // Coup de l'IA
        function makeAIMove() {
            if(gameState.currentPlayer !== 'red' || !gameState.isGameActive || gameState.gameMode !== 'ai' || gameState.isPaused) return;
            
            gameState.aiThinking = true;
            const t = translations[gameState.currentLanguage];
            showAIMessage(t.aiCalculating, 0);
            
            setTimeout(() => {
                if(gameState.isGameActive && gameState.currentPlayer === 'red' && gameState.gameMode === 'ai') {
                    const bestMove = calculateBestMove();
                    if(bestMove) {
                        // Simuler la sÃ©lection et le mouvement de l'IA
                        gameState.selectedSquare = { row: bestMove.fromRow, col: bestMove.fromCol };
                        gameState.possibleMoves = calculatePossibleMoves(bestMove.fromRow, bestMove.fromCol);
                        makeMove(bestMove.fromRow, bestMove.fromCol, bestMove.toRow, bestMove.toCol);
                    }
                }
                gameState.aiThinking = false;
                hideAIMessage();
            }, 1800 + Math.random() * 2500);
        }

        // Calculer le meilleur coup pour l'IA
        function calculateBestMove() {
            const allMoves = [];
            
            // GÃ©nÃ©rer tous les coups possibles pour les piÃ¨ces rouges
            for(let row = 0; row < 8; row++) {
                for(let col = 0; col < 8; col++) {
                    const piece = gameState.board[row][col];
                    if(piece && getPieceColor(piece) === 'red') {
                        const moves = calculatePossibleMoves(row, col);
                        moves.forEach(move => {
                            allMoves.push({
                                fromRow: row,
                                fromCol: col,
                                toRow: move.row,
                                toCol: move.col,
                                type: move.type,
                                score: evaluateMove(row, col, move.row, move.col, move)
                            });
                        });
                    }
                }
            }
            
            if(allMoves.length === 0) return null;
            
            // Prioriser les captures
            const captures = allMoves.filter(m => m.type === 'capture');
            if(captures.length > 0) {
                captures.sort((a, b) => b.score - a.score);
                return captures[0];
            }
            
            // Trier par score et prendre le meilleur
            allMoves.sort((a, b) => b.score - a.score);
            
            // Ajouter un peu d'alÃ©atoire selon la difficultÃ©
            const randomFactor = gameState.difficulty === 'easy' ? 0.6 : 
                                 gameState.difficulty === 'normal' ? 0.3 : 0.1;
            
            if(Math.random() < randomFactor) {
                return allMoves[Math.floor(Math.random() * Math.min(4, allMoves.length))];
            }
            
            return allMoves[0];
        }

        // Ã‰valuer un coup
        function evaluateMove(fromRow, fromCol, toRow, toCol, move) {
            let score = 0;
            
            // Bonus Ã©norme pour les captures
            if(move.type === 'capture') {
                const capturedPiece = gameState.board[move.capturedRow][move.capturedCol];
                score += isKing(capturedPiece) ? 30 : 10;
            }
            
            // Bonus pour avancer vers la promotion
            if(!isKing(gameState.board[fromRow][fromCol])) {
                score += (toRow - fromRow) * 2; // Plus on avance, mieux c'est
            }
            
            // Bonus pour contrÃ´ler le centre
            const centerDistance = Math.abs(toRow - 3.5) + Math.abs(toCol - 3.5);
            score += (7 - centerDistance) * 1.5;
            
            // Bonus pour la sÃ©curitÃ© (Ã©viter les bords)
            if(toRow > 0 && toRow < 7 && toCol > 0 && toCol < 7) {
                score += 2;
            }
            
            return score + Math.random() * 3;
        }

        // VÃ©rifier la fin de partie
        function isGameOver() {
            // Compter les piÃ¨ces
            let yellowPieces = 0;
            let redPieces = 0;
            let yellowMoves = 0;
            let redMoves = 0;
            
            for(let row = 0; row < 8; row++) {
                for(let col = 0; col < 8; col++) {
                    const piece = gameState.board[row][col];
                    if(piece) {
                        if(getPieceColor(piece) === 'yellow') {
                            yellowPieces++;
                            yellowMoves += calculatePossibleMoves(row, col).length;
                        } else {
                            redPieces++;
                            redMoves += calculatePossibleMoves(row, col).length;
                        }
                    }
                }
            }
            
            // Fin de partie si plus de piÃ¨ces ou plus de mouvements possibles
            return yellowPieces === 0 || redPieces === 0 || 
                   (gameState.currentPlayer === 'yellow' && yellowMoves === 0) ||
                   (gameState.currentPlayer === 'red' && redMoves === 0);
        }

        // Terminer la partie
        function endGame() {
            gameState.isGameActive = false;
            clearInterval(gameState.timer);
            
            const t = translations[gameState.currentLanguage];
            
            // DÃ©terminer le gagnant
            let yellowPieces = 0;
            let redPieces = 0;
            let yellowMoves = 0;
            let redMoves = 0;
            
            for(let row = 0; row < 8; row++) {
                for(let col = 0; col < 8; col++) {
                    const piece = gameState.board[row][col];
                    if(piece) {
                        if(getPieceColor(piece) === 'yellow') {
                            yellowPieces++;
                            yellowMoves += calculatePossibleMoves(row, col).length;
                        } else {
                            redPieces++;
                            redMoves += calculatePossibleMoves(row, col).length;
                        }
                    }
                }
            }
            
            let winner;
            let reason = "";
            
            // DÃ©terminer la raison de la victoire
            if(yellowPieces === 0) {
                winner = t.reds;
                reason = t.allPiecesCaptured || "Toutes les piÃ¨ces capturÃ©es";
            } else if(redPieces === 0) {
                winner = t.yellows;
                reason = t.allPiecesCaptured || "Toutes les piÃ¨ces capturÃ©es";
            } else if(gameState.currentPlayer === 'yellow' && yellowMoves === 0) {
                winner = t.reds;
                reason = t.noMovesLeft || "Aucun mouvement possible";
            } else if(gameState.currentPlayer === 'red' && redMoves === 0) {
                winner = t.yellows;
                reason = t.noMovesLeft || "Aucun mouvement possible";
            } else if(yellowPieces > redPieces) {
                winner = t.yellows;
                reason = t.morePieces || "Plus de piÃ¨ces";
            } else if(redPieces > yellowPieces) {
                winner = t.reds;
                reason = t.morePieces || "Plus de piÃ¨ces";
            } else {
                winner = gameState.currentPlayer === 'yellow' ? t.reds : t.yellows;
                reason = t.strategicAdvantage || "Avantage stratÃ©gique";
            }
            
            // Afficher un message de fin de partie dÃ©taillÃ©
            const finalMessage = `ğŸ† ${t.gameEnded}!\n\n${t.victory}: ${winner}\n${t.reason || "Raison"}: ${reason}\n\n${t.finalScore || "Score final"}: ${gameState.score} points\n${t.totalMoves || "Total coups"}: ${gameState.moveCount}`;
            
            // Afficher le message avec style
            showGameEndMessage(finalMessage);
            
            // Ajouter Ã  l'historique
            addMoveToHistory(`ğŸ† ${t.victory}: ${winner} (${reason})`);
        }
        
        // Afficher le message de fin de partie avec style
        function showGameEndMessage(message) {
            // CrÃ©er une overlay pour le message de fin
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 1000;
                backdrop-filter: blur(10px);
            `;
            
            const messageBox = document.createElement('div');
            messageBox.style.cssText = `
                background: linear-gradient(145deg, rgba(30, 30, 58, 0.95), rgba(76, 29, 149, 0.95));
                border: 3px solid #ff6b35;
                border-radius: 20px;
                padding: 40px;
                text-align: center;
                color: white;
                font-size: 18px;
                font-weight: bold;
                max-width: 500px;
                box-shadow: 0 0 50px rgba(255, 107, 53, 0.7);
                animation: gameEndPulse 2s ease-in-out infinite alternate;
                white-space: pre-line;
            `;
            
            messageBox.textContent = message;
            
            const closeButton = document.createElement('button');
            closeButton.textContent = 'âœ¨ Nouvelle Partie';
            closeButton.style.cssText = `
                margin-top: 30px;
                padding: 15px 30px;
                background: linear-gradient(145deg, #ff6b35, #f59e0b);
                color: white;
                border: none;
                border-radius: 15px;
                font-size: 16px;
                font-weight: bold;
                cursor: pointer;
                transition: all 0.3s ease;
            `;
            
            closeButton.onmouseover = () => {
                closeButton.style.transform = 'scale(1.1)';
                closeButton.style.boxShadow = '0 10px 30px rgba(255, 107, 53, 0.7)';
            };
            
            closeButton.onmouseout = () => {
                closeButton.style.transform = 'scale(1)';
                closeButton.style.boxShadow = 'none';
            };
            
            closeButton.onclick = () => {
                document.body.removeChild(overlay);
                resetGame();
            };
            
            messageBox.appendChild(closeButton);
            overlay.appendChild(messageBox);
            document.body.appendChild(overlay);
            
            // Ajouter l'animation CSS
            const style = document.createElement('style');
            style.textContent = `
                @keyframes gameEndPulse {
                    from { 
                        box-shadow: 0 0 50px rgba(255, 107, 53, 0.7);
                        transform: scale(1);
                    }
                    to { 
                        box-shadow: 0 0 80px rgba(255, 107, 53, 1);
                        transform: scale(1.02);
                    }
                }
            `;
            document.head.appendChild(style);
        }

        // Afficher un message IA
        function showAIMessage(message, duration = 2500) {
            const aiThinking = document.getElementById('aiThinking');
            const aiMessage = document.getElementById('aiMessage');
            
            aiMessage.textContent = message;
            aiThinking.classList.add('active');
            
            if(duration > 0) {
                setTimeout(() => {
                    aiThinking.classList.remove('active');
                }, duration);
            }
        }

        // Masquer le message IA
        function hideAIMessage() {
            const aiThinking = document.getElementById('aiThinking');
            aiThinking.classList.remove('active');
        }

        // DÃ©marrer le timer
        function startTimer() {
            if(gameState.timer) {
                clearInterval(gameState.timer);
            }
            
            gameState.timer = setInterval(() => {
                if(gameState.isGameActive) {
                    updateUI();
                }
            }, 1000);
        }

        // Mettre Ã  jour l'interface utilisateur
        function updateUI() {
            document.getElementById('moveCount').textContent = gameState.moveCount;
            document.getElementById('aiLevel').textContent = gameState.aiLevel;
            document.getElementById('gameScore').textContent = gameState.score;
            
            // Mettre Ã  jour le temps
            if(gameState.startTime) {
                const elapsedTime = Date.now() - gameState.startTime;
                const minutes = Math.floor(elapsedTime / 60000);
                const seconds = Math.floor((elapsedTime % 60000) / 1000);
                document.getElementById('gameTime').textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
            
            // Mettre Ã  jour le bouton statut du joueur
            const t = translations[gameState.currentLanguage];
            const playerName = gameState.currentPlayer === 'yellow' ? t.playerYellow : 
                              (gameState.gameMode === 'ai' ? t.aiPlayer : t.playerRed);
            const playerIcon = gameState.currentPlayer === 'yellow' ? 'ğŸ”¥' : 'ğŸ¤–';
            
            document.getElementById('currentPlayer').textContent = playerIcon;
            document.getElementById('playerName').textContent = playerName;
            
            // Changer la couleur du bouton selon le joueur
            const playerBtn = document.getElementById('playerStatusBtn');
            playerBtn.classList.remove('yellow-player', 'red-player');
            if(gameState.currentPlayer === 'yellow') {
                playerBtn.classList.add('yellow-player');
            } else {
                playerBtn.classList.add('red-player');
            }
        }

        // Fonction pour changer de joueur manuellement (mode 2 joueurs uniquement)
        function switchPlayer() {
            if(gameState.gameMode === 'human' && gameState.isGameActive && !gameState.aiThinking) {
                gameState.currentPlayer = gameState.currentPlayer === 'yellow' ? 'red' : 'yellow';
                deselectSquare();
                updateUI();
                
                const t = translations[gameState.currentLanguage];
                showAIMessage(`${t.turnOf} ${gameState.currentPlayer === 'yellow' ? t.playerYellow : t.playerRed}`, 1800);
            }
        }

        // Fonctions des boutons
        function setGameMode(mode) {
            gameState.gameMode = mode;
            
            const aiBtn = document.getElementById('aiModeBtn');
            const humanBtn = document.getElementById('humanModeBtn');
            
            if(mode === 'ai') {
                aiBtn.classList.add('active');
                humanBtn.classList.remove('active');
            } else {
                humanBtn.classList.add('active');
                aiBtn.classList.remove('active');
            }
            
            resetGame();
        }

        function undoMove() {
            if(gameState.moveHistory.length <= 1) return;
            
            const t = translations[gameState.currentLanguage];
            showAIMessage(t.undoInDevelopment, 2500);
        }

        function activateQuantumMode() {
            gameState.quantumMode = !gameState.quantumMode;
            const btn = document.getElementById('quantumBtn');
            const t = translations[gameState.currentLanguage];
            
            if(gameState.quantumMode) {
                btn.style.background = 'linear-gradient(145deg, #10b981, #059669)';
                showAIMessage(t.quantumActivated, 3500);
                
                // Ajouter des effets visuels quantiques
                document.querySelectorAll('.dame-square').forEach(square => {
                    if(Math.random() < 0.12) {
                        square.classList.add('quantum-state');
                        setTimeout(() => {
                            square.classList.remove('quantum-state');
                        }, 2500);
                    }
                });
            } else {
                btn.style.background = 'linear-gradient(145deg, #ec4899, #db2777)';
                showAIMessage(t.quantumDeactivated, 2500);
            }
        }

        function resetGame() {
            const t = translations[gameState.currentLanguage];
            showAIMessage(t.newGameStarted, 2500);
            initGame();
        }

        function changeDifficulty() {
            const difficulties = ['easy', 'normal', 'hard', 'expert'];
            const currentIndex = difficulties.indexOf(gameState.difficulty);
            const nextIndex = (currentIndex + 1) % difficulties.length;
            gameState.difficulty = difficulties[nextIndex];
            
            gameState.aiLevel = nextIndex + 2;
            
            const t = translations[gameState.currentLanguage];
            const diffText = t.difficultyText.replace('Expert', t.difficulties[gameState.difficulty]);
            document.getElementById('difficultyText').textContent = diffText;
            
            showAIMessage(`${t.difficultyChanged} ${t.difficulties[gameState.difficulty]}`, 2500);
        }

        function toggleAIAnalysis() {
            const t = translations[gameState.currentLanguage];
            showAIMessage(t.aiAnalyzing, 3500);
            
            setTimeout(() => {
                const analysis = analyzePosition();
                showAIMessage(analysis, 6000);
            }, 2500);
        }

        function analyzePosition() {
            let yellowScore = 0;
            let redScore = 0;
            
            for(let row = 0; row < 8; row++) {
                for(let col = 0; col < 8; col++) {
                    const piece = gameState.board[row][col];
                    if(piece) {
                        const value = isKing(piece) ? 3 : 1;
                        if(getPieceColor(piece) === 'yellow') {
                            yellowScore += value;
                        } else {
                            redScore += value;
                        }
                    }
                }
            }
            
            const t = translations[gameState.currentLanguage];
            const advantage = yellowScore - redScore;
            if(advantage > 4) return t.yellowAdvantage;
            if(advantage < -4) return t.redAdvantage;
            if(advantage > 0) return t.slightYellowAdvantage;
            if(advantage < 0) return t.slightRedAdvantage;
            return t.balancedPosition;
        }

        function showBestMoves() {
            const t = translations[gameState.currentLanguage];
            showAIMessage(t.bestMovesCalculating, 2500);
            
            setTimeout(() => {
                const moves = calculateBestMove();
                if(moves) {
                    const suggestion = `${t.suggestion} ${String.fromCharCode(97 + moves.fromCol)}${8 - moves.fromRow} â†’ ${String.fromCharCode(97 + moves.toCol)}${8 - moves.toRow}`;
                    showAIMessage(suggestion, 5000);
                } else {
                    showAIMessage(t.noMovesAvailable, 2500);
                }
            }, 2500);
        }

        function saveGame() {
            const saveData = {
                board: gameState.board,
                currentPlayer: gameState.currentPlayer,
                gameMode: gameState.gameMode,
                moveHistory: gameState.moveHistory,
                moveCount: gameState.moveCount,
                score: gameState.score,
                difficulty: gameState.difficulty,
                currentLanguage: gameState.currentLanguage
            };
            
            localStorage.setItem('quantumDamesSave', JSON.stringify(saveData));
            const t = translations[gameState.currentLanguage];
            showAIMessage(t.gameSaved, 2500);
        }

        function loadGame() {
            const saveData = localStorage.getItem('quantumDamesSave');
            if(saveData) {
                const data = JSON.parse(saveData);
                gameState.board = data.board;
                gameState.currentPlayer = data.currentPlayer;
                gameState.gameMode = data.gameMode;
                gameState.moveHistory = data.moveHistory;
                gameState.moveCount = data.moveCount;
                gameState.score = data.score;
                gameState.difficulty = data.difficulty;
                if(data.currentLanguage) {
                    gameState.currentLanguage = data.currentLanguage;
                    document.getElementById('languageSelector').value = data.currentLanguage;
                    changeLanguage();
                }
                
                createDameboard();
                updateUI();
                const t = translations[gameState.currentLanguage];
                showAIMessage(t.gameLoaded, 2500);
            }
        }

        // Fonction pour basculer pause/reprendre
        function togglePause() {
            const t = translations[gameState.currentLanguage];
            const pauseBtn = document.getElementById('pauseBtn');
            const pauseTextElement = document.getElementById('pauseText');
            
            gameState.isPaused = !gameState.isPaused;
            
            if(gameState.isPaused) {
                // Mettre en pause
                pauseBtn.innerHTML = 'â–¶ï¸ <span id="pauseText">' + t.resumeText + '</span>';
                pauseBtn.style.background = 'linear-gradient(145deg, #10b981, #059669)';
                showAIMessage(t.gamePaused, 2000);
                
                // ArrÃªter le timer
                if(gameState.timer) {
                    clearInterval(gameState.timer);
                }
            } else {
                // Reprendre
                pauseBtn.innerHTML = 'â¸ï¸ <span id="pauseText">' + t.pauseText + '</span>';
                pauseBtn.style.background = 'linear-gradient(145deg, #8b5cf6, #7c3aed)';
                showAIMessage(t.gameResumed, 2000);
                
                // RedÃ©marrer le timer
                startTimer();
            }
        }

        // Initialisation
        document.addEventListener('DOMContentLoaded', function() {
            initFuturisticEffects();
            initGame();
            
            // Charger une sauvegarde si elle existe
            if(localStorage.getItem('quantumDamesSave')) {
                setTimeout(() => {
                    const t = translations[gameState.currentLanguage];
                    if(confirm(t.loadSavedGame)) {
                        loadGame();
                    }
                }, 1200);
            }
            
            // Message de bienvenue
            setTimeout(() => {
                const t = translations[gameState.currentLanguage];
                showAIMessage(t.welcome, 5000);
            }, 1200);
        });
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'984959ce0269777e',t:'MTc1ODc5MTAzMi4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>
