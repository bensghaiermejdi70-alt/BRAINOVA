<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üî• Brainova Quantum Dames - IA Futuriste</title>
    <script>
        (function(){
            if(window.__platform_nonblocking_dialogs) return; window.__platform_nonblocking_dialogs=true;
            try{
                const _alert = window.alert.bind(window);
                const _confirm = window.confirm.bind(window);
                const _prompt = window.prompt.bind(window);
                function send(type,text){ try{ if(window.parent && window.parent!==window) parent.postMessage({action:'dialog', dialogType:type, text:String(text||'')}, '*'); }catch(e){} }
                window.alert = function(msg){ if(window.parent && window.parent!==window){ send('alert', msg); } else { _alert(msg); } };
                window.confirm = function(msg){ if(window.parent && window.parent!==window){ send('confirm', msg); return true; } else { return _confirm(msg); } };
                window.prompt = function(msg, def){ if(window.parent && window.parent!==window){ send('prompt', msg+'\n(default: '+(def||'')+')'); return def||null; } else { return _prompt(msg, def); } };
            }catch(e){ }
        })();
    </script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            box-sizing: border-box;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a3a 30%, #2d1b69 70%, #4c1d95 100%);
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }

        /* Particules quantiques d'arri√®re-plan */
        .quantum-particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .quantum-particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: #ff6b35;
            border-radius: 50%;
            animation: quantumFloat 15s infinite linear;
            box-shadow: 0 0 12px #ff6b35, 0 0 24px #ff6b35;
        }

        @keyframes quantumFloat {
            0% {
                transform: translateY(100vh) translateX(0) rotate(0deg) scale(0);
                opacity: 0;
            }
            10% {
                opacity: 1;
                transform: translateY(90vh) translateX(30px) rotate(45deg) scale(1);
            }
            50% {
                transform: translateY(50vh) translateX(-40px) rotate(180deg) scale(1.8);
            }
            90% {
                opacity: 1;
                transform: translateY(10vh) translateX(60px) rotate(315deg) scale(1);
            }
            100% {
                transform: translateY(-10vh) translateX(120px) rotate(360deg) scale(0);
                opacity: 0;
            }
        }

        /* Lignes d'√©nergie futuristes */
        .energy-lines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
            overflow: hidden;
        }

        .energy-line {
            position: absolute;
            height: 3px;
            background: linear-gradient(90deg, transparent, #ff6b35, transparent);
            animation: energyFlow 10s infinite linear;
            box-shadow: 0 0 15px #ff6b35;
        }

        @keyframes energyFlow {
            0% {
                transform: translateX(-100%);
                opacity: 0;
            }
            10% {
                opacity: 1;
            }
            90% {
                opacity: 1;
            }
            100% {
                transform: translateX(100vw);
                opacity: 0;
            }
        }

        /* Cercles d'√©nergie pulsants */
        .energy-circles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .energy-circle {
            position: absolute;
            border: 3px solid rgba(255, 107, 53, 0.4);
            border-radius: 50%;
            animation: energyPulse 8s infinite ease-in-out;
        }

        @keyframes energyPulse {
            0% {
                transform: scale(0) rotate(0deg);
                opacity: 1;
                border-color: rgba(255, 107, 53, 0.9);
            }
            50% {
                transform: scale(1.2) rotate(180deg);
                opacity: 0.6;
                border-color: rgba(255, 107, 53, 0.5);
            }
            100% {
                transform: scale(2.5) rotate(360deg);
                opacity: 0;
                border-color: rgba(255, 107, 53, 0.1);
            }
        }

        /* Grille quantique de fond */
        .quantum-grid {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(255, 107, 53, 0.15) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 107, 53, 0.15) 1px, transparent 1px);
            background-size: 80px 80px;
            animation: quantumGridMove 30s linear infinite;
            z-index: 1;
        }

        @keyframes quantumGridMove {
            0% { transform: translate(0, 0) rotate(0deg); }
            50% { transform: translate(40px, 40px) rotate(2deg); }
            100% { transform: translate(80px, 80px) rotate(0deg); }
        }

        /* Rayons laser */
        .laser-beams {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .laser-beam {
            position: absolute;
            width: 3px;
            height: 100vh;
            background: linear-gradient(to bottom, 
                transparent 0%, 
                rgba(255, 107, 53, 0.9) 20%, 
                rgba(255, 107, 53, 0.5) 50%, 
                rgba(255, 107, 53, 0.9) 80%, 
                transparent 100%);
            animation: laserScan 15s infinite linear;
            box-shadow: 0 0 25px rgba(255, 107, 53, 0.7);
        }

        @keyframes laserScan {
            0% {
                transform: translateX(-15px);
                opacity: 0;
            }
            10% {
                opacity: 1;
            }
            90% {
                opacity: 1;
            }
            100% {
                transform: translateX(100vw);
                opacity: 0;
            }
        }

        /* Container principal */
        .quantum-dames-container {
            position: relative;
            z-index: 10;
            display: grid;
            grid-template-columns: 180px 1fr 180px;
            gap: 12px;
            min-height: 100vh;
            padding: 10px;
            max-width: 1200px;
            margin: 0 auto;
            padding-top: 15px;
        }

        .left-panel, .right-panel {
            background: linear-gradient(145deg, 
                rgba(30, 30, 58, 0.95) 0%,
                rgba(45, 27, 105, 0.95) 50%,
                rgba(76, 29, 149, 0.95) 100%);
            backdrop-filter: blur(30px);
            border-radius: 15px;
            padding: 12px;
            height: fit-content;
            box-shadow: 
                0 15px 30px rgba(0, 0, 0, 0.7),
                0 0 60px rgba(255, 107, 53, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 107, 53, 0.5);
            animation: quantumPanelGlow 5s ease-in-out infinite alternate;
        }

        .game-panel {
            background: linear-gradient(145deg, 
                rgba(30, 30, 58, 0.95) 0%,
                rgba(45, 27, 105, 0.95) 50%,
                rgba(76, 29, 149, 0.95) 100%);
            backdrop-filter: blur(30px);
            border-radius: 20px;
            padding: 20px;
            width: 100%;
            height: fit-content;
            box-shadow: 
                0 25px 50px rgba(0, 0, 0, 0.7),
                0 0 100px rgba(255, 107, 53, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 107, 53, 0.5);
            animation: quantumPanelGlow 5s ease-in-out infinite alternate;
        }

        @keyframes quantumPanelGlow {
            from { 
                box-shadow: 
                    0 25px 50px rgba(0, 0, 0, 0.7),
                    0 0 100px rgba(255, 107, 53, 0.2),
                    inset 0 1px 0 rgba(255, 255, 255, 0.1);
            }
            to { 
                box-shadow: 
                    0 30px 60px rgba(0, 0, 0, 0.7),
                    0 0 120px rgba(255, 107, 53, 0.3),
                    inset 0 1px 0 rgba(255, 255, 255, 0.2);
            }
        }

        /* En-t√™te du jeu */
        .quantum-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid rgba(255, 107, 53, 0.5);
        }

        .quantum-title {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .quantum-title h1 {
            color: #ff6b35;
            margin: 0;
            font-size: 18px;
            font-weight: 700;
            text-shadow: 0 0 30px rgba(255, 107, 53, 0.9);
            animation: quantumTitlePulse 4s infinite alternate;
        }

        @keyframes quantumTitlePulse {
            from { 
                text-shadow: 0 0 30px rgba(255, 107, 53, 0.9);
                transform: scale(1);
            }
            to { 
                text-shadow: 0 0 40px rgba(255, 107, 53, 1);
                transform: scale(1.03);
            }
        }

        .quantum-icon {
            font-size: 28px;
            animation: quantumIconSpin 8s linear infinite;
            filter: drop-shadow(0 0 20px #ff6b35);
            color: #fbbf24;
            text-shadow: 
                0 0 15px rgba(251, 191, 36, 0.9),
                0 0 30px rgba(251, 191, 36, 0.7),
                0 0 45px rgba(251, 191, 36, 0.5);
        }

        @keyframes quantumIconSpin {
            0% { transform: rotate(0deg) scale(1); }
            25% { transform: rotate(90deg) scale(1.15); }
            50% { transform: rotate(180deg) scale(1); }
            75% { transform: rotate(270deg) scale(1.15); }
            100% { transform: rotate(360deg) scale(1); }
        }

        .quantum-badge {
            background: linear-gradient(45deg, #ff6b35, #f59e0b, #ef4444, #8b5cf6);
            background-size: 400% 400%;
            color: white;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 10px;
            font-weight: bold;
            animation: quantumBadgeShine 5s ease-in-out infinite;
            box-shadow: 0 0 25px rgba(255, 107, 53, 0.7);
        }

        @keyframes quantumBadgeShine {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .close-btn {
            background: rgba(255, 0, 0, 0.25);
            border: 2px solid rgba(255, 0, 0, 0.6);
            color: #ff4757;
            width: 45px;
            height: 45px;
            border-radius: 50%;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .close-btn:hover {
            background: rgba(255, 0, 0, 0.5);
            transform: scale(1.15) rotate(90deg);
            box-shadow: 0 0 30px rgba(255, 71, 87, 0.9);
        }

        /* S√©lecteur de langue */
        .language-selector {
            background: linear-gradient(145deg, #ff6b35, #f59e0b);
            color: white;
            border: 2px solid rgba(255, 107, 53, 0.5);
            border-radius: 15px;
            padding: 12px 18px;
            font-weight: bold;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.3s ease;
            box-shadow: 0 0 25px rgba(255, 107, 53, 0.5);
            backdrop-filter: blur(15px);
            min-width: 160px;
            max-height: 220px;
            overflow-y: auto;
        }

        .language-selector:hover {
            background: linear-gradient(145deg, #ff8c42, #fbbf24);
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(255, 107, 53, 0.7);
            border-color: rgba(255, 107, 53, 0.7);
        }

        .language-selector:focus {
            outline: none;
            box-shadow: 0 0 35px rgba(255, 107, 53, 0.9);
            border-color: rgba(255, 107, 53, 0.9);
        }

        .language-selector option {
            background: #1e1e3a;
            color: white;
            padding: 10px 15px;
            border: none;
            font-size: 13px;
        }

        .language-selector option:hover {
            background: #ff6b35;
        }

        /* Contr√¥les de mode de jeu */
        .game-mode-controls {
            display: flex;
            justify-content: center;
            gap: 12px;
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 12px;
            border: 2px solid rgba(255, 107, 53, 0.4);
        }

        .mode-btn {
            padding: 12px 20px;
            background: linear-gradient(145deg, #ff6b35, #f59e0b);
            color: white;
            border: none;
            border-radius: 12px;
            font-weight: bold;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 1.2px;
            min-width: 130px;
        }

        .mode-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.5), transparent);
            transition: left 0.6s ease;
        }

        .mode-btn:hover::before {
            left: 100%;
        }

        .mode-btn:hover {
            transform: translateY(-4px);
            box-shadow: 0 12px 35px rgba(255, 107, 53, 0.6);
            background: linear-gradient(145deg, #ff8c42, #fbbf24);
        }

        .mode-btn.active {
            background: linear-gradient(145deg, #8b5cf6, #7c3aed);
            box-shadow: 0 0 30px rgba(139, 92, 246, 0.7);
        }

        .mode-btn.active:hover {
            background: linear-gradient(145deg, #a78bfa, #8b5cf6);
        }

        /* Plateau de dames quantique */
        .quantum-dameboard-container {
            display: flex;
            justify-content: center;
            margin-bottom: 15px;
            position: relative;
            margin-top: 15px;
        }

        .quantum-dameboard {
            width: 480px;
            height: 480px;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            border: 4px solid rgba(255, 107, 53, 0.9);
            border-radius: 18px;
            box-shadow: 
                0 0 35px rgba(255, 107, 53, 0.7),
                0 0 70px rgba(255, 107, 53, 0.4),
                inset 0 0 25px rgba(255, 107, 53, 0.25);
            animation: quantumBoardGlow 6s ease-in-out infinite alternate;
            position: relative;
            overflow: hidden;
        }

        @keyframes quantumBoardGlow {
            from { 
                box-shadow: 
                    0 0 30px rgba(255, 107, 53, 0.5),
                    0 0 60px rgba(255, 107, 53, 0.3),
                    inset 0 0 20px rgba(255, 107, 53, 0.2);
            }
            to { 
                box-shadow: 
                    0 0 40px rgba(255, 107, 53, 0.7),
                    0 0 80px rgba(255, 107, 53, 0.4),
                    inset 0 0 30px rgba(255, 107, 53, 0.25);
            }
        }

        .dame-square {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 107, 53, 0.4);
            box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.2);
        }

        .dame-square.light {
            background: linear-gradient(145deg, #f3f4f6, #d1d5db);
            box-shadow: 
                inset 0 0 20px rgba(255, 255, 255, 0.5),
                inset 0 0 12px rgba(255, 107, 53, 0.2);
        }

        .dame-square.dark {
            background: linear-gradient(145deg, #374151, #1f2937);
            box-shadow: 
                inset 0 0 20px rgba(0, 0, 0, 0.7),
                inset 0 0 12px rgba(255, 107, 53, 0.3);
        }

        .dame-square:hover {
            transform: scale(1.08);
            z-index: 15;
            box-shadow: 
                0 0 30px rgba(255, 107, 53, 0.9),
                inset 0 0 25px rgba(255, 107, 53, 0.3);
            border: 2px solid rgba(255, 107, 53, 0.7);
        }

        .dame-square.selected {
            background: linear-gradient(145deg, #fbbf24, #f59e0b) !important;
            box-shadow: 
                0 0 35px rgba(251, 191, 36, 1),
                inset 0 0 25px rgba(251, 191, 36, 0.4),
                0 0 60px rgba(251, 191, 36, 0.6);
            transform: scale(1.12);
            z-index: 25;
            border: 3px solid #fbbf24;
            animation: selectedPulse 2s ease-in-out infinite alternate;
        }

        @keyframes selectedPulse {
            from { 
                box-shadow: 
                    0 0 35px rgba(251, 191, 36, 1),
                    inset 0 0 25px rgba(251, 191, 36, 0.4),
                    0 0 60px rgba(251, 191, 36, 0.6);
            }
            to { 
                box-shadow: 
                    0 0 45px rgba(251, 191, 36, 1),
                    inset 0 0 35px rgba(251, 191, 36, 0.5),
                    0 0 80px rgba(251, 191, 36, 0.8);
            }
        }

        .dame-square.possible-move {
            background: linear-gradient(145deg, #10b981, #059669) !important;
            box-shadow: 
                0 0 25px rgba(16, 185, 129, 0.9),
                inset 0 0 20px rgba(16, 185, 129, 0.3);
            border: 2px solid #10b981;
            animation: possibleMovePulse 2.5s ease-in-out infinite alternate;
        }

        @keyframes possibleMovePulse {
            from { 
                box-shadow: 
                    0 0 25px rgba(16, 185, 129, 0.9),
                    inset 0 0 20px rgba(16, 185, 129, 0.3);
            }
            to { 
                box-shadow: 
                    0 0 35px rgba(16, 185, 129, 1),
                    inset 0 0 30px rgba(16, 185, 129, 0.4);
            }
        }

        .dame-square.quantum-state {
            background: linear-gradient(145deg, #ec4899, #db2777) !important;
            box-shadow: 
                0 0 30px rgba(236, 72, 153, 1),
                inset 0 0 25px rgba(236, 72, 153, 0.4);
            animation: quantumPulse 1.2s infinite alternate;
            border: 2px solid #ec4899;
        }

        @keyframes quantumPulse {
            from { transform: scale(1); }
            to { transform: scale(1.08); }
        }

        /* Pions de dames */
        .dame-piece {
            width: 42px;
            height: 42px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: 900;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            z-index: 10;
            border: 2px solid rgba(0, 0, 0, 0.3);
            box-shadow: 
                0 6px 12px rgba(0, 0, 0, 0.4),
                inset 0 2px 4px rgba(255, 255, 255, 0.3);
        }

        .dame-piece:hover {
            transform: scale(1.2);
            z-index: 20;
            box-shadow: 
                0 12px 24px rgba(0, 0, 0, 0.5),
                0 0 25px currentColor,
                inset 0 2px 4px rgba(255, 255, 255, 0.4);
            animation: pieceGlow 0.6s ease-in-out;
        }

        @keyframes pieceGlow {
            0% { transform: scale(1.2); }
            50% { transform: scale(1.25); }
            100% { transform: scale(1.2); }
        }

        .dame-piece.white {
            background: linear-gradient(145deg, #fbbf24, #f59e0b);
            color: #1f2937;
            text-shadow: 
                2px 2px 4px rgba(0, 0, 0, 0.3),
                0 0 15px rgba(251, 191, 36, 0.8);
            border-color: rgba(31, 41, 55, 0.4);
        }

        .dame-piece.white:hover {
            background: linear-gradient(145deg, #fcd34d, #fbbf24);
            text-shadow: 
                2px 2px 4px rgba(0, 0, 0, 0.4),
                0 0 20px rgba(252, 211, 77, 1);
        }

        .dame-piece.black {
            background: linear-gradient(145deg, #ef4444, #dc2626);
            color: #f9fafb;
            text-shadow: 
                2px 2px 4px rgba(0, 0, 0, 0.6),
                0 0 15px rgba(239, 68, 68, 0.8);
            border-color: rgba(249, 250, 251, 0.4);
        }

        .dame-piece.black:hover {
            background: linear-gradient(145deg, #f87171, #ef4444);
            text-shadow: 
                2px 2px 4px rgba(0, 0, 0, 0.7),
                0 0 20px rgba(248, 113, 113, 1);
        }

        .dame-piece.king {
            font-size: 24px;
            border-width: 3px;
            box-shadow: 
                0 8px 16px rgba(0, 0, 0, 0.5),
                0 0 25px currentColor,
                inset 0 3px 6px rgba(255, 255, 255, 0.4);
        }

        /* Panneau de titre des sections */
        .panel-title {
            color: #ff6b35;
            font-size: 13px;
            font-weight: bold;
            margin-bottom: 12px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            text-shadow: 0 0 15px rgba(255, 107, 53, 0.9);
            border-bottom: 2px solid rgba(255, 107, 53, 0.5);
            padding-bottom: 8px;
        }

        /* Contr√¥les quantiques */
        .quantum-controls {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px;
            margin-bottom: 12px;
        }

        .quantum-btn {
            padding: 10px 14px;
            background: linear-gradient(145deg, #ff6b35, #f59e0b);
            color: white;
            border: none;
            border-radius: 10px;
            font-weight: bold;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 0.6px;
        }

        .quantum-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            transition: left 0.6s ease;
        }

        .quantum-btn:hover::before {
            left: 100%;
        }

        .quantum-btn:hover {
            transform: translateY(-4px);
            box-shadow: 0 10px 30px rgba(255, 107, 53, 0.5);
            background: linear-gradient(145deg, #ff8c42, #fbbf24);
        }

        .quantum-btn:active {
            transform: translateY(-2px);
        }

        .quantum-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        /* Boutons sp√©cialis√©s */
        .ai-btn {
            background: linear-gradient(145deg, #8b5cf6, #7c3aed);
        }

        .ai-btn:hover {
            background: linear-gradient(145deg, #a78bfa, #8b5cf6);
        }

        .reset-btn {
            background: linear-gradient(145deg, #ef4444, #dc2626);
        }

        .reset-btn:hover {
            background: linear-gradient(145deg, #f87171, #ef4444);
        }

        .quantum-special-btn {
            background: linear-gradient(145deg, #ec4899, #db2777);
        }

        .quantum-special-btn:hover {
            background: linear-gradient(145deg, #f472b6, #ec4899);
        }

        /* Bouton statut du joueur */
        .player-status-btn {
            display: inline-flex;
            align-items: center;
            gap: 12px;
            padding: 12px 18px;
            background: linear-gradient(145deg, #ff6b35, #f59e0b);
            color: white;
            border: none;
            border-radius: 15px;
            font-weight: bold;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            box-shadow: 0 4px 12px rgba(255, 107, 53, 0.5);
            border: 2px solid rgba(255, 107, 53, 0.4);
        }

        .player-status-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            transition: left 0.6s ease;
        }

        .player-status-btn:hover::before {
            left: 100%;
        }

        .player-status-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(255, 107, 53, 0.7);
            background: linear-gradient(145deg, #ff8c42, #fbbf24);
            border-color: rgba(255, 107, 53, 0.6);
        }

        .player-status-btn:active {
            transform: translateY(-1px);
        }

        .player-status-btn.yellow-player {
            background: linear-gradient(145deg, #fef08a, #fbbf24);
            border-color: rgba(254, 240, 138, 0.6);
            color: #1f2937;
            text-shadow: 0 0 10px rgba(254, 240, 138, 0.9);
        }

        .player-status-btn.yellow-player:hover {
            background: linear-gradient(145deg, #fefce8, #fef08a);
            border-color: rgba(254, 240, 138, 0.8);
            box-shadow: 0 10px 30px rgba(254, 240, 138, 0.7);
        }

        .player-status-btn.red-player {
            background: linear-gradient(145deg, #ef4444, #dc2626);
            border-color: rgba(239, 68, 68, 0.6);
            color: white;
        }

        .player-status-btn.red-player:hover {
            background: linear-gradient(145deg, #f87171, #ef4444);
            border-color: rgba(239, 68, 68, 0.8);
            box-shadow: 0 10px 30px rgba(239, 68, 68, 0.7);
        }

        .player-status-btn #currentPlayer {
            font-size: 18px;
            text-shadow: 0 0 12px rgba(255, 255, 255, 0.9);
        }

        /* IA Quantique Status */
        .quantum-ai-status {
            margin-bottom: 18px;
            text-align: center;
            min-height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .ai-thinking {
            display: inline-flex;
            align-items: center;
            gap: 15px;
            color: #ff6b35;
            font-size: 15px;
            opacity: 0;
            transition: opacity 0.6s ease;
            background: rgba(255, 107, 53, 0.2);
            padding: 12px 25px;
            border-radius: 30px;
            border: 1px solid rgba(255, 107, 53, 0.5);
        }

        .ai-thinking.active {
            opacity: 1;
        }

        .quantum-pulse {
            width: 15px;
            height: 15px;
            background: #ff6b35;
            border-radius: 50%;
            animation: quantumAIPulse 2.5s infinite;
            box-shadow: 0 0 20px #ff6b35;
        }

        @keyframes quantumAIPulse {
            0%, 100% { 
                transform: scale(1); 
                opacity: 1; 
            }
            50% { 
                transform: scale(2); 
                opacity: 0.4; 
            }
        }

        /* Statistiques du jeu */
        .game-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 12px;
        }

        .stat-item {
            background: rgba(255, 107, 53, 0.15);
            padding: 8px;
            border-radius: 12px;
            text-align: center;
            border: 2px solid rgba(255, 107, 53, 0.4);
            position: relative;
            overflow: hidden;
        }

        .stat-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 107, 53, 0.3), transparent);
            animation: statQuantumScan 5s linear infinite;
        }

        @keyframes statQuantumScan {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .stat-label {
            display: block;
            color: #9ca3af;
            font-size: 10px;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 1.2px;
        }

        .stat-value {
            display: block;
            color: #ff6b35;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 0 0 15px rgba(255, 107, 53, 0.9);
            position: relative;
            z-index: 1;
        }

        /* Historique des coups */
        .move-history {
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid rgba(255, 107, 53, 0.4);
            border-radius: 12px;
            padding: 10px;
            max-height: 150px;
            overflow-y: auto;
        }

        .move-item {
            color: #ff6b35;
            font-size: 12px;
            padding: 5px 10px;
            margin-bottom: 5px;
            background: rgba(255, 107, 53, 0.15);
            border-radius: 8px;
            border-left: 3px solid #ff6b35;
        }

        /* Responsive */
        @media (max-width: 1100px) {
            .quantum-dames-container {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .left-panel, .right-panel {
                display: none;
            }
            
            .quantum-dameboard {
                width: 450px;
                height: 450px;
            }
            
            .dame-piece {
                width: 38px;
                height: 38px;
                font-size: 18px;
            }
        }

        @media (max-width: 768px) {
            .game-panel {
                padding: 15px;
                margin: 8px;
            }
            
            .game-mode-controls {
                flex-direction: column;
                gap: 12px;
            }
            
            .quantum-title h1 {
                font-size: 16px;
            }
            
            .quantum-dameboard {
                width: 480px;
                height: 480px;
            }
            
            .dame-piece {
                width: 40px;
                height: 40px;
                font-size: 20px;
            }
        }

        @media (max-width: 520px) {
            .quantum-dameboard {
                width: 400px;
                height: 400px;
            }
            
            .dame-piece {
                width: 35px;
                height: 35px;
                font-size: 18px;
            }
            
            .game-stats {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <!-- Particules quantiques d'arri√®re-plan -->
    <div class="quantum-particles" id="quantumParticles"></div>
    
    <!-- Grille quantique -->
    <div class="quantum-grid"></div>
    
    <!-- Lignes d'√©nergie futuristes -->
    <div class="energy-lines" id="energyLines"></div>
    
    <!-- Cercles d'√©nergie pulsants -->
    <div class="energy-circles" id="energyCircles"></div>
    
    <!-- Rayons laser -->
    <div class="laser-beams" id="laserBeams"></div>
    
    <!-- Container principal -->
    <div class="quantum-dames-container">
        <!-- Panneau gauche -->
        <div class="left-panel">
            <div class="panel-section">
                <div class="panel-title" id="controlsTitle">üéÆ Contr√¥les Quantiques</div>
                <div class="quantum-controls">
                    <button class="quantum-btn" onclick="undoMove()" id="undoBtn">
                        ‚Ü∂ <span id="undoText">Annuler Coup</span>
                    </button>
                    <button class="quantum-btn quantum-special-btn" onclick="activateQuantumMode()" id="quantumBtn">
                        ‚öõÔ∏è <span id="quantumModeText">Mode Quantique</span>
                    </button>
                    <button class="quantum-btn reset-btn" onclick="resetGame()">
                        üîÑ <span id="newGameText">Nouvelle Partie</span>
                    </button>
                </div>
            </div>

            <div class="panel-section">
                <div class="panel-title" id="statsTitle">üìä Statistiques</div>
                <div class="game-stats">
                    <div class="stat-item">
                        <span class="stat-label" id="movesLabel">Coups Jou√©s</span>
                        <span class="stat-value" id="moveCount">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label" id="aiLevelLabel">Niveau IA</span>
                        <span class="stat-value" id="aiLevel">5</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label" id="timeLabel">Temps</span>
                        <span class="stat-value" id="gameTime">00:00</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label" id="scoreLabel">Score</span>
                        <span class="stat-value" id="gameScore">0</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Panneau central -->
        <div class="game-panel">
            <!-- En-t√™te -->
            <div class="quantum-header">
                <div class="quantum-title">
                    <span class="quantum-icon">üî•</span>
                    <h1 id="gameTitle">Brainova Quantum Dames</h1>
                    <span class="quantum-badge" id="quantumBadge">üöÄ IA QUANTIQUE</span>
                </div>
                <div style="display: flex; align-items: center; gap: 18px;">
                    <select id="languageSelector" onchange="changeLanguage()" class="language-selector">
                        <option value="fr">üá´üá∑ Fran√ßais</option>
                        <option value="en">üá∫üá∏ English</option>
                        <option value="ar">üá∏üá¶ ÿßŸÑÿπÿ±ÿ®Ÿäÿ©</option>
                        <option value="es">üá™üá∏ Espa√±ol</option>
                        <option value="de">üá©üá™ Deutsch</option>
                        <option value="zh">üá®üá≥ ‰∏≠Êñá</option>
                    </select>
                    <button class="close-btn" onclick="window.close()" id="closeBtn" title="Fermer">‚úï</button>
                </div>
            </div>



            <!-- Contr√¥les de jeu en haut -->
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <!-- Bouton Pause/Reprendre √† gauche -->
                <button class="quantum-btn" id="pauseBtn" onclick="togglePause()" style="background: linear-gradient(145deg, #8b5cf6, #7c3aed);">
                    ‚è∏Ô∏è <span id="pauseText">Pause</span>
                </button>
                
                <!-- Bouton statut du joueur au centre -->
                <button class="player-status-btn yellow-player" id="playerStatusBtn" onclick="switchPlayer()">
                    <span id="currentPlayer">üî•</span>
                    <span id="playerName">Joueur Jaune</span>
                </button>
                
                <!-- Bouton IA Quantique √† droite -->
                <button class="quantum-btn ai-btn" onclick="makeAIMove()" id="aiMoveBtn">
                    ü§ñ <span id="aiMoveText">Coup IA Quantique</span>
                </button>
            </div>

            <!-- Plateau de dames quantique -->
            <div class="quantum-dameboard-container" style="margin-top: 5px;">
                <div class="quantum-dameboard" id="dameboard">
                    <!-- Les cases seront g√©n√©r√©es dynamiquement -->
                </div>
            </div>

            <!-- Statut IA Quantique -->
            <div class="quantum-ai-status">
                <div class="ai-thinking" id="aiThinking">
                    <span class="quantum-pulse"></span>
                    <span id="aiMessage">IA Quantique en analyse...</span>
                </div>
            </div>
        </div>

        <!-- Panneau droit -->
        <div class="right-panel">
            <div class="panel-section">
                <div class="panel-title" id="historyTitle">üìú Historique</div>
                <div class="move-history" id="moveHistory">
                    <div class="move-item" id="gameStarted"></div>
                </div>
            </div>

            <div class="panel-section">
                <div class="panel-title" id="gameModeTitle">üéÆ Mode de Jeu</div>
                <div class="quantum-controls">
                    <button class="mode-btn active" onclick="setGameMode('ai')" id="aiModeBtn">
                        ü§ñ <span id="aiModeText">Jouer vs IA</span>
                    </button>
                    <button class="mode-btn" onclick="setGameMode('human')" id="humanModeBtn">
                        üë• <span id="humanModeText">2 Joueurs</span>
                    </button>
                </div>
            </div>

            <div class="panel-section">
                <div class="panel-title" id="optionsTitle">‚öôÔ∏è Options IA</div>
                <div class="quantum-controls">
                    <button class="quantum-btn" onclick="changeDifficulty()" id="difficultyBtn">
                        üéØ <span id="difficultyText">Difficult√©: Expert</span>
                    </button>
                    <button class="quantum-btn ai-btn" onclick="toggleAIAnalysis()" id="analysisBtn">
                        üîç <span id="analysisText">Analyse IA</span>
                    </button>
                    <button class="quantum-btn quantum-special-btn" onclick="showBestMoves()" id="hintBtn">
                        üí° <span id="hintText">Meilleurs Coups</span>
                    </button>
                    <button class="quantum-btn" onclick="saveGame()" id="saveBtn">
                        üíæ <span id="saveText">Sauvegarder</span>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Traductions multilingues
        const translations = {
            fr: {
                gameTitle: "Brainova Quantum Dames",
                quantumBadge: "üöÄ IA QUANTIQUE",
                controlsTitle: "üéÆ Contr√¥les Quantiques",
                gameModeTitle: "üéÆ Mode de Jeu",
                aiMoveText: "Coup IA Quantique",
                undoText: "Annuler Coup",
                quantumModeText: "Mode Quantique",
                newGameText: "Nouvelle Partie",
                statsTitle: "üìä Statistiques",
                movesLabel: "Coups Jou√©s",
                aiLevelLabel: "Niveau IA",
                timeLabel: "Temps",
                scoreLabel: "Score",
                aiModeText: "Jouer vs IA",
                humanModeText: "2 Joueurs",
                gameStatus: "Nouvelle partie - Jaunes commencent",
                playerYellow: "Joueur Jaune",
                playerRed: "Joueur Rouge",
                aiPlayer: "IA Quantique",
                historyTitle: "üìú Historique",
                gameStarted: "Partie commenc√©e",
                optionsTitle: "‚öôÔ∏è Options IA",
                difficultyText: "Difficult√©: Expert",
                analysisText: "Analyse IA",
                hintText: "Meilleurs Coups",
                saveText: "Sauvegarder",
                aiThinking: "IA Quantique en analyse...",
                closeBtn: "Fermer",
                turnOf: "Tour du",
                gameEnded: "Partie termin√©e",
                newGameStarted: "Nouvelle partie commenc√©e",
                quantumActivated: "Mode Quantique activ√© ! Les pions peuvent se t√©l√©porter !",
                quantumDeactivated: "Mode Quantique d√©sactiv√©",
                gameSaved: "Partie sauvegard√©e !",
                gameLoaded: "Partie charg√©e !",
                loadSavedGame: "Voulez-vous charger la partie sauvegard√©e ?",
                welcome: "Bienvenue dans Brainova Quantum Dames ! Choisissez votre mode de jeu.",
                aiCalculating: "IA Quantique calcule le meilleur coup...",
                undoInDevelopment: "Fonction d'annulation en d√©veloppement",
                aiAnalyzing: "Analyse IA en cours...",
                bestMovesCalculating: "Calcul des meilleurs coups...",
                suggestion: "Suggestion:",
                noMovesAvailable: "Aucun coup disponible",
                difficultyChanged: "Difficult√© chang√©e:",
                yellowAdvantage: "Avantage significatif aux Jaunes",
                redAdvantage: "Avantage significatif aux Rouges",
                slightYellowAdvantage: "L√©ger avantage aux Jaunes",
                slightRedAdvantage: "L√©ger avantage aux Rouges",
                balancedPosition: "Position √©quilibr√©e",
                victory: "Victoire des",
                yellows: "Jaunes",
                reds: "Rouges",
                difficulties: {
                    easy: "facile",
                    normal: "normal",
                    hard: "difficile",
                    expert: "expert"
                },
                mustCapture: "Vous devez prendre un pion adverse !",
                invalidMove: "Mouvement invalide !",
                piecePromoted: "Pion promu en Dame !",
                multipleCaptures: "Captures multiples possibles !",
                allPiecesCaptured: "Toutes les pi√®ces captur√©es",
                noMovesLeft: "Aucun mouvement possible",
                morePieces: "Plus de pi√®ces restantes",
                strategicAdvantage: "Avantage strat√©gique",
                reason: "Raison",
                finalScore: "Score Final",
                totalMoves: "Total Coups",
                pauseText: "Pause",
                resumeText: "Reprendre",
                gamePaused: "Jeu en pause",
                gameResumed: "Jeu repris"
            },
            en: {
                gameTitle: "Brainova Quantum Checkers",
                quantumBadge: "üöÄ QUANTUM AI",
                controlsTitle: "üéÆ Quantum Controls",
                gameModeTitle: "üéÆ Game Mode",
                aiMoveText: "Quantum AI Move",
                undoText: "Undo Move",
                quantumModeText: "Quantum Mode",
                newGameText: "New Game",
                statsTitle: "üìä Statistics",
                movesLabel: "Moves Played",
                aiLevelLabel: "AI Level",
                timeLabel: "Time",
                scoreLabel: "Score",
                aiModeText: "Play vs AI",
                humanModeText: "2 Players",
                gameStatus: "New game - Yellow starts",
                playerYellow: "Yellow Player",
                playerRed: "Red Player",
                aiPlayer: "Quantum AI",
                historyTitle: "üìú History",
                gameStarted: "Game started",
                optionsTitle: "‚öôÔ∏è AI Options",
                difficultyText: "Difficulty: Expert",
                analysisText: "AI Analysis",
                hintText: "Best Moves",
                saveText: "Save Game",
                aiThinking: "Quantum AI analyzing...",
                closeBtn: "Close",
                turnOf: "Turn of",
                gameEnded: "Game ended",
                newGameStarted: "New game started",
                quantumActivated: "Quantum Mode activated! Pieces can teleport!",
                quantumDeactivated: "Quantum Mode deactivated",
                gameSaved: "Game saved!",
                gameLoaded: "Game loaded!",
                loadSavedGame: "Do you want to load the saved game?",
                welcome: "Welcome to Brainova Quantum Checkers! Choose your game mode.",
                aiCalculating: "Quantum AI calculating best move...",
                undoInDevelopment: "Undo function in development",
                aiAnalyzing: "AI analysis in progress...",
                bestMovesCalculating: "Calculating best moves...",
                suggestion: "Suggestion:",
                noMovesAvailable: "No moves available",
                difficultyChanged: "Difficulty changed:",
                yellowAdvantage: "Significant advantage to Yellow",
                redAdvantage: "Significant advantage to Red",
                slightYellowAdvantage: "Slight advantage to Yellow",
                slightRedAdvantage: "Slight advantage to Red",
                balancedPosition: "Balanced position",
                victory: "Victory for",
                yellows: "Yellow",
                reds: "Red",
                difficulties: {
                    easy: "easy",
                    normal: "normal",
                    hard: "hard",
                    expert: "expert"
                },
                mustCapture: "You must capture an opponent piece!",
                invalidMove: "Invalid move!",
                piecePromoted: "Piece promoted to King!",
                multipleCaptures: "Multiple captures possible!",
                allPiecesCaptured: "All pieces captured",
                noMovesLeft: "No moves left",
                morePieces: "More pieces remaining",
                strategicAdvantage: "Strategic advantage",
                reason: "Reason",
                finalScore: "Final Score",
                totalMoves: "Total Moves",
                pauseText: "Pause",
                resumeText: "Resume",
                gamePaused: "Game paused",
                gameResumed: "Game resumed"
            },
            ar: {
                gameTitle: "ÿ®ÿ±ŸäŸÜŸàŸÅÿß ÿßŸÑÿØÿßŸÖÿß ÿßŸÑŸÉŸÖŸäÿ©",
                quantumBadge: "üöÄ ÿ∞ŸÉÿßÿ° ŸÉŸÖŸä",
                controlsTitle: "üéÆ ÿ™ÿ≠ŸÉŸÖ ŸÉŸÖŸä",
                gameModeTitle: "üéÆ Ÿàÿ∂ÿπ ÿßŸÑŸÑÿπÿ®",
                aiMoveText: "ÿ≠ÿ±ŸÉÿ© ÿßŸÑÿ∞ŸÉÿßÿ° ÿßŸÑŸÉŸÖŸä",
                undoText: "ÿ™ÿ±ÿßÿ¨ÿπ ÿπŸÜ ÿßŸÑÿ≠ÿ±ŸÉÿ©",
                quantumModeText: "ÿßŸÑŸàÿ∂ÿπ ÿßŸÑŸÉŸÖŸä",
                newGameText: "ŸÑÿπÿ®ÿ© ÿ¨ÿØŸäÿØÿ©",
                statsTitle: "üìä ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™",
                movesLabel: "ÿßŸÑÿ≠ÿ±ŸÉÿßÿ™ ÿßŸÑŸÖŸèŸÑÿπÿ®ÿ©",
                aiLevelLabel: "ŸÖÿ≥ÿ™ŸàŸâ ÿßŸÑÿ∞ŸÉÿßÿ°",
                timeLabel: "ÿßŸÑŸàŸÇÿ™",
                scoreLabel: "ÿßŸÑŸÜŸÇÿßÿ∑",
                aiModeText: "ÿßŸÑÿπÿ® ÿ∂ÿØ ÿßŸÑÿ∞ŸÉÿßÿ°",
                humanModeText: "ŸÑÿßÿπÿ®ÿßŸÜ",
                gameStatus: "ŸÑÿπÿ®ÿ© ÿ¨ÿØŸäÿØÿ© - ÿßŸÑÿ£ÿµŸÅÿ± Ÿäÿ®ÿØÿ£",
                playerYellow: "ÿßŸÑŸÑÿßÿπÿ® ÿßŸÑÿ£ÿµŸÅÿ±",
                playerRed: "ÿßŸÑŸÑÿßÿπÿ® ÿßŸÑÿ£ÿ≠ŸÖÿ±",
                aiPlayer: "ÿßŸÑÿ∞ŸÉÿßÿ° ÿßŸÑŸÉŸÖŸä",
                historyTitle: "üìú ÿßŸÑÿ™ÿßÿ±ŸäÿÆ",
                gameStarted: "ÿ®ÿØÿ£ÿ™ ÿßŸÑŸÑÿπÿ®ÿ©",
                optionsTitle: "‚öôÔ∏è ÿÆŸäÿßÿ±ÿßÿ™ ÿßŸÑÿ∞ŸÉÿßÿ°",
                difficultyText: "ÿßŸÑÿµÿπŸàÿ®ÿ©: ÿÆÿ®Ÿäÿ±",
                analysisText: "ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑÿ∞ŸÉÿßÿ°",
                hintText: "ÿ£ŸÅÿ∂ŸÑ ÿßŸÑÿ≠ÿ±ŸÉÿßÿ™",
                saveText: "ÿ≠ŸÅÿ∏ ÿßŸÑŸÑÿπÿ®ÿ©",
                aiThinking: "ÿßŸÑÿ∞ŸÉÿßÿ° ÿßŸÑŸÉŸÖŸä Ÿäÿ≠ŸÑŸÑ...",
                closeBtn: "ÿ•ÿ∫ŸÑÿßŸÇ",
                turnOf: "ÿØŸàÿ±",
                gameEnded: "ÿßŸÜÿ™Ÿáÿ™ ÿßŸÑŸÑÿπÿ®ÿ©",
                newGameStarted: "ÿ®ÿØÿ£ÿ™ ŸÑÿπÿ®ÿ© ÿ¨ÿØŸäÿØÿ©",
                quantumActivated: "ÿ™ŸÖ ÿ™ŸÅÿπŸäŸÑ ÿßŸÑŸàÿ∂ÿπ ÿßŸÑŸÉŸÖŸä! ŸäŸÖŸÉŸÜ ŸÑŸÑŸÇÿ∑ÿπ ÿßŸÑÿßŸÜÿ™ŸÇÿßŸÑ ÿßŸÑŸÅŸàÿ±Ÿä!",
                quantumDeactivated: "ÿ™ŸÖ ÿ•ŸÑÿ∫ÿßÿ° ÿßŸÑŸàÿ∂ÿπ ÿßŸÑŸÉŸÖŸä",
                gameSaved: "ÿ™ŸÖ ÿ≠ŸÅÿ∏ ÿßŸÑŸÑÿπÿ®ÿ©!",
                gameLoaded: "ÿ™ŸÖ ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑŸÑÿπÿ®ÿ©!",
                loadSavedGame: "ŸáŸÑ ÿ™ÿ±ŸäÿØ ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑŸÑÿπÿ®ÿ© ÿßŸÑŸÖÿ≠ŸÅŸàÿ∏ÿ©ÿü",
                welcome: "ŸÖÿ±ÿ≠ÿ®ÿßŸã ÿ®ŸÉ ŸÅŸä ÿ®ÿ±ŸäŸÜŸàŸÅÿß ÿßŸÑÿØÿßŸÖÿß ÿßŸÑŸÉŸÖŸäÿ©! ÿßÿÆÿ™ÿ± Ÿàÿ∂ÿπ ÿßŸÑŸÑÿπÿ®.",
                aiCalculating: "ÿßŸÑÿ∞ŸÉÿßÿ° ÿßŸÑŸÉŸÖŸä Ÿäÿ≠ÿ≥ÿ® ÿ£ŸÅÿ∂ŸÑ ÿ≠ÿ±ŸÉÿ©...",
                undoInDevelopment: "Ÿàÿ∏ŸäŸÅÿ© ÿßŸÑÿ™ÿ±ÿßÿ¨ÿπ ŸÇŸäÿØ ÿßŸÑÿ™ÿ∑ŸàŸäÿ±",
                aiAnalyzing: "ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑÿ∞ŸÉÿßÿ° ÿ¨ÿßÿ±Ÿä...",
                bestMovesCalculating: "ÿ≠ÿ≥ÿßÿ® ÿ£ŸÅÿ∂ŸÑ ÿßŸÑÿ≠ÿ±ŸÉÿßÿ™...",
                suggestion: "ÿßŸÇÿ™ÿ±ÿßÿ≠:",
                noMovesAvailable: "ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ≠ÿ±ŸÉÿßÿ™ ŸÖÿ™ÿßÿ≠ÿ©",
                difficultyChanged: "ÿ™ŸÖ ÿ™ÿ∫ŸäŸäÿ± ÿßŸÑÿµÿπŸàÿ®ÿ©:",
                yellowAdvantage: "ŸÖŸäÿ≤ÿ© ŸÉÿ®Ÿäÿ±ÿ© ŸÑŸÑÿ£ÿµŸÅÿ±",
                redAdvantage: "ŸÖŸäÿ≤ÿ© ŸÉÿ®Ÿäÿ±ÿ© ŸÑŸÑÿ£ÿ≠ŸÖÿ±",
                slightYellowAdvantage: "ŸÖŸäÿ≤ÿ© ÿ∑ŸÅŸäŸÅÿ© ŸÑŸÑÿ£ÿµŸÅÿ±",
                slightRedAdvantage: "ŸÖŸäÿ≤ÿ© ÿ∑ŸÅŸäŸÅÿ© ŸÑŸÑÿ£ÿ≠ŸÖÿ±",
                balancedPosition: "ŸÖŸàŸÇŸÅ ŸÖÿ™Ÿàÿßÿ≤ŸÜ",
                victory: "ÿßŸÜÿ™ÿµÿßÿ±",
                yellows: "ÿßŸÑÿ£ÿµŸÅÿ±",
                reds: "ÿßŸÑÿ£ÿ≠ŸÖÿ±",
                difficulties: {
                    easy: "ÿ≥ŸáŸÑ",
                    normal: "ÿπÿßÿØŸä",
                    hard: "ÿµÿπÿ®",
                    expert: "ÿÆÿ®Ÿäÿ±"
                },
                mustCapture: "Ÿäÿ¨ÿ® ÿ£ŸÜ ÿ™ÿ£ÿÆÿ∞ ŸÇÿ∑ÿπÿ© ÿßŸÑÿÆÿµŸÖ!",
                invalidMove: "ÿ≠ÿ±ŸÉÿ© ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠ÿ©!",
                piecePromoted: "ÿ™ŸÖ ÿ™ÿ±ŸÇŸäÿ© ÿßŸÑŸÇÿ∑ÿπÿ© ÿ•ŸÑŸâ ŸÖŸÑŸÉ!",
                multipleCaptures: "ÿπÿØÿ© ÿßŸÑÿ™ŸÇÿßÿ∑ÿßÿ™ ŸÖŸÖŸÉŸÜÿ©!",
                allPiecesCaptured: "ÿ™ŸÖ ÿ£ÿ≥ÿ± ÿ¨ŸÖŸäÿπ ÿßŸÑŸÇÿ∑ÿπ",
                noMovesLeft: "ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ≠ÿ±ŸÉÿßÿ™ ŸÖÿ™ÿ®ŸÇŸäÿ©",
                morePieces: "ŸÇÿ∑ÿπ ÿ£ŸÉÿ´ÿ± ŸÖÿ™ÿ®ŸÇŸäÿ©",
                strategicAdvantage: "ŸÖŸäÿ≤ÿ© ÿßÿ≥ÿ™ÿ±ÿßÿ™Ÿäÿ¨Ÿäÿ©",
                reason: "ÿßŸÑÿ≥ÿ®ÿ®",
                finalScore: "ÿßŸÑŸÜÿ™Ÿäÿ¨ÿ© ÿßŸÑŸÜŸáÿßÿ¶Ÿäÿ©",
                totalMoves: "ÿ•ÿ¨ŸÖÿßŸÑŸä ÿßŸÑÿ≠ÿ±ŸÉÿßÿ™",
                pauseText: "ÿ•ŸäŸÇÿßŸÅ",
                resumeText: "ÿßÿ≥ÿ™ÿ¶ŸÜÿßŸÅ",
                gamePaused: "ÿßŸÑŸÑÿπÿ®ÿ© ŸÖÿ™ŸàŸÇŸÅÿ©",
                gameResumed: "ÿ™ŸÖ ÿßÿ≥ÿ™ÿ¶ŸÜÿßŸÅ ÿßŸÑŸÑÿπÿ®ÿ©"
            },
            es: {
                gameTitle: "Brainova Damas Cu√°nticas",
                quantumBadge: "üöÄ IA CU√ÅNTICA",
                controlsTitle: "üéÆ Controles Cu√°nticos",
                gameModeTitle: "üéÆ Modo de Juego",
                aiMoveText: "Movimiento IA Cu√°ntica",
                undoText: "Deshacer Movimiento",
                quantumModeText: "Modo Cu√°ntico",
                newGameText: "Nueva Partida",
                statsTitle: "üìä Estad√≠sticas",
                movesLabel: "Movimientos Jugados",
                aiLevelLabel: "Nivel IA",
                timeLabel: "Tiempo",
                scoreLabel: "Puntuaci√≥n",
                aiModeText: "Jugar vs IA",
                humanModeText: "2 Jugadores",
                gameStatus: "Nueva partida - Amarillo empieza",
                playerYellow: "Jugador Amarillo",
                playerRed: "Jugador Rojo",
                aiPlayer: "IA Cu√°ntica",
                historyTitle: "üìú Historial",
                gameStarted: "Partida iniciada",
                optionsTitle: "‚öôÔ∏è Opciones IA",
                difficultyText: "Dificultad: Experto",
                analysisText: "An√°lisis IA",
                hintText: "Mejores Movimientos",
                saveText: "Guardar Partida",
                aiThinking: "IA Cu√°ntica analizando...",
                closeBtn: "Cerrar",
                turnOf: "Turno de",
                gameEnded: "Partida terminada",
                newGameStarted: "Nueva partida iniciada",
                quantumActivated: "¬°Modo Cu√°ntico activado! ¬°Las piezas pueden teletransportarse!",
                quantumDeactivated: "Modo Cu√°ntico desactivado",
                gameSaved: "¬°Partida guardada!",
                gameLoaded: "¬°Partida cargada!",
                loadSavedGame: "¬øQuieres cargar la partida guardada?",
                welcome: "¬°Bienvenido a Brainova Damas Cu√°nticas! Elige tu modo de juego.",
                aiCalculating: "IA Cu√°ntica calculando mejor movimiento...",
                undoInDevelopment: "Funci√≥n de deshacer en desarrollo",
                aiAnalyzing: "An√°lisis IA en progreso...",
                bestMovesCalculating: "Calculando mejores movimientos...",
                suggestion: "Sugerencia:",
                noMovesAvailable: "No hay movimientos disponibles",
                difficultyChanged: "Dificultad cambiada:",
                yellowAdvantage: "Ventaja significativa para Amarillo",
                redAdvantage: "Ventaja significativa para Rojo",
                slightYellowAdvantage: "Ligera ventaja para Amarillo",
                slightRedAdvantage: "Ligera ventaja para Rojo",
                balancedPosition: "Posici√≥n equilibrada",
                victory: "Victoria de",
                yellows: "Amarillo",
                reds: "Rojo",
                difficulties: {
                    easy: "f√°cil",
                    normal: "normal",
                    hard: "dif√≠cil",
                    expert: "experto"
                },
                mustCapture: "¬°Debes capturar una pieza oponente!",
                invalidMove: "¬°Movimiento inv√°lido!",
                piecePromoted: "¬°Pieza promovida a Rey!",
                multipleCaptures: "¬°M√∫ltiples capturas posibles!",
                allPiecesCaptured: "Todas las piezas capturadas",
                noMovesLeft: "No quedan movimientos",
                morePieces: "M√°s piezas restantes",
                strategicAdvantage: "Ventaja estrat√©gica",
                reason: "Raz√≥n",
                finalScore: "Puntuaci√≥n Final",
                totalMoves: "Movimientos Totales",
                pauseText: "Pausa",
                resumeText: "Reanudar",
                gamePaused: "Juego pausado",
                gameResumed: "Juego reanudado"
            },
            de: {
                gameTitle: "Brainova Quanten-Dame",
                quantumBadge: "üöÄ QUANTEN-KI",
                controlsTitle: "üéÆ Quanten-Steuerung",
                gameModeTitle: "üéÆ Spielmodus",
                aiMoveText: "Quanten-KI Zug",
                undoText: "Zug r√ºckg√§ngig",
                quantumModeText: "Quanten-Modus",
                newGameText: "Neues Spiel",
                statsTitle: "üìä Statistiken",
                movesLabel: "Gespielte Z√ºge",
                aiLevelLabel: "KI-Level",
                timeLabel: "Zeit",
                scoreLabel: "Punkte",
                aiModeText: "Gegen KI spielen",
                humanModeText: "2 Spieler",
                gameStatus: "Neues Spiel - Gelb beginnt",
                playerYellow: "Gelber Spieler",
                playerRed: "Roter Spieler",
                aiPlayer: "Quanten-KI",
                historyTitle: "üìú Verlauf",
                gameStarted: "Spiel gestartet",
                optionsTitle: "‚öôÔ∏è KI-Optionen",
                difficultyText: "Schwierigkeit: Experte",
                analysisText: "KI-Analyse",
                hintText: "Beste Z√ºge",
                saveText: "Spiel speichern",
                aiThinking: "Quanten-KI analysiert...",
                closeBtn: "Schlie√üen",
                turnOf: "Zug von",
                gameEnded: "Spiel beendet",
                newGameStarted: "Neues Spiel gestartet",
                quantumActivated: "Quanten-Modus aktiviert! Figuren k√∂nnen sich teleportieren!",
                quantumDeactivated: "Quanten-Modus deaktiviert",
                gameSaved: "Spiel gespeichert!",
                gameLoaded: "Spiel geladen!",
                loadSavedGame: "M√∂chten Sie das gespeicherte Spiel laden?",
                welcome: "Willkommen bei Brainova Quanten-Dame! W√§hlen Sie Ihren Spielmodus.",
                aiCalculating: "Quanten-KI berechnet besten Zug...",
                undoInDevelopment: "R√ºckg√§ngig-Funktion in Entwicklung",
                aiAnalyzing: "KI-Analyse l√§uft...",
                bestMovesCalculating: "Berechne beste Z√ºge...",
                suggestion: "Vorschlag:",
                noMovesAvailable: "Keine Z√ºge verf√ºgbar",
                difficultyChanged: "Schwierigkeit ge√§ndert:",
                yellowAdvantage: "Signifikanter Vorteil f√ºr Gelb",
                redAdvantage: "Signifikanter Vorteil f√ºr Rot",
                slightYellowAdvantage: "Leichter Vorteil f√ºr Gelb",
                slightRedAdvantage: "Leichter Vorteil f√ºr Rot",
                balancedPosition: "Ausgeglichene Position",
                victory: "Sieg f√ºr",
                yellows: "Gelb",
                reds: "Rot",
                difficulties: {
                    easy: "einfach",
                    normal: "normal",
                    hard: "schwer",
                    expert: "experte"
                },
                mustCapture: "Sie m√ºssen eine gegnerische Figur schlagen!",
                invalidMove: "Ung√ºltiger Zug!",
                piecePromoted: "Figur zur Dame bef√∂rdert!",
                multipleCaptures: "Mehrere Schl√§ge m√∂glich!",
                allPiecesCaptured: "Alle Figuren geschlagen",
                noMovesLeft: "Keine Z√ºge √ºbrig",
                morePieces: "Mehr Figuren √ºbrig",
                strategicAdvantage: "Strategischer Vorteil",
                reason: "Grund",
                finalScore: "Endpunktzahl",
                totalMoves: "Gesamtz√ºge",
                pauseText: "Pause",
                resumeText: "Fortsetzen",
                gamePaused: "Spiel pausiert",
                gameResumed: "Spiel fortgesetzt"
            },
            zh: {
                gameTitle: "ËÑëËØ∫Áì¶ÈáèÂ≠êË∑≥Ê£ã",
                quantumBadge: "üöÄ ÈáèÂ≠ê‰∫∫Â∑•Êô∫ËÉΩ",
                controlsTitle: "üéÆ ÈáèÂ≠êÊéßÂà∂",
                gameModeTitle: "üéÆ Ê∏∏ÊàèÊ®°Âºè",
                aiMoveText: "ÈáèÂ≠êAIËµ∞Ê£ã",
                undoText: "Êí§ÈîÄËµ∞Ê£ã",
                quantumModeText: "ÈáèÂ≠êÊ®°Âºè",
                newGameText: "Êñ∞Ê∏∏Êàè",
                statsTitle: "üìä ÁªüËÆ°Êï∞ÊçÆ",
                movesLabel: "Â∑≤Ëµ∞Ê≠•Êï∞",
                aiLevelLabel: "AIÁ≠âÁ∫ß",
                timeLabel: "Êó∂Èó¥",
                scoreLabel: "ÂæóÂàÜ",
                aiModeText: "ÂØπÊàòAI",
                humanModeText: "Âèå‰∫∫ÂØπÊàò",
                gameStatus: "Êñ∞Ê∏∏Êàè - ÈªÑÊñπÂÖàË°å",
                playerYellow: "ÈªÑÊñπÁé©ÂÆ∂",
                playerRed: "Á∫¢ÊñπÁé©ÂÆ∂",
                aiPlayer: "ÈáèÂ≠êAI",
                historyTitle: "üìú ÂéÜÂè≤ËÆ∞ÂΩï",
                gameStarted: "Ê∏∏ÊàèÂºÄÂßã",
                optionsTitle: "‚öôÔ∏è AIÈÄâÈ°π",
                difficultyText: "ÈöæÂ∫¶Ôºö‰∏ìÂÆ∂",
                analysisText: "AIÂàÜÊûê",
                hintText: "ÊúÄ‰Ω≥Ëµ∞Ê≥ï",
                saveText: "‰øùÂ≠òÊ∏∏Êàè",
                aiThinking: "ÈáèÂ≠êAIÂàÜÊûê‰∏≠...",
                closeBtn: "ÂÖ≥Èó≠",
                turnOf: "ËΩÆÂà∞",
                gameEnded: "Ê∏∏ÊàèÁªìÊùü",
                newGameStarted: "Êñ∞Ê∏∏ÊàèÂºÄÂßã",
                quantumActivated: "ÈáèÂ≠êÊ®°ÂºèÂ∑≤ÊøÄÊ¥ªÔºÅÊ£ãÂ≠êÂèØ‰ª•Áû¨ÁßªÔºÅ",
                quantumDeactivated: "ÈáèÂ≠êÊ®°ÂºèÂ∑≤ÂÖ≥Èó≠",
                gameSaved: "Ê∏∏ÊàèÂ∑≤‰øùÂ≠òÔºÅ",
                gameLoaded: "Ê∏∏ÊàèÂ∑≤Âä†ËΩΩÔºÅ",
                loadSavedGame: "ÊÇ®Ë¶ÅÂä†ËΩΩ‰øùÂ≠òÁöÑÊ∏∏ÊàèÂêóÔºü",
                welcome: "Ê¨¢ËøéÊù•Âà∞ËÑëËØ∫Áì¶ÈáèÂ≠êË∑≥Ê£ãÔºÅÈÄâÊã©ÊÇ®ÁöÑÊ∏∏ÊàèÊ®°Âºè„ÄÇ",
                aiCalculating: "ÈáèÂ≠êAIÊ≠£Âú®ËÆ°ÁÆóÊúÄ‰Ω≥Ëµ∞Ê≥ï...",
                undoInDevelopment: "Êí§ÈîÄÂäüËÉΩÂºÄÂèë‰∏≠",
                aiAnalyzing: "AIÂàÜÊûêËøõË°å‰∏≠...",
                bestMovesCalculating: "ËÆ°ÁÆóÊúÄ‰Ω≥Ëµ∞Ê≥ï‰∏≠...",
                suggestion: "Âª∫ËÆÆÔºö",
                noMovesAvailable: "Êó†ÂèØÁî®Ëµ∞Ê≥ï",
                difficultyChanged: "ÈöæÂ∫¶Â∑≤Êõ¥ÊîπÔºö",
                yellowAdvantage: "ÈªÑÊñπÊòæËëó‰ºòÂäø",
                redAdvantage: "Á∫¢ÊñπÊòæËëó‰ºòÂäø",
                slightYellowAdvantage: "ÈªÑÊñπËΩªÂæÆ‰ºòÂäø",
                slightRedAdvantage: "Á∫¢ÊñπËΩªÂæÆ‰ºòÂäø",
                balancedPosition: "Âπ≥Ë°°Â±ÄÈù¢",
                victory: "Ëé∑ËÉúÊñπ",
                yellows: "ÈªÑÊñπ",
                reds: "Á∫¢Êñπ",
                difficulties: {
                    easy: "ÁÆÄÂçï",
                    normal: "ÊôÆÈÄö",
                    hard: "Âõ∞Èöæ",
                    expert: "‰∏ìÂÆ∂"
                },
                mustCapture: "ÊÇ®ÂøÖÈ°ªÂêÉÊéâÂØπÊñπÊ£ãÂ≠êÔºÅ",
                invalidMove: "Êó†ÊïàÁßªÂä®ÔºÅ",
                piecePromoted: "Ê£ãÂ≠êÂçáÁ∫ß‰∏∫ÁéãÔºÅ",
                multipleCaptures: "ÂèØ‰ª•ËøûÁª≠ÂêÉÂ≠êÔºÅ",
                allPiecesCaptured: "ÊâÄÊúâÊ£ãÂ≠êË¢´ÂêÉ",
                noMovesLeft: "Êó†Ââ©‰ΩôËµ∞Ê≥ï",
                morePieces: "Ââ©‰ΩôÊ£ãÂ≠êÊõ¥Â§ö",
                strategicAdvantage: "ÊàòÁï•‰ºòÂäø",
                reason: "ÂéüÂõ†",
                finalScore: "ÊúÄÁªàÂæóÂàÜ",
                totalMoves: "ÊÄªÊ≠•Êï∞",
                pauseText: "ÊöÇÂÅú",
                resumeText: "ÁªßÁª≠",
                gamePaused: "Ê∏∏ÊàèÂ∑≤ÊöÇÂÅú",
                gameResumed: "Ê∏∏ÊàèÂ∑≤ÁªßÁª≠"
            }
        };

        // √âtat du jeu
        let gameState = {
            board: [],
            currentPlayer: 'yellow',
            gameMode: 'ai', // 'ai' ou 'human'
            selectedSquare: null,
            possibleMoves: [],
            moveHistory: [],
            moveCount: 0,
            startTime: null,
            timer: null,
            aiLevel: 5,
            score: 0,
            isGameActive: true,
            quantumMode: false,
            aiThinking: false,
            difficulty: 'expert',
            capturedPieces: { yellow: [], red: [] },
            currentLanguage: 'fr',
            mustCapture: false,
            captureSequence: [],
            isPaused: false
        };

        // Position initiale des pions
        const initialBoard = [
            [null, 'üî¥', null, 'üî¥', null, 'üî¥', null, 'üî¥'],
            ['üî¥', null, 'üî¥', null, 'üî¥', null, 'üî¥', null],
            [null, 'üî¥', null, 'üî¥', null, 'üî¥', null, 'üî¥'],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            ['üü°', null, 'üü°', null, 'üü°', null, 'üü°', null],
            [null, 'üü°', null, 'üü°', null, 'üü°', null, 'üü°'],
            ['üü°', null, 'üü°', null, 'üü°', null, 'üü°', null]
        ];

        // Fonction de changement de langue
        function changeLanguage() {
            const selector = document.getElementById('languageSelector');
            const selectedLang = selector.value;
            gameState.currentLanguage = selectedLang;
            
            const t = translations[selectedLang];
            
            // Mettre √† jour tous les textes
            document.getElementById('gameTitle').textContent = t.gameTitle;
            document.getElementById('quantumBadge').textContent = t.quantumBadge;
            document.getElementById('controlsTitle').textContent = t.controlsTitle;
            if(document.getElementById('gameModeTitle')) {
                document.getElementById('gameModeTitle').textContent = t.gameModeTitle;
            }
            document.getElementById('aiMoveText').textContent = t.aiMoveText;
            document.getElementById('undoText').textContent = t.undoText;
            document.getElementById('quantumModeText').textContent = t.quantumModeText;
            document.getElementById('newGameText').textContent = t.newGameText;
            document.getElementById('statsTitle').textContent = t.statsTitle;
            document.getElementById('movesLabel').textContent = t.movesLabel;
            document.getElementById('aiLevelLabel').textContent = t.aiLevelLabel;
            document.getElementById('timeLabel').textContent = t.timeLabel;
            document.getElementById('scoreLabel').textContent = t.scoreLabel;
            document.getElementById('aiModeText').textContent = t.aiModeText;
            document.getElementById('humanModeText').textContent = t.humanModeText;
            document.getElementById('historyTitle').textContent = t.historyTitle;
            document.getElementById('optionsTitle').textContent = t.optionsTitle;
            document.getElementById('analysisText').textContent = t.analysisText;
            document.getElementById('hintText').textContent = t.hintText;
            document.getElementById('saveText').textContent = t.saveText;
            document.getElementById('closeBtn').title = t.closeBtn;
            
            // Mettre √† jour le texte de difficult√©
            const diffText = t.difficultyText.replace('Expert', t.difficulties[gameState.difficulty]);
            document.getElementById('difficultyText').textContent = diffText;
            
            // Mettre √† jour le message "Partie commenc√©e" dans l'historique
            const gameStartedElement = document.getElementById('gameStarted');
            if(gameStartedElement) {
                gameStartedElement.textContent = t.gameStarted;
            }
            
            // Mettre √† jour le bouton pause
            const pauseTextElement = document.getElementById('pauseText');
            if(pauseTextElement) {
                pauseTextElement.textContent = gameState.isPaused ? t.resumeText : t.pauseText;
            }
            
            updateUI();
        }

        // Cr√©er les particules quantiques
        function createQuantumParticles() {
            const container = document.getElementById('quantumParticles');
            
            for(let i = 0; i < 35; i++) {
                const particle = document.createElement('div');
                particle.className = 'quantum-particle';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.animationDelay = Math.random() * 15 + 's';
                particle.style.animationDuration = (15 + Math.random() * 8) + 's';
                container.appendChild(particle);
            }
        }

        // Cr√©er les lignes d'√©nergie
        function createEnergyLines() {
            const container = document.getElementById('energyLines');
            
            for(let i = 0; i < 10; i++) {
                const line = document.createElement('div');
                line.className = 'energy-line';
                line.style.top = Math.random() * 100 + '%';
                line.style.width = (250 + Math.random() * 500) + 'px';
                line.style.animationDelay = Math.random() * 10 + 's';
                line.style.animationDuration = (10 + Math.random() * 5) + 's';
                container.appendChild(line);
            }
        }

        // Cr√©er les cercles d'√©nergie
        function createEnergyCircles() {
            const container = document.getElementById('energyCircles');
            
            for(let i = 0; i < 8; i++) {
                const circle = document.createElement('div');
                circle.className = 'energy-circle';
                circle.style.left = Math.random() * 100 + '%';
                circle.style.top = Math.random() * 100 + '%';
                circle.style.width = (60 + Math.random() * 120) + 'px';
                circle.style.height = circle.style.width;
                circle.style.animationDelay = Math.random() * 8 + 's';
                circle.style.animationDuration = (8 + Math.random() * 4) + 's';
                container.appendChild(circle);
            }
        }

        // Cr√©er les rayons laser
        function createLaserBeams() {
            const container = document.getElementById('laserBeams');
            
            for(let i = 0; i < 6; i++) {
                const beam = document.createElement('div');
                beam.className = 'laser-beam';
                beam.style.left = Math.random() * 100 + '%';
                beam.style.animationDelay = Math.random() * 15 + 's';
                beam.style.animationDuration = (15 + Math.random() * 8) + 's';
                container.appendChild(beam);
            }
        }

        // Initialiser tous les effets futuristes
        function initFuturisticEffects() {
            createQuantumParticles();
            createEnergyLines();
            createEnergyCircles();
            createLaserBeams();
        }

        // Initialiser le jeu
        function initGame() {
            gameState.board = initialBoard.map(row => [...row]);
            gameState.currentPlayer = 'yellow';
            gameState.selectedSquare = null;
            gameState.possibleMoves = [];
            gameState.moveHistory = [];
            gameState.moveCount = 0;
            gameState.startTime = Date.now();
            gameState.isGameActive = true;
            gameState.quantumMode = false;
            gameState.mustCapture = false;
            gameState.captureSequence = [];
            
            createDameboard();
            updateUI();
            startTimer();
            
            const t = translations[gameState.currentLanguage];
            
            // Vider l'historique et ajouter le message de d√©but
            const historyElement = document.getElementById('moveHistory');
            historyElement.innerHTML = '';
            const gameStartedElement = document.createElement('div');
            gameStartedElement.className = 'move-item';
            gameStartedElement.id = 'gameStarted';
            gameStartedElement.textContent = t.gameStarted;
            historyElement.appendChild(gameStartedElement);
        }

        // Cr√©er le plateau de dames
        function createDameboard() {
            const dameboard = document.getElementById('dameboard');
            dameboard.innerHTML = '';
            
            for(let row = 0; row < 8; row++) {
                for(let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = `dame-square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                    square.dataset.row = row;
                    square.dataset.col = col;
                    square.onclick = () => handleSquareClick(row, col);
                    
                    const piece = gameState.board[row][col];
                    if(piece) {
                        const pieceElement = document.createElement('div');
                        pieceElement.className = `dame-piece ${getPieceColor(piece)} ${isKing(piece) ? 'king' : ''}`;
                        pieceElement.textContent = piece;
                        square.appendChild(pieceElement);
                    }
                    
                    dameboard.appendChild(square);
                }
            }
        }

        // Obtenir la couleur d'une pi√®ce
        function getPieceColor(piece) {
            if(piece === 'üü°' || piece === 'üëë') return 'yellow';
            if(piece === 'üî¥' || piece === '‚ôõ') return 'red';
            return null;
        }

        // V√©rifier si une pi√®ce est un roi/dame
        function isKing(piece) {
            return piece === 'üëë' || piece === '‚ôõ';
        }

        // G√©rer le clic sur une case
        function handleSquareClick(row, col) {
            if(!gameState.isGameActive || gameState.aiThinking || gameState.isPaused) return;
            
            const piece = gameState.board[row][col];
            
            // Si on est en mode capture multiple, seul le pion qui capture peut bouger
            if(gameState.mustCapture && gameState.captureSequence.length > 0) {
                const lastCapture = gameState.captureSequence[gameState.captureSequence.length - 1];
                
                // Si on clique sur une case de mouvement possible pour continuer la capture
                if(gameState.selectedSquare && 
                   gameState.selectedSquare.row === lastCapture.row && 
                   gameState.selectedSquare.col === lastCapture.col &&
                   gameState.possibleMoves.some(move => move.row === row && move.col === col)) {
                    makeMove(gameState.selectedSquare.row, gameState.selectedSquare.col, row, col);
                    return;
                }
                
                // Sinon, on ne peut s√©lectionner que le pion qui doit continuer √† capturer
                if(row === lastCapture.row && col === lastCapture.col) {
                    selectSquare(row, col);
                } else {
                    // Message d'erreur si on essaie de s√©lectionner autre chose
                    const t = translations[gameState.currentLanguage];
                    showAIMessage(t.mustCapture || "Vous devez continuer avec le m√™me pion !", 2000);
                }
                return;
            }
            
            // Si aucune pi√®ce n'est s√©lectionn√©e
            if(!gameState.selectedSquare) {
                if(piece && getPieceColor(piece) === gameState.currentPlayer) {
                    selectSquare(row, col);
                }
                return;
            }
            
            // Si on clique sur la m√™me case
            if(gameState.selectedSquare.row === row && gameState.selectedSquare.col === col) {
                deselectSquare();
                return;
            }
            
            // Si on clique sur une case de mouvement possible
            if(gameState.possibleMoves.some(move => move.row === row && move.col === col)) {
                makeMove(gameState.selectedSquare.row, gameState.selectedSquare.col, row, col);
                return;
            }
            
            // Si on clique sur une autre pi√®ce de la m√™me couleur (et pas en capture multiple)
            if(piece && getPieceColor(piece) === gameState.currentPlayer && !gameState.mustCapture) {
                deselectSquare();
                selectSquare(row, col);
                return;
            }
            
            // Sinon, d√©s√©lectionner
            deselectSquare();
        }

        // S√©lectionner une case
        function selectSquare(row, col) {
            gameState.selectedSquare = { row, col };
            gameState.possibleMoves = calculatePossibleMoves(row, col);
            
            // Mettre en √©vidence la case s√©lectionn√©e
            const square = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            square.classList.add('selected');
            
            // Mettre en √©vidence les mouvements possibles
            gameState.possibleMoves.forEach(move => {
                const moveSquare = document.querySelector(`[data-row="${move.row}"][data-col="${move.col}"]`);
                moveSquare.classList.add('possible-move');
            });
        }

        // D√©s√©lectionner une case
        function deselectSquare() {
            if(gameState.selectedSquare) {
                const square = document.querySelector(`[data-row="${gameState.selectedSquare.row}"][data-col="${gameState.selectedSquare.col}"]`);
                square.classList.remove('selected');
            }
            
            // Enlever la mise en √©vidence des mouvements possibles
            document.querySelectorAll('.possible-move').forEach(square => {
                square.classList.remove('possible-move');
            });
            
            gameState.selectedSquare = null;
            gameState.possibleMoves = [];
        }

        // Calculer les mouvements possibles pour une pi√®ce
        function calculatePossibleMoves(row, col) {
            const piece = gameState.board[row][col];
            if(!piece) return [];
            
            const moves = [];
            const color = getPieceColor(piece);
            const king = isKing(piece);
            
            // Directions de mouvement
            let directions = [];
            if(king) {
                directions = [[-1, -1], [-1, 1], [1, -1], [1, 1]]; // Toutes les diagonales
            } else if(color === 'yellow') {
                directions = [[-1, -1], [-1, 1]]; // Vers le haut
            } else {
                directions = [[1, -1], [1, 1]]; // Vers le bas
            }
            
            // V√©rifier les captures obligatoires d'abord
            const captures = [];
            for(let [drow, dcol] of directions) {
                if(king) {
                    // Pour les dames : v√©rifier les captures √† longue distance
                    const longCaptures = checkLongRangeCapture(row, col, drow, dcol);
                    captures.push(...longCaptures);
                } else {
                    // Pour les pions : capture simple
                    const captureMove = checkCapture(row, col, drow, dcol);
                    if(captureMove) {
                        captures.push(captureMove);
                    }
                }
            }
            
            // Si des captures sont possibles, elles sont obligatoires
            if(captures.length > 0) {
                return captures;
            }
            
            // Sinon, mouvements normaux
            if(king) {
                // Les dames peuvent se d√©placer sur toute la diagonale
                for(let [drow, dcol] of directions) {
                    for(let distance = 1; distance < 8; distance++) {
                        const newRow = row + drow * distance;
                        const newCol = col + dcol * distance;
                        
                        if(newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                            if(!gameState.board[newRow][newCol]) {
                                moves.push({ row: newRow, col: newCol, type: 'move' });
                            } else {
                                break; // Arr√™ter si on rencontre une pi√®ce
                            }
                        } else {
                            break; // Arr√™ter si on sort du plateau
                        }
                    }
                }
            } else {
                // Les pions ne peuvent se d√©placer que d'une case
                for(let [drow, dcol] of directions) {
                    const newRow = row + drow;
                    const newCol = col + dcol;
                    
                    if(newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                        if(!gameState.board[newRow][newCol]) {
                            moves.push({ row: newRow, col: newCol, type: 'move' });
                        }
                    }
                }
            }
            
            return moves;
        }

        // V√©rifier une capture possible (pour les pions)
        function checkCapture(row, col, drow, dcol) {
            const jumpRow = row + drow;
            const jumpCol = col + dcol;
            const landRow = row + 2 * drow;
            const landCol = col + 2 * dcol;
            
            // V√©rifier les limites
            if(landRow < 0 || landRow >= 8 || landCol < 0 || landCol >= 8) return null;
            
            const jumpPiece = gameState.board[jumpRow][jumpCol];
            const landSquare = gameState.board[landRow][landCol];
            
            // Il doit y avoir une pi√®ce adverse √† sauter et une case vide pour atterrir
            if(jumpPiece && getPieceColor(jumpPiece) !== gameState.currentPlayer && !landSquare) {
                return { 
                    row: landRow, 
                    col: landCol, 
                    type: 'capture',
                    capturedRow: jumpRow,
                    capturedCol: jumpCol
                };
            }
            
            return null;
        }

        // V√©rifier les captures √† longue distance (pour les dames)
        function checkLongRangeCapture(row, col, drow, dcol) {
            const captures = [];
            let foundEnemy = false;
            let enemyRow = -1;
            let enemyCol = -1;
            let capturedPieces = [];
            
            // Parcourir la diagonale
            for(let distance = 1; distance < 8; distance++) {
                const checkRow = row + drow * distance;
                const checkCol = col + dcol * distance;
                
                // V√©rifier les limites
                if(checkRow < 0 || checkRow >= 8 || checkCol < 0 || checkCol >= 8) break;
                
                const piece = gameState.board[checkRow][checkCol];
                
                if(piece) {
                    if(getPieceColor(piece) !== gameState.currentPlayer) {
                        // Pi√®ce ennemie trouv√©e
                        if(foundEnemy) {
                            // D√©j√† une pi√®ce ennemie trouv√©e, arr√™ter
                            break;
                        }
                        foundEnemy = true;
                        enemyRow = checkRow;
                        enemyCol = checkCol;
                        capturedPieces.push({ row: checkRow, col: checkCol });
                    } else {
                        // Pi√®ce alli√©e, arr√™ter
                        break;
                    }
                } else if(foundEnemy) {
                    // Case vide apr√®s une pi√®ce ennemie = capture possible
                    // Continuer √† chercher d'autres cases vides
                    captures.push({
                        row: checkRow,
                        col: checkCol,
                        type: 'capture',
                        capturedPieces: [...capturedPieces]
                    });
                }
            }
            
            return captures;
        }

        // Effectuer un mouvement
        function makeMove(fromRow, fromCol, toRow, toCol) {
            const piece = gameState.board[fromRow][fromCol];
            const move = gameState.possibleMoves.find(m => m.row === toRow && m.col === toCol);
            
            if(!move) return;
            
            // Effectuer le mouvement
            gameState.board[toRow][toCol] = piece;
            gameState.board[fromRow][fromCol] = null;
            
            let moveNotation = `${piece} ${String.fromCharCode(97 + fromCol)}${8 - fromRow} ‚Üí ${String.fromCharCode(97 + toCol)}${8 - toRow}`;
            let continueCapturing = false;
            
            // G√©rer les captures
            if(move.type === 'capture') {
                // Capturer toutes les pi√®ces dans le chemin (pour les dames)
                if(move.capturedPieces) {
                    move.capturedPieces.forEach(captured => {
                        const capturedPiece = gameState.board[captured.row][captured.col];
                        gameState.board[captured.row][captured.col] = null;
                        
                        const capturedColor = getPieceColor(capturedPiece);
                        gameState.capturedPieces[capturedColor].push(capturedPiece);
                        gameState.score += isKing(capturedPiece) ? 3 : 1;
                        moveNotation += ` (capture ${capturedPiece})`;
                    });
                } else {
                    // Capture simple (pion normal)
                    const capturedPiece = gameState.board[move.capturedRow][move.capturedCol];
                    gameState.board[move.capturedRow][move.capturedCol] = null;
                    
                    const capturedColor = getPieceColor(capturedPiece);
                    gameState.capturedPieces[capturedColor].push(capturedPiece);
                    gameState.score += isKing(capturedPiece) ? 3 : 1;
                    moveNotation += ` (capture ${capturedPiece})`;
                }
                
                // V√©rifier les captures multiples avec LE M√äME PION
                const additionalCaptures = calculatePossibleMoves(toRow, toCol).filter(m => m.type === 'capture');
                if(additionalCaptures.length > 0) {
                    gameState.mustCapture = true;
                    gameState.captureSequence.push({ row: toRow, col: toCol });
                    continueCapturing = true;
                    
                    // S√©lectionner automatiquement LA M√äME pi√®ce pour continuer
                    setTimeout(() => {
                        selectSquare(toRow, toCol);
                        const t = translations[gameState.currentLanguage];
                        showAIMessage(t.multipleCaptures, 2500);
                    }, 300);
                }
            }
            
            // Promotion en dame/roi
            if(!isKing(piece)) {
                if((getPieceColor(piece) === 'yellow' && toRow === 0) || 
                   (getPieceColor(piece) === 'red' && toRow === 7)) {
                    gameState.board[toRow][toCol] = getPieceColor(piece) === 'yellow' ? 'üëë' : '‚ôõ';
                    const t = translations[gameState.currentLanguage];
                    showAIMessage(t.piecePromoted, 2000);
                }
            }
            
            // Ajouter √† l'historique
            addMoveToHistory(moveNotation);
            gameState.moveCount++;
            
            // Si pas de capture multiple, terminer le tour
            if(!continueCapturing) {
                gameState.mustCapture = false;
                gameState.captureSequence = [];
                deselectSquare();
                
                // Changer de joueur seulement si pas de capture multiple
                gameState.currentPlayer = gameState.currentPlayer === 'yellow' ? 'red' : 'yellow';
            } else {
                // Ne pas d√©s√©lectionner si capture multiple avec LE M√äME PION
                // Le joueur actuel garde la main avec le m√™me pion
            }
            
            createDameboard();
            
            // V√©rifier la fin de partie
            if(isGameOver()) {
                endGame();
                return;
            }
            
            updateUI();
            
            // Si c'est le tour de l'IA en mode IA ET pas de capture multiple
            if(gameState.gameMode === 'ai' && gameState.currentPlayer === 'red' && gameState.isGameActive && !continueCapturing) {
                setTimeout(() => {
                    if(gameState.isGameActive && gameState.currentPlayer === 'red') {
                        makeAIMove();
                    }
                }, 1200);
            }
            
            // Si l'IA doit continuer une capture multiple avec le m√™me pion
            if(gameState.gameMode === 'ai' && gameState.currentPlayer === 'red' && gameState.isGameActive && continueCapturing) {
                setTimeout(() => {
                    if(gameState.isGameActive && gameState.currentPlayer === 'red' && gameState.mustCapture) {
                        makeAIMove();
                    }
                }, 1500);
            }
        }

        // Ajouter un coup √† l'historique
        function addMoveToHistory(move) {
            gameState.moveHistory.push(move);
            const historyElement = document.getElementById('moveHistory');
            const moveElement = document.createElement('div');
            moveElement.className = 'move-item';
            moveElement.textContent = `${gameState.moveHistory.length}. ${move}`;
            historyElement.appendChild(moveElement);
            historyElement.scrollTop = historyElement.scrollHeight;
        }

        // Coup de l'IA
        function makeAIMove() {
            if(gameState.currentPlayer !== 'red' || !gameState.isGameActive || gameState.gameMode !== 'ai' || gameState.isPaused) return;
            
            gameState.aiThinking = true;
            const t = translations[gameState.currentLanguage];
            showAIMessage(t.aiCalculating, 0);
            
            setTimeout(() => {
                if(gameState.isGameActive && gameState.currentPlayer === 'red' && gameState.gameMode === 'ai') {
                    const bestMove = calculateBestMove();
                    if(bestMove) {
                        // Simuler la s√©lection et le mouvement de l'IA
                        gameState.selectedSquare = { row: bestMove.fromRow, col: bestMove.fromCol };
                        gameState.possibleMoves = calculatePossibleMoves(bestMove.fromRow, bestMove.fromCol);
                        makeMove(bestMove.fromRow, bestMove.fromCol, bestMove.toRow, bestMove.toCol);
                    }
                }
                gameState.aiThinking = false;
                hideAIMessage();
            }, 1800 + Math.random() * 2500);
        }

        // Calculer le meilleur coup pour l'IA
        function calculateBestMove() {
            const allMoves = [];
            
            // G√©n√©rer tous les coups possibles pour les pi√®ces rouges
            for(let row = 0; row < 8; row++) {
                for(let col = 0; col < 8; col++) {
                    const piece = gameState.board[row][col];
                    if(piece && getPieceColor(piece) === 'red') {
                        const moves = calculatePossibleMoves(row, col);
                        moves.forEach(move => {
                            allMoves.push({
                                fromRow: row,
                                fromCol: col,
                                toRow: move.row,
                                toCol: move.col,
                                type: move.type,
                                score: evaluateMove(row, col, move.row, move.col, move)
                            });
                        });
                    }
                }
            }
            
            if(allMoves.length === 0) return null;
            
            // Prioriser les captures
            const captures = allMoves.filter(m => m.type === 'capture');
            if(captures.length > 0) {
                captures.sort((a, b) => b.score - a.score);
                return captures[0];
            }
            
            // Trier par score et prendre le meilleur
            allMoves.sort((a, b) => b.score - a.score);
            
            // Ajouter un peu d'al√©atoire selon la difficult√©
            const randomFactor = gameState.difficulty === 'easy' ? 0.6 : 
                                 gameState.difficulty === 'normal' ? 0.3 : 0.1;
            
            if(Math.random() < randomFactor) {
                return allMoves[Math.floor(Math.random() * Math.min(4, allMoves.length))];
            }
            
            return allMoves[0];
        }

        // √âvaluer un coup
        function evaluateMove(fromRow, fromCol, toRow, toCol, move) {
            let score = 0;
            
            // Bonus √©norme pour les captures
            if(move.type === 'capture') {
                const capturedPiece = gameState.board[move.capturedRow][move.capturedCol];
                score += isKing(capturedPiece) ? 30 : 10;
            }
            
            // Bonus pour avancer vers la promotion
            if(!isKing(gameState.board[fromRow][fromCol])) {
                score += (toRow - fromRow) * 2; // Plus on avance, mieux c'est
            }
            
            // Bonus pour contr√¥ler le centre
            const centerDistance = Math.abs(toRow - 3.5) + Math.abs(toCol - 3.5);
            score += (7 - centerDistance) * 1.5;
            
            // Bonus pour la s√©curit√© (√©viter les bords)
            if(toRow > 0 && toRow < 7 && toCol > 0 && toCol < 7) {
                score += 2;
            }
            
            return score + Math.random() * 3;
        }

        // V√©rifier la fin de partie
        function isGameOver() {
            // Compter les pi√®ces
            let yellowPieces = 0;
            let redPieces = 0;
            let yellowMoves = 0;
            let redMoves = 0;
            
            for(let row = 0; row < 8; row++) {
                for(let col = 0; col < 8; col++) {
                    const piece = gameState.board[row][col];
                    if(piece) {
                        if(getPieceColor(piece) === 'yellow') {
                            yellowPieces++;
                            yellowMoves += calculatePossibleMoves(row, col).length;
                        } else {
                            redPieces++;
                            redMoves += calculatePossibleMoves(row, col).length;
                        }
                    }
                }
            }
            
            // Fin de partie si plus de pi√®ces ou plus de mouvements possibles
            return yellowPieces === 0 || redPieces === 0 || 
                   (gameState.currentPlayer === 'yellow' && yellowMoves === 0) ||
                   (gameState.currentPlayer === 'red' && redMoves === 0);
        }

        // Terminer la partie
        function endGame() {
            gameState.isGameActive = false;
            clearInterval(gameState.timer);
            
            const t = translations[gameState.currentLanguage];
            
            // D√©terminer le gagnant
            let yellowPieces = 0;
            let redPieces = 0;
            let yellowMoves = 0;
            let redMoves = 0;
            
            for(let row = 0; row < 8; row++) {
                for(let col = 0; col < 8; col++) {
                    const piece = gameState.board[row][col];
                    if(piece) {
                        if(getPieceColor(piece) === 'yellow') {
                            yellowPieces++;
                            yellowMoves += calculatePossibleMoves(row, col).length;
                        } else {
                            redPieces++;
                            redMoves += calculatePossibleMoves(row, col).length;
                        }
                    }
                }
            }
            
            let winner;
            let reason = "";
            
            // D√©terminer la raison de la victoire
            if(yellowPieces === 0) {
                winner = t.reds;
                reason = t.allPiecesCaptured || "Toutes les pi√®ces captur√©es";
            } else if(redPieces === 0) {
                winner = t.yellows;
                reason = t.allPiecesCaptured || "Toutes les pi√®ces captur√©es";
            } else if(gameState.currentPlayer === 'yellow' && yellowMoves === 0) {
                winner = t.reds;
                reason = t.noMovesLeft || "Aucun mouvement possible";
            } else if(gameState.currentPlayer === 'red' && redMoves === 0) {
                winner = t.yellows;
                reason = t.noMovesLeft || "Aucun mouvement possible";
            } else if(yellowPieces > redPieces) {
                winner = t.yellows;
                reason = t.morePieces || "Plus de pi√®ces";
            } else if(redPieces > yellowPieces) {
                winner = t.reds;
                reason = t.morePieces || "Plus de pi√®ces";
            } else {
                winner = gameState.currentPlayer === 'yellow' ? t.reds : t.yellows;
                reason = t.strategicAdvantage || "Avantage strat√©gique";
            }
            
            // Afficher un message de fin de partie d√©taill√©
            const finalMessage = `üèÜ ${t.gameEnded}!\n\n${t.victory}: ${winner}\n${t.reason || "Raison"}: ${reason}\n\n${t.finalScore || "Score final"}: ${gameState.score} points\n${t.totalMoves || "Total coups"}: ${gameState.moveCount}`;
            
            // Afficher le message avec style
            showGameEndMessage(finalMessage);
            
            // Ajouter √† l'historique
            addMoveToHistory(`üèÜ ${t.victory}: ${winner} (${reason})`);
        }
        
        // Afficher le message de fin de partie avec style
        function showGameEndMessage(message) {
            // Cr√©er une overlay pour le message de fin
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 1000;
                backdrop-filter: blur(10px);
            `;
            
            const messageBox = document.createElement('div');
            messageBox.style.cssText = `
                background: linear-gradient(145deg, rgba(30, 30, 58, 0.95), rgba(76, 29, 149, 0.95));
                border: 3px solid #ff6b35;
                border-radius: 20px;
                padding: 40px;
                text-align: center;
                color: white;
                font-size: 18px;
                font-weight: bold;
                max-width: 500px;
                box-shadow: 0 0 50px rgba(255, 107, 53, 0.7);
                animation: gameEndPulse 2s ease-in-out infinite alternate;
                white-space: pre-line;
            `;
            
            messageBox.textContent = message;
            
            const closeButton = document.createElement('button');
            closeButton.textContent = '‚ú® Nouvelle Partie';
            closeButton.style.cssText = `
                margin-top: 30px;
                padding: 15px 30px;
                background: linear-gradient(145deg, #ff6b35, #f59e0b);
                color: white;
                border: none;
                border-radius: 15px;
                font-size: 16px;
                font-weight: bold;
                cursor: pointer;
                transition: all 0.3s ease;
            `;
            
            closeButton.onmouseover = () => {
                closeButton.style.transform = 'scale(1.1)';
                closeButton.style.boxShadow = '0 10px 30px rgba(255, 107, 53, 0.7)';
            };
            
            closeButton.onmouseout = () => {
                closeButton.style.transform = 'scale(1)';
                closeButton.style.boxShadow = 'none';
            };
            
            closeButton.onclick = () => {
                document.body.removeChild(overlay);
                resetGame();
            };
            
            messageBox.appendChild(closeButton);
            overlay.appendChild(messageBox);
            document.body.appendChild(overlay);
            
            // Ajouter l'animation CSS
            const style = document.createElement('style');
            style.textContent = `
                @keyframes gameEndPulse {
                    from { 
                        box-shadow: 0 0 50px rgba(255, 107, 53, 0.7);
                        transform: scale(1);
                    }
                    to { 
                        box-shadow: 0 0 80px rgba(255, 107, 53, 1);
                        transform: scale(1.02);
                    }
                }
            `;
            document.head.appendChild(style);
        }

        // Afficher un message IA
        function showAIMessage(message, duration = 2500) {
            const aiThinking = document.getElementById('aiThinking');
            const aiMessage = document.getElementById('aiMessage');
            
            aiMessage.textContent = message;
            aiThinking.classList.add('active');
            
            if(duration > 0) {
                setTimeout(() => {
                    aiThinking.classList.remove('active');
                }, duration);
            }
        }

        // Masquer le message IA
        function hideAIMessage() {
            const aiThinking = document.getElementById('aiThinking');
            aiThinking.classList.remove('active');
        }

        // D√©marrer le timer
        function startTimer() {
            if(gameState.timer) {
                clearInterval(gameState.timer);
            }
            
            gameState.timer = setInterval(() => {
                if(gameState.isGameActive) {
                    updateUI();
                }
            }, 1000);
        }

        // Mettre √† jour l'interface utilisateur
        function updateUI() {
            document.getElementById('moveCount').textContent = gameState.moveCount;
            document.getElementById('aiLevel').textContent = gameState.aiLevel;
            document.getElementById('gameScore').textContent = gameState.score;
            
            // Mettre √† jour le temps
            if(gameState.startTime) {
                const elapsedTime = Date.now() - gameState.startTime;
                const minutes = Math.floor(elapsedTime / 60000);
                const seconds = Math.floor((elapsedTime % 60000) / 1000);
                document.getElementById('gameTime').textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
            
            // Mettre √† jour le bouton statut du joueur
            const t = translations[gameState.currentLanguage];
            const playerName = gameState.currentPlayer === 'yellow' ? t.playerYellow : 
                              (gameState.gameMode === 'ai' ? t.aiPlayer : t.playerRed);
            const playerIcon = gameState.currentPlayer === 'yellow' ? 'üî•' : 'ü§ñ';
            
            document.getElementById('currentPlayer').textContent = playerIcon;
            document.getElementById('playerName').textContent = playerName;
            
            // Changer la couleur du bouton selon le joueur
            const playerBtn = document.getElementById('playerStatusBtn');
            playerBtn.classList.remove('yellow-player', 'red-player');
            if(gameState.currentPlayer === 'yellow') {
                playerBtn.classList.add('yellow-player');
            } else {
                playerBtn.classList.add('red-player');
            }
        }

        // Fonction pour changer de joueur manuellement (mode 2 joueurs uniquement)
        function switchPlayer() {
            if(gameState.gameMode === 'human' && gameState.isGameActive && !gameState.aiThinking) {
                gameState.currentPlayer = gameState.currentPlayer === 'yellow' ? 'red' : 'yellow';
                deselectSquare();
                updateUI();
                
                const t = translations[gameState.currentLanguage];
                showAIMessage(`${t.turnOf} ${gameState.currentPlayer === 'yellow' ? t.playerYellow : t.playerRed}`, 1800);
            }
        }

        // Fonctions des boutons
        function setGameMode(mode) {
            gameState.gameMode = mode;
            
            const aiBtn = document.getElementById('aiModeBtn');
            const humanBtn = document.getElementById('humanModeBtn');
            
            if(mode === 'ai') {
                aiBtn.classList.add('active');
                humanBtn.classList.remove('active');
            } else {
                humanBtn.classList.add('active');
                aiBtn.classList.remove('active');
            }
            
            resetGame();
        }

        function undoMove() {
            if(gameState.moveHistory.length <= 1) return;
            
            const t = translations[gameState.currentLanguage];
            showAIMessage(t.undoInDevelopment, 2500);
        }

        function activateQuantumMode() {
            gameState.quantumMode = !gameState.quantumMode;
            const btn = document.getElementById('quantumBtn');
            const t = translations[gameState.currentLanguage];
            
            if(gameState.quantumMode) {
                btn.style.background = 'linear-gradient(145deg, #10b981, #059669)';
                showAIMessage(t.quantumActivated, 3500);
                
                // Ajouter des effets visuels quantiques
                document.querySelectorAll('.dame-square').forEach(square => {
                    if(Math.random() < 0.12) {
                        square.classList.add('quantum-state');
                        setTimeout(() => {
                            square.classList.remove('quantum-state');
                        }, 2500);
                    }
                });
            } else {
                btn.style.background = 'linear-gradient(145deg, #ec4899, #db2777)';
                showAIMessage(t.quantumDeactivated, 2500);
            }
        }

        function resetGame() {
            const t = translations[gameState.currentLanguage];
            showAIMessage(t.newGameStarted, 2500);
            initGame();
        }

        function changeDifficulty() {
            const difficulties = ['easy', 'normal', 'hard', 'expert'];
            const currentIndex = difficulties.indexOf(gameState.difficulty);
            const nextIndex = (currentIndex + 1) % difficulties.length;
            gameState.difficulty = difficulties[nextIndex];
            
            gameState.aiLevel = nextIndex + 2;
            
            const t = translations[gameState.currentLanguage];
            const diffText = t.difficultyText.replace('Expert', t.difficulties[gameState.difficulty]);
            document.getElementById('difficultyText').textContent = diffText;
            
            showAIMessage(`${t.difficultyChanged} ${t.difficulties[gameState.difficulty]}`, 2500);
        }

        function toggleAIAnalysis() {
            const t = translations[gameState.currentLanguage];
            showAIMessage(t.aiAnalyzing, 3500);
            
            setTimeout(() => {
                const analysis = analyzePosition();
                showAIMessage(analysis, 6000);
            }, 2500);
        }

        function analyzePosition() {
            let yellowScore = 0;
            let redScore = 0;
            
            for(let row = 0; row < 8; row++) {
                for(let col = 0; col < 8; col++) {
                    const piece = gameState.board[row][col];
                    if(piece) {
                        const value = isKing(piece) ? 3 : 1;
                        if(getPieceColor(piece) === 'yellow') {
                            yellowScore += value;
                        } else {
                            redScore += value;
                        }
                    }
                }
            }
            
            const t = translations[gameState.currentLanguage];
            const advantage = yellowScore - redScore;
            if(advantage > 4) return t.yellowAdvantage;
            if(advantage < -4) return t.redAdvantage;
            if(advantage > 0) return t.slightYellowAdvantage;
            if(advantage < 0) return t.slightRedAdvantage;
            return t.balancedPosition;
        }

        function showBestMoves() {
            const t = translations[gameState.currentLanguage];
            showAIMessage(t.bestMovesCalculating, 2500);
            
            setTimeout(() => {
                const moves = calculateBestMove();
                if(moves) {
                    const suggestion = `${t.suggestion} ${String.fromCharCode(97 + moves.fromCol)}${8 - moves.fromRow} ‚Üí ${String.fromCharCode(97 + moves.toCol)}${8 - moves.toRow}`;
                    showAIMessage(suggestion, 5000);
                } else {
                    showAIMessage(t.noMovesAvailable, 2500);
                }
            }, 2500);
        }

        function saveGame() {
            const saveData = {
                board: gameState.board,
                currentPlayer: gameState.currentPlayer,
                gameMode: gameState.gameMode,
                moveHistory: gameState.moveHistory,
                moveCount: gameState.moveCount,
                score: gameState.score,
                difficulty: gameState.difficulty,
                currentLanguage: gameState.currentLanguage
            };
            
            localStorage.setItem('quantumDamesSave', JSON.stringify(saveData));
            const t = translations[gameState.currentLanguage];
            showAIMessage(t.gameSaved, 2500);
        }

        function loadGame() {
            const saveData = localStorage.getItem('quantumDamesSave');
            if(saveData) {
                const data = JSON.parse(saveData);
                gameState.board = data.board;
                gameState.currentPlayer = data.currentPlayer;
                gameState.gameMode = data.gameMode;
                gameState.moveHistory = data.moveHistory;
                gameState.moveCount = data.moveCount;
                gameState.score = data.score;
                gameState.difficulty = data.difficulty;
                if(data.currentLanguage) {
                    gameState.currentLanguage = data.currentLanguage;
                    document.getElementById('languageSelector').value = data.currentLanguage;
                    changeLanguage();
                }
                
                createDameboard();
                updateUI();
                const t = translations[gameState.currentLanguage];
                showAIMessage(t.gameLoaded, 2500);
            }
        }

        // Fonction pour basculer pause/reprendre
        function togglePause() {
            const t = translations[gameState.currentLanguage];
            const pauseBtn = document.getElementById('pauseBtn');
            const pauseTextElement = document.getElementById('pauseText');
            
            gameState.isPaused = !gameState.isPaused;
            
            if(gameState.isPaused) {
                // Mettre en pause
                pauseBtn.innerHTML = '‚ñ∂Ô∏è <span id="pauseText">' + t.resumeText + '</span>';
                pauseBtn.style.background = 'linear-gradient(145deg, #10b981, #059669)';
                showAIMessage(t.gamePaused, 2000);
                
                // Arr√™ter le timer
                if(gameState.timer) {
                    clearInterval(gameState.timer);
                }
            } else {
                // Reprendre
                pauseBtn.innerHTML = '‚è∏Ô∏è <span id="pauseText">' + t.pauseText + '</span>';
                pauseBtn.style.background = 'linear-gradient(145deg, #8b5cf6, #7c3aed)';
                showAIMessage(t.gameResumed, 2000);
                
                // Red√©marrer le timer
                startTimer();
            }
        }

        // Initialisation
        document.addEventListener('DOMContentLoaded', function() {
            initFuturisticEffects();
            initGame();
            
            // Charger une sauvegarde si elle existe
            if(localStorage.getItem('quantumDamesSave')) {
                setTimeout(() => {
                    const t = translations[gameState.currentLanguage];
                    if(confirm(t.loadSavedGame)) {
                        loadGame();
                    }
                }, 1200);
            }
            
            // Message de bienvenue
            setTimeout(() => {
                const t = translations[gameState.currentLanguage];
                showAIMessage(t.welcome, 5000);
            }, 1200);
        });
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'984959ce0269777e',t:'MTc1ODc5MTAzMi4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>
