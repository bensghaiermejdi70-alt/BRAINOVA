<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
</head>
<body>
  <!-- Auto-redirect removed. Choose which platform to open: canonical or correct. -->
  <div style="padding:14px;margin:12px;background:#021226;color:#dff;border-radius:8px;max-width:960px;margin-left:auto;margin-right:auto;text-align:center">
  Platform chooser: <a href="../brainova.html">canonical</a> — <a href="../global_platform_correct.html">correct</a>
  </div>
</head>
<body>
  Redirecting to the canonical platform — <a href="../brainova.html">open platform</a>
  </body>
</html>

  <main class="main" style="max-width:1200px;margin:18px auto;padding:0 18px">
    <section class="hero" id="catalog-hero" style="padding:18px;background:linear-gradient(135deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));border-radius:12px;margin-bottom:18px">
      <div style="max-width:1200px;margin:0 auto;display:flex;align-items:center;justify-content:space-between;gap:18px;flex-wrap:wrap">
        <div style="display:flex;align-items:center;gap:14px">
          <div style="width:96px;height:96px;border-radius:12px;background:linear-gradient(135deg,#00d4ff,#ff0096);display:flex;align-items:center;justify-content:center;font-size:28px;font-weight:900;color:#001;padding:12px;box-shadow:0 8px 40px rgba(0,212,255,0.08)">36<br><small style="font-size:10px;color:#001;font-weight:700">JEUX</small></div>
          <div>
            <h2 style="margin:0;font-family:Orbitron,monospace;color:#00d4ff">Catalogue Brainova — 36 jeux</h2>
            <p style="margin:6px 0;color:#cfefff">Explorez par thème : sélectionnez une catégorie pour filtrer les cartes de jeux.</p>
          </div>
        </div>
        <div id="catalogCats" style="display:flex;gap:12px;flex-wrap:wrap">
          <button class="cat" data-filter="all" style="padding:10px 14px;background:linear-gradient(135deg,rgba(0,0,0,0.6),rgba(26,26,46,0.6));border:1px solid rgba(255,255,255,0.03);border-radius:10px;color:#cfefff;cursor:pointer">Tous</button>
          <button class="cat" data-filter="memoire" style="padding:10px 14px;background:linear-gradient(135deg,rgba(0,0,0,0.6),rgba(26,26,46,0.6));border:1px solid rgba(255,255,255,0.03);border-radius:10px;color:#cfefff;cursor:pointer">Mémoire</button>
          <button class="cat" data-filter="quiz" style="padding:10px 14px;background:linear-gradient(135deg,rgba(0,0,0,0.6),rgba(26,26,46,0.6));border:1px solid rgba(255,255,255,0.03);border-radius:10px;color:#cfefff;cursor:pointer">Quiz</button>
          <button class="cat" data-filter="puzzle" style="padding:10px 14px;background:linear-gradient(135deg,rgba(0,0,0,0.6),rgba(26,26,46,0.6));border:1px solid rgba(255,255,255,0.03);border-radius:10px;color:#cfefff;cursor:pointer">Puzzle</button>
          <button class="cat" data-filter="arcade" style="padding:10px 14px;background:linear-gradient(135deg,rgba(0,0,0,0.6),rgba(26,26,46,0.6));border:1px solid rgba(255,255,255,0.03);border-radius:10px;color:#cfefff;cursor:pointer">Arcade</button>
        </div>
      </div>
    </section>

    <main id="gamesGrid" class="games-grid" aria-live="polite"></main>
  </main>

  <script>
    // --- begin header interactivity (language, settings, login/signup) ---
    (function(){
      const Translations = {
        fr: { login: 'Connexion', signup: 'Inscription' },
        en: { login: 'Login', signup: 'Sign up' },
        ar: { login: 'تسجيل الدخول', signup: 'إنشاء حساب' },
        es: { login: 'Conexión', signup: 'Registro' },
        de: { login: 'Anmelden', signup: 'Registrieren' },
        zh: { login: '登录', signup: '注册' }
      };

      function applyHeaderLang(code){
        const t = Translations[code] || Translations.fr;
        const b1 = document.getElementById('btnLogin'); if(b1) b1.textContent = t.login;
        const b2 = document.getElementById('btnSignup'); if(b2) b2.textContent = t.signup;
      }

      const langSelect = document.getElementById('langSelect');
      if(langSelect){
        const stored = localStorage.getItem('brainovaLang') || 'fr';
        langSelect.value = stored;
        applyHeaderLang(stored);
        langSelect.addEventListener('change', ()=>{
          localStorage.setItem('brainovaLang', langSelect.value);
          applyHeaderLang(langSelect.value);
        });
      }

      // settings button toggle
      const settingsBtn = document.getElementById('settingsBtn');
      const settingsMenu = document.getElementById('settingsMenu');
      if(settingsBtn && settingsMenu){
        settingsBtn.addEventListener('click', ()=>{
          settingsMenu.style.display = settingsMenu.style.display === 'block' ? 'none' : 'block';
        });
        document.addEventListener('click', (e)=>{ if(!settingsBtn.contains(e.target) && !settingsMenu.contains(e.target)) settingsMenu.style.display='none'; });
      }

      // simple nav actions
  const btnLogin = document.getElementById('btnLogin'); if(btnLogin) btnLogin.addEventListener('click', ()=>{ try{ parent.postMessage({ action: 'dialog', dialogType: 'alert', text: 'Connexion (placeholder)' }, '*'); }catch(e){} });
  const btnSignup = document.getElementById('btnSignup'); if(btnSignup) btnSignup.addEventListener('click', ()=>{ try{ parent.postMessage({ action: 'dialog', dialogType: 'alert', text: 'Inscription (placeholder)' }, '*'); }catch(e){} });
    })();
    // --- end header interactivity ---
    window.PlatformConfig = { totalGames: 36, currentLanguage: 'fr', gameModules: new Map() };

    // --- Bundle / Pack support ---
    // If you sell a single "Pass Premium" bundle (all premium games),
    // configure the hosted Payment Link in the header 'Pass Premium' anchor
    // or set localStorage.bundlePaymentLink. After successful payment the
    // Payment Link can redirect back to the site with ?bundle_purchased=1&email=...
    // We detect that and mark all premium games owned locally.
    function getBundleLink(){
      // Try header anchor first
      try{
        const anchor = document.querySelector('a.nav-btn[href*="buy.stripe.com"]');
        if(anchor && anchor.href) return anchor.href;
      }catch(e){}
      // Fallback to explicit localStorage override
      return localStorage.getItem('bundlePaymentLink') || null;
    }

    function handleBundleRedirectFromURL(){
      // Parse query params and store basic purchase/session info to localStorage.
      try{
        const params = new URLSearchParams(window.location.search);
        const sessionId = params.get('session_id') || params.get('checkout_session_id');
        const email = params.get('email') || params.get('customer_email');
        const bundleFlag = params.get('bundle_purchased') === '1' || params.get('bundle') === '1' || params.get('payment') === 'success';

  // Store transient session info in sessionStorage (do not persist email/token across browser sessions)
  try{ if(sessionId) sessionStorage.setItem('last_stripe_session', sessionId); }catch(e){ if(sessionId) localStorage.setItem('last_stripe_session', sessionId); }
  try{ if(email) sessionStorage.setItem('brainovaUserEmail', email); }catch(e){ if(email) localStorage.setItem('brainovaUserEmail', email); }
  if(bundleFlag) localStorage.setItem('bundlePurchased','1');
      }catch(e){ /* ignore parsing errors */ }

      // Clean the querystring to keep URL neat
      try{
        const clean = window.location.pathname + window.location.hash;
        window.history.replaceState({}, document.title, clean);
      }catch(e){}

      // Verify purchases server-side (best-effort) and apply gating
      (function(){
        (async function(){
            try{
            let purchases = [];
            // Prefer session storage for transient session/email, fallback to localStorage for legacy
            const s = sessionStorage.getItem('last_stripe_session') || localStorage.getItem('last_stripe_session');
            const e = sessionStorage.getItem('brainovaUserEmail') || localStorage.getItem('brainovaUserEmail');
            if(s){
              try{ const resp = await fetch('/.netlify/functions/check-purchase?session_id=' + encodeURIComponent(s)); if(resp.ok){ const d = await resp.json(); purchases = purchases.concat(d.purchases || []); } }catch(_){ }
            }
            if(e){
              try{ const resp2 = await fetch('/.netlify/functions/check-purchase?email=' + encodeURIComponent(e)); if(resp2.ok){ const d2 = await resp2.json(); purchases = purchases.concat(d2.purchases || []); } }catch(_){ }
            }
            if(purchases.length > 0) localStorage.setItem('bundlePurchased','1');
            applyPurchaseGating();
          }catch(err){ console.warn('post-check verification failed', err); }
        })();
      })();

      // Attempt to preload games-index and then init platform
      (function(){
        import('./games/games-index.js').then(mod=>{ window.GamesIndex = mod.default; }).catch(()=>{ /* ignore */ }).finally(()=>{ try{ initPlatform(); }catch(e){} });
      })();
    }

    function loadScriptAsync(src){
      return new Promise((resolve,reject)=>{
        const s = document.createElement('script');
        s.src = src;
        s.async = false; // preserve execution order for core scripts
        s.onload = ()=>resolve();
        s.onerror = (e)=>reject(e);
        document.head.appendChild(s);
      });
    }

    function loadCSSAsync(href){
      return new Promise((resolve)=>{
        const l = document.createElement('link');
        l.rel = 'stylesheet';
        l.href = href;
        l.media = 'print';
        l.onload = function(){ l.media = 'all'; resolve(); };
        l.onerror = function(){ /* resolve even if CSS fails to load */ resolve(); };
        document.head.appendChild(l);
      });
    }

    function waitFor(cond, timeout){
      return new Promise((resolve)=>{
        const start = Date.now();
        (function tick(){
          try{ if(cond()) return resolve(true); }catch(e){}
          if(Date.now()-start > timeout) return resolve(false);
          setTimeout(tick, 50);
        })();
      });
    }

    function initPlatform(){
      document.getElementById('loader').style.display='none';
      document.getElementById('header').style.display='flex';
      // detect possible redirect from a Payment Link and mark bundle if present
      try{ handleBundleRedirectFromURL(); }catch(e){/* ignore */}
      loadGameCards();
      setupCategoryFilters();
      // Attempt to apply purchase gating if we have an email stored
      applyPurchaseGating();
    }

    async function applyPurchaseGating(){
      try{
        const email = localStorage.getItem('brainovaUserEmail');
        const bundleOwned = localStorage.getItem('bundlePurchased') === '1';
        if(!email && !bundleOwned) return;

        // If we have an email, query server purchases; otherwise rely on bundle flag
        let purchases = [];
        if(email){
          try{
            const resp = await fetch(`/.netlify/functions/check-purchase?email=${encodeURIComponent(email)}`);
            if(resp.ok){
              const data = await resp.json();
              purchases = data.purchases || [];
            }
          }catch(e){ /* ignore and continue, bundleOwned may still apply */ }
        }

        const ownedGameIds = new Set();
        purchases.forEach(p=>{
          try{
            const meta = p.metadata || p.metadata_value || {};
            const m = (typeof meta === 'string') ? JSON.parse(meta || '{}') : meta;
            if(m.game_id) ownedGameIds.add(String(m.game_id));
          }catch(e){}
        });

        // If bundle was purchased, mark all premium ids as owned (0 and 11..36)
        if(bundleOwned){
          for(let i=0;i<=36;i++){
            if(i === 0 || (i >= 11 && i <= 36)) ownedGameIds.add(String(i));
          }
        }

        if(ownedGameIds.size === 0) return;
        // disable buy buttons for owned games
        const grid = document.getElementById('gamesGrid');
        const buyButtons = grid.querySelectorAll('.buy-btn');
        buyButtons.forEach(b=>{
          const gid = b.getAttribute('data-game');
          if(ownedGameIds.has(String(gid))){
            b.textContent = 'Déjà acheté';
            b.disabled = true;
            b.classList.add('owned');
            b.style.opacity = '0.6';
          }
        });
      }catch(e){ console.warn('applyPurchaseGating error', e); }
    }

    function loadGameCards(){
      const grid = document.getElementById('gamesGrid');
        for(let i=0;i<=36;i++){
              const card = document.createElement('div'); card.className='game-card'; card.dataset.gameId=i;
              // Lock card 0 and cards 11..36 by default (require purchase)
              if(i === 0 || (i >= 11 && i <= 36)){
                card.classList.add('locked');
                card.dataset.locked = '1';
              }
          card.innerHTML = `
            <div class="game-header">
              <div class="game-number">${String(i).padStart(2,'0')}</div>
              <div class="game-status">--</div>
            </div>
            <div class="game-icon">🎮</div>
            <h3>Jeu ${i}</h3>
            <p>Chargement…</p>
            <div class="game-tags"></div>
            <div class="game-stats"><span>--</span><span>--</span></div>
          `;
          observeCard(card);
          grid.appendChild(card);
        }
    }

    async function loadGameContent(card){
      const id = card.dataset.gameId;
      // use central games-index module
      try{
          const GamesIndex = (await import('./games/games-index.js')).default;
            // ensure consistent markup from GamesIndex
            const html = GamesIndex.getCardHTML(id);
            // apply any per-card outer style (e.g. accent for 'qi') to the .game-card
            if(typeof GamesIndex.getCardStyle === 'function'){
              const styleText = GamesIndex.getCardStyle(id) || '';
              if(styleText) card.style.cssText += styleText;
            }
            // If GamesIndex provides inner markup, replace innerHTML, otherwise keep fallback
            card.innerHTML = html || card.innerHTML;
            card.onclick = ()=>GamesIndex.launch(id);
        window.PlatformConfig.gameModules.set(id, true);
      }catch(e){ /* keep placeholder */ }
    }

    function observeCard(card){
      const obs = new IntersectionObserver((entries, o)=>{ entries.forEach(e=>{ if(e.isIntersecting){ loadGameContent(e.target); o.unobserve(e.target); } }); }, {rootMargin:'200px'});
      obs.observe(card);
    }

    // Build a simple tags index and wire up category buttons
    function setupCategoryFilters(){
      const cats = document.querySelectorAll('#catalogCats .cat');
      // For quick lookup, build a map of id -> tags from GamesIndex if available
      const tagsMap = new Map();
      try{
        if(window.GamesIndex && typeof window.GamesIndex.getCardTags === 'function'){
          for(let i=0;i<=36;i++) tagsMap.set(String(i), window.GamesIndex.getCardTags(i));
        }
      }catch(e){ /* ignore */ }

      function applyFilter(filter){
        const grid = document.getElementById('gamesGrid');
        const cards = grid.querySelectorAll('.game-card');
        cards.forEach(card=>{
          const id = card.dataset.gameId;
          if(filter === 'all'){ card.style.display = ''; return; }
          const tags = tagsMap.get(id) || [];
          if(tags.indexOf(filter) !== -1) card.style.display = '';
          else card.style.display = 'none';
        });
      }

      cats.forEach(btn=>{
        btn.addEventListener('click', ()=>{
          const f = btn.getAttribute('data-filter');
          applyFilter(f);
          // simple active state
          cats.forEach(b=>b.style.opacity = '0.8'); btn.style.opacity='1';
        });
      });
    }

      // Load the stripe client helper so we can start server-side Checkout sessions
      import('./stripe-client.js').then(mod=>{ window.StripeClient = mod; }).catch(()=>{});

      // Delegate clicks for inner action buttons (Open / Buy / Gratuit / Test QI)
  document.getElementById('gamesGrid').addEventListener('click', (e)=>{
          // If the clicked card (or its parent) is locked, intercept and redirect to purchase flow
          const clickedCard = e.target.closest && e.target.closest('.game-card');
          if(clickedCard && clickedCard.dataset && clickedCard.dataset.locked === '1'){
            // Check local purchase flags (bundle or per-game) before allowing access
            const gameIdLocked = Number(clickedCard.dataset.gameId);
            const bundleOwned = localStorage.getItem('bundlePurchased') === '1';
            const perGameOwned = localStorage.getItem('purchased_game_' + gameIdLocked) === '1';
            if(!bundleOwned && !perGameOwned){
              e.stopPropagation(); e.preventDefault();
              // Try bundle first
              try{
                const bundleLink = getBundleLink();
                if(bundleLink){ window.open(bundleLink, '_blank', 'noopener'); return; }
              }catch(err){ /* continue to per-game purchase */ }

              // Start per-game checkout if StripeClient available
              const name = (clickedCard.querySelector && clickedCard.querySelector('h3') && clickedCard.querySelector('h3').textContent) || `Jeu ${gameIdLocked}`;
              const priceAttr = clickedCard.querySelector && clickedCard.querySelector('.buy-btn') && clickedCard.querySelector('.buy-btn').getAttribute('data-price');
              const price = priceAttr ? Number(priceAttr) : 499;
              if(window.StripeClient && typeof window.StripeClient.startCheckout === 'function'){
                const userEmail = localStorage.getItem('brainovaUserEmail') || null;
                const metadata = { game_id: String(gameIdLocked) };
                if(userEmail) metadata.user_email = userEmail;
                window.StripeClient.startCheckout([{ name, amount: price, quantity: 1 }], metadata);
                return;
              }

              // fallback: open bundle or generic buy page
              const fallback = getBundleLink() || 'https://buy.stripe.com/cNi8wR7IC77o54icy49EI01';
              window.open(fallback, '_blank', 'noopener');
              return;
            }
          }
        const openBtn = e.target.closest && e.target.closest('.open-btn');
        if(openBtn){
          e.stopPropagation(); e.preventDefault();
          const id = Number(openBtn.getAttribute('data-open'));
          import('./games/games-index.js').then(mod=>{ mod.default.launch(id); }).catch(()=>{});
          return;
        }

        const buyBtn = e.target.closest && e.target.closest('.buy-btn');
        if(buyBtn){
          e.stopPropagation(); e.preventDefault();
          const gameId = Number(buyBtn.getAttribute('data-game'));
          const price = Number(buyBtn.getAttribute('data-price')) || 499;
          const name = buyBtn.getAttribute('data-name') || `Jeu ${gameId}`;
          // If a bundle payment link exists and the user hasn't purchased
          // the bundle yet, open the bundle link instead of per-game checkout.
          try{
            const bundleOwned = localStorage.getItem('bundlePurchased') === '1';
            const bundleLink = getBundleLink();
            if(bundleLink && !bundleOwned){
              window.open(bundleLink, '_blank', 'noopener');
              return;
            }
          }catch(e){/* continue to per-game flow */}

          // Start a server-side Checkout; StripeClient.startCheckout expects items in cents
          if(window.StripeClient && typeof window.StripeClient.startCheckout === 'function'){
            // include metadata for webhook persistence: game id and user email (if known)
            const userEmail = localStorage.getItem('brainovaUserEmail') || null;
            const metadata = { game_id: String(gameId) };
            if(userEmail) metadata.user_email = userEmail;
            window.StripeClient.startCheckout([{ name, amount: price, quantity: 1 }], metadata);
          }else{
            // Fallback: open hosted link (try bundle then default)
  const fallback = getBundleLink() || './brainova.html?bundle_purchased=1';
            window.open(fallback,'_blank');
          }
          return;
        }

        const freeBtn = e.target.closest && e.target.closest('.free-btn');
        if(freeBtn){
          e.stopPropagation(); e.preventDefault();
          const id = Number(freeBtn.getAttribute('data-open'));
          import('./games/games-index.js').then(mod=>{ mod.default.launch(id); }).catch(()=>{});
          return;
        }

        const testQi = e.target.closest && e.target.closest('.test-qi-btn');
        if(testQi){
          e.stopPropagation(); e.preventDefault();
          const targetId = testQi.getAttribute('data-target') || '0';
          import('./games/games-index.js').then(mod=>{ mod.default.launch(Number(targetId)); }).catch(()=>{});
          return;
        }
      });

      // On page load, check for Stripe Checkout redirect with session_id
      (function handleCheckoutReturn(){
        try{
          const urlParams = new URLSearchParams(window.location.search);
          const sessionId = urlParams.get('session_id') || urlParams.get('checkout_session_id');
          if(!sessionId) return;

          fetch('/.netlify/functions/check-access?session_id=' + encodeURIComponent(sessionId)).then(r=>r.json()).then(j=>{
            if(j && j.ok && j.allowed){
              const row = j.row || {};
              const meta = row.metadata || {};
              if(meta && meta.game_id){
                localStorage.setItem('purchased_game_' + String(meta.game_id), '1');
              } else {
                localStorage.setItem('bundlePurchased','1');
              }
              if(window.history && history.replaceState){
                const clean = window.location.pathname + window.location.hash;
                history.replaceState({}, document.title, clean);
              }
              setTimeout(()=>location.reload(), 600);
            }
          }).catch(()=>{});
        }catch(e){}
      })();
  </script>
</body>
</html>