<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetris Quantum AI 2077</title>
    <style>
        body {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Orbitron', monospace;
            background: linear-gradient(135deg, #0a0a0a, #1a1a2e, #16213e, #0f3460);
            color: #00ffff;
            height: 100%;
            overflow-x: hidden;
            overflow-y: auto;
            animation: backgroundPulse 8s ease-in-out infinite;
        }

        /* Style personnalisÃ© pour la barre de dÃ©filement */
        ::-webkit-scrollbar {
            width: 12px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            border: 1px solid rgba(0, 255, 255, 0.2);
        }

        ::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, #00ffff, #0080ff, #ff00ff);
            border-radius: 10px;
            border: 1px solid rgba(0, 255, 255, 0.5);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
        }

        ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(180deg, #ff00ff, #00ffff, #ffff00);
            box-shadow: 0 0 15px rgba(255, 0, 255, 0.5);
        }

        ::-webkit-scrollbar-corner {
            background: rgba(0, 0, 0, 0.3);
        }

        @keyframes backgroundPulse {
            0%, 100% { background: linear-gradient(135deg, #0a0a0a, #1a1a2e, #16213e, #0f3460); }
            50% { background: linear-gradient(135deg, #1a1a2e, #16213e, #0f3460, #533483); }
        }

        .game-header {
            text-align: center;
            padding: 20px;
        }

        .language-selector:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 255, 255, 0.4);
        }

        .language-selector option {
            background: #1a1a2e;
            color: #00ffff;
            padding: 5px;
        }

        /* Futuristic language selector */
        .futuristic-select {
            appearance: none;
            -webkit-appearance: none;
            background: linear-gradient(135deg, rgba(0,255,255,0.08), rgba(255,0,255,0.06));
            border: 1px solid rgba(0,255,255,0.18);
            color: #00ffff;
            padding: 8px 12px;
            border-radius: 12px;
            font-weight: bold;
            box-shadow: 0 8px 30px rgba(0,255,255,0.04);
            backdrop-filter: blur(6px);
            cursor: pointer;
            transition: transform 160ms ease, box-shadow 160ms ease;
            font-family: 'Orbitron', monospace;
        }

        .controls-header {
            display: flex;
            flex-direction: column;
            align-items: flex-end; /* keep select right aligned */
            gap: 6px;
        }

        .close-btn {
            background: linear-gradient(45deg, #ff4b4b, #ff0000);
            color: #fff;
            border: 0;
            padding: 6px 10px;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            box-shadow: 0 8px 30px rgba(255,0,0,0.12);
            transition: transform 120ms ease, box-shadow 120ms ease, opacity 120ms;
        }

        .close-btn:hover { transform: translateY(-3px); opacity: 0.95 }

        .difficulty-selector {
            width: 100%;
            background: linear-gradient(45deg, #ff00ff, #8000ff);
            border: 2px solid #ff00ff;
            border-radius: 8px;
            color: #fff;
            font-weight: bold;
            font-size: 12px;
            padding: 8px;
            cursor: pointer;
            transition: all 0.3s;
            outline: none;
            margin-bottom: 10px;
        }

        .difficulty-selector:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 0, 255, 0.4);
        }

        .difficulty-selector option {
            background: #1a1a2e;
            color: #fff;
            padding: 5px;
        }

        .difficulty-info {
            background: rgba(255, 0, 255, 0.1);
            border: 1px solid rgba(255, 0, 255, 0.3);
            border-radius: 6px;
            padding: 8px;
            font-size: 10px;
        }

        .difficulty-stat {
            display: flex;
            justify-content: space-between;
            margin: 3px 0;
        }

        .difficulty-value {
            font-weight: bold;
            color: #ff00ff;
            text-shadow: 0 0 5px #ff00ff;
        }

        .obstacle-cell {
            background: linear-gradient(45deg, #666, #333) !important;
            border: 2px solid #999 !important;
            box-shadow: 0 0 8px rgba(153, 153, 153, 0.5) !important;
        }

        .quantum-effect {
            animation: quantumGlitch 0.5s ease-in-out infinite;
        }

        @keyframes quantumGlitch {
            0%, 100% { transform: scale(1) rotate(0deg); }
            25% { transform: scale(1.1) rotate(1deg); }
            50% { transform: scale(0.9) rotate(-1deg); }
            75% { transform: scale(1.05) rotate(0.5deg); }
        }







        .game-container {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            gap: 20px;
            padding: 15px;
            min-height: calc(100vh - 120px);
            transition: margin-left 0.4s ease;
        }



        .side-panel {
            width: 220px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .panel {
            background: rgba(0, 255, 255, 0.1);
            border: 2px solid #00ffff;
            border-radius: 10px;
            padding: 10px;
            text-align: center;
        }

        .panel h3 {
            margin: 0 0 8px 0;
            font-size: 13px;
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
        }

        .btn {
            width: 100%;
            padding: 8px;
            margin: 3px 0;
            background: linear-gradient(45deg, #00ffff, #0080ff);
            border: none;
            border-radius: 8px;
            color: #000;
            font-weight: bold;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(0, 255, 255, 0.4);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .tetris-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        .game-board {
            width: 300px;
            height: 480px;
            background: rgba(0, 0, 0, 0.9);
            border: 4px solid #00ffff;
            border-radius: 15px;
            position: relative;
            overflow: hidden;
            box-shadow: 0 0 40px rgba(0, 255, 255, 0.5), 
                        0 0 60px rgba(255, 0, 255, 0.3);
        }

        .game-board::before {
            content: '';
            position: absolute;
            top: -4px;
            left: -4px;
            right: -4px;
            bottom: -4px;
            background: linear-gradient(45deg, #00ffff, #ff00ff, #ffff00);
            border-radius: 19px;
            z-index: -1;
            animation: borderGlow 3s ease-in-out infinite;
        }

        @keyframes borderGlow {
            0%, 100% { 
                background: linear-gradient(45deg, #00ffff, #ff00ff, #ffff00);
                filter: brightness(1);
            }
            50% { 
                background: linear-gradient(45deg, #ffff00, #00ffff, #ff00ff);
                filter: brightness(1.5);
            }
        }

        .tetris-grid {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            grid-template-rows: repeat(16, 1fr);
            width: 100%;
            height: 100%;
            gap: 1px;
            padding: 5px;
        }

        .tetris-cell {
            background: rgba(0, 20, 40, 0.3);
            border: 1px solid rgba(0, 255, 255, 0.1);
            transition: all 0.3s;
        }

        .tetris-cell.filled {
            border: 2px solid #fff;
            box-shadow: 0 0 10px currentColor;
            animation: cellGlow 0.5s ease-in-out;
        }

        @keyframes cellGlow {
            0% { transform: scale(0.8); opacity: 0.5; }
            100% { transform: scale(1); opacity: 1; }
        }

        .tetris-cell.clearing {
            animation: lineClear 0.8s ease-in-out;
        }

        @keyframes lineClear {
            0% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.2); background: #ffff00; }
            100% { opacity: 0; transform: scale(0); }
        }

        /* Couleurs des piÃ¨ces Tetris */
        .piece-I { background: linear-gradient(45deg, #00ffff, #0080ff); }
        .piece-O { background: linear-gradient(45deg, #ffff00, #ff8000); }
        .piece-T { background: linear-gradient(45deg, #ff00ff, #8000ff); }
        .piece-S { background: linear-gradient(45deg, #00ff00, #008000); }
        .piece-Z { background: linear-gradient(45deg, #ff0000, #800000); }
        .piece-J { background: linear-gradient(45deg, #0000ff, #000080); }
        .piece-L { background: linear-gradient(45deg, #ff8000, #804000); }

        .next-piece-panel {
            width: 80px;
            height: 80px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #ff00ff;
            border-radius: 8px;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(4, 1fr);
            gap: 1px;
            padding: 6px;
        }

        .next-cell {
            /* keep the cell visually empty by default; allow piece color classes (.piece-I etc.) to apply their background */
            background: transparent;
            border-radius: 3px;
            border: 1px solid rgba(255, 0, 255, 0.06);
            transition: background 120ms ease, box-shadow 120ms ease;
                box-sizing: border-box;
                display: block;
                width: 100%;
                height: 100%;
        }

        .next-cell.filled {
                /* when a piece is drawn, the piece color class (e.g. .piece-I) will set the background
                    and we add a visible glow to emphasize it */
                box-shadow: 0 0 8px rgba(255,255,255,0.08);
                border: 1px solid rgba(255,255,255,0.06);
                transform: translateZ(0);
        }



        .stats-display {
            background: rgba(255, 0, 255, 0.1);
            border: 2px solid #ff00ff;
            border-radius: 10px;
            padding: 10px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 11px;
        }

        .stat-value {
            font-weight: bold;
            color: #ff00ff;
            text-shadow: 0 0 10px #ff00ff;
        }

        .ai-panel {
            background: rgba(0, 255, 0, 0.1);
            border: 2px solid #00ff00;
            border-radius: 10px;
            padding: 10px;
        }

        .ai-suggestion {
            font-size: 10px;
            margin-top: 8px;
            color: #00ff00;
            min-height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            line-height: 1.3;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            padding: 8px;
        }

        .level-bar {
            width: 100%;
            height: 15px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            overflow: hidden;
            margin: 6px 0;
        }

        .level-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ffff00, #00ff00);
            transition: width 0.5s ease;
            border-radius: 8px;
        }

        .game-status {
            font-size: 18px;
            font-weight: bold;
            text-align: center;
            margin: 15px 0;
            min-height: 25px;
            text-shadow: 0 0 15px currentColor;
        }

        .game-status.paused {
            color: #ffff00;
            animation: statusPulse 2s ease-in-out infinite;
        }

        .game-status.game-over {
            color: #ff0000;
            animation: statusPulse 1s ease-in-out infinite;
        }

        @keyframes statusPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .controls-info {
            background: rgba(255, 255, 0, 0.1);
            border: 2px solid #ffff00;
            border-radius: 10px;
            padding: 10px;
            font-size: 10px;
        }

        .control-key {
            display: inline-block;
            background: rgba(255, 255, 0, 0.2);
            border: 1px solid #ffff00;
            border-radius: 4px;
            padding: 1px 4px;
            margin: 1px;
            font-weight: bold;
            font-size: 9px;
        }

        .neural-grid {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.1;
            z-index: -1;
        }

        .neural-line {
            position: absolute;
            background: linear-gradient(90deg, transparent, #00ffff, transparent);
            height: 1px;
            animation: neuralFlow 6s linear infinite;
        }

        @keyframes neuralFlow {
            0% { transform: translateX(-100%); opacity: 0; }
            50% { opacity: 1; }
            100% { transform: translateX(100vw); opacity: 0; }
        }

        .quantum-effects {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .quantum-particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: #00ffff;
            border-radius: 50%;
            animation: quantumFloat 4s ease-in-out infinite;
        }

        @keyframes quantumFloat {
            0%, 100% { transform: translateY(0) scale(1); opacity: 0.3; }
            50% { transform: translateY(-20px) scale(1.5); opacity: 1; }
        }

        @media (max-width: 1200px) {
            .game-container {
                flex-direction: column;
                align-items: center;
                height: auto;
                overflow-y: auto;
            }
            
            .side-panel {
                width: 100%;
                max-width: 500px;
            }
            
            .game-board {
                width: 250px;
                height: 500px;
            }
        }

        @media (max-width: 768px) {
            .game-title {
                font-size: 32px;
            }
            
            .game-board {
                width: 200px;
                height: 400px;
            }
            
            .side-panel {
                width: 90%;
            }
        }
    </style>
</head>
<body>
    <div class="neural-grid" id="neuralGrid"></div>



    <div class="game-header">
    <h1 class="game-title">TETRIS QUANTUM AI 2077</h1>
    <p class="subtitle">NEURAL PLACEMENT INTERFACE ACTIVATED</p>
        
        <div class="controls-header">
            <!-- language selector: futuristic style -->
            <select id="languageSelector" onchange="changeLanguage()" class="language-selector futuristic-select">
                <option value="fr">ğŸ‡«ğŸ‡· FranÃ§ais</option>
                <option value="en" selected>ğŸ‡ºğŸ‡¸ English</option>
                <option value="ar">ğŸ‡¸ğŸ‡¦ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©</option>
                <option value="es">ğŸ‡ªğŸ‡¸ EspaÃ±ol</option>
                <option value="de">ğŸ‡©ğŸ‡ª Deutsch</option>
                <option value="zh">ğŸ‡¨ğŸ‡³ ä¸­æ–‡</option>
            </select>
            <!-- close button moved below and aligned right -->
            <div style="width:100%;display:flex;justify-content:flex-end;">
                <button class="close-btn" onclick="closePlatform()" id="closeBtn" title="Back to platform home">âœ•</button>
            </div>
        </div>
    </div>

    <div class="game-container">
        <div class="side-panel">
            <div class="panel">
                <h3 data-i18n="quantumControls">QUANTUM CONTROLS</h3>
                <button class="btn" id="startBtn" onclick="startGame()">Start</button>
                <button class="btn" id="pauseBtn" onclick="pauseGame()" disabled>Pause</button>
                <button class="btn" id="resetBtn" onclick="resetGame()">Reset</button>
                <button class="btn" id="aiModeBtn" onclick="toggleAIMode()">AI Mode: OFF</button>
            </div>

            <div class="panel">
                <h3 data-i18n="difficultyLevel">DIFFICULTY LEVEL</h3>
                <select id="difficultySelector" onchange="changeDifficulty()" class="difficulty-selector">
                    <option value="easy">ğŸŸ¢ Easy</option>
                    <option value="normal" selected>ğŸŸ¡ Normal</option>
                    <option value="hard">ğŸŸ  Hard</option>
                    <option value="expert">ğŸ”´ Expert</option>
                    <option value="quantum">âš¡ Quantum</option>
                </select>
                <div class="difficulty-info" id="difficultyInfo">
                    <div class="difficulty-stat">
                        <span>Vitesse:</span>
                        <span class="difficulty-value" id="speedValue">Normal</span>
                    </div>
                    <div class="difficulty-stat">
                        <span>Obstacles:</span>
                        <span class="difficulty-value" id="obstaclesValue">Aucun</span>
                    </div>
                    <div class="difficulty-stat">
                        <span>Bonus:</span>
                        <span class="difficulty-value" id="bonusValue">x1</span>
                    </div>
                </div>
            </div>

            <div class="stats-display">
                <h3 data-i18n="statistics">STATISTICS</h3>
                <div class="stat-item">
                    <span>Score:</span>
                    <span class="stat-value" id="scoreValue">0</span>
                </div>
                <div class="stat-item">
                    <span>Lines:</span>
                    <span class="stat-value" id="linesValue">0</span>
                </div>
                <div class="stat-item">
                    <span>Level:</span>
                    <span class="stat-value" id="levelValue">1</span>
                </div>
                <div class="stat-item">
                    <span>Pieces:</span>
                    <span class="stat-value" id="piecesValue">0</span>
                </div>
                <div class="level-bar">
                    <div class="level-fill" id="levelFill" style="width: 0%"></div>
                </div>
            </div>



            <div class="controls-info">
                <h3 data-i18n="controls">CONTROLS</h3>
                <div>
                    <span class="control-key">â†â†’</span> Move<br>
                    <span class="control-key">â†“</span> Down<br>
                    <span class="control-key">â†‘</span> Up<br>
                    <span class="control-key">R</span> Rotate<br>
                    <span class="control-key">ESPACE</span> Hard Drop<br>
                    <span class="control-key">P</span> Pause
                </div>
            </div>
        </div>

        <div class="tetris-container">
            <div class="game-status" id="gameStatus">Press Start to begin</div>
            
            <div class="game-board">
                <div class="quantum-effects" id="quantumEffects"></div>
                <div class="tetris-grid" id="tetrisGrid"></div>
            </div>
        </div>

        <div class="side-panel">
            <div class="panel">
                <h3 data-i18n="nextPiece">NEXT PIECE</h3>
                <div class="next-piece-panel" id="nextPiecePanel"></div>
            </div>



            <div class="stats-display">
                <h3 data-i18n="aiAnalysis">AI ANALYSIS</h3>
                <div class="stat-item">
                    <span data-i18n="efficiency">EfficacitÃ© :</span>
                    <span class="stat-value" id="efficiencyValue">0%</span>
                </div>
                <div class="stat-item">
                    <span data-i18n="prediction">PrÃ©diction :</span>
                    <span class="stat-value" id="predictionValue">-</span>
                </div>
                <div class="stat-item">
                    <span data-i18n="holes">Trous :</span>
                    <span class="stat-value" id="holesValue">0</span>
                </div>
                <div class="stat-item">
                    <span data-i18n="height">Hauteur :</span>
                    <span class="stat-value" id="heightValue">0</span>
                </div>
            </div>

            <div class="ai-panel">
                <h3 data-i18n="aiAssistant">QUANTUM AI ASSISTANT</h3>
                <button class="btn" id="aiHintBtn" onclick="getAIHint()" style="background: linear-gradient(45deg, #00ff00, #00cc00);">AI Hint</button>
                <button class="btn" id="aiAnalyzeBtn" onclick="analyzeBoard()" style="background: linear-gradient(45deg, #ff00ff, #cc00cc);">Analyze</button>
                <div class="ai-suggestion" id="aiSuggestion">AI ready to analyze the board</div>
            </div>

            <div class="panel">
                <h3 data-i18n="strategies">AI STRATEGIES</h3>
                <button class="btn" data-i18n="tetrisStrategy" onclick="applyStrategy('tetris')" style="font-size: 11px;">Aim Tetris</button>
                <button class="btn" data-i18n="clearStrategy" onclick="applyStrategy('clear')" style="font-size: 11px;">Clear</button>
                <button class="btn" data-i18n="stackStrategy" onclick="applyStrategy('stack')" style="font-size: 11px;">Stack</button>
                <button class="btn" data-i18n="surviveStrategy" onclick="applyStrategy('survive')" style="font-size: 11px;">Survive</button>
            </div>

            <div class="stats-display">
                <h3 data-i18n="records">RECORDS</h3>
                <div class="stat-item">
                    <span>Best Score:</span>
                    <span class="stat-value" id="bestScoreValue">0</span>
                </div>
                <div class="stat-item">
                    <span>Max Lines:</span>
                    <span class="stat-value" id="bestLinesValue">0</span>
                </div>
                <div class="stat-item">
                    <span>Max Level:</span>
                    <span class="stat-value" id="bestLevelValue">1</span>
                </div>
                <div class="stat-item">
                    <span>Total Time:</span>
                    <span class="stat-value" id="totalTimeValue">0:00</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Variables du jeu
        const BOARD_WIDTH = 10;
        const BOARD_HEIGHT = 16;
        let board = Array(BOARD_HEIGHT).fill().map(() => Array(BOARD_WIDTH).fill(0));
        let currentPiece = null;
        let nextPiece = null;

        let gameRunning = false;
        let gamePaused = false;
        let aiMode = false;
        let gameLoop = null;
        let dropInterval = 1000;
        
        // SystÃ¨me de difficultÃ©
        let currentDifficulty = 'normal';
        let difficultySettings = {
            easy: {
                baseSpeed: 1500,
                speedIncrease: 30,
                obstacles: false,
                scoreMultiplier: 0.8,
                quantumEffects: false,
                ghostPieces: false
            },
            normal: {
                baseSpeed: 1000,
                speedIncrease: 50,
                obstacles: false,
                scoreMultiplier: 1.0,
                quantumEffects: false,
                ghostPieces: false
            },
            hard: {
                baseSpeed: 700,
                speedIncrease: 70,
                obstacles: true,
                scoreMultiplier: 1.3,
                quantumEffects: false,
                ghostPieces: true
            },
            expert: {
                baseSpeed: 400,
                speedIncrease: 100,
                obstacles: true,
                scoreMultiplier: 1.8,
                quantumEffects: true,
                ghostPieces: true
            },
            quantum: {
                baseSpeed: 200,
                speedIncrease: 150,
                obstacles: true,
                scoreMultiplier: 2.5,
                quantumEffects: true,
                ghostPieces: true
            }
        };
        
        // Statistiques
        let score = 0;
        let lines = 0;
        let level = 1;
        let pieces = 0;
        let gameStartTime = 0;
        
        // Records
        let bestScore = localStorage.getItem('tetris-best-score') || 0;
        let bestLines = localStorage.getItem('tetris-best-lines') || 0;
        let bestLevel = localStorage.getItem('tetris-best-level') || 1;
        let totalTime = localStorage.getItem('tetris-total-time') || 0;

    // SystÃ¨me de traduction
    // Prefer the platform-wide key 'brainovaLang' when available; fallback to the local key.
    let currentLanguage = localStorage.getItem('brainovaLang') || localStorage.getItem('tetris-language') || 'en';
        
        const translations = {
            fr: {
                title: "TETRIS QUANTUM AI 2077",
                subtitle: "INTERFACE NEURALE DE PLACEMENT ACTIVÃ‰E",
                quantumControls: "CONTRÃ”LES QUANTIQUES",
                start: "DÃ©marrer",
                pause: "Pause",
                resume: "Reprendre",
                reset: "Reset",
                aiMode: "Mode IA",
                statistics: "STATISTIQUES",
                score: "Score:",
                lines: "Lignes:",
                level: "Niveau:",
                pieces: "PiÃ¨ces:",
                nextPiece: "PROCHAINE PIÃˆCE",

                controls: "CONTRÃ”LES",
                move: "DÃ©placer",
                down: "Descendre",
                up: "Monter",
                fastDown: "Descente rapide",
                fastUp: "MontÃ©e rapide",
                rotate: "Rotation",
                drop: "Chute libre",
                pauseKey: "Pause",
                aiAssistant: "ASSISTANT IA QUANTIQUE",
                aiHint: "Conseil IA",
                analyze: "Analyser",
                aiReady: "IA prÃªte Ã  analyser le plateau",
                aiAnalysis: "ANALYSE IA",
                efficiency: "EfficacitÃ©:",
                prediction: "PrÃ©diction:",
                holes: "Trous:",
                height: "Hauteur:",
                strategies: "STRATÃ‰GIES IA",
                tetrisStrategy: "Viser Tetris",
                clearStrategy: "Nettoyer",
                stackStrategy: "Empiler",
                surviveStrategy: "Survivre",
                records: "RECORDS",
                bestScore: "Meilleur Score:",
                maxLines: "Max Lignes:",
                maxLevel: "Max Niveau:",
                totalTime: "Temps Total:",
                startMessage: "Appuyez sur DÃ©marrer pour commencer",
                gameRunning: "Jeu en cours...",
                gamePaused: "Jeu en pause",
                gameOver: "Game Over! Score:",
                noPiece: "Aucune piÃ¨ce active",
                startToAnalyze: "DÃ©marrez une partie pour analyser",
                startToUseStrategies: "DÃ©marrez une partie pour utiliser les stratÃ©gies",
                newRecord: "ğŸ† Nouveau record Ã©tabli!",
                confirmQuit: "Voulez-vous vraiment quitter le jeu et retourner Ã  l'accueil ?",
                backToHome: "Retour Ã  l'accueil de la plateforme",
                difficultyLevel: "NIVEAU DE DIFFICULTÃ‰",
                easy: "ğŸŸ¢ Facile",
                normal: "ğŸŸ¡ Normal", 
                hard: "ğŸŸ  Difficile",
                expert: "ğŸ”´ Expert",
                quantum: "âš¡ Quantique",
                speed: "Vitesse:",
                obstacles: "Obstacles:",
                bonus: "Bonus:",
                none: "Aucun",
                few: "Quelques",
                many: "Nombreux",
                extreme: "ExtrÃªme",
                slow: "Lente",
                fast: "Rapide",
                veryFast: "TrÃ¨s rapide",
                insane: "Folle"
            },
            en: {
                title: "TETRIS QUANTUM AI 2077",
                subtitle: "NEURAL PLACEMENT INTERFACE ACTIVATED",
                quantumControls: "QUANTUM CONTROLS",
                start: "Start",
                pause: "Pause",
                resume: "Resume",
                reset: "Reset",
                aiMode: "AI Mode",
                statistics: "STATISTICS",
                score: "Score:",
                lines: "Lines:",
                level: "Level:",
                pieces: "Pieces:",
                nextPiece: "NEXT PIECE",

                controls: "CONTROLS",
                move: "Move",
                down: "Down",
                up: "Up",
                fastDown: "Fast Down",
                fastUp: "Fast Up",
                rotate: "Rotate",
                drop: "Hard Drop",
                pauseKey: "Pause",
                aiAssistant: "QUANTUM AI ASSISTANT",
                aiHint: "AI Hint",
                analyze: "Analyze",
                aiReady: "AI ready to analyze the board",
                aiAnalysis: "AI ANALYSIS",
                efficiency: "Efficiency:",
                prediction: "Prediction:",
                holes: "Holes:",
                height: "Height:",
                strategies: "AI STRATEGIES",
                tetrisStrategy: "Aim Tetris",
                clearStrategy: "Clear",
                stackStrategy: "Stack",
                surviveStrategy: "Survive",
                records: "RECORDS",
                bestScore: "Best Score:",
                maxLines: "Max Lines:",
                maxLevel: "Max Level:",
                totalTime: "Total Time:",
                startMessage: "Press Start to begin",
                gameRunning: "Game running...",
                gamePaused: "Game paused",
                gameOver: "Game Over! Score:",
                noPiece: "No active piece",
                startToAnalyze: "Start a game to analyze",
                startToUseStrategies: "Start a game to use strategies",
                newRecord: "ğŸ† New record achieved!",
                confirmQuit: "Do you really want to quit the game and return to home?",
                backToHome: "Back to platform home",
                difficultyLevel: "DIFFICULTY LEVEL",
                easy: "ğŸŸ¢ Easy",
                normal: "ğŸŸ¡ Normal",
                hard: "ğŸŸ  Hard", 
                expert: "ğŸ”´ Expert",
                quantum: "âš¡ Quantum",
                speed: "Speed:",
                obstacles: "Obstacles:",
                bonus: "Bonus:",
                none: "None",
                few: "Few",
                many: "Many",
                extreme: "Extreme",
                slow: "Slow",
                fast: "Fast",
                veryFast: "Very Fast",
                insane: "Insane"
            },
            ar: {
                title: "ØªÙŠØªØ±ÙŠØ³ Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ø§Ù„ÙƒÙ…ÙŠ 2077",
                subtitle: "ØªÙ… ØªÙØ¹ÙŠÙ„ ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ø¹ØµØ¨ÙŠ",
                quantumControls: "Ø§Ù„ØªØ­ÙƒÙ… Ø§Ù„ÙƒÙ…ÙŠ",
                start: "Ø§Ø¨Ø¯Ø£",
                pause: "ØªÙˆÙ‚Ù",
                resume: "Ø§Ø³ØªØ¦Ù†Ø§Ù",
                reset: "Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ†",
                aiMode: "ÙˆØ¶Ø¹ Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ",
                statistics: "Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª",
                score: "Ø§Ù„Ù†Ù‚Ø§Ø·:",
                lines: "Ø§Ù„Ø®Ø·ÙˆØ·:",
                level: "Ø§Ù„Ù…Ø³ØªÙˆÙ‰:",
                pieces: "Ø§Ù„Ù‚Ø·Ø¹:",
                nextPiece: "Ø§Ù„Ù‚Ø·Ø¹Ø© Ø§Ù„ØªØ§Ù„ÙŠØ©",

                controls: "Ø§Ù„ØªØ­ÙƒÙ…",
                move: "ØªØ­Ø±Ùƒ",
                down: "Ø£Ø³ÙÙ„",
                up: "Ø£Ø¹Ù„Ù‰",
                fastDown: "Ù†Ø²ÙˆÙ„ Ø³Ø±ÙŠØ¹",
                fastUp: "ØµØ¹ÙˆØ¯ Ø³Ø±ÙŠØ¹",
                rotate: "Ø¯ÙˆØ±Ø§Ù†",
                drop: "Ø³Ù‚ÙˆØ· Ø³Ø±ÙŠØ¹",
                pauseKey: "ØªÙˆÙ‚Ù",
                aiAssistant: "Ù…Ø³Ø§Ø¹Ø¯ Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ø§Ù„ÙƒÙ…ÙŠ",
                aiHint: "Ù†ØµÙŠØ­Ø© Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ",
                analyze: "ØªØ­Ù„ÙŠÙ„",
                aiReady: "Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ø¬Ø§Ù‡Ø² Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù„ÙˆØ­Ø©",
                aiAnalysis: "ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ",
                efficiency: "Ø§Ù„ÙƒÙØ§Ø¡Ø©:",
                prediction: "Ø§Ù„ØªÙ†Ø¨Ø¤:",
                holes: "Ø§Ù„Ø«Ù‚ÙˆØ¨:",
                height: "Ø§Ù„Ø§Ø±ØªÙØ§Ø¹:",
                strategies: "Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ§Øª Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ",
                tetrisStrategy: "Ø§Ø³ØªÙ‡Ø¯Ø§Ù ØªÙŠØªØ±ÙŠØ³",
                clearStrategy: "ØªÙ†Ø¸ÙŠÙ",
                stackStrategy: "ØªÙƒØ¯ÙŠØ³",
                surviveStrategy: "Ø§Ù„Ø¨Ù‚Ø§Ø¡",
                records: "Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ù‚ÙŠØ§Ø³ÙŠØ©",
                bestScore: "Ø£ÙØ¶Ù„ Ù†Ù‚Ø§Ø·:",
                maxLines: "Ø£Ù‚ØµÙ‰ Ø®Ø·ÙˆØ·:",
                maxLevel: "Ø£Ù‚ØµÙ‰ Ù…Ø³ØªÙˆÙ‰:",
                totalTime: "Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ:",
                startMessage: "Ø§Ø¶ØºØ· Ø§Ø¨Ø¯Ø£ Ù„Ù„Ø¨Ø¯Ø¡",
                gameRunning: "Ø§Ù„Ù„Ø¹Ø¨Ø© Ù‚ÙŠØ¯ Ø§Ù„ØªØ´ØºÙŠÙ„...",
                gamePaused: "Ø§Ù„Ù„Ø¹Ø¨Ø© Ù…ØªÙˆÙ‚ÙØ©",
                gameOver: "Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù„Ø¹Ø¨Ø©! Ø§Ù„Ù†Ù‚Ø§Ø·:",
                noPiece: "Ù„Ø§ ØªÙˆØ¬Ø¯ Ù‚Ø·Ø¹Ø© Ù†Ø´Ø·Ø©",
                startToAnalyze: "Ø§Ø¨Ø¯Ø£ Ù„Ø¹Ø¨Ø© Ù„Ù„ØªØ­Ù„ÙŠÙ„",
                startToUseStrategies: "Ø§Ø¨Ø¯Ø£ Ù„Ø¹Ø¨Ø© Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ§Øª",
                newRecord: "ğŸ† ØªÙ… ØªØ­Ù‚ÙŠÙ‚ Ø±Ù‚Ù… Ù‚ÙŠØ§Ø³ÙŠ Ø¬Ø¯ÙŠØ¯!",
                confirmQuit: "Ù‡Ù„ ØªØ±ÙŠØ¯ Ø­Ù‚Ø§Ù‹ Ø§Ù„Ø®Ø±ÙˆØ¬ Ù…Ù† Ø§Ù„Ù„Ø¹Ø¨Ø© ÙˆØ§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ø±Ø¦ÙŠØ³ÙŠØ©ØŸ",
                backToHome: "Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ø±Ø¦ÙŠØ³ÙŠØ© Ø§Ù„Ù…Ù†ØµØ©"
            },
            es: {
                title: "TETRIS QUANTUM AI 2077",
                subtitle: "INTERFAZ NEURAL DE COLOCACIÃ“N ACTIVADA",
                quantumControls: "CONTROLES CUÃNTICOS",
                start: "Iniciar",
                pause: "Pausa",
                resume: "Reanudar",
                reset: "Reiniciar",
                aiMode: "Modo IA",
                statistics: "ESTADÃSTICAS",
                score: "PuntuaciÃ³n:",
                lines: "LÃ­neas:",
                level: "Nivel:",
                pieces: "Piezas:",
                nextPiece: "SIGUIENTE PIEZA",

                controls: "CONTROLES",
                move: "Mover",
                down: "Abajo",
                up: "Arriba",
                fastDown: "Bajada rÃ¡pida",
                fastUp: "Subida rÃ¡pida",
                rotate: "Rotar",
                drop: "CaÃ­da rÃ¡pida",
                pauseKey: "Pausa",
                aiAssistant: "ASISTENTE IA CUÃNTICO",
                aiHint: "Consejo IA",
                analyze: "Analizar",
                aiReady: "IA lista para analizar el tablero",
                aiAnalysis: "ANÃLISIS IA",
                efficiency: "Eficiencia:",
                prediction: "PredicciÃ³n:",
                holes: "Agujeros:",
                height: "Altura:",
                strategies: "ESTRATEGIAS IA",
                tetrisStrategy: "Apuntar Tetris",
                clearStrategy: "Limpiar",
                stackStrategy: "Apilar",
                surviveStrategy: "Sobrevivir",
                records: "RÃ‰CORDS",
                bestScore: "Mejor PuntuaciÃ³n:",
                maxLines: "MÃ¡x LÃ­neas:",
                maxLevel: "MÃ¡x Nivel:",
                totalTime: "Tiempo Total:",
                startMessage: "Presiona Iniciar para comenzar",
                gameRunning: "Juego en curso...",
                gamePaused: "Juego pausado",
                gameOver: "Â¡Juego Terminado! PuntuaciÃ³n:",
                noPiece: "No hay pieza activa",
                startToAnalyze: "Inicia un juego para analizar",
                startToUseStrategies: "Inicia un juego para usar estrategias",
                newRecord: "ğŸ† Â¡Nuevo rÃ©cord logrado!",
                confirmQuit: "Â¿Realmente quieres salir del juego y volver al inicio?",
                backToHome: "Volver al inicio de la plataforma"
            },
            de: {
                title: "TETRIS QUANTUM AI 2077",
                subtitle: "NEURALE PLATZIERUNGSSCHNITTSTELLE AKTIVIERT",
                quantumControls: "QUANTENSTEUERUNG",
                start: "Starten",
                pause: "Pause",
                resume: "Fortsetzen",
                reset: "ZurÃ¼cksetzen",
                aiMode: "KI-Modus",
                statistics: "STATISTIKEN",
                score: "Punkte:",
                lines: "Linien:",
                level: "Level:",
                pieces: "Teile:",
                nextPiece: "NÃ„CHSTES TEIL",

                controls: "STEUERUNG",
                move: "Bewegen",
                down: "Runter",
                up: "Hoch",
                fastDown: "Schnell runter",
                fastUp: "Schnell hoch",
                rotate: "Drehen",
                drop: "Schneller Fall",
                pauseKey: "Pause",
                aiAssistant: "QUANTEN-KI-ASSISTENT",
                aiHint: "KI-Tipp",
                analyze: "Analysieren",
                aiReady: "KI bereit zur Brett-Analyse",
                aiAnalysis: "KI-ANALYSE",
                efficiency: "Effizienz:",
                prediction: "Vorhersage:",
                holes: "LÃ¶cher:",
                height: "HÃ¶he:",
                strategies: "KI-STRATEGIEN",
                tetrisStrategy: "Tetris anvisieren",
                clearStrategy: "RÃ¤umen",
                stackStrategy: "Stapeln",
                surviveStrategy: "Ãœberleben",
                records: "REKORDE",
                bestScore: "Beste Punkte:",
                maxLines: "Max Linien:",
                maxLevel: "Max Level:",
                totalTime: "Gesamtzeit:",
                startMessage: "DrÃ¼cke Starten zum Beginnen",
                gameRunning: "Spiel lÃ¤uft...",
                gamePaused: "Spiel pausiert",
                gameOver: "Spiel Vorbei! Punkte:",
                noPiece: "Kein aktives Teil",
                startToAnalyze: "Starte ein Spiel zur Analyse",
                startToUseStrategies: "Starte ein Spiel fÃ¼r Strategien",
                newRecord: "ğŸ† Neuer Rekord erreicht!",
                confirmQuit: "Willst du wirklich das Spiel verlassen und zur Startseite zurÃ¼ckkehren?",
                backToHome: "ZurÃ¼ck zur Plattform-Startseite"
            },
            zh: {
                title: "ä¿„ç½—æ–¯æ–¹å—é‡å­AI 2077",
                subtitle: "ç¥ç»æ”¾ç½®ç•Œé¢å·²æ¿€æ´»",
                quantumControls: "é‡å­æ§åˆ¶",
                start: "å¼€å§‹",
                pause: "æš‚åœ",
                resume: "ç»§ç»­",
                reset: "é‡ç½®",
                aiMode: "AIæ¨¡å¼",
                statistics: "ç»Ÿè®¡",
                score: "åˆ†æ•°:",
                lines: "è¡Œæ•°:",
                level: "ç­‰çº§:",
                pieces: "æ–¹å—:",
                nextPiece: "ä¸‹ä¸€ä¸ªæ–¹å—",
                controls: "æ§åˆ¶",
                move: "ç§»åŠ¨",
                down: "ä¸‹é™",
                up: "ä¸Šå‡",
                fastDown: "å¿«é€Ÿä¸‹é™",
                fastUp: "å¿«é€Ÿä¸Šå‡",
                rotate: "æ—‹è½¬",
                drop: "ç¬é—´ä¸‹é™",
                pauseKey: "æš‚åœ",
                aiAssistant: "é‡å­AIåŠ©æ‰‹",
                aiHint: "AIæç¤º",
                analyze: "åˆ†æ",
                aiReady: "AIå‡†å¤‡åˆ†ææ£‹ç›˜",
                aiAnalysis: "AIåˆ†æ",
                efficiency: "æ•ˆç‡:",
                prediction: "é¢„æµ‹:",
                holes: "ç©ºæ´:",
                height: "é«˜åº¦:",
                strategies: "AIç­–ç•¥",
                tetrisStrategy: "ç„å‡†ä¿„ç½—æ–¯æ–¹å—",
                clearStrategy: "æ¸…é™¤",
                stackStrategy: "å †å ",
                surviveStrategy: "ç”Ÿå­˜",
                records: "è®°å½•",
                bestScore: "æœ€é«˜åˆ†:",
                maxLines: "æœ€å¤šè¡Œ:",
                maxLevel: "æœ€é«˜ç­‰çº§:",
                totalTime: "æ€»æ—¶é—´:",
                startMessage: "æŒ‰å¼€å§‹é”®å¼€å§‹æ¸¸æˆ",
                gameRunning: "æ¸¸æˆè¿›è¡Œä¸­...",
                gamePaused: "æ¸¸æˆå·²æš‚åœ",
                gameOver: "æ¸¸æˆç»“æŸï¼åˆ†æ•°:",
                noPiece: "æ²¡æœ‰æ´»åŠ¨æ–¹å—",
                startToAnalyze: "å¼€å§‹æ¸¸æˆè¿›è¡Œåˆ†æ",
                startToUseStrategies: "å¼€å§‹æ¸¸æˆä½¿ç”¨ç­–ç•¥",
                newRecord: "ğŸ† æ–°è®°å½•è¾¾æˆï¼",
                confirmQuit: "ä½ çœŸçš„æƒ³é€€å‡ºæ¸¸æˆå¹¶è¿”å›ä¸»é¡µå—ï¼Ÿ",
                backToHome: "è¿”å›å¹³å°ä¸»é¡µ"
            }
        };

        // DÃ©finition des piÃ¨ces Tetris
        const PIECES = {
            I: {
                shape: [
                    [1, 1, 1, 1]
                ],
                color: 'piece-I'
            },
            O: {
                shape: [
                    [1, 1],
                    [1, 1]
                ],
                color: 'piece-O'
            },
            T: {
                shape: [
                    [0, 1, 0],
                    [1, 1, 1]
                ],
                color: 'piece-T'
            },
            S: {
                shape: [
                    [0, 1, 1],
                    [1, 1, 0]
                ],
                color: 'piece-S'
            },
            Z: {
                shape: [
                    [1, 1, 0],
                    [0, 1, 1]
                ],
                color: 'piece-Z'
            },
            J: {
                shape: [
                    [1, 0, 0],
                    [1, 1, 1]
                ],
                color: 'piece-J'
            },
            L: {
                shape: [
                    [0, 0, 1],
                    [1, 1, 1]
                ],
                color: 'piece-L'
            }
        };

        const PIECE_TYPES = Object.keys(PIECES);

        // Initialisation
        function init() {
            createNeuralGrid();
            createQuantumEffects();
            createTetrisGrid();
            createNextPieceGrid();
            // ensure the next-piece preview shows immediately (even before the first Start)
            try { nextPiece = generatePiece(); } catch (e) { nextPiece = null; }

            setupEventListeners();
            updateDisplay();
            loadRecords();
        }

        function createNeuralGrid() {
            const neuralGrid = document.getElementById('neuralGrid');
            for (let i = 0; i < 50; i++) {
                const line = document.createElement('div');
                line.className = 'neural-line';
                line.style.top = Math.random() * 100 + '%';
                line.style.width = '400px';
                line.style.animationDelay = Math.random() * 6 + 's';
                neuralGrid.appendChild(line);
            }
        }

        function createQuantumEffects() {
            const effectsContainer = document.getElementById('quantumEffects');
            for (let i = 0; i < 20; i++) {
                const particle = document.createElement('div');
                particle.className = 'quantum-particle';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.top = Math.random() * 100 + '%';
                particle.style.animationDelay = Math.random() * 4 + 's';
                effectsContainer.appendChild(particle);
            }
        }

        function createTetrisGrid() {
            const grid = document.getElementById('tetrisGrid');
            grid.innerHTML = '';
            
            for (let row = 0; row < BOARD_HEIGHT; row++) {
                for (let col = 0; col < BOARD_WIDTH; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'tetris-cell';
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    grid.appendChild(cell);
                }
            }
        }

        function createNextPieceGrid() {
            const grid = document.getElementById('nextPiecePanel');
            grid.innerHTML = '';
            
            for (let i = 0; i < 16; i++) {
                const cell = document.createElement('div');
                cell.className = 'next-cell';
                grid.appendChild(cell);
            }
        }



        function setupEventListeners() {
            document.addEventListener('keydown', handleKeyPress);
        }

        function handleKeyPress(e) {
            if (!gameRunning || gamePaused || !currentPiece) return;
            
            switch(e.code) {
                case 'ArrowLeft':
                    e.preventDefault();
                    movePiece(-1, 0);
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    movePiece(1, 0);
                    break;
                case 'ArrowDown':
                    e.preventDefault();
                    movePiece(0, 1); // Descendre normalement
                    break;
                case 'ArrowUp':
                    e.preventDefault();
                    movePiece(0, -1); // Monter la piÃ¨ce
                    break;
                case 'KeyR':
                    e.preventDefault();
                    rotatePiece(); // Rotation avec R
                    break;
                case 'Space':
                    e.preventDefault();
                    hardDrop(); // Chute libre instantanÃ©e
                    break;
                case 'KeyS':
                    e.preventDefault();
                    softDrop(); // Descente rapide mais contrÃ´lÃ©e
                    break;
                case 'KeyW':
                    e.preventDefault();
                    fastUp(); // MontÃ©e rapide
                    break;
                case 'KeyP':
                    e.preventDefault();
                    pauseGame();
                    break;
            }
        }

        function generatePiece() {
            const type = PIECE_TYPES[Math.floor(Math.random() * PIECE_TYPES.length)];
            return {
                type: type,
                shape: PIECES[type].shape,
                color: PIECES[type].color,
                x: Math.floor(BOARD_WIDTH / 2) - Math.floor(PIECES[type].shape[0].length / 2),
                y: 0
            };
        }

        function changeDifficulty() {
            if (gameRunning) return; // Ne pas changer pendant le jeu
            
            const selector = document.getElementById('difficultySelector');
            currentDifficulty = selector.value;
            localStorage.setItem('tetris-difficulty', currentDifficulty);
            
            // Mettre Ã  jour l'affichage des informations de difficultÃ©
            updateDifficultyDisplay();
            
            // Appliquer les paramÃ¨tres de difficultÃ©
            const settings = difficultySettings[currentDifficulty];
            dropInterval = settings.baseSpeed;
        }

        function updateDifficultyDisplay() {
            const t = translations[currentLanguage];
            const settings = difficultySettings[currentDifficulty];
            
            // Mettre Ã  jour la vitesse
            let speedText = t.slow;
            if (settings.baseSpeed <= 200) speedText = t.insane;
            else if (settings.baseSpeed <= 400) speedText = t.veryFast;
            else if (settings.baseSpeed <= 700) speedText = t.fast;
            else if (settings.baseSpeed <= 1000) speedText = t.normal;
            
            document.getElementById('speedValue').textContent = speedText;
            
            // Mettre Ã  jour les obstacles
            let obstacleText = t.none;
            if (currentDifficulty === 'hard') obstacleText = t.few;
            else if (currentDifficulty === 'expert') obstacleText = t.many;
            else if (currentDifficulty === 'quantum') obstacleText = t.extreme;
            
            document.getElementById('obstaclesValue').textContent = obstacleText;
            
            // Mettre Ã  jour le bonus
            document.getElementById('bonusValue').textContent = 'x' + settings.scoreMultiplier;
        }

        function addObstacles() {
            if (!difficultySettings[currentDifficulty].obstacles) return;
            
            const obstacleCount = {
                hard: 3,
                expert: 6,
                quantum: 10
            }[currentDifficulty] || 0;
            
            for (let i = 0; i < obstacleCount; i++) {
                const row = Math.floor(Math.random() * (BOARD_HEIGHT - 5)) + 5; // Obstacles dans la partie basse
                const col = Math.floor(Math.random() * BOARD_WIDTH);
                
                if (board[row][col] === 0) {
                    board[row][col] = 'obstacle';
                }
            }
        }

        function startGame() {
            if (gameRunning) return;
            
            gameRunning = true;
            gamePaused = false;
            gameStartTime = Date.now();
            const t = translations[currentLanguage];
            
            // RÃ©initialiser le plateau
            board = Array(BOARD_HEIGHT).fill().map(() => Array(BOARD_WIDTH).fill(0));
            
            // Ajouter des obstacles selon la difficultÃ©
            addObstacles();
            
            // Appliquer les paramÃ¨tres de difficultÃ©
            const settings = difficultySettings[currentDifficulty];
            dropInterval = settings.baseSpeed;
            
            // GÃ©nÃ©rer les piÃ¨ces
            currentPiece = generatePiece();
            nextPiece = generatePiece();
            
            // DÃ©marrer la boucle de jeu
            gameLoop = setInterval(gameStep, dropInterval);
            
            // Mettre Ã  jour l'interface
            document.getElementById('startBtn').disabled = true;
            document.getElementById('pauseBtn').disabled = false;
            document.getElementById('gameStatus').textContent = t.gameRunning;
            document.getElementById('difficultySelector').disabled = true;
            
            updateDisplay();
        }

        function pauseGame() {
            if (!gameRunning) return;
            
            gamePaused = !gamePaused;
            const t = translations[currentLanguage];
            
            if (gamePaused) {
                clearInterval(gameLoop);
                document.getElementById('gameStatus').textContent = t.gamePaused;
                document.getElementById('gameStatus').className = 'game-status paused';
                document.getElementById('pauseBtn').textContent = t.resume;
            } else {
                gameLoop = setInterval(gameStep, dropInterval);
                document.getElementById('gameStatus').textContent = t.gameRunning;
                document.getElementById('gameStatus').className = 'game-status';
                document.getElementById('pauseBtn').textContent = t.pause;
            }
        }

        function resetGame() {
            gameRunning = false;
            gamePaused = false;
            const t = translations[currentLanguage];
            
            if (gameLoop) {
                clearInterval(gameLoop);
            }
            
            // RÃ©initialiser les statistiques
            score = 0;
            lines = 0;
            level = 1;
            pieces = 0;
            dropInterval = difficultySettings[currentDifficulty].baseSpeed;
            
            // RÃ©initialiser le plateau
            board = Array(BOARD_HEIGHT).fill().map(() => Array(BOARD_WIDTH).fill(0));
            currentPiece = null;
            // ensure a next piece is available so the preview isn't empty after reset
            try { nextPiece = generatePiece(); } catch (e) { nextPiece = null; }
            
            // Mettre Ã  jour l'interface
            document.getElementById('startBtn').disabled = false;
            document.getElementById('pauseBtn').disabled = true;
            document.getElementById('pauseBtn').textContent = t.pause;
            document.getElementById('gameStatus').textContent = t.startMessage;
            document.getElementById('gameStatus').className = 'game-status';
            document.getElementById('difficultySelector').disabled = false;
            
            updateDisplay();
        }

        function gameStep() {
            if (!currentPiece) return;
            
            // Mode IA automatique
            if (aiMode) {
                performAIMove();
            }
            
            // Appliquer les effets quantiques
            applyQuantumEffects();
            
            // Faire descendre la piÃ¨ce
            if (!movePiece(0, 1)) {
                // La piÃ¨ce ne peut plus descendre
                placePiece();
                clearLines();
                
                // GÃ©nÃ©rer une nouvelle piÃ¨ce
                currentPiece = nextPiece;
                nextPiece = generatePiece();
                pieces++;
                
                // VÃ©rifier si le jeu est terminÃ©
                if (checkGameOver()) {
                    endGame();
                    return;
                }
            }
            
            updateDisplay();
        }

        function movePiece(dx, dy) {
            if (!currentPiece) return false;
            
            const newX = currentPiece.x + dx;
            const newY = currentPiece.y + dy;
            
            if (isValidPosition(currentPiece.shape, newX, newY)) {
                currentPiece.x = newX;
                currentPiece.y = newY;
                return true;
            }
            
            return false;
        }

        function rotatePiece() {
            if (!currentPiece) return;
            
            const rotated = rotateMatrix(currentPiece.shape);
            
            if (isValidPosition(rotated, currentPiece.x, currentPiece.y)) {
                currentPiece.shape = rotated;
            }
        }

        function rotateMatrix(matrix) {
            const rows = matrix.length;
            const cols = matrix[0].length;
            const rotated = Array(cols).fill().map(() => Array(rows).fill(0));
            
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    rotated[col][rows - 1 - row] = matrix[row][col];
                }
            }
            
            return rotated;
        }

        function hardDrop() {
            if (!currentPiece) return;
            
            while (movePiece(0, 1)) {
                // Continue Ã  descendre jusqu'au bas
            }
        }

        function softDrop() {
            if (!currentPiece) return;
            
            // Descente rapide de 3 cases
            for (let i = 0; i < 3; i++) {
                if (!movePiece(0, 1)) break;
            }
        }

        function fastUp() {
            if (!currentPiece) return;
            
            // MontÃ©e rapide de 3 cases
            for (let i = 0; i < 3; i++) {
                if (!movePiece(0, -1)) break;
            }
        }

        function isValidPosition(shape, x, y) {
            for (let row = 0; row < shape.length; row++) {
                for (let col = 0; col < shape[row].length; col++) {
                    if (shape[row][col]) {
                        const newX = x + col;
                        const newY = y + row;
                        
                        if (newX < 0 || newX >= BOARD_WIDTH || 
                            newY >= BOARD_HEIGHT || 
                            (newY >= 0 && board[newY][newX])) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }

        function applyQuantumEffects() {
            if (!difficultySettings[currentDifficulty].quantumEffects) return;
            
            // Effet quantique : tÃ©lÃ©portation alÃ©atoire de la piÃ¨ce
            if (Math.random() < 0.05) { // 5% de chance
                const newX = Math.floor(Math.random() * (BOARD_WIDTH - 3));
                if (isValidPosition(currentPiece.shape, newX, currentPiece.y)) {
                    currentPiece.x = newX;
                    
                    // Effet visuel
                    const gameBoard = document.querySelector('.game-board');
                    gameBoard.classList.add('quantum-effect');
                    setTimeout(() => {
                        gameBoard.classList.remove('quantum-effect');
                    }, 500);
                }
            }
            
            // Effet quantique : rotation spontanÃ©e
            if (Math.random() < 0.03) { // 3% de chance
                const rotated = rotateMatrix(currentPiece.shape);
                if (isValidPosition(rotated, currentPiece.x, currentPiece.y)) {
                    currentPiece.shape = rotated;
                }
            }
        }

        function placePiece() {
            if (!currentPiece) return;
            
            for (let row = 0; row < currentPiece.shape.length; row++) {
                for (let col = 0; col < currentPiece.shape[row].length; col++) {
                    if (currentPiece.shape[row][col]) {
                        const x = currentPiece.x + col;
                        const y = currentPiece.y + row;
                        
                        if (y >= 0) {
                            board[y][x] = currentPiece.color;
                        }
                    }
                }
            }
        }

        function clearLines() {
            let linesCleared = 0;
            
            for (let row = BOARD_HEIGHT - 1; row >= 0; row--) {
                if (board[row].every(cell => cell !== 0)) {
                    // Animer la ligne qui disparaÃ®t
                    animateLineClear(row);
                    
                    // Supprimer la ligne
                    board.splice(row, 1);
                    board.unshift(Array(BOARD_WIDTH).fill(0));
                    
                    linesCleared++;
                    row++; // RevÃ©rifier la mÃªme ligne
                }
            }
            
            if (linesCleared > 0) {
                // Calculer le score avec multiplicateur de difficultÃ©
                const lineScores = [0, 100, 300, 500, 800];
                const settings = difficultySettings[currentDifficulty];
                const baseScore = lineScores[linesCleared] * level;
                score += Math.floor(baseScore * settings.scoreMultiplier);
                lines += linesCleared;
                
                // Augmenter le niveau
                const newLevel = Math.floor(lines / 10) + 1;
                if (newLevel > level) {
                    level = newLevel;
                    // Calculer la nouvelle vitesse selon la difficultÃ©
                    dropInterval = Math.max(50, settings.baseSpeed - (level - 1) * settings.speedIncrease);
                    
                    if (gameLoop) {
                        clearInterval(gameLoop);
                        gameLoop = setInterval(gameStep, dropInterval);
                    }
                }
            }
        }

        function animateLineClear(row) {
            for (let col = 0; col < BOARD_WIDTH; col++) {
                const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                if (cell) {
                    cell.classList.add('clearing');
                    setTimeout(() => {
                        cell.classList.remove('clearing');
                    }, 800);
                }
            }
        }

        function checkGameOver() {
            return !isValidPosition(currentPiece.shape, currentPiece.x, currentPiece.y);
        }

        function endGame() {
            gameRunning = false;
            gamePaused = false;
            const t = translations[currentLanguage];
            
            if (gameLoop) {
                clearInterval(gameLoop);
            }
            
            // Mettre Ã  jour les records
            updateRecords();
            
            // Afficher le message de fin
            document.getElementById('gameStatus').textContent = `${t.gameOver} ${score}`;
            document.getElementById('gameStatus').className = 'game-status game-over';
            
            // RÃ©activer les boutons
            document.getElementById('startBtn').disabled = false;
            document.getElementById('pauseBtn').disabled = true;
            document.getElementById('pauseBtn').textContent = t.pause;
        }

        function updateDisplay() {
            // Mettre Ã  jour la grille
            const cells = document.querySelectorAll('.tetris-cell');
            
            // Effacer la grille
            cells.forEach(cell => {
                cell.className = 'tetris-cell';
            });
            
            // Afficher le plateau
            for (let row = 0; row < BOARD_HEIGHT; row++) {
                for (let col = 0; col < BOARD_WIDTH; col++) {
                    const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                    if (board[row][col]) {
                        if (board[row][col] === 'obstacle') {
                            cell.classList.add('obstacle-cell');
                        } else {
                            cell.classList.add('filled', board[row][col]);
                        }
                    }
                }
            }
            
            // Afficher la piÃ¨ce actuelle
            if (currentPiece) {
                for (let row = 0; row < currentPiece.shape.length; row++) {
                    for (let col = 0; col < currentPiece.shape[row].length; col++) {
                        if (currentPiece.shape[row][col]) {
                            const x = currentPiece.x + col;
                            const y = currentPiece.y + row;
                            
                            if (y >= 0 && y < BOARD_HEIGHT && x >= 0 && x < BOARD_WIDTH) {
                                const cell = document.querySelector(`[data-row="${y}"][data-col="${x}"]`);
                                if (cell) {
                                    cell.classList.add('filled', currentPiece.color);
                                }
                            }
                        }
                    }
                }
            }
            
            // Afficher la prochaine piÃ¨ce
            updateNextPieceDisplay();
            

            
            // Mettre Ã  jour les statistiques
            document.getElementById('scoreValue').textContent = score.toLocaleString();
            document.getElementById('linesValue').textContent = lines;
            document.getElementById('levelValue').textContent = level;
            document.getElementById('piecesValue').textContent = pieces;
            
            // Barre de progression du niveau
            const levelProgress = (lines % 10) / 10 * 100;
            document.getElementById('levelFill').style.width = levelProgress + '%';
            
            // Analyse IA
            updateAIAnalysis();
            

        }

        function updateNextPieceDisplay() {
            const cells = Array.from(document.querySelectorAll('.next-cell'));

            // clear cells keeping the base class
            cells.forEach(cell => {
                // remove any piece- classes but keep next-cell
                cell.className = 'next-cell';
            });

            // Debug/testing fallback: if localStorage contains a forced piece code, use it
            try {
                const forced = localStorage.getItem('tetris-debug-force-next');
                if (forced && PIECES[forced]) {
                    console.debug('[debug] Forcing nextPiece to:', forced);
                    nextPiece = {
                        type: forced,
                        shape: PIECES[forced].shape,
                        color: PIECES[forced].color,
                        x: 0, y: 0
                    };
                }
            } catch (e) { /* ignore */ }

            if (!nextPiece) {
                console.debug('[debug] updateNextPieceDisplay: no nextPiece available');
                return;
            }

            try {
                const shape = nextPiece.shape;
                const startRow = Math.floor((4 - shape.length) / 2);
                const startCol = Math.floor((4 - shape[0].length) / 2);
                const colorClass = nextPiece.color || '';

                console.debug('[debug] updateNextPieceDisplay nextPiece:', nextPiece, 'startRow', startRow, 'startCol', startCol);

                // ensure cells are cleared of previous color classes
                cells.forEach(c => {
                    Array.from(c.classList).forEach(cl => {
                        if (/^piece-/.test(cl)) c.classList.remove(cl);
                    });
                    // clear inline styles too
                    c.style.background = '';
                    c.style.boxShadow = '';
                });

                // mapping JS gradients to avoid CSS specificity issues
                const PIECE_BACKGROUNDS = {
                    I: 'linear-gradient(45deg, #00ffff, #0080ff)',
                    O: 'linear-gradient(45deg, #ffff00, #ff8000)',
                    T: 'linear-gradient(45deg, #ff00ff, #8000ff)',
                    S: 'linear-gradient(45deg, #00ff00, #008000)',
                    Z: 'linear-gradient(45deg, #ff0000, #800000)',
                    J: 'linear-gradient(45deg, #0000ff, #000080)',
                    L: 'linear-gradient(45deg, #ff8000, #804000)'
                };

                const glow = '0 0 8px rgba(255,255,255,0.08)';

                for (let row = 0; row < shape.length; row++) {
                    for (let col = 0; col < shape[row].length; col++) {
                        if (shape[row][col]) {
                            const cellIndex = (startRow + row) * 4 + (startCol + col);
                            if (cellIndex >= 0 && cellIndex < cells.length) {
                                const target = cells[cellIndex];
                                if (target) {
                                    target.classList.add('filled');
                                    if (colorClass) target.classList.add(colorClass);
                                    // apply inline background for reliability
                                    try {
                                        const typeKey = nextPiece.type || (colorClass.replace(/^piece-/, '').toUpperCase());
                                        const bg = PIECE_BACKGROUNDS[typeKey] || '';
                                        if (bg) target.style.background = bg;
                                        target.style.boxShadow = glow;
                                    } catch (e) { /* ignore */ }
                                }
                            } else {
                                console.debug('[debug] computed cellIndex out of bounds:', cellIndex);
                            }
                        }
                    }
                }
            } catch (e) {
                console.error('Error in updateNextPieceDisplay:', e);
            }
        }



        function updateAIAnalysis() {
            if (!gameRunning) return;
            
            // Calculer l'efficacitÃ©
            const totalCells = BOARD_WIDTH * BOARD_HEIGHT;
            const filledCells = board.flat().filter(cell => cell !== 0).length;
            const efficiency = Math.round((filledCells / totalCells) * 100);
            document.getElementById('efficiencyValue').textContent = efficiency + '%';
            
            // Calculer les trous
            const holes = countHoles();
            document.getElementById('holesValue').textContent = holes;
            
            // Calculer la hauteur moyenne
            const height = calculateAverageHeight();
            document.getElementById('heightValue').textContent = height;
            
            // PrÃ©diction simple
            const prediction = predictNextMove();
            document.getElementById('predictionValue').textContent = prediction;
        }

        function countHoles() {
            let holes = 0;
            
            for (let col = 0; col < BOARD_WIDTH; col++) {
                let foundBlock = false;
                for (let row = 0; row < BOARD_HEIGHT; row++) {
                    if (board[row][col] !== 0) {
                        foundBlock = true;
                    } else if (foundBlock) {
                        holes++;
                    }
                }
            }
            
            return holes;
        }

        function calculateAverageHeight() {
            let totalHeight = 0;
            
            for (let col = 0; col < BOARD_WIDTH; col++) {
                for (let row = 0; row < BOARD_HEIGHT; row++) {
                    if (board[row][col] !== 0) {
                        totalHeight += BOARD_HEIGHT - row;
                        break;
                    }
                }
            }
            
            return Math.round(totalHeight / BOARD_WIDTH);
        }

        function predictNextMove() {
            if (!currentPiece) return '-';
            
            const moves = {
                fr: ['Gauche', 'Droite', 'Rotation', 'Descente'],
                en: ['Left', 'Right', 'Rotate', 'Down'],
                ar: ['ÙŠØ³Ø§Ø±', 'ÙŠÙ…ÙŠÙ†', 'Ø¯ÙˆØ±Ø§Ù†', 'Ø£Ø³ÙÙ„'],
                es: ['Izquierda', 'Derecha', 'Rotar', 'Abajo'],
                de: ['Links', 'Rechts', 'Drehen', 'Runter'],
                zh: ['å·¦', 'å³', 'æ—‹è½¬', 'ä¸‹']
            };
            
            const currentMoves = moves[currentLanguage] || moves.fr;
            return currentMoves[Math.floor(Math.random() * currentMoves.length)];
        }

        function toggleAIMode() {
            aiMode = !aiMode;
            const t = translations[currentLanguage];
            const btn = document.getElementById('aiModeBtn');
            btn.textContent = `${t.aiMode}: ${aiMode ? 'ON' : 'OFF'}`;
            btn.style.background = aiMode ? 
                'linear-gradient(45deg, #00ff00, #00cc00)' : 
                'linear-gradient(45deg, #00ffff, #0080ff)';
        }

        function getAIHint() {
            const t = translations[currentLanguage];
            
            if (!currentPiece || !gameRunning) {
                document.getElementById('aiSuggestion').textContent = t.noPiece;
                return;
            }
            
            const hints = {
                fr: [
                    'ğŸ’¡ Essayez de crÃ©er des lignes complÃ¨tes',
                    'ğŸ¯ Placez la piÃ¨ce sur le cÃ´tÃ© droit',
                    'âš¡ Utilisez la rotation pour mieux ajuster',
                    'ğŸ”„ Ã‰vitez de crÃ©er des trous',
                    'ğŸ“Š Gardez une hauteur uniforme',
                    'ğŸ® PrÃ©parez-vous pour un Tetris!'
                ],
                en: [
                    'ğŸ’¡ Try to create complete lines',
                    'ğŸ¯ Place the piece on the right side',
                    'âš¡ Use rotation to adjust better',
                    'ğŸ”„ Avoid creating holes',
                    'ğŸ“Š Keep uniform height',
                    'ğŸ® Prepare for a Tetris!'
                ],
                ar: [
                    'ğŸ’¡ Ø­Ø§ÙˆÙ„ Ø¥Ù†Ø´Ø§Ø¡ Ø®Ø·ÙˆØ· ÙƒØ§Ù…Ù„Ø©',
                    'ğŸ¯ Ø¶Ø¹ Ø§Ù„Ù‚Ø·Ø¹Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø¬Ø§Ù†Ø¨ Ø§Ù„Ø£ÙŠÙ…Ù†',
                    'âš¡ Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø¯ÙˆØ±Ø§Ù† Ù„Ù„ØªØ¹Ø¯ÙŠÙ„ Ø¨Ø´ÙƒÙ„ Ø£ÙØ¶Ù„',
                    'ğŸ”„ ØªØ¬Ù†Ø¨ Ø¥Ù†Ø´Ø§Ø¡ Ø«Ù‚ÙˆØ¨',
                    'ğŸ“Š Ø­Ø§ÙØ¸ Ø¹Ù„Ù‰ Ø§Ø±ØªÙØ§Ø¹ Ù…ÙˆØ­Ø¯',
                    'ğŸ® Ø§Ø³ØªØ¹Ø¯ Ù„ØªÙŠØªØ±ÙŠØ³!'
                ],
                es: [
                    'ğŸ’¡ Trata de crear lÃ­neas completas',
                    'ğŸ¯ Coloca la pieza en el lado derecho',
                    'âš¡ Usa la rotaciÃ³n para ajustar mejor',
                    'ğŸ”„ Evita crear agujeros',
                    'ğŸ“Š MantÃ©n altura uniforme',
                    'ğŸ® Â¡PrepÃ¡rate para un Tetris!'
                ],
                de: [
                    'ğŸ’¡ Versuche vollstÃ¤ndige Linien zu erstellen',
                    'ğŸ¯ Platziere das Teil auf der rechten Seite',
                    'âš¡ Nutze Rotation fÃ¼r bessere Anpassung',
                    'ğŸ”„ Vermeide LÃ¶cher zu schaffen',
                    'ğŸ“Š Halte einheitliche HÃ¶he',
                    'ğŸ® Bereite dich auf Tetris vor!'
                ],
                zh: [
                    'ğŸ’¡ å°è¯•åˆ›å»ºå®Œæ•´çš„è¡Œ',
                    'ğŸ¯ å°†æ–¹å—æ”¾åœ¨å³ä¾§',
                    'âš¡ ä½¿ç”¨æ—‹è½¬æ¥æ›´å¥½åœ°è°ƒæ•´',
                    'ğŸ”„ é¿å…åˆ›å»ºç©ºæ´',
                    'ğŸ“Š ä¿æŒå‡åŒ€é«˜åº¦',
                    'ğŸ® ä¸ºä¿„ç½—æ–¯æ–¹å—åšå‡†å¤‡ï¼'
                ]
            };
            
            const currentHints = hints[currentLanguage] || hints.fr;
            const hint = currentHints[Math.floor(Math.random() * currentHints.length)];
            document.getElementById('aiSuggestion').textContent = hint;
        }

        function analyzeBoard() {
            const t = translations[currentLanguage];
            
            if (!gameRunning) {
                document.getElementById('aiSuggestion').textContent = t.startToAnalyze;
                return;
            }
            
            const holes = countHoles();
            const height = calculateAverageHeight();
            
            const analysisTexts = {
                fr: {
                    title: 'ğŸ” Analyse du plateau:\n',
                    noHoles: 'âœ… Aucun trou dÃ©tectÃ©',
                    fewHoles: 'âš ï¸ Quelques trous prÃ©sents',
                    manyHoles: 'âŒ Trop de trous, attention!',
                    optimalHeight: '\nğŸ“Š Hauteur optimale',
                    moderateHeight: '\nâš ï¸ Hauteur modÃ©rÃ©e',
                    criticalHeight: '\nğŸš¨ Hauteur critique!'
                },
                en: {
                    title: 'ğŸ” Board analysis:\n',
                    noHoles: 'âœ… No holes detected',
                    fewHoles: 'âš ï¸ Few holes present',
                    manyHoles: 'âŒ Too many holes, watch out!',
                    optimalHeight: '\nğŸ“Š Optimal height',
                    moderateHeight: '\nâš ï¸ Moderate height',
                    criticalHeight: '\nğŸš¨ Critical height!'
                },
                ar: {
                    title: 'ğŸ” ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù„ÙˆØ­Ø©:\n',
                    noHoles: 'âœ… Ù„Ù… ÙŠØªÙ… Ø§ÙƒØªØ´Ø§Ù Ø«Ù‚ÙˆØ¨',
                    fewHoles: 'âš ï¸ Ø¨Ø¹Ø¶ Ø§Ù„Ø«Ù‚ÙˆØ¨ Ù…ÙˆØ¬ÙˆØ¯Ø©',
                    manyHoles: 'âŒ Ø«Ù‚ÙˆØ¨ ÙƒØ«ÙŠØ±Ø©ØŒ Ø§Ù†ØªØ¨Ù‡!',
                    optimalHeight: '\nğŸ“Š Ø§Ø±ØªÙØ§Ø¹ Ù…Ø«Ø§Ù„ÙŠ',
                    moderateHeight: '\nâš ï¸ Ø§Ø±ØªÙØ§Ø¹ Ù…Ø¹ØªØ¯Ù„',
                    criticalHeight: '\nğŸš¨ Ø§Ø±ØªÙØ§Ø¹ Ø­Ø±Ø¬!'
                },
                es: {
                    title: 'ğŸ” AnÃ¡lisis del tablero:\n',
                    noHoles: 'âœ… No se detectaron agujeros',
                    fewHoles: 'âš ï¸ Pocos agujeros presentes',
                    manyHoles: 'âŒ Demasiados agujeros, Â¡cuidado!',
                    optimalHeight: '\nğŸ“Š Altura Ã³ptima',
                    moderateHeight: '\nâš ï¸ Altura moderada',
                    criticalHeight: '\nğŸš¨ Â¡Altura crÃ­tica!'
                },
                de: {
                    title: 'ğŸ” Brett-Analyse:\n',
                    noHoles: 'âœ… Keine LÃ¶cher erkannt',
                    fewHoles: 'âš ï¸ Wenige LÃ¶cher vorhanden',
                    manyHoles: 'âŒ Zu viele LÃ¶cher, Vorsicht!',
                    optimalHeight: '\nğŸ“Š Optimale HÃ¶he',
                    moderateHeight: '\nâš ï¸ Moderate HÃ¶he',
                    criticalHeight: '\nğŸš¨ Kritische HÃ¶he!'
                },
                zh: {
                    title: 'ğŸ” æ£‹ç›˜åˆ†æ:\n',
                    noHoles: 'âœ… æœªæ£€æµ‹åˆ°ç©ºæ´',
                    fewHoles: 'âš ï¸ å­˜åœ¨å°‘é‡ç©ºæ´',
                    manyHoles: 'âŒ ç©ºæ´å¤ªå¤šï¼Œå°å¿ƒï¼',
                    optimalHeight: '\nğŸ“Š æœ€ä½³é«˜åº¦',
                    moderateHeight: '\nâš ï¸ ä¸­ç­‰é«˜åº¦',
                    criticalHeight: '\nğŸš¨ å±é™©é«˜åº¦ï¼'
                }
            };
            
            const texts = analysisTexts[currentLanguage] || analysisTexts.fr;
            let analysis = texts.title;
            
            if (holes === 0) {
                analysis += texts.noHoles;
            } else if (holes < 3) {
                analysis += texts.fewHoles;
            } else {
                analysis += texts.manyHoles;
            }
            
            if (height < 5) {
                analysis += texts.optimalHeight;
            } else if (height < 10) {
                analysis += texts.moderateHeight;
            } else {
                analysis += texts.criticalHeight;
            }
            
            document.getElementById('aiSuggestion').textContent = analysis;
        }

        function performAIMove() {
            if (!currentPiece) return;
            
            // IA simple qui essaie de placer les piÃ¨ces intelligemment
            const moves = Math.floor(Math.random() * 4);
            
            switch(moves) {
                case 0:
                    if (Math.random() > 0.7) movePiece(-1, 0);
                    break;
                case 1:
                    if (Math.random() > 0.7) movePiece(1, 0);
                    break;
                case 2:
                    if (Math.random() > 0.9) rotatePiece();
                    break;
                case 3:
                    if (Math.random() > 0.8) hardDrop();
                    break;
            }
        }

        function applyStrategy(strategy) {
            const t = translations[currentLanguage];
            
            if (!gameRunning || !currentPiece) {
                document.getElementById('aiSuggestion').textContent = t.startToUseStrategies;
                return;
            }
            
            const strategyMessages = {
                fr: {
                    tetris: 'ğŸ¯ StratÃ©gie Tetris: Gardez une colonne libre pour les piÃ¨ces I',
                    clear: 'ğŸ§¹ StratÃ©gie Nettoyage: Ã‰liminez les trous en prioritÃ©',
                    stack: 'ğŸ“š StratÃ©gie Empilement: Construisez uniformÃ©ment',
                    survive: 'ğŸ›¡ï¸ StratÃ©gie Survie: Gardez la hauteur basse'
                },
                en: {
                    tetris: 'ğŸ¯ Tetris Strategy: Keep one column free for I-pieces',
                    clear: 'ğŸ§¹ Clear Strategy: Eliminate holes first',
                    stack: 'ğŸ“š Stack Strategy: Build evenly',
                    survive: 'ğŸ›¡ï¸ Survive Strategy: Keep height low'
                },
                ar: {
                    tetris: 'ğŸ¯ Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© ØªÙŠØªØ±ÙŠØ³: Ø§Ø­ØªÙØ¸ Ø¨Ø¹Ù…ÙˆØ¯ ÙˆØ§Ø­Ø¯ ÙØ§Ø±Øº Ù„Ù„Ù‚Ø·Ø¹ I',
                    clear: 'ğŸ§¹ Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© Ø§Ù„ØªÙ†Ø¸ÙŠÙ: ØªØ®Ù„Øµ Ù…Ù† Ø§Ù„Ø«Ù‚ÙˆØ¨ Ø£ÙˆÙ„Ø§Ù‹',
                    stack: 'ğŸ“š Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© Ø§Ù„ØªÙƒØ¯ÙŠØ³: Ø§Ø¨Ù† Ø¨Ø§Ù†ØªØ¸Ø§Ù…',
                    survive: 'ğŸ›¡ï¸ Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© Ø§Ù„Ø¨Ù‚Ø§Ø¡: Ø­Ø§ÙØ¸ Ø¹Ù„Ù‰ Ø§Ø±ØªÙØ§Ø¹ Ù…Ù†Ø®ÙØ¶'
                },
                es: {
                    tetris: 'ğŸ¯ Estrategia Tetris: MantÃ©n una columna libre para piezas I',
                    clear: 'ğŸ§¹ Estrategia Limpiar: Elimina agujeros primero',
                    stack: 'ğŸ“š Estrategia Apilar: Construye uniformemente',
                    survive: 'ğŸ›¡ï¸ Estrategia Sobrevivir: MantÃ©n altura baja'
                },
                de: {
                    tetris: 'ğŸ¯ Tetris-Strategie: Halte eine Spalte fÃ¼r I-Teile frei',
                    clear: 'ğŸ§¹ RÃ¤um-Strategie: LÃ¶cher zuerst beseitigen',
                    stack: 'ğŸ“š Stapel-Strategie: GleichmÃ¤ÃŸig bauen',
                    survive: 'ğŸ›¡ï¸ Ãœberlebens-Strategie: HÃ¶he niedrig halten'
                },
                zh: {
                    tetris: 'ğŸ¯ ä¿„ç½—æ–¯æ–¹å—ç­–ç•¥ï¼šä¸ºIå‹æ–¹å—ä¿ç•™ä¸€åˆ—',
                    clear: 'ğŸ§¹ æ¸…é™¤ç­–ç•¥ï¼šä¼˜å…ˆæ¶ˆé™¤ç©ºæ´',
                    stack: 'ğŸ“š å †å ç­–ç•¥ï¼šå‡åŒ€å»ºé€ ',
                    survive: 'ğŸ›¡ï¸ ç”Ÿå­˜ç­–ç•¥ï¼šä¿æŒä½é«˜åº¦'
                }
            };
            
            const messages = strategyMessages[currentLanguage] || strategyMessages.fr;
            document.getElementById('aiSuggestion').textContent = messages[strategy];
        }

        function loadRecords() {
            document.getElementById('bestScoreValue').textContent = parseInt(bestScore).toLocaleString();
            document.getElementById('bestLinesValue').textContent = bestLines;
            document.getElementById('bestLevelValue').textContent = bestLevel;
            
            const totalSeconds = parseInt(totalTime);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            document.getElementById('totalTimeValue').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        function updateRecords() {
            let updated = false;
            
            if (score > bestScore) {
                bestScore = score;
                localStorage.setItem('tetris-best-score', bestScore);
                updated = true;
            }
            
            if (lines > bestLines) {
                bestLines = lines;
                localStorage.setItem('tetris-best-lines', bestLines);
                updated = true;
            }
            
            if (level > bestLevel) {
                bestLevel = level;
                localStorage.setItem('tetris-best-level', bestLevel);
                updated = true;
            }
            
            // Ajouter le temps de jeu
            const gameTime = Math.floor((Date.now() - gameStartTime) / 1000);
            totalTime = parseInt(totalTime) + gameTime;
            localStorage.setItem('tetris-total-time', totalTime);
            
            loadRecords();
            
            if (updated) {
                const t = translations[currentLanguage];
                document.getElementById('aiSuggestion').textContent = t.newRecord;
            }
        }

        function closePlatform() {
            console.debug('jeux1: closePlatform called');
            try{
                if (window.parent && window.parent !== window) {
                        window.parent.postMessage({ action: 'close', reason: 'user-initiated' }, '*');
                        return;
                    }
            }catch(e){/* ignore */}
            try{
                if(window.opener && !window.opener.closed){
                    try{ window.opener.postMessage({ action: 'child-closed' }, '*'); }catch(e){}
                    try{ window.close(); }catch(e){}
                    return;
                }
            }catch(e){/* ignore */}
            try{ window.location.href = new URL('./brainova.html', window.location.href).href; }catch(e){/* ignore */}
        }


        // Apply translations to visible UI elements
        function setTexts(t) {
            try {
                // Title & subtitle
                const titleEl = document.querySelector('.game-title');
                if (titleEl) titleEl.textContent = t.title || titleEl.textContent;
                const sub = document.querySelector('.subtitle');
                if (sub) sub.textContent = t.subtitle || sub.textContent;

                // Main buttons
                const startBtn = document.getElementById('startBtn');
                const pauseBtn = document.getElementById('pauseBtn');
                const resetBtn = document.getElementById('resetBtn');
                const aiModeBtn = document.getElementById('aiModeBtn');
                const aiHintBtn = document.getElementById('aiHintBtn');
                const aiAnalyzeBtn = document.getElementById('aiAnalyzeBtn');

                if (startBtn) startBtn.textContent = t.start || startBtn.textContent;
                if (pauseBtn) pauseBtn.textContent = t.pause || pauseBtn.textContent;
                if (resetBtn) resetBtn.textContent = t.reset || resetBtn.textContent;
                if (aiModeBtn) aiModeBtn.textContent = (t.aiMode || 'Mode IA') + ': ' + (aiMode ? (t.on || 'ON') : (t.off || 'OFF'));
                if (aiHintBtn) aiHintBtn.textContent = t.aiHint || aiHintBtn.textContent;
                if (aiAnalyzeBtn) aiAnalyzeBtn.textContent = t.analyze || aiAnalyzeBtn.textContent;

                // Apply translations to elements that declare a data-i18n key (preferred)
                document.querySelectorAll('[data-i18n]').forEach(el => {
                    const key = el.getAttribute('data-i18n');
                    if (key && t[key]) el.textContent = t[key];
                });

                // Fallback heuristic for legacy headings that may not have data-i18n
                document.querySelectorAll('h3').forEach(h3 => {
                    // skip if we already set it via data-i18n
                    if (h3.hasAttribute('data-i18n')) return;
                    const txt = h3.textContent.trim().toLowerCase();
                    if (/contr/i.test(txt) || /control/i.test(txt)) h3.textContent = t.quantumControls || h3.textContent;
                    else if (/niveau|difficulty/i.test(txt)) h3.textContent = t.difficultyLevel || h3.textContent;
                    else if (/procha|next/i.test(txt)) h3.textContent = t.nextPiece || h3.textContent;
                    else if (/analyse|ai/i.test(txt)) h3.textContent = t.aiAnalysis || h3.textContent;
                    else if (/assistant|assistant/i.test(txt)) h3.textContent = t.aiAssistant || h3.textContent;
                    else if (/strat/i.test(txt) || /strateg/i.test(txt)) h3.textContent = t.strategies || h3.textContent;
                    else if (/record/i.test(txt) || /meilleur|best/i.test(txt)) h3.textContent = t.records || h3.textContent;
                });

                // Controls info (list of keys + labels)
                const controlsInfo = document.querySelector('.controls-info');
                if (controlsInfo) {
                    controlsInfo.innerHTML = `
                        <h3>${t.controls || 'CONTROLS'}</h3>
                        <div>
                            <span class="control-key">â†â†’</span> ${t.move || 'Move'}<br>
                            <span class="control-key">â†“</span> ${t.down || 'Down'}<br>
                            <span class="control-key">â†‘</span> ${t.up || 'Up'}<br>
                            <span class="control-key">R</span> ${t.rotate || 'Rotate'}<br>
                            <span class="control-key">ESPACE</span> ${t.drop || 'Hard Drop'}<br>
                            <span class="control-key">P</span> ${t.pauseKey || 'Pause'}
                        </div>
                    `;
                }

                // Difficulty options
                const diff = document.getElementById('difficultySelector');
                if (diff && diff.options) {
                    const map = ['easy','normal','hard','expert','quantum'];
                    for (let i=0;i<diff.options.length && i<map.length;i++){
                        const k = map[i];
                        if (t[k]) diff.options[i].text = t[k];
                    }
                }

                // Stat labels (update left label preceding value spans)
                const statMap = {
                    'scoreValue': t.score || 'Score:',
                    'linesValue': t.lines || 'Lines:',
                    'levelValue': t.level || 'Level:',
                    'piecesValue': t.pieces || 'Pieces:'
                };
                Object.keys(statMap).forEach(id => {
                    const el = document.getElementById(id);
                    if (el) {
                        // try to find the label element in the same .stat-item
                        const parent = el.closest('.stat-item');
                        if (parent) {
                            const lbl = parent.querySelector('span:not(.stat-value)');
                            if (lbl) lbl.textContent = statMap[id];
                        }
                    }
                });

                // Strategies buttons
                document.querySelectorAll('button[onclick^="applyStrategy"]').forEach(btn => {
                    const txt = btn.textContent.trim().toLowerCase();
                    if (/tetris/i.test(txt)) btn.textContent = t.tetrisStrategy || btn.textContent;
                    else if (/nettoyer|clear/i.test(txt)) btn.textContent = t.clearStrategy || btn.textContent;
                    else if (/empil|stack/i.test(txt)) btn.textContent = t.stackStrategy || btn.textContent;
                    else if (/surviv|survive/i.test(txt)) btn.textContent = t.surviveStrategy || btn.textContent;
                });

                // Records panel headers
                const recordsHeaders = Array.from(document.querySelectorAll('.stats-display h3'));
                recordsHeaders.forEach(h3 => {
                    const p = h3.textContent.trim().toLowerCase();
                    if (/records|record|meilleur|best/i.test(p)) h3.textContent = t.records || h3.textContent;
                });

                // Game status initial message
                const gs = document.getElementById('gameStatus');
                if (gs) gs.textContent = t.startMessage || gs.textContent;

                // Close button tooltip/title
                const closeBtn = document.getElementById('closeBtn');
                if (closeBtn) closeBtn.title = t.backToHome || closeBtn.title;

                // Direction for Arabic
                document.documentElement.dir = (currentLanguage === 'ar') ? 'rtl' : 'ltr';

                // Normalization pass: remove mixed-language fragments like "DÃ©marrer / Start" or "Start / DÃ©marrer"
                normalizeMixedLanguage(currentLanguage);
                // Update dynamic labels that are controlled by helper functions
                try { updateStatLabels(t); } catch(e) {}
                try { updateControlsText(t); } catch(e) {}
                try { updateStrategyButtons(t); } catch(e) {}
                try { updateSectionTitles(t); } catch(e) {}
                try { updateStatusMessages(t); } catch(e) {}
            } catch (e) { /* ignore errors */ }
        }

        function normalizeMixedLanguage(lang) {
            // Build a regex that matches patterns like "frText / enText" or "enText / frText" and keep only the chunk matching 'lang'
            // We rely on translations object to know common words in each language.
            try {
                const allKeys = Object.keys(translations[lang] || {});
                // Create a set of common words for current language for heuristic matching
                const keepWords = new Set(allKeys.map(k => (translations[lang][k] || '').split(/\s+/)[0]).filter(Boolean).map(s=>s.toLowerCase()));

                // Walk text nodes under the main container
                const walker = document.createTreeWalker(document.body, NodeFilter.SHOW_TEXT, null, false);
                const toUpdate = [];
                while(walker.nextNode()){
                    const node = walker.currentNode;
                    const txt = node.nodeValue;
                    if (!txt || txt.trim().length < 2) continue;
                    // detect common bilingual separators
                    if (/[\/\|Â·â€“â€”]/.test(txt) && /[A-Za-zÃ€-Å¾\u0600-\u06FF\u4E00-\u9FFF]/.test(txt)){
                        // split by slash, pipe, bullet, dash
                        const parts = txt.split(/[\/\|Â·â€“â€”]/).map(p=>p.trim()).filter(Boolean);
                        if (parts.length >= 2) {
                            // choose the part that contains a 'keep' word or that best matches language script
                            let chosen = parts.find(p => {
                                const lower = p.toLowerCase();
                                // check for Arabic script if lang === 'ar'
                                if (lang === 'ar' && /[\u0600-\u06FF]/.test(p)) return true;
                                if (lang === 'zh' && /[\u4E00-\u9FFF]/.test(p)) return true;
                                // heuristic: contains any of keepWords
                                for (const w of keepWords) if (lower.includes(w)) return true;
                                return false;
                            });
                            if (!chosen) chosen = parts[0];
                            toUpdate.push({node, val: chosen});
                        }
                    }
                }
                toUpdate.forEach(({node,val})=> node.nodeValue = val);
            } catch(e) { /* ignore */ }
        }

        function changeLanguage() {
            const sel = document.getElementById('languageSelector');
            if (!sel) return;
            currentLanguage = sel.value;
            localStorage.setItem('brainovaLang', currentLanguage);
            localStorage.setItem('tetris-language', currentLanguage);
            const t = translations[currentLanguage] || translations['fr'];
            setTexts(t);
        }

        // Initialize language selector and apply texts after DOM is ready
        function applyInitialLanguage(){
            const sel = document.getElementById('languageSelector');
            if (sel) sel.value = currentLanguage;
            const t = translations[currentLanguage] || translations['fr'];
            setTexts(t);
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', applyInitialLanguage);
        } else {
            applyInitialLanguage();
        }



        function showControls() {
            const controlsText = `
ğŸ® CONTRÃ”LES TETRIS QUANTUM:\n
âŒ¨ï¸ Clavier:\nâ€¢ â† â†’ : DÃ©placer la piÃ¨ce horizontalement\nâ€¢ â†“ : Descendre la piÃ¨ce\nâ€¢ â†‘ : Monter la piÃ¨ce\nâ€¢ R : Rotation de la piÃ¨ce\nâ€¢ ESPACE : Chute libre\nâ€¢ P : Pause/Reprendre\n
ğŸ¤– IA:\nâ€¢ Mode IA Auto : L'IA joue automatiquement\nâ€¢ Conseil IA : Obtenir des suggestions\nâ€¢ Analyser : Ã‰valuer le plateau\n
âš¡ StratÃ©gies:\nâ€¢ Tetris : Viser les lignes de 4\nâ€¢ Nettoyage : Ã‰liminer les trous\nâ€¢ Empilement : Construction uniforme\nâ€¢ Survie : Garder une hauteur basse\n`;

            showInlineModal('ContrÃ´les Tetris Quantum', controlsText, [{ label: 'Fermer', value: 'close' }]);
        }

        function resetRecords() {
            showInlineModal('Effacer les records', 'Voulez-vous vraiment effacer tous vos records ?', [
                { label: 'Annuler', value: 'cancel' },
                { label: 'Effacer', value: 'confirm', class: 'danger' }
            ]).then(res => {
                if (res === 'confirm'){
                    localStorage.removeItem('tetris-best-score');
                    localStorage.removeItem('tetris-best-lines');
                    localStorage.removeItem('tetris-best-level');
                    localStorage.removeItem('tetris-total-time');

                    bestScore = 0;
                    bestLines = 0;
                    bestLevel = 1;
                    totalTime = 0;

                    loadRecords();

                    document.getElementById('aiSuggestion').textContent = 'ğŸ—‘ï¸ Records effacÃ©s avec succÃ¨s!';
                }
            }).catch(()=>{});
        }



        

        function updateSectionTitles(t) {
            const sections = document.querySelectorAll('.panel h3, .stats-display h3, .ai-panel h3, .controls-info h3');
            sections.forEach(section => {
                const text = section.textContent;
                if (text.includes('CONTRÃ”LES') || text.includes('QUANTUM') || text.includes('QUANTENSTEUERUNG') || text.includes('Ø§Ù„ØªØ­ÙƒÙ…') || text.includes('CONTROLES') || text.includes('é‡å­')) {
                    section.textContent = t.quantumControls;
                } else if (text.includes('STATISTIQUES') || text.includes('STATISTICS') || text.includes('Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª') || text.includes('ESTADÃSTICAS') || text.includes('STATISTIKEN') || text.includes('ç»Ÿè®¡')) {
                    section.textContent = t.statistics;
                } else if (text.includes('PROCHAINE') || text.includes('NEXT') || text.includes('Ø§Ù„ØªØ§Ù„ÙŠØ©') || text.includes('SIGUIENTE') || text.includes('NÃ„CHSTES') || text.includes('ä¸‹ä¸€ä¸ª')) {
                    section.textContent = t.nextPiece;
                } else if (text.includes('ASSISTANT') || text.includes('Ù…Ø³Ø§Ø¹Ø¯') || text.includes('ASISTENTE') || text.includes('ASSISTENT') || text.includes('åŠ©æ‰‹')) {
                    section.textContent = t.aiAssistant;
                } else if (text.includes('ANALYSE') || text.includes('ANALYSIS') || text.includes('ØªØ­Ù„ÙŠÙ„') || text.includes('ANÃLISIS') || text.includes('åˆ†æ')) {
                    section.textContent = t.aiAnalysis;
                } else if (text.includes('STRATÃ‰GIES') || text.includes('STRATEGIES') || text.includes('Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ§Øª') || text.includes('ESTRATEGIAS') || text.includes('STRATEGIEN') || text.includes('ç­–ç•¥')) {
                    section.textContent = t.strategies;
                } else if (text.includes('RECORDS') || text.includes('Ø§Ù„Ø£Ø±Ù‚Ø§Ù…') || text.includes('RÃ‰CORDS') || text.includes('REKORDE') || text.includes('è®°å½•')) {
                    section.textContent = t.records;
                }
            });
        }

        function updateStatLabels(t) {
            const statItems = document.querySelectorAll('.stat-item span:first-child');
            statItems.forEach(label => {
                const text = label.textContent;
                if (text.includes('Score') || text.includes('Ø§Ù„Ù†Ù‚Ø§Ø·') || text.includes('PuntuaciÃ³n') || text.includes('Punkte') || text.includes('åˆ†æ•°')) {
                    label.textContent = t.score;
                } else if (text.includes('Lignes') || text.includes('Lines') || text.includes('LÃ­neas') || text.includes('Linien') || text.includes('Ø§Ù„Ø®Ø·ÙˆØ·') || text.includes('è¡Œæ•°')) {
                    label.textContent = t.lines;
                } else if (text.includes('Niveau') || text.includes('Level') || text.includes('Nivel') || text.includes('Ø§Ù„Ù…Ø³ØªÙˆÙ‰') || text.includes('ç­‰çº§')) {
                    label.textContent = t.level;
                } else if (text.includes('PiÃ¨ces') || text.includes('Pieces') || text.includes('Piezas') || text.includes('Teile') || text.includes('Ø§Ù„Ù‚Ø·Ø¹') || text.includes('æ–¹å—')) {
                    label.textContent = t.pieces;
                } else if (text.includes('EfficacitÃ©') || text.includes('Efficiency') || text.includes('Ø§Ù„ÙƒÙØ§Ø¡Ø©') || text.includes('Eficiencia') || text.includes('Effizienz') || text.includes('æ•ˆç‡')) {
                    label.textContent = t.efficiency;
                } else if (text.includes('PrÃ©diction') || text.includes('Prediction') || text.includes('Ø§Ù„ØªÙ†Ø¨Ø¤') || text.includes('PredicciÃ³n') || text.includes('Vorhersage') || text.includes('é¢„æµ‹')) {
                    label.textContent = t.prediction;
                } else if (text.includes('Trous') || text.includes('Holes') || text.includes('Ø§Ù„Ø«Ù‚ÙˆØ¨') || text.includes('Agujeros') || text.includes('LÃ¶cher') || text.includes('ç©ºæ´')) {
                    label.textContent = t.holes;
                } else if (text.includes('Hauteur') || text.includes('Height') || text.includes('Ø§Ù„Ø§Ø±ØªÙØ§Ø¹') || text.includes('Altura') || text.includes('HÃ¶he') || text.includes('é«˜åº¦')) {
                    label.textContent = t.height;
                } else if (text.includes('Meilleur') || text.includes('Best') || text.includes('Ø£ÙØ¶Ù„') || text.includes('Mejor') || text.includes('Beste') || text.includes('æœ€é«˜')) {
                    label.textContent = t.bestScore;
                } else if (text.includes('Max') && (text.includes('Lignes') || text.includes('Lines') || text.includes('Ø®Ø·ÙˆØ·') || text.includes('LÃ­neas') || text.includes('Linien') || text.includes('è¡Œ'))) {
                    label.textContent = t.maxLines;
                } else if (text.includes('Max') && (text.includes('Niveau') || text.includes('Level') || text.includes('Ù…Ø³ØªÙˆÙ‰') || text.includes('Nivel') || text.includes('ç­‰çº§'))) {
                    label.textContent = t.maxLevel;
                } else if (text.includes('Temps') || text.includes('Time') || text.includes('Ø§Ù„ÙˆÙ‚Øª') || text.includes('Tiempo') || text.includes('Zeit') || text.includes('æ—¶é—´')) {
                    label.textContent = t.totalTime;
                }
            });
        }

        function updateControlsText(t) {
            const controlsDiv = document.querySelector('.controls-info div');
            if (controlsDiv) {
                controlsDiv.innerHTML = `
                    <span class="control-key">â†â†’</span> ${t.move}<br>
                    <span class="control-key">â†“</span> ${t.down}<br>
                    <span class="control-key">â†‘</span> ${t.up}<br>
                    <span class="control-key">S</span> ${t.fastDown}<br>
                    <span class="control-key">W</span> ${t.fastUp}<br>
                    <span class="control-key">R</span> ${t.rotate}<br>
                    <span class="control-key">ESPACE</span> ${t.drop}<br>
                    <span class="control-key">P</span> ${t.pauseKey}
                `;
            }
        }

        function updateStatusMessages(t) {
            const gameStatus = document.getElementById('gameStatus');
            const currentStatus = gameStatus.textContent;
            
            if (!gameRunning && !gamePaused) {
                gameStatus.textContent = t.startMessage;
            } else if (gamePaused) {
                gameStatus.textContent = t.gamePaused;
            } else if (gameRunning) {
                if (!currentStatus.includes('Score') && !currentStatus.includes('Ø§Ù„Ù†Ù‚Ø§Ø·') && !currentStatus.includes('PuntuaciÃ³n') && !currentStatus.includes('Punkte') && !currentStatus.includes('åˆ†æ•°')) {
                    gameStatus.textContent = t.gameRunning;
                }
            }
            
            // Mettre Ã  jour le message de l'IA
            const aiSuggestion = document.getElementById('aiSuggestion');
            if (aiSuggestion.textContent.includes('prÃªte') || aiSuggestion.textContent.includes('ready') || aiSuggestion.textContent.includes('Ø¬Ø§Ù‡Ø²') || aiSuggestion.textContent.includes('lista') || aiSuggestion.textContent.includes('bereit') || aiSuggestion.textContent.includes('å‡†å¤‡')) {
                aiSuggestion.textContent = t.aiReady;
            }
        }

        function updateStrategyButtons(t) {
            const strategyButtons = document.querySelectorAll('.panel:last-child .btn');
            if (strategyButtons.length >= 4) {
                strategyButtons[0].textContent = t.tetrisStrategy;
                strategyButtons[1].textContent = t.clearStrategy;
                strategyButtons[2].textContent = t.stackStrategy;
                strategyButtons[3].textContent = t.surviveStrategy;
            }
        }

    // Initialiser le jeu
    init();

    // Charger la langue sauvegardÃ©e (safe)
    const langSel = document.getElementById('languageSelector');
    if (langSel) langSel.value = currentLanguage;
    const _t_init = translations[currentLanguage] || translations['fr'];
    setTexts(_t_init);
        
        // Charger la difficultÃ© sauvegardÃ©e
        const savedDifficulty = localStorage.getItem('tetris-difficulty');
        if (savedDifficulty && difficultySettings[savedDifficulty]) {
            currentDifficulty = savedDifficulty;
            document.getElementById('difficultySelector').value = currentDifficulty;
        }
        updateDifficultyDisplay();
</script>
<!-- Inline modal used to replace alert()/confirm() -->
<style>
    #inlineModal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.6);z-index:99999}
    #inlineModal .card{background:#071026;padding:18px;border-radius:10px;max-width:720px;color:#e6f9ff;border:1px solid rgba(0,212,255,0.06);box-shadow:0 12px 40px rgba(0,0,0,0.6)}
    #inlineModal .card h3{margin:0 0 8px 0}
    #inlineModal .card pre{white-space:pre-wrap;font-family:monospace;background:transparent;border:none;color:inherit}
    #inlineModal .actions{display:flex;gap:8px;justify-content:flex-end;margin-top:12px}
    #inlineModal .btn{padding:8px 12px;border-radius:8px;border:none;cursor:pointer}
    #inlineModal .btn.danger{background:linear-gradient(45deg,#ff4444,#ff0000);color:#fff}
    #inlineModal .btn.primary{background:linear-gradient(45deg,#00d4ff,#0088ff);color:#001}
</style>
<div id="inlineModal" role="dialog" aria-modal="true">
    <div class="card">
        <h3 id="inlineModalTitle">Titre</h3>
        <pre id="inlineModalBody"></pre>
        <div class="actions" id="inlineModalActions"></div>
    </div>
</div>
<script>
    function showInlineModal(title, message, buttons){
        return new Promise((resolve)=>{
            const modal = document.getElementById('inlineModal');
            document.getElementById('inlineModalTitle').textContent = title || '';
            document.getElementById('inlineModalBody').textContent = message || '';
            const actions = document.getElementById('inlineModalActions');
            actions.innerHTML = '';
            buttons = buttons || [{ label: 'OK', value: 'ok', class: 'primary' }];
            buttons.forEach(b=>{
                const btn = document.createElement('button');
                btn.className = 'btn ' + (b.class || '');
                btn.textContent = b.label;
                btn.addEventListener('click', ()=>{
                    modal.style.display = 'none';
                    resolve(b.value);
                });
                actions.appendChild(btn);
            });
            modal.style.display = 'flex';
        });
    }
</script>
</body>
</html>
