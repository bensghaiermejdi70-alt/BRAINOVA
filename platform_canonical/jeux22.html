<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Pipes</title>
    <script>
        (function(){
            if(window.__platform_nonblocking_dialogs) return; window.__platform_nonblocking_dialogs=true;
            try{
                const _alert = window.alert.bind(window);
                const _confirm = window.confirm.bind(window);
                const _prompt = window.prompt.bind(window);
                function send(type,text){ try{ if(window.parent && window.parent!==window) parent.postMessage({action:'dialog', dialogType:type, text:String(text||'')}, '*'); }catch(e){} }
                window.alert = function(msg){ if(window.parent && window.parent!==window){ send('alert', msg); } else { _alert(msg); } };
                window.confirm = function(msg){ if(window.parent && window.parent!==window){ send('confirm', msg); return true; } else { return _confirm(msg); } };
                window.prompt = function(msg, def){ if(window.parent && window.parent!==window){ send('prompt', msg+'\n(default: '+(def||'')+')'); return def||null; } else { return _prompt(msg, def); } };
            }catch(e){ }
        })();
    </script>
    <style>
        body {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            color: #ffffff;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            position: relative;
        }

        .title-section {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .game-logo {
            font-size: 4rem;
            animation: quantumGlow 3s ease-in-out infinite;
        }

        .title {
            font-size: 3rem;
            font-weight: bold;
            background: linear-gradient(45deg, #00ffff, #ff00ff, #ffff00);
            background-size: 200% 200%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: quantumGlow 3s ease-in-out infinite;
            text-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
            margin-bottom: 10px;
        }

        @keyframes quantumGlow {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .subtitle {
            font-size: 1.2rem;
            color: #00ffff;
            opacity: 0.8;
            margin-bottom: 30px;
        }

        .game-layout {
            display: flex;
            gap: 30px;
            align-items: flex-start;
        }

        .left-controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            min-width: 200px;
        }

        .right-controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            min-width: 200px;
        }

        .language-selector {
            position: relative;
        }

        .language-btn {
            background: linear-gradient(45deg, #1e3c72, #2a5298);
            border: 2px solid #00ffff;
            color: #ffffff;
            padding: 12px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 255, 255, 0.3);
        }

        .language-btn:hover {
            background: linear-gradient(45deg, #2a5298, #1e3c72);
            box-shadow: 0 6px 20px rgba(0, 255, 255, 0.5);
            transform: translateY(-2px);
        }

        .language-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            border: 2px solid #00ffff;
            border-radius: 15px;
            margin-top: 5px;
            display: none;
            z-index: 100;
            backdrop-filter: blur(10px);
        }

        .language-dropdown.show {
            display: block;
        }

        .language-option {
            padding: 10px 15px;
            cursor: pointer;
            transition: background 0.3s ease;
            border-radius: 10px;
            margin: 5px;
        }

        .language-option:hover {
            background: rgba(0, 255, 255, 0.2);
        }

        .rules-btn, .start-btn {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            border: none;
            color: #ffffff;
            padding: 12px 25px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3);
        }

        .start-btn {
            background: linear-gradient(45deg, #00ff88, #00cc6a);
            box-shadow: 0 4px 15px rgba(0, 255, 136, 0.3);
        }

        .rules-btn:hover, .start-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.5);
        }

        .start-btn:hover {
            box-shadow: 0 6px 20px rgba(0, 255, 136, 0.5);
        }

        .level-selector {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .level-btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            border: 2px solid #ffffff;
            color: #ffffff;
            padding: 10px 15px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
            width: 100%;
            text-align: center;
        }

        .solution-btn {
            background: linear-gradient(45deg, #ffa500, #ff8c00);
            border: none;
            color: #ffffff;
            padding: 12px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(255, 165, 0, 0.3);
            width: 100%;
        }

        .solution-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 165, 0, 0.5);
        }

        .level-btn:hover, .level-btn.active {
            background: linear-gradient(45deg, #764ba2, #667eea);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.5);
            transform: translateY(-2px);
        }

        .game-area {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid #00ffff;
            border-radius: 20px;
            padding: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 255, 255, 0.1);
            flex: 1;
        }

        .game-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 8px;
            max-width: 480px;
            margin: 0 auto;
            padding: 15px;
        }

        .pipe-cell {
            width: 65px;
            height: 65px;
            background: linear-gradient(45deg, #1a1a2e, #16213e);
            border: 2px solid #333;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .pipe-cell:hover {
            border-color: #00ffff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }

        .pipe-cell.source {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            box-shadow: 0 0 20px rgba(255, 107, 107, 0.5);
        }

        .pipe-cell.target {
            background: linear-gradient(45deg, #00ff88, #00cc6a);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
        }

        .pipe-cell.connected {
            background: linear-gradient(45deg, #00ffff, #0099cc);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.7);
        }

        .pipe-cell.solution-path {
            background: linear-gradient(45deg, #ffd700, #ffb347) !important;
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.8) !important;
            animation: solutionPulse 2s ease-in-out infinite;
        }

        @keyframes solutionPulse {
            0%, 100% { 
                box-shadow: 0 0 25px rgba(255, 215, 0, 0.8);
                transform: scale(1);
            }
            50% { 
                box-shadow: 0 0 35px rgba(255, 215, 0, 1);
                transform: scale(1.05);
            }
        }

        .pipe-symbol {
            font-size: 2rem;
            font-weight: bold;
            text-shadow: 0 0 10px currentColor;
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 20px;
        }

        .info-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px 20px;
            border-radius: 15px;
            border: 1px solid #00ffff;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            backdrop-filter: blur(5px);
        }

        .modal-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            border: 2px solid #00ffff;
            border-radius: 20px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal h2 {
            color: #00ffff;
            margin-bottom: 20px;
            text-align: center;
        }

        .close-btn {
            position: absolute;
            top: 15px;
            right: 20px;
            background: none;
            border: none;
            color: #ff6b6b;
            font-size: 1.5rem;
            cursor: pointer;
        }

        .ai-hint {
            background: linear-gradient(45deg, #667eea, #764ba2);
            border: none;
            color: #ffffff;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9rem;
            margin-top: 10px;
        }

        .pause-btn {
            background: linear-gradient(45deg, #ff9500, #ff7b00);
            border: none;
            color: #ffffff;
            padding: 12px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(255, 149, 0, 0.3);
            width: 100%;
        }

        .pause-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 149, 0, 0.5);
        }

        .new-game-btn {
            background: linear-gradient(45deg, #9c27b0, #673ab7);
            border: none;
            color: #ffffff;
            padding: 12px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(156, 39, 176, 0.3);
            width: 100%;
        }

        .new-game-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(156, 39, 176, 0.5);
        }

        @media (max-width: 768px) {
            .title {
                font-size: 2rem;
            }
            
            .game-logo {
                font-size: 3rem;
            }
            
            .header {
                flex-direction: column;
                gap: 20px;
            }
            
            .game-layout {
                flex-direction: column;
                gap: 20px;
            }
            
            .left-controls, .right-controls {
                min-width: auto;
                width: 100%;
            }
            
            .level-selector {
                flex-direction: row;
                flex-wrap: wrap;
            }
            
            .level-btn {
                flex: 1;
                min-width: 80px;
            }
            
            .game-grid {
                grid-template-columns: repeat(4, 1fr);
                max-width: 320px;
            }
            
            .pipe-cell {
                width: 50px;
                height: 50px;
            }
        }
    </style>
    <style>
    /* override: consistent global close button */
    .global-close-btn { position: fixed !important; top: 14px !important; right: 14px !important; z-index: 99999 !important; background: linear-gradient(45deg,#ff3b3b,#ff0066) !important; color: #fff !important; border: none !important; width:52px !important; height:52px !important; border-radius:50% !important; font-size:22px !important; cursor:pointer !important; display:flex !important;align-items:center !important;justify-content:center !important; box-shadow:0 8px 22px rgba(255,59,59,0.28) !important; }
    .global-close-btn:hover{ transform: scale(1.06); }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="title-section">
                <div class="game-logo">âš›ï¸</div>
                <div>
                    <h1 class="title">QUANTUM PIPES</h1>
                    <p class="subtitle" id="subtitle">Connectez les conduits quantiques avec l'IA</p>
                </div>
            </div>
            <button class="global-close-btn" title="Fermer" aria-label="Fermer" onclick="closePlatform()">âœ•</button>
            <div class="language-selector">
                <button class="language-btn" id="languageBtn">ğŸŒ FranÃ§ais</button>
                <div class="language-dropdown" id="languageDropdown">
                    <div class="language-option" data-lang="fr">ğŸ‡«ğŸ‡· FranÃ§ais</div>
                    <div class="language-option" data-lang="en">ğŸ‡¬ğŸ‡§ English</div>
                    <div class="language-option" data-lang="ar">ğŸ‡¸ğŸ‡¦ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©</div>
                    <div class="language-option" data-lang="es">ğŸ‡ªğŸ‡¸ EspaÃ±ol</div>
                    <div class="language-option" data-lang="de">ğŸ‡©ğŸ‡ª Deutsch</div>
                    <div class="language-option" data-lang="zh">ğŸ‡¨ğŸ‡³ ä¸­æ–‡</div>
                </div>
            </div>
        </div>

        <div class="game-layout">
            <div class="left-controls">
                <h3 style="color: #00ffff; margin-bottom: 15px;" id="levelsTitle">Niveaux</h3>
                <div class="level-selector">
                    <button class="level-btn active" data-level="1" id="level1">Niveau 1</button>
                    <button class="level-btn" data-level="2" id="level2">Niveau 2</button>
                    <button class="level-btn" data-level="3" id="level3">Niveau 3</button>
                </div>
                <button class="solution-btn" id="solutionBtn">ğŸ’¡ Solution</button>
            </div>

            <div class="game-area">
                <div class="game-info">
                    <div class="info-item">
                        <span id="movesLabel">Mouvements:</span> <span id="moves">0</span>
                    </div>
                    <div class="info-item">
                        <span id="timeLabel">Temps:</span> <span id="time">00:00</span>
                    </div>
                    <div class="info-item">
                        <span id="levelLabel">Niveau:</span> <span id="currentLevel">1</span>
                    </div>

                    <button class="ai-hint" id="aiHint">ğŸ¤– Indice IA</button>
                </div>
                <div class="game-grid" id="gameGrid"></div>
            </div>

            <div class="right-controls">
                <h3 style="color: #00ffff; margin-bottom: 15px;" id="actionsTitle">Actions</h3>
                <button class="rules-btn" id="rulesBtn">ğŸ“‹ RÃ¨gles</button>
                <button class="start-btn" id="startBtn">ğŸš€ Commencer</button>
                <button class="pause-btn" id="pauseBtn">â¸ï¸ Pause</button>
                <button class="new-game-btn" id="newGameBtn">ğŸ® Nouvelle Partie</button>
            </div>
        </div>
    </div>

    <!-- Modal des rÃ¨gles -->
    <div class="modal" id="rulesModal">
        <div class="modal-content">
            <button class="close-btn" id="closeRules">&times;</button>
            <h2 id="rulesTitle">RÃ¨gles du Jeu</h2>
            <div id="rulesContent">
                <p><strong>Objectif:</strong> Connectez la source quantique (ğŸ”´) Ã  la cible (ğŸŸ¢) en faisant tourner les conduits.</p>
                <p><strong>Comment jouer:</strong></p>
                <ul>
                    <li>Cliquez sur les conduits pour les faire tourner</li>
                    <li>CrÃ©ez un chemin continu de la source Ã  la cible</li>
                    <li>Utilisez l'IA pour obtenir des indices</li>
                    <li>Terminez en moins de mouvements possible</li>
                </ul>
                <p><strong>Symboles:</strong></p>
                <ul>
                    <li>ğŸ”´ Source quantique</li>
                    <li>ğŸŸ¢ Cible quantique</li>
                    <li>â” â”ƒ â” â”“ â”— â”› Conduits directionnels</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        // Traductions
        const translations = {
            fr: {
                subtitle: "Connectez les conduits quantiques avec l'IA",
                rules: "ğŸ“‹ RÃ¨gles",
                start: "ğŸš€ Commencer",
                level: "Niveau",

                moves: "Mouvements:",
                time: "Temps:",
                aiHint: "ğŸ¤– Indice IA",
                solution: "ğŸ’¡ Solution",
                pause: "â¸ï¸ Pause",
                resume: "â–¶ï¸ Reprendre",
                newGame: "ğŸ® Nouvelle Partie",
                levels: "Niveaux",
                actions: "Actions",
                rulesTitle: "RÃ¨gles du Jeu",
                gamePaused: "Jeu en pause",
                nextLevel: "Niveau suivant",
                rulesContent: `
                    <p><strong>Objectif:</strong> Connectez la source quantique (ğŸ”´) Ã  la cible (ğŸŸ¢) en faisant tourner les conduits.</p>
                    <p><strong>Comment jouer:</strong></p>
                    <ul>
                        <li>Cliquez sur les conduits pour les faire tourner</li>
                        <li>CrÃ©ez un chemin continu de la source Ã  la cible</li>
                        <li>Utilisez l'IA pour obtenir des indices</li>
                        <li>Terminez en moins de mouvements possible</li>
                    </ul>
                    <p><strong>Symboles:</strong></p>
                    <ul>
                        <li>ğŸ”´ Source quantique</li>
                        <li>ğŸŸ¢ Cible quantique</li>
                        <li>â” â”ƒ â” â”“ â”— â”› Conduits directionnels</li>
                    </ul>
                `
            },
            en: {
                subtitle: "Connect quantum pipes with AI assistance",
                rules: "ğŸ“‹ Rules",
                start: "ğŸš€ Start",
                level: "Level",

                moves: "Moves:",
                time: "Time:",
                aiHint: "ğŸ¤– AI Hint",
                solution: "ğŸ’¡ Solution",
                pause: "â¸ï¸ Pause",
                resume: "â–¶ï¸ Resume",
                newGame: "ğŸ® New Game",
                levels: "Levels",
                actions: "Actions",
                rulesTitle: "Game Rules",
                gamePaused: "Game Paused",
                nextLevel: "Next Level",
                rulesContent: `
                    <p><strong>Objective:</strong> Connect the quantum source (ğŸ”´) to the target (ğŸŸ¢) by rotating pipes.</p>
                    <p><strong>How to play:</strong></p>
                    <ul>
                        <li>Click on pipes to rotate them</li>
                        <li>Create a continuous path from source to target</li>
                        <li>Use AI for hints</li>
                        <li>Complete with minimum moves</li>
                    </ul>
                    <p><strong>Symbols:</strong></p>
                    <ul>
                        <li>ğŸ”´ Quantum source</li>
                        <li>ğŸŸ¢ Quantum target</li>
                        <li>â” â”ƒ â” â”“ â”— â”› Directional pipes</li>
                    </ul>
                `
            },
            ar: {
                subtitle: "Ø§Ø±Ø¨Ø· Ø§Ù„Ø£Ù†Ø§Ø¨ÙŠØ¨ Ø§Ù„ÙƒÙ…ÙŠØ© Ø¨Ù…Ø³Ø§Ø¹Ø¯Ø© Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ",
                rules: "ğŸ“‹ Ø§Ù„Ù‚ÙˆØ§Ø¹Ø¯",
                start: "ğŸš€ Ø§Ø¨Ø¯Ø£",
                level: "Ø§Ù„Ù…Ø³ØªÙˆÙ‰",
                game: "Ø§Ù„Ù„Ø¹Ø¨Ø©:",
                moves: "Ø§Ù„Ø­Ø±ÙƒØ§Øª:",
                time: "Ø§Ù„ÙˆÙ‚Øª:",
                aiHint: "ğŸ¤– ØªÙ„Ù…ÙŠØ­ Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ",
                solution: "ğŸ’¡ Ø§Ù„Ø­Ù„",
                pause: "â¸ï¸ Ø¥ÙŠÙ‚Ø§Ù",
                resume: "â–¶ï¸ Ø§Ø³ØªØ¦Ù†Ø§Ù",
                newGame: "ğŸ® Ù„Ø¹Ø¨Ø© Ø¬Ø¯ÙŠØ¯Ø©",
                levels: "Ø§Ù„Ù…Ø³ØªÙˆÙŠØ§Øª",
                actions: "Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª",
                rulesTitle: "Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„Ù„Ø¹Ø¨Ø©",
                gamePaused: "Ø§Ù„Ù„Ø¹Ø¨Ø© Ù…ØªÙˆÙ‚ÙØ©",
                nextLevel: "Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ØªØ§Ù„ÙŠ",
                rulesContent: `
                    <p><strong>Ø§Ù„Ù‡Ø¯Ù:</strong> Ø§Ø±Ø¨Ø· Ø§Ù„Ù…ØµØ¯Ø± Ø§Ù„ÙƒÙ…ÙŠ (ğŸ”´) Ø¨Ø§Ù„Ù‡Ø¯Ù (ğŸŸ¢) Ø¹Ù† Ø·Ø±ÙŠÙ‚ ØªØ¯ÙˆÙŠØ± Ø§Ù„Ø£Ù†Ø§Ø¨ÙŠØ¨.</p>
                    <p><strong>ÙƒÙŠÙÙŠØ© Ø§Ù„Ù„Ø¹Ø¨:</strong></p>
                    <ul>
                        <li>Ø§Ù†Ù‚Ø± Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù†Ø§Ø¨ÙŠØ¨ Ù„ØªØ¯ÙˆÙŠØ±Ù‡Ø§</li>
                        <li>Ø£Ù†Ø´Ø¦ Ù…Ø³Ø§Ø±Ù‹Ø§ Ù…Ø³ØªÙ…Ø±Ù‹Ø§ Ù…Ù† Ø§Ù„Ù…ØµØ¯Ø± Ø¥Ù„Ù‰ Ø§Ù„Ù‡Ø¯Ù</li>
                        <li>Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ ØªÙ„Ù…ÙŠØ­Ø§Øª</li>
                        <li>Ø£ÙƒÙ…Ù„ Ø¨Ø£Ù‚Ù„ Ø¹Ø¯Ø¯ Ù…Ù† Ø§Ù„Ø­Ø±ÙƒØ§Øª</li>
                    </ul>
                    <p><strong>Ø§Ù„Ø±Ù…ÙˆØ²:</strong></p>
                    <ul>
                        <li>ğŸ”´ Ø§Ù„Ù…ØµØ¯Ø± Ø§Ù„ÙƒÙ…ÙŠ</li>
                        <li>ğŸŸ¢ Ø§Ù„Ù‡Ø¯Ù Ø§Ù„ÙƒÙ…ÙŠ</li>
                        <li>â” â”ƒ â” â”“ â”— â”› Ø£Ù†Ø§Ø¨ÙŠØ¨ Ø§ØªØ¬Ø§Ù‡ÙŠØ©</li>
                    </ul>
                `
            },
            es: {
                subtitle: "Conecta tuberÃ­as cuÃ¡nticas con asistencia de IA",
                rules: "ğŸ“‹ Reglas",
                start: "ğŸš€ Comenzar",
                level: "Nivel",
                game: "Partida:",
                moves: "Movimientos:",
                time: "Tiempo:",
                aiHint: "ğŸ¤– Pista IA",
                solution: "ğŸ’¡ SoluciÃ³n",
                pause: "â¸ï¸ Pausa",
                resume: "â–¶ï¸ Reanudar",
                newGame: "ğŸ® Nuevo Juego",
                levels: "Niveles",
                actions: "Acciones",
                rulesTitle: "Reglas del Juego",
                gamePaused: "Juego Pausado",
                nextLevel: "Siguiente Nivel",
                rulesContent: `
                    <p><strong>Objetivo:</strong> Conecta la fuente cuÃ¡ntica (ğŸ”´) al objetivo (ğŸŸ¢) rotando tuberÃ­as.</p>
                    <p><strong>CÃ³mo jugar:</strong></p>
                    <ul>
                        <li>Haz clic en las tuberÃ­as para rotarlas</li>
                        <li>Crea un camino continuo desde la fuente al objetivo</li>
                        <li>Usa la IA para obtener pistas</li>
                        <li>Completa con el mÃ­nimo de movimientos</li>
                    </ul>
                    <p><strong>SÃ­mbolos:</strong></p>
                    <ul>
                        <li>ğŸ”´ Fuente cuÃ¡ntica</li>
                        <li>ğŸŸ¢ Objetivo cuÃ¡ntico</li>
                        <li>â” â”ƒ â” â”“ â”— â”› TuberÃ­as direccionales</li>
                    </ul>
                `
            },
            de: {
                subtitle: "Verbinde Quantenrohre mit KI-UnterstÃ¼tzung",
                rules: "ğŸ“‹ Regeln",
                start: "ğŸš€ Starten",
                level: "Level",
                game: "Spiel:",
                moves: "ZÃ¼ge:",
                time: "Zeit:",
                aiHint: "ğŸ¤– KI-Hinweis",
                solution: "ğŸ’¡ LÃ¶sung",
                pause: "â¸ï¸ Pause",
                resume: "â–¶ï¸ Fortsetzen",
                newGame: "ğŸ® Neues Spiel",
                levels: "Level",
                actions: "Aktionen",
                rulesTitle: "Spielregeln",
                gamePaused: "Spiel Pausiert",
                nextLevel: "NÃ¤chstes Level",
                rulesContent: `
                    <p><strong>Ziel:</strong> Verbinde die Quantenquelle (ğŸ”´) mit dem Ziel (ğŸŸ¢) durch Drehen der Rohre.</p>
                    <p><strong>Spielweise:</strong></p>
                    <ul>
                        <li>Klicke auf Rohre, um sie zu drehen</li>
                        <li>Erstelle einen durchgehenden Pfad von der Quelle zum Ziel</li>
                        <li>Nutze die KI fÃ¼r Hinweise</li>
                        <li>Beende mit minimalen ZÃ¼gen</li>
                    </ul>
                    <p><strong>Symbole:</strong></p>
                    <ul>
                        <li>ğŸ”´ Quantenquelle</li>
                        <li>ğŸŸ¢ Quantenziel</li>
                        <li>â” â”ƒ â” â”“ â”— â”› Richtungsrohre</li>
                    </ul>
                `
            },
            zh: {
                subtitle: "åœ¨AIååŠ©ä¸‹è¿æ¥é‡å­ç®¡é“",
                rules: "ğŸ“‹ è§„åˆ™",
                start: "ğŸš€ å¼€å§‹",
                level: "ç­‰çº§",
                game: "æ¸¸æˆ:",
                moves: "ç§»åŠ¨:",
                time: "æ—¶é—´:",
                aiHint: "ğŸ¤– AIæç¤º",
                solution: "ğŸ’¡ è§£å†³æ–¹æ¡ˆ",
                pause: "â¸ï¸ æš‚åœ",
                resume: "â–¶ï¸ ç»§ç»­",
                newGame: "ğŸ® æ–°æ¸¸æˆ",
                levels: "ç­‰çº§",
                actions: "æ“ä½œ",
                rulesTitle: "æ¸¸æˆè§„åˆ™",
                gamePaused: "æ¸¸æˆæš‚åœ",
                nextLevel: "ä¸‹ä¸€å…³",
                rulesContent: `
                    <p><strong>ç›®æ ‡:</strong> é€šè¿‡æ—‹è½¬ç®¡é“å°†é‡å­æº(ğŸ”´)è¿æ¥åˆ°ç›®æ ‡(ğŸŸ¢)ã€‚</p>
                    <p><strong>æ¸¸æˆæ–¹æ³•:</strong></p>
                    <ul>
                        <li>ç‚¹å‡»ç®¡é“æ¥æ—‹è½¬å®ƒä»¬</li>
                        <li>åˆ›å»ºä»æºåˆ°ç›®æ ‡çš„è¿ç»­è·¯å¾„</li>
                        <li>ä½¿ç”¨AIè·å–æç¤º</li>
                        <li>ç”¨æœ€å°‘çš„ç§»åŠ¨å®Œæˆ</li>
                    </ul>
                    <p><strong>ç¬¦å·:</strong></p>
                    <ul>
                        <li>ğŸ”´ é‡å­æº</li>
                        <li>ğŸŸ¢ é‡å­ç›®æ ‡</li>
                        <li>â” â”ƒ â” â”“ â”— â”› æ–¹å‘ç®¡é“</li>
                    </ul>
                `
            }
        };

        // Variables du jeu
        let currentLanguage = 'fr';
        let currentLevel = 1;
        let moves = 0;
        let gameTime = 0;
        let gameTimer = null;
        let gameGrid = [];
        let gridSize = { rows: 6, cols: 6 };
        let gamePaused = false;
        let gameNumber = 1;
        let maxGamesPerLevel = 100;

        // Types de conduits avec leurs connexions
        const pipeTypes = [
            { symbol: 'â”', connections: ['left', 'right'] },
            { symbol: 'â”ƒ', connections: ['top', 'bottom'] },
            { symbol: 'â”', connections: ['right', 'bottom'] },
            { symbol: 'â”“', connections: ['left', 'bottom'] },
            { symbol: 'â”—', connections: ['top', 'right'] },
            { symbol: 'â”›', connections: ['top', 'left'] }
        ];
        
        // Ã‰tat du jeu
        let gameStarted = false;
        let levelCompleted = false;
        
        // Initialisation
        document.addEventListener('DOMContentLoaded', function() {
            initializeGame();
            setupEventListeners();
        });

        function setupEventListeners() {
            // SÃ©lecteur de langue
            document.getElementById('languageBtn').addEventListener('click', function() {
                const dropdown = document.getElementById('languageDropdown');
                dropdown.classList.toggle('show');
            });

            // Options de langue
            document.querySelectorAll('.language-option').forEach(option => {
                option.addEventListener('click', function() {
                    const lang = this.dataset.lang;
                    changeLanguage(lang);
                    document.getElementById('languageDropdown').classList.remove('show');
                });
            });

            // Boutons de niveau
            document.querySelectorAll('.level-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.level-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    currentLevel = parseInt(this.dataset.level);
                    document.getElementById('currentLevel').textContent = currentLevel;
                    gameNumber = 1; // RÃ©initialiser le compteur pour le nouveau niveau
                    generateLevel();
                });
            });

            // Boutons de contrÃ´le
            document.getElementById('rulesBtn').addEventListener('click', showRules);
            document.getElementById('startBtn').addEventListener('click', startNewGame);
            document.getElementById('closeRules').addEventListener('click', hideRules);
            document.getElementById('aiHint').addEventListener('click', showAIHint);
            document.getElementById('solutionBtn').addEventListener('click', showSolution);
            document.getElementById('pauseBtn').addEventListener('click', togglePause);
            document.getElementById('newGameBtn').addEventListener('click', startNewGame);

            // Fermer dropdown en cliquant ailleurs
            document.addEventListener('click', function(e) {
                if (!e.target.closest('.language-selector')) {
                    document.getElementById('languageDropdown').classList.remove('show');
                }
            });
        }

        function changeLanguage(lang) {
            currentLanguage = lang;
            const t = translations[lang];
            
            // Mettre Ã  jour les textes
            document.getElementById('subtitle').textContent = t.subtitle;
            document.getElementById('rulesBtn').innerHTML = t.rules;
            document.getElementById('startBtn').innerHTML = t.start;
            document.getElementById('movesLabel').textContent = t.moves;
            document.getElementById('timeLabel').textContent = t.time;
            document.getElementById('levelLabel').textContent = t.level + ':';
            document.getElementById('aiHint').innerHTML = t.aiHint;
            document.getElementById('solutionBtn').innerHTML = t.solution;
            document.getElementById('pauseBtn').innerHTML = gamePaused ? t.resume : t.pause;
            document.getElementById('newGameBtn').innerHTML = t.newGame;
            document.getElementById('levelsTitle').textContent = t.levels;
            document.getElementById('actionsTitle').textContent = t.actions;
            
            // Mettre Ã  jour les boutons de niveau
            for (let i = 1; i <= 3; i++) {
                document.getElementById(`level${i}`).textContent = `${t.level} ${i}`;
            }
            
            // Mettre Ã  jour le bouton de langue
            const flags = { fr: 'ğŸ‡«ğŸ‡·', en: 'ğŸ‡¬ğŸ‡§', ar: 'ğŸ‡¸ğŸ‡¦', es: 'ğŸ‡ªğŸ‡¸', de: 'ğŸ‡©ğŸ‡ª', zh: 'ğŸ‡¨ğŸ‡³' };
            const names = { fr: 'FranÃ§ais', en: 'English', ar: 'Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©', es: 'EspaÃ±ol', de: 'Deutsch', zh: 'ä¸­æ–‡' };
            document.getElementById('languageBtn').innerHTML = `ğŸŒ ${names[lang]}`;
        }

        function initializeGame() {
            generateLevel();
            updateDisplay();
        }

        function generateLevel() {
            const gridElement = document.getElementById('gameGrid');
            gridElement.innerHTML = '';
            
            // Ajuster la taille de la grille selon le niveau
            const sizes = [
                { rows: 4, cols: 4 },
                { rows: 5, cols: 5 },
                { rows: 6, cols: 6 }
            ];
            
            gridSize = sizes[currentLevel - 1];
            gridElement.style.gridTemplateColumns = `repeat(${gridSize.cols}, 1fr)`;
            
            // GÃ©nÃ©rer un niveau simple avec variation limitÃ©e
            generateSimpleLevel();
            resetGame();
        }



        function generateSimpleLevel() {
            // GÃ©nÃ©rer un niveau simple avec variation limitÃ©e
            const sourcePos = 0;
            const targetPos = gridSize.rows * gridSize.cols - 1;
            
            gameGrid = [];
            const gridElement = document.getElementById('gameGrid');
            gridElement.innerHTML = '';
            
            for (let i = 0; i < gridSize.rows * gridSize.cols; i++) {
                const cell = document.createElement('div');
                cell.className = 'pipe-cell';
                cell.dataset.index = i;
                
                let cellData;
                
                if (i === sourcePos) {
                    cell.classList.add('source');
                    cell.innerHTML = '<span class="pipe-symbol">ğŸ”´</span>';
                    cellData = {
                        type: 'source',
                        symbol: 'ğŸ”´',
                        connections: ['right', 'bottom'],
                        rotation: 0,
                        connected: false,
                        isFixed: true
                    };
                } else if (i === targetPos) {
                    cell.classList.add('target');
                    cell.innerHTML = '<span class="pipe-symbol">ğŸŸ¢</span>';
                    cellData = {
                        type: 'target',
                        symbol: 'ğŸŸ¢',
                        connections: ['left', 'top'],
                        rotation: 0,
                        connected: false,
                        isFixed: true
                    };
                } else {
                    // Variation simple basÃ©e sur le numÃ©ro de partie (limitÃ© Ã  100)
                    const variation = (gameNumber - 1) % maxGamesPerLevel;
                    const pipeIndex = (i + variation) % 3; // Seulement les 3 premiers types
                    const pipe = pipeTypes[pipeIndex];
                    const rotation = ((i * variation) % 4) * 90; // Rotation basÃ©e sur position et variation
                    
                    cell.innerHTML = `<span class="pipe-symbol">${pipe.symbol}</span>`;
                    cell.addEventListener('click', () => rotatePipe(i));
                    
                    cellData = {
                        type: 'pipe',
                        symbol: pipe.symbol,
                        connections: rotateConnections(pipe.connections, rotation / 90),
                        rotation: rotation,
                        connected: false,
                        isFixed: false,
                        pipeIndex: pipeIndex
                    };
                    
                    cell.style.transform = `rotate(${rotation}deg)`;
                }
                
                gridElement.appendChild(cell);
                gameGrid.push(cellData);
            }
        }

        function rotateConnections(connections, rotations) {
            let result = [...connections];
            for (let i = 0; i < rotations; i++) {
                result = result.map(conn => {
                    switch(conn) {
                        case 'top': return 'right';
                        case 'right': return 'bottom';
                        case 'bottom': return 'left';
                        case 'left': return 'top';
                        default: return conn;
                    }
                });
            }
            return result;
        }



        function togglePause() {
            if (!gameStarted) return;
            
            gamePaused = !gamePaused;
            const t = translations[currentLanguage];
            
            if (gamePaused) {
                if (gameTimer) clearInterval(gameTimer);
                document.getElementById('pauseBtn').innerHTML = t.resume;
                
                // DÃ©sactiver les interactions avec la grille
                document.querySelectorAll('.pipe-cell').forEach(cell => {
                    cell.style.pointerEvents = 'none';
                    cell.style.opacity = '0.5';
                });
                
                try{ parent.postMessage({ action: 'dialog', dialogType: 'alert', text: t.gamePaused }, '*'); }catch(e){}
            } else {
                gameTimer = setInterval(() => {
                    gameTime++;
                    updateDisplay();
                }, 1000);
                document.getElementById('pauseBtn').innerHTML = t.pause;
                
                // RÃ©activer les interactions avec la grille
                document.querySelectorAll('.pipe-cell').forEach(cell => {
                    cell.style.pointerEvents = 'auto';
                    cell.style.opacity = '1';
                });
            }
        }

        function rotatePipe(index) {
            if (gamePaused || levelCompleted) return;
            
            if (!gameStarted) {
                gameStarted = true;
                if (gameTimer) clearInterval(gameTimer);
                gameTimer = setInterval(() => {
                    if (!gamePaused) {
                        gameTime++;
                        updateDisplay();
                    }
                }, 1000);
            }
            
            if (gameGrid[index].type === 'pipe' && !gameGrid[index].isFixed && !levelCompleted) {
                // Faire tourner les connexions de 90 degrÃ©s
                const connections = gameGrid[index].connections;
                const rotatedConnections = connections.map(conn => {
                    switch(conn) {
                        case 'top': return 'right';
                        case 'right': return 'bottom';
                        case 'bottom': return 'left';
                        case 'left': return 'top';
                        default: return conn;
                    }
                });
                
                gameGrid[index].connections = rotatedConnections;
                gameGrid[index].rotation = (gameGrid[index].rotation + 90) % 360;
                
                const cell = document.querySelector(`[data-index="${index}"]`);
                cell.style.transform = `rotate(${gameGrid[index].rotation}deg)`;
                
                // Effet visuel de rotation
                cell.style.transition = 'transform 0.3s ease';
                setTimeout(() => {
                    cell.style.transition = '';
                }, 300);
                
                moves++;
                updateDisplay();
                checkConnections();
            }
        }

        function checkConnections() {
            // RÃ©initialiser toutes les connexions
            gameGrid.forEach((cell, index) => {
                cell.connected = false;
                const cellElement = document.querySelector(`[data-index="${index}"]`);
                cellElement.classList.remove('connected', 'solution-path');
            });
            
            // Algorithme de recherche en profondeur pour trouver le chemin
            const visited = new Set();
            const connectedCells = new Set();
            const solutionPath = [];
            
            function dfs(index, path = []) {
                if (visited.has(index)) return false;
                visited.add(index);
                connectedCells.add(index);
                path.push(index);
                
                const cell = gameGrid[index];
                const row = Math.floor(index / gridSize.cols);
                const col = index % gridSize.cols;
                
                // VÃ©rifier les connexions dans toutes les directions
                const directions = [
                    { name: 'top', row: row - 1, col: col, opposite: 'bottom' },
                    { name: 'right', row: row, col: col + 1, opposite: 'left' },
                    { name: 'bottom', row: row + 1, col: col, opposite: 'top' },
                    { name: 'left', row: row, col: col - 1, opposite: 'right' }
                ];
                
                for (const dir of directions) {
                    if (dir.row >= 0 && dir.row < gridSize.rows && 
                        dir.col >= 0 && dir.col < gridSize.cols) {
                        
                        const neighborIndex = dir.row * gridSize.cols + dir.col;
                        const neighbor = gameGrid[neighborIndex];
                        
                        // VÃ©rifier si cette cellule a une connexion dans cette direction
                        if (cell.connections.includes(dir.name) && 
                            neighbor.connections.includes(dir.opposite)) {
                            
                            if (neighbor.type === 'target') {
                                solutionPath.push(...path, neighborIndex);
                                return true; // Chemin trouvÃ© vers la cible!
                            }
                            
                            if (!visited.has(neighborIndex)) {
                                if (dfs(neighborIndex, [...path])) {
                                    return true;
                                }
                            }
                        }
                    }
                }
                
                return false;
            }
            
            // Commencer la recherche depuis la source
            const sourceIndex = 0;
            const pathFound = dfs(sourceIndex);
            
            // Marquer visuellement les cellules connectÃ©es
            if (pathFound && solutionPath.length > 0) {
                // Chemin de solution trouvÃ© - utiliser la couleur dorÃ©e
                solutionPath.forEach(index => {
                    gameGrid[index].connected = true;
                    const cellElement = document.querySelector(`[data-index="${index}"]`);
                    cellElement.classList.add('solution-path');
                });
                
                levelCompleted = true;
                if (gameTimer) clearInterval(gameTimer);
                
                setTimeout(() => {
                    const t = translations[currentLanguage];
                    const message = currentLanguage === 'fr' ? 
                        `ğŸ‰ Niveau ${currentLevel} terminÃ© en ${moves} mouvements et ${Math.floor(gameTime/60)}:${(gameTime%60).toString().padStart(2,'0')}!` :
                        currentLanguage === 'en' ?
                        `ğŸ‰ Level ${currentLevel} completed in ${moves} moves and ${Math.floor(gameTime/60)}:${(gameTime%60).toString().padStart(2,'0')}!` :
                        currentLanguage === 'es' ?
                        `ğŸ‰ Nivel ${currentLevel} completado en ${moves} movimientos y ${Math.floor(gameTime/60)}:${(gameTime%60).toString().padStart(2,'0')}!` :
                        currentLanguage === 'de' ?
                        `ğŸ‰ Level ${currentLevel} abgeschlossen in ${moves} ZÃ¼gen und ${Math.floor(gameTime/60)}:${(gameTime%60).toString().padStart(2,'0')}!` :
                        currentLanguage === 'zh' ?
                        `ğŸ‰ ç¬¬${currentLevel}å…³å®Œæˆï¼Œç”¨æ—¶${moves}æ­¥å’Œ${Math.floor(gameTime/60)}:${(gameTime%60).toString().padStart(2,'0')}!` :
                        currentLanguage === 'ar' ?
                        `ğŸ‰ Ø§Ù„Ù…Ø³ØªÙˆÙ‰ ${currentLevel} Ù…ÙƒØªÙ…Ù„ ÙÙŠ ${moves} Ø­Ø±ÙƒØ§Øª Ùˆ ${Math.floor(gameTime/60)}:${(gameTime%60).toString().padStart(2,'0')}!` :
                        `ğŸ‰ Niveau ${currentLevel} terminÃ© en ${moves} mouvements!`;
                    
                    try{ parent.postMessage({ action: 'dialog', dialogType: 'alert', text: message }, '*'); }catch(e){}
                    
                    // Auto-avancer au niveau suivant si disponible
                    if (currentLevel < 3) {
                        setTimeout(() => {
                            const t = translations[currentLanguage];
                            if (confirm(`${t.nextLevel} ${currentLevel + 1}?`)) {
                                const nextLevelBtn = document.querySelector(`[data-level="${currentLevel + 1}"]`);
                                if (nextLevelBtn) {
                                    nextLevelBtn.click();
                                }
                            }
                        }, 1000);
                    }
                }, 500);
            } else {
                // Pas de solution complÃ¨te - marquer seulement les connexions partielles en bleu
                connectedCells.forEach(index => {
                    gameGrid[index].connected = true;
                    const cellElement = document.querySelector(`[data-index="${index}"]`);
                    cellElement.classList.add('connected');
                });
            }
        }

        function startNewGame() {
            levelCompleted = false;
            gameStarted = false;
            
            // VÃ©rifier la limite de 100 parties par niveau
            if (gameNumber >= maxGamesPerLevel) {
                const limitMessages = {
                    fr: `âš ï¸ Limite atteinte! Maximum ${maxGamesPerLevel} parties par niveau. Changez de niveau pour continuer.`,
                    en: `âš ï¸ Limit reached! Maximum ${maxGamesPerLevel} games per level. Change level to continue.`,
                    ar: `âš ï¸ ØªÙ… Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰! Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ ${maxGamesPerLevel} Ù„Ø¹Ø¨Ø© Ù„ÙƒÙ„ Ù…Ø³ØªÙˆÙ‰. ØºÙŠØ± Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ù„Ù„Ù…ØªØ§Ø¨Ø¹Ø©.`,
                    es: `âš ï¸ Â¡LÃ­mite alcanzado! MÃ¡ximo ${maxGamesPerLevel} juegos por nivel. Cambia de nivel para continuar.`,
                    de: `âš ï¸ Limit erreicht! Maximum ${maxGamesPerLevel} Spiele pro Level. Level wechseln um fortzufahren.`,
                    zh: `âš ï¸ å·²è¾¾åˆ°é™åˆ¶ï¼æ¯å…³æœ€å¤š${maxGamesPerLevel}ä¸ªæ¸¸æˆã€‚æ›´æ¢å…³å¡ä»¥ç»§ç»­ã€‚`
                };
                
                const message = limitMessages[currentLanguage] || limitMessages.fr;
                try{ parent.postMessage({ action: 'dialog', dialogType: 'alert', text: message }, '*'); }catch(e){}
                return;
            }
            
            gameNumber++; // IncrÃ©menter pour gÃ©nÃ©rer un nouveau niveau
            generateLevel();
        }

        function resetGame() {
            moves = 0;
            gameTime = 0;
            gameStarted = false;
            levelCompleted = false;
            gamePaused = false;
            if (gameTimer) clearInterval(gameTimer);
            
            // RÃ©initialiser le bouton pause
            const t = translations[currentLanguage];
            document.getElementById('pauseBtn').innerHTML = t.pause;
            
            updateDisplay();
        }

        function updateDisplay() {
            document.getElementById('moves').textContent = moves;
            document.getElementById('currentLevel').textContent = currentLevel;
            
            const minutes = Math.floor(gameTime / 60);
            const seconds = gameTime % 60;
            document.getElementById('time').textContent = 
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        function showRules() {
            const modal = document.getElementById('rulesModal');
            const t = translations[currentLanguage];
            
            document.getElementById('rulesTitle').textContent = t.rulesTitle;
            document.getElementById('rulesContent').innerHTML = t.rulesContent;
            
            modal.style.display = 'block';
        }

        function hideRules() {
            document.getElementById('rulesModal').style.display = 'none';
        }

        function showAIHint() {
            if (levelCompleted) return;
            
            // Analyser la grille pour donner un indice intelligent
            const sourceIndex = 0;
            const targetIndex = gridSize.rows * gridSize.cols - 1;
            
            // Trouver les cellules adjacentes Ã  la source
            const sourceRow = Math.floor(sourceIndex / gridSize.cols);
            const sourceCol = sourceIndex % gridSize.cols;
            
            const adjacentCells = [];
            const directions = [
                { name: 'right', row: sourceRow, col: sourceCol + 1, dir: 'droite' },
                { name: 'bottom', row: sourceRow + 1, col: sourceCol, dir: 'bas' }
            ];
            
            for (const dir of directions) {
                if (dir.row >= 0 && dir.row < gridSize.rows && 
                    dir.col >= 0 && dir.col < gridSize.cols) {
                    const index = dir.row * gridSize.cols + dir.col;
                    adjacentCells.push({ index, direction: dir.dir, name: dir.name });
                }
            }
            
            // Analyser les connexions actuelles
            let bestHint = null;
            for (const adj of adjacentCells) {
                const cell = gameGrid[adj.index];
                if (cell.type === 'pipe') {
                    const needsConnection = adj.name === 'right' ? 'left' : 'top';
                    if (!cell.connections.includes(needsConnection)) {
                        bestHint = adj;
                        break;
                    }
                }
            }
            
            const hints = {
                fr: {
                    general: [
                        "ğŸ’¡ Commencez par connecter la source rouge aux conduits adjacents",
                        "ğŸ¤– Cherchez un chemin direct vers la cible verte",
                        "âš¡ Les conduits doivent s'aligner parfaitement pour se connecter",
                        "ğŸ”® Essayez de crÃ©er un chemin continu sans interruption"
                    ],
                    specific: bestHint ? `ğŸ¯ Essayez de faire tourner le conduit Ã  ${bestHint.direction} de la source` : null
                },
                en: {
                    general: [
                        "ğŸ’¡ Start by connecting the red source to adjacent pipes",
                        "ğŸ¤– Look for a direct path to the green target",
                        "âš¡ Pipes must align perfectly to connect",
                        "ğŸ”® Try to create a continuous path without interruption"
                    ],
                    specific: bestHint ? `ğŸ¯ Try rotating the pipe to the ${bestHint.direction === 'droite' ? 'right' : 'bottom'} of the source` : null
                },
                ar: {
                    general: [
                        "ğŸ’¡ Ø§Ø¨Ø¯Ø£ Ø¨Ø±Ø¨Ø· Ø§Ù„Ù…ØµØ¯Ø± Ø§Ù„Ø£Ø­Ù…Ø± Ø¨Ø§Ù„Ø£Ù†Ø§Ø¨ÙŠØ¨ Ø§Ù„Ù…Ø¬Ø§ÙˆØ±Ø©",
                        "ğŸ¤– Ø§Ø¨Ø­Ø« Ø¹Ù† Ù…Ø³Ø§Ø± Ù…Ø¨Ø§Ø´Ø± Ø¥Ù„Ù‰ Ø§Ù„Ù‡Ø¯Ù Ø§Ù„Ø£Ø®Ø¶Ø±",
                        "âš¡ ÙŠØ¬Ø¨ Ø£Ù† ØªØªÙ…Ø§Ø´Ù‰ Ø§Ù„Ø£Ù†Ø§Ø¨ÙŠØ¨ ØªÙ…Ø§Ù…Ø§Ù‹ Ù„Ù„Ø§ØªØµØ§Ù„",
                        "ğŸ”® Ø­Ø§ÙˆÙ„ Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø³Ø§Ø± Ù…Ø³ØªÙ…Ø± Ø¨Ø¯ÙˆÙ† Ø§Ù†Ù‚Ø·Ø§Ø¹"
                    ],
                    specific: bestHint ? `ğŸ¯ Ø­Ø§ÙˆÙ„ ØªØ¯ÙˆÙŠØ± Ø§Ù„Ø£Ù†Ø¨ÙˆØ¨ ${bestHint.direction === 'droite' ? 'ÙŠÙ…ÙŠÙ†' : 'Ø£Ø³ÙÙ„'} Ø§Ù„Ù…ØµØ¯Ø±` : null
                },
                es: {
                    general: [
                        "ğŸ’¡ Comienza conectando la fuente roja a tuberÃ­as adyacentes",
                        "ğŸ¤– Busca un camino directo al objetivo verde",
                        "âš¡ Las tuberÃ­as deben alinearse perfectamente para conectar",
                        "ğŸ”® Intenta crear un camino continuo sin interrupciones"
                    ],
                    specific: bestHint ? `ğŸ¯ Intenta rotar la tuberÃ­a a la ${bestHint.direction === 'droite' ? 'derecha' : 'abajo'} de la fuente` : null
                },
                de: {
                    general: [
                        "ğŸ’¡ Beginne damit, die rote Quelle mit benachbarten Rohren zu verbinden",
                        "ğŸ¤– Suche einen direkten Pfad zum grÃ¼nen Ziel",
                        "âš¡ Rohre mÃ¼ssen perfekt ausgerichtet sein, um sich zu verbinden",
                        "ğŸ”® Versuche einen kontinuierlichen Pfad ohne Unterbrechung zu erstellen"
                    ],
                    specific: bestHint ? `ğŸ¯ Versuche das Rohr ${bestHint.direction === 'droite' ? 'rechts' : 'unten'} von der Quelle zu drehen` : null
                },
                zh: {
                    general: [
                        "ğŸ’¡ ä»è¿æ¥çº¢è‰²æºåˆ°ç›¸é‚»ç®¡é“å¼€å§‹",
                        "ğŸ¤– å¯»æ‰¾åˆ°ç»¿è‰²ç›®æ ‡çš„ç›´æ¥è·¯å¾„",
                        "âš¡ ç®¡é“å¿…é¡»å®Œç¾å¯¹é½æ‰èƒ½è¿æ¥",
                        "ğŸ”® å°è¯•åˆ›å»ºä¸€ä¸ªè¿ç»­çš„è·¯å¾„"
                    ],
                    specific: bestHint ? `ğŸ¯ å°è¯•æ—‹è½¬æº${bestHint.direction === 'droite' ? 'å³ä¾§' : 'ä¸‹æ–¹'}çš„ç®¡é“` : null
                }
            };
            
            const langHints = hints[currentLanguage] || hints.fr;
            let hintMessage;
            
            if (langHints.specific && Math.random() > 0.3) {
                hintMessage = langHints.specific;
            } else {
                hintMessage = langHints.general[Math.floor(Math.random() * langHints.general.length)];
            }
            
            try{ parent.postMessage({ action: 'dialog', dialogType: 'alert', text: hintMessage }, '*'); }catch(e){}
        }

        function showSolution() {
            if (levelCompleted) return;
            
            const solutionMessages = {
                fr: "ğŸ¤– RÃ©solution automatique du niveau " + currentLevel + "...",
                en: "ğŸ¤– Automatically solving level " + currentLevel + "...",
                ar: "ğŸ¤– Ø­Ù„ ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù„Ù„Ù…Ø³ØªÙˆÙ‰ " + currentLevel + "...",
                es: "ğŸ¤– Resolviendo automÃ¡ticamente el nivel " + currentLevel + "...",
                de: "ğŸ¤– Automatisches LÃ¶sen von Level " + currentLevel + "...",
                zh: "ğŸ¤– è‡ªåŠ¨è§£å†³ç¬¬" + currentLevel + "å…³..."
            };
            
            const message = solutionMessages[currentLanguage] || solutionMessages.fr;
            try{ parent.postMessage({ action: 'dialog', dialogType: 'alert', text: message }, '*'); }catch(e){}
            
            // DÃ©marrer le jeu si pas encore commencÃ©
            if (!gameStarted) {
                gameStarted = true;
                if (gameTimer) clearInterval(gameTimer);
                gameTimer = setInterval(() => {
                    gameTime++;
                    updateDisplay();
                }, 1000);
            }
            
            // Algorithme de rÃ©solution automatique
            setTimeout(() => {
                solvePuzzleAutomatically();
            }, 1000);
        }

        function solvePuzzleAutomatically() {
            // DÃ©marrer le jeu si pas encore commencÃ©
            if (!gameStarted) {
                gameStarted = true;
                if (gameTimer) clearInterval(gameTimer);
                gameTimer = setInterval(() => {
                    gameTime++;
                    updateDisplay();
                }, 1000);
            }
            
            // Algorithme de rÃ©solution avec limite de 150 coups maximum
            let attempts = 0;
            const maxAttempts = 200; // Augmenter les tentatives
            const maxSolutionMoves = 150; // Limite de coups pour la solution uniquement
            const initialMoves = moves; // Sauvegarder le nombre de coups initial
            let solutionMoves = 0; // Compteur sÃ©parÃ© pour les coups de solution
            
            function testSolution() {
                const visited = new Set();
                
                function dfs(index) {
                    if (visited.has(index)) return false;
                    visited.add(index);
                    
                    const cell = gameGrid[index];
                    const row = Math.floor(index / gridSize.cols);
                    const col = index % gridSize.cols;
                    
                    const directions = [
                        { name: 'top', row: row - 1, col: col, opposite: 'bottom' },
                        { name: 'right', row: row, col: col + 1, opposite: 'left' },
                        { name: 'bottom', row: row + 1, col: col, opposite: 'top' },
                        { name: 'left', row: row, col: col - 1, opposite: 'right' }
                    ];
                    
                    for (const dir of directions) {
                        if (dir.row >= 0 && dir.row < gridSize.rows && 
                            dir.col >= 0 && dir.col < gridSize.cols) {
                            
                            const neighborIndex = dir.row * gridSize.cols + dir.col;
                            const neighbor = gameGrid[neighborIndex];
                            
                            if (cell.connections.includes(dir.name) && 
                                neighbor.connections.includes(dir.opposite)) {
                                
                                if (neighbor.type === 'target') {
                                    return true;
                                }
                                
                                if (!visited.has(neighborIndex)) {
                                    if (dfs(neighborIndex)) {
                                        return true;
                                    }
                                }
                            }
                        }
                    }
                    return false;
                }
                
                return dfs(0);
            }
            
            function solve() {
                // VÃ©rifier si on a dÃ©passÃ© la limite de coups de solution
                if (solutionMoves >= maxSolutionMoves) {
                    const limitMessages = {
                        fr: `âš ï¸ Limite de ${maxSolutionMoves} coups atteinte! Solution arrÃªtÃ©e.`,
                        en: `âš ï¸ ${maxSolutionMoves} moves limit reached! Solution stopped.`,
                        ar: `âš ï¸ ØªÙ… Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ø­Ø¯ ${maxSolutionMoves} Ø­Ø±ÙƒØ©! ØªÙˆÙ‚Ù Ø§Ù„Ø­Ù„.`,
                        es: `âš ï¸ Â¡LÃ­mite de ${maxSolutionMoves} movimientos alcanzado! SoluciÃ³n detenida.`,
                        de: `âš ï¸ ${maxSolutionMoves} ZÃ¼ge-Limit erreicht! LÃ¶sung gestoppt.`,
                        zh: `âš ï¸ å·²è¾¾åˆ°${maxSolutionMoves}æ­¥é™åˆ¶ï¼è§£å†³æ–¹æ¡ˆå·²åœæ­¢ã€‚`
                    };
                    try{ parent.postMessage({ action: 'dialog', dialogType: 'alert', text: (limitMessages[currentLanguage] || limitMessages.fr) }, '*'); }catch(e){}
                    return;
                }
                
                if (attempts >= maxAttempts) {
                    const failMessages = {
                        fr: `âŒ Solution non trouvÃ©e en ${maxSolutionMoves} coups max. Essayez manuellement!`,
                        en: `âŒ Solution not found within ${maxSolutionMoves} moves. Try manually!`,
                        ar: `âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø­Ù„ ÙÙŠ ${maxSolutionMoves} Ø­Ø±ÙƒØ© ÙƒØ­Ø¯ Ø£Ù‚ØµÙ‰. Ø¬Ø±Ø¨ ÙŠØ¯ÙˆÙŠØ§Ù‹!`,
                        es: `âŒ SoluciÃ³n no encontrada en mÃ¡ximo ${maxSolutionMoves} movimientos. Â¡IntÃ©ntalo manualmente!`,
                        de: `âŒ LÃ¶sung nicht in max. ${maxSolutionMoves} ZÃ¼gen gefunden. Versuche es manuell!`,
                        zh: `âŒ åœ¨æœ€å¤š${maxSolutionMoves}æ­¥å†…æœªæ‰¾åˆ°è§£å†³æ–¹æ¡ˆã€‚è¯·æ‰‹åŠ¨å°è¯•ï¼`
                    };
                    try{ parent.postMessage({ action: 'dialog', dialogType: 'alert', text: (failMessages[currentLanguage] || failMessages.fr) }, '*'); }catch(e){}
                    return;
                }
                
                attempts++;
                
                if (testSolution()) {
                    checkConnections();
                    
                    // Afficher le nombre de coups utilisÃ©s pour la solution
                    const successMessages = {
                        fr: `âœ… Solution trouvÃ©e en ${solutionMoves} coups!`,
                        en: `âœ… Solution found in ${solutionMoves} moves!`,
                        ar: `âœ… ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ø­Ù„ ÙÙŠ ${solutionMoves} Ø­Ø±ÙƒØ©!`,
                        es: `âœ… Â¡SoluciÃ³n encontrada en ${solutionMoves} movimientos!`,
                        de: `âœ… LÃ¶sung in ${solutionMoves} ZÃ¼gen gefunden!`,
                        zh: `âœ… åœ¨${solutionMoves}æ­¥å†…æ‰¾åˆ°è§£å†³æ–¹æ¡ˆï¼`
                    };
                    
                    setTimeout(() => {
                        try{ parent.postMessage({ action: 'dialog', dialogType: 'alert', text: (successMessages[currentLanguage] || successMessages.fr) }, '*'); }catch(e){}
                    }, 1000);
                    return;
                }
                
                // Faire tourner un conduit alÃ©atoire
                const pipeIndices = [];
                gameGrid.forEach((cell, index) => {
                    if (cell.type === 'pipe' && !cell.isFixed) {
                        pipeIndices.push(index);
                    }
                });
                
                if (pipeIndices.length > 0) {
                    const randomPipeIndex = pipeIndices[Math.floor(Math.random() * pipeIndices.length)];
                    
                    // Faire la rotation manuellement pour contrÃ´ler le comptage
                    if (gameGrid[randomPipeIndex].type === 'pipe' && !gameGrid[randomPipeIndex].isFixed) {
                        // Faire tourner les connexions de 90 degrÃ©s
                        const connections = gameGrid[randomPipeIndex].connections;
                        const rotatedConnections = connections.map(conn => {
                            switch(conn) {
                                case 'top': return 'right';
                                case 'right': return 'bottom';
                                case 'bottom': return 'left';
                                case 'left': return 'top';
                                default: return conn;
                            }
                        });
                        
                        gameGrid[randomPipeIndex].connections = rotatedConnections;
                        gameGrid[randomPipeIndex].rotation = (gameGrid[randomPipeIndex].rotation + 90) % 360;
                        
                        const cell = document.querySelector(`[data-index="${randomPipeIndex}"]`);
                        cell.style.transform = `rotate(${gameGrid[randomPipeIndex].rotation}deg)`;
                        cell.style.transition = 'transform 0.1s ease';
                        
                        // IncrÃ©menter seulement le compteur de solution
                        solutionMoves++;
                        moves++; // Aussi le compteur global pour l'affichage
                        updateDisplay();
                    }
                    
                    setTimeout(solve, 50); // RÃ©duire le dÃ©lai pour plus de fluiditÃ©
                }
            }
            
            solve();
        }

    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'9874168571c611be',t:'MTc1OTIzOTE2My4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>

<script>
    // canonical close handler for platform overlay (jeux22)
    function closePlatform(){
        try{ console.debug('jeux22: closePlatform called'); }catch(e){}
        try{
            if(window.parent && window.parent !== window){
                window.parent.postMessage({ action:'close', reason:'user-initiated', source:'jeux22' }, '*');
                return;
            }
        }catch(e){}
        try{
            if(window.opener && !window.opener.closed){
                try{ window.opener.postMessage({ action:'child-closed', source:'jeux22' }, '*'); }catch(e){}
                try{ window.close(); }catch(e){}
                return;
            }
        }catch(e){}
        // final fallback: absolute path to platform
    try{ window.location.href = new URL('./brainova.html', window.location.href).href; }catch(e){ window.location.href = './brainova.html'; }
    }
    window.closePlatform = closePlatform;
</script>
