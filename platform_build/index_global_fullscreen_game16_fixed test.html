<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brainova - Jeux Intelligents 2077</title>
    <script>
        (function(){
            if(window.__platform_nonblocking_dialogs) return; window.__platform_nonblocking_dialogs=true;
            try{
                const _alert = window.alert.bind(window);
                const _confirm = window.confirm.bind(window);
                const _prompt = window.prompt.bind(window);
                function send(type,text){ try{ if(window.parent && window.parent!==window) parent.postMessage({action:'dialog', dialogType:type, text:String(text||'')}, '*'); }catch(e){} }
                window.alert = function(msg){ if(window.parent && window.parent!==window){ send('alert', msg); } else { _alert(msg); } };
                window.confirm = function(msg){ if(window.parent && window.parent!==window){ send('confirm', msg); return true; } else { return _confirm(msg); } };
                window.prompt = function(msg, def){ if(window.parent && window.parent!==window){ send('prompt', msg+'\n(default: '+(def||'')+')'); return def||null; } else { return _prompt(msg, def); } };
            }catch(e){ }
        })();
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@300;400;700;900&family=Rajdhani:wght@300;400;600;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Rajdhani', sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            color: #ffffff;
            overflow-x: hidden;

        
        /* Header */
        .header {
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(26, 26, 46, 0.9));
            backdrop-filter: blur(20px);
            border-bottom: 2px solid #00d4ff;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 1000;
            box-shadow: 0 4px 20px rgba(0, 212, 255, 0.3);
        }
        
        .logo {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .logo h1 {
            font-family: 'Orbitron', monospace;
            font-size: 1.8rem;
            font-weight: 900;
            background: linear-gradient(45deg, #00d4ff, #ff0096, #00ff88);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin: 0;
            text-shadow: 0 0 20px rgba(0, 212, 255, 0.5);
        }
        
        .nav {
            display: flex;
            gap: 20px;
            align-items: center;
        }
        
        .nav-btn {
            background: linear-gradient(45deg, #00d4ff, #ff0096);
            border: none;
            border-radius: 25px;
            padding: 10px 20px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            font-family: 'Rajdhani', sans-serif;
            font-size: 1rem;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 212, 255, 0.3);
        }
        
        .nav-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(255, 0, 150, 0.4);
        }
        
        /* Main Content */
        .main-content {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .hero-section {
            text-align: center;
            margin-bottom: 40px;
            padding: 40px 20px;
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.1), rgba(255, 0, 150, 0.1));
            border-radius: 20px;
            border: 1px solid rgba(0, 212, 255, 0.3);
        }
        
        .hero-section h2 {
            font-family: 'Orbitron', monospace;
            font-size: 2.5rem;
            margin-bottom: 15px;
            background: linear-gradient(45deg, #00d4ff, #ff0096, #00ff88);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .hero-section p {
            font-size: 1.2rem;
            color: #cccccc;
            margin: 0 0 25px 0;
        }
        
        .category-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            justify-content: center;
            margin-top: 20px;
        }
        
        .category-btn {
            background: linear-gradient(45deg, rgba(0, 212, 255, 0.2), rgba(255, 0, 150, 0.2));
            border: 2px solid #00d4ff;
            border-radius: 25px;
            padding: 10px 20px;
            color: #00d4ff;
            font-weight: bold;
            cursor: pointer;
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.95rem;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 212, 255, 0.2);
        }
        
        .category-btn:hover {
            background: linear-gradient(45deg, #00d4ff, #ff0096);
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 212, 255, 0.4);
        }
        
        .category-btn.active {
            background: linear-gradient(45deg, #00ff88, #ffd700);
            color: #000;
            border-color: #00ff88;
            transform: scale(1.05);
            box-shadow: 0 6px 25px rgba(0, 255, 136, 0.4);
        }
        
        /* Games Grid */
        .games-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            padding: 20px 0;
        }
        
        .game-card {
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(26, 26, 46, 0.8));
            border: 2px solid #00d4ff;
            border-radius: 20px;
            padding: 20px;
            backdrop-filter: blur(15px);
            box-shadow: 0 0 30px rgba(0, 212, 255, 0.3);
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }
        
        .game-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 40px rgba(0, 212, 255, 0.5);
            border-color: #ff0096;
        }
        
        .game-card.featured {
            border: 3px solid #ffd700;
            box-shadow: 0 0 40px rgba(255, 215, 0, 0.4);
        }
        
        .game-card.featured:hover {
            box-shadow: 0 10px 50px rgba(255, 215, 0, 0.6);
        }
        
        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .game-number {
            background: linear-gradient(45deg, #00d4ff, #ff0096);
            color: white;
            font-weight: bold;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 0.9rem;
            font-family: 'Orbitron', monospace;
        }
        
        .game-status {
            background: linear-gradient(45deg, #00ff88, #ffd700);
            color: #000;
            font-weight: bold;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
        }
        
        .game-icon {
            font-size: 3rem;
            text-align: center;
            margin: 15px 0;
            filter: drop-shadow(0 0 10px rgba(0, 212, 255, 0.5));
        }
        
        .game-card h3 {
            font-family: 'Orbitron', monospace;
            font-size: 1.3rem;
            margin: 10px 0;
            color: #00d4ff;
            text-align: center;
        }
        
        .game-card p {
            color: #cccccc;
            text-align: center;
            margin-bottom: 15px;
            font-size: 0.95rem;
        }
        
        .game-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
            margin-bottom: 15px;
        }
        
        .tag {
            background: rgba(0, 212, 255, 0.2);
            border: 1px solid #00d4ff;
            color: #00d4ff;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: bold;
        }
        
        .game-stats {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-top: 15px;
            border-top: 1px solid rgba(0, 212, 255, 0.3);
            font-size: 0.9rem;
            color: #cccccc;
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            .header {
                flex-direction: column;
                gap: 15px;
                padding: 15px;
            }
            
            .nav {
                flex-wrap: wrap;
                gap: 10px;
            }
            
            .nav-btn {
                padding: 8px 15px;
                font-size: 0.9rem;
            }
            
            .hero-section h2 {
                font-size: 2rem;
            }
            
            .hero-section p {
                font-size: 1rem;
            }
            
            .games-grid {
                grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
                gap: 15px;
            }
            
            .game-card {
                padding: 15px;
            }
            
            .game-icon {
                font-size: 2.5rem;
            }
            
            .game-card h3 {
                font-size: 1.1rem;
            }
        }
        
        @media (max-width: 480px) {
            .main-content {
                padding: 10px;
            }
            
            .hero-section {
                padding: 20px 15px;
                margin-bottom: 20px;
            }
            
            .hero-section h2 {
                font-size: 1.5rem;
            }
            
            .games-grid {
                grid-template-columns: 1fr;
                gap: 10px;
            }
            
            .category-buttons {
                gap: 8px;
            }
            
            .category-btn {
                padding: 8px 12px;
                font-size: 0.85rem;
            }
        }

        /* Sélecteur de langues */
        .language-selector {
            position: relative;
            display: inline-block;
        }

        .language-btn {
            position: relative;
            overflow: hidden;
        }

        .language-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transition: left 0.5s;
        }

        .language-btn:hover::before {
            left: 100%;
        }

        .language-menu {
            position: absolute;
            top: 100%;
            right: 0;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(26, 26, 46, 0.95));
            backdrop-filter: blur(20px);
            border: 2px solid #00d4ff;
            border-radius: 15px;
            min-width: 180px;
            box-shadow: 0 10px 30px rgba(0, 212, 255, 0.4);
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px) scale(0.95);
            transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            z-index: 1000;
            overflow: hidden;
        }

        .language-menu.active {
            opacity: 1;
            visibility: visible;
            transform: translateY(0) scale(1);
        }

        .language-menu::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, #00d4ff, #ff0096, #00ff88, #ffd700);
            background-size: 400% 400%;
            animation: gradientShift 3s ease infinite;
            opacity: 0.1;
            z-index: -1;
        }

        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .language-option {
            padding: 12px 16px;
            color: #ffffff;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Rajdhani', sans-serif;
            font-weight: 600;
            border-bottom: 1px solid rgba(0, 212, 255, 0.2);
            position: relative;
            overflow: hidden;
        }

        .language-option:last-child {
            border-bottom: none;
        }

        .language-option::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 212, 255, 0.3), transparent);
            transition: left 0.4s ease;
        }

        .language-option:hover {
            background: linear-gradient(90deg, rgba(0, 212, 255, 0.2), rgba(255, 0, 150, 0.2));
            color: #00d4ff;
            transform: translateX(5px);
            text-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
        }

        .language-option:hover::before {
            left: 100%;
        }

        .language-option:active {
            transform: translateX(5px) scale(0.98);
        }
    </style>
</head>
<body>
<script>
function launchGame32() {
    document.getElementById('game32Overlay').style.display = 'block';
}
function closeGame32() {
    document.getElementById('game32Overlay').style.display = 'none';
}
document.addEventListener('keydown', function(e) {
    if (e.key === "Escape") {
        closeGame32();
    }
});
</script>
<!-- Overlay du Jeu 32 -->
<div id="game32Overlay" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:#000; z-index:10000; overflow:auto;">
    <button onclick="closeGame32()" style="position:absolute; top:20px; right:20px; background:red; color:#fff; border:none; padding:10px; font-size:20px; cursor:pointer; z-index:10001;">✖</button>
    <div id="game32Container" style="width:100%; height:100%; overflow:auto; background:#000; color:#fff;">
        <iframe src="jeux32.html" style="width:100vw; height:100vh; border:none; background:#000;" allowfullscreen></iframe>
    </div>
</div>
    <script>
    function launchGame33() {
        document.getElementById('game33Overlay').style.display = 'block';
    }
    function closeGame33() {
        document.getElementById('game33Overlay').style.display = 'none';
    }
    document.addEventListener('keydown', function(e) {
        if (e.key === "Escape") {
            closeGame33();
        }
    });
    </script>
    <!-- Overlay du Jeu 33 -->
    <div id="game33Overlay" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:#000; z-index:10000; overflow:auto;">
        <button onclick="closeGame33()" style="position:absolute; top:20px; right:20px; background:red; color:#fff; border:none; padding:10px; font-size:20px; cursor:pointer; z-index:10001;">✖</button>
        <div id="game33Container" style="width:100%; height:100%; overflow:auto; background:#000; color:#fff;">
            <iframe src="jeux33.html" style="width:100vw; height:100vh; border:none; background:#000;" allowfullscreen></iframe>
        </div>
    </div>
    <script>
    function launchGame34() {
        document.getElementById('game34Overlay').style.display = 'block';
    }
    function closeGame34() {
        document.getElementById('game34Overlay').style.display = 'none';
    }
    document.addEventListener('keydown', function(e) {
        if (e.key === "Escape") {
            closeGame34();
        }
    });
    </script>
    <!-- Overlay du Jeu 34 -->
    <div id="game34Overlay" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:#000; z-index:10000; overflow:auto;">
        <button onclick="closeGame34()" style="position:absolute; top:20px; right:20px; background:red; color:#fff; border:none; padding:10px; font-size:20px; cursor:pointer; z-index:10001;">✖</button>
        <div id="game34Container" style="width:100%; height:100%; overflow:auto; background:#000; color:#fff;">
            <iframe src="jeux34.html" style="width:100vw; height:100vh; border:none; background:#000;" allowfullscreen></iframe>
        </div>
    </div>
<script>
function launchGame31() {
    document.getElementById('game31Overlay').style.display = 'block';
}
function closeGame31() {
    document.getElementById('game31Overlay').style.display = 'none';
}
document.addEventListener('keydown', function(e) {
    if (e.key === "Escape") {
        closeGame31();
    }
});
</script>
<!-- Overlay du Jeu 31 -->
<div id="game31Overlay" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:#000; z-index:10000; overflow:auto;">
    <button onclick="closeGame31()" style="position:absolute; top:20px; right:20px; background:red; color:#fff; border:none; padding:10px; font-size:20px; cursor:pointer; z-index:10001;">✖</button>
    <div id="game31Container" style="width:100%; height:100%; overflow:auto; background:#000; color:#fff;">
        <iframe src="jeux31.html" style="width:100vw; height:100vh; border:none; background:#000;" allowfullscreen></iframe>
    </div>
</div>
<script>
function launchGame30() {
    document.getElementById('game30Overlay').style.display = 'block';
}
function closeGame30() {
    document.getElementById('game30Overlay').style.display = 'none';
}
document.addEventListener('keydown', function(e) {
    if (e.key === "Escape") {
        closeGame30();
    }
});
</script>
<!-- Overlay du Jeu 30 -->
<div id="game30Overlay" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:#000; z-index:10000; overflow:auto;">
    <button onclick="closeGame30()" style="position:absolute; top:20px; right:20px; background:red; color:#fff; border:none; padding:10px; font-size:20px; cursor:pointer; z-index:10001;">✖</button>
    <div id="game30Container" style="width:100%; height:100%; overflow:auto; background:#000; color:#fff;">
        <iframe src="jeux30.html" style="width:100vw; height:100vh; border:none; background:#000;" allowfullscreen></iframe>
    </div>
</div>
<script>
function launchGame29() {
    document.getElementById('game29Overlay').style.display = 'block';
}
function closeGame29() {
    document.getElementById('game29Overlay').style.display = 'none';
}
document.addEventListener('keydown', function(e) {
    if (e.key === "Escape") {
        closeGame29();
    }
});
</script>
<!-- Overlay du Jeu 29 -->
<div id="game29Overlay" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:#000; z-index:10000; overflow:auto;">
    <button onclick="closeGame29()" style="position:absolute; top:20px; right:20px; background:red; color:#fff; border:none; padding:10px; font-size:20px; cursor:pointer; z-index:10001;">✖</button>
    <div id="game29Container" style="width:100%; height:100%; overflow:auto; background:#000; color:#fff;">
        <iframe src="jeux29.html" style="width:100vw; height:100vh; border:none; background:#000;" allowfullscreen></iframe>
    </div>
</div>
<script>
function launchGame28() {
    document.getElementById('game28Overlay').style.display = 'block';
}
function closeGame28() {
    document.getElementById('game28Overlay').style.display = 'none';
}
document.addEventListener('keydown', function(e) {
    if (e.key === "Escape") {
        closeGame28();
    }
});
</script>
<!-- Overlay du Jeu 28 -->
<div id="game28Overlay" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:#000; z-index:10000; overflow:auto;">
    <button onclick="closeGame28()" style="position:absolute; top:20px; right:20px; background:red; color:#fff; border:none; padding:10px; font-size:20px; cursor:pointer; z-index:10001;">✖</button>
    <div id="game28Container" style="width:100%; height:100%; overflow:auto; background:#000; color:#fff;">
        <iframe src="jeux28.html" style="width:100vw; height:100vh; border:none; background:#000;" allowfullscreen></iframe>
    </div>
</div>
<script>
function launchGame27() {
    document.getElementById('game27Overlay').style.display = 'block';
}
function closeGame27() {
    document.getElementById('game27Overlay').style.display = 'none';
}
document.addEventListener('keydown', function(e) {
    if (e.key === "Escape") {
        closeGame27();
    }
});
</script>
<!-- Overlay du Jeu 27 -->
<div id="game27Overlay" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:#000; z-index:10000; overflow:auto;">
    <button onclick="closeGame27()" style="position:absolute; top:20px; right:20px; background:red; color:#fff; border:none; padding:10px; font-size:20px; cursor:pointer; z-index:10001;">✖</button>
    <div id="game27Container" style="width:100%; height:100%; overflow:auto; background:#000; color:#fff;">
        <iframe src="jeux27.html" style="width:100vw; height:100vh; border:none; background:#000;" allowfullscreen></iframe>
    </div>
</div>
<script>
function launchGame24() {
    document.getElementById('game24Overlay').style.display = 'block';
}
function closeGame24() {
    document.getElementById('game24Overlay').style.display = 'none';
}
document.addEventListener('keydown', function(e) {
    if (e.key === "Escape") {
        closeGame24();
    }
});
</script>
<!-- Overlay du Jeu 24 -->
<div id="game24Overlay" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:#000; z-index:10000; overflow:auto;">
    <button onclick="closeGame24()" style="position:absolute; top:20px; right:20px; background:red; color:#fff; border:none; padding:10px; font-size:20px; cursor:pointer; z-index:10001;">✖</button>
    <div id="game24Container" style="width:100%; height:100%; overflow:auto; background:#000; color:#fff;">
        <iframe src="jeux24.html" style="width:100vw; height:100vh; border:none; background:#000;" allowfullscreen></iframe>
    </div>
</div>
<script>
function launchGame25() {
    document.getElementById('game25Overlay').style.display = 'block';
}
function closeGame25() {
    document.getElementById('game25Overlay').style.display = 'none';
}
document.addEventListener('keydown', function(e) {
    if (e.key === "Escape") {
        closeGame25();
    }
});
</script>
<!-- Overlay du Jeu 25 -->
<div id="game25Overlay" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:#000; z-index:10000; overflow:auto;">
    <button onclick="closeGame25()" style="position:absolute; top:20px; right:20px; background:red; color:#fff; border:none; padding:10px; font-size:20px; cursor:pointer; z-index:10001;">✖</button>
    <div id="game25Container" style="width:100%; height:100%; overflow:auto; background:#000; color:#fff;">
        <iframe src="jeux25.html" style="width:100vw; height:100vh; border:none; background:#000;" allowfullscreen></iframe>
    </div>
</div>

<script>
function launchGame24() {
    document.getElementById('game24Overlay').style.display = 'block';
}
function closeGame24() {
    document.getElementById('game24Overlay').style.display = 'none';
}
document.addEventListener('keydown', function(e) {
    if (e.key === "Escape") {
        closeGame24();
    }
});
function launchGame25() {
    document.getElementById('game22Overlay').style.display = 'block';
}
function closeGame22() {
    document.getElementById('game22Overlay').style.display = 'none';
}
document.addEventListener('keydown', function(e) {
    if (e.key === "Escape") {
        closeGame22();
    }
});
</script>
<!-- Overlay du Jeu 24 -->
<div id="game24Overlay" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:#000; z-index:10000; overflow:auto;">
    <button onclick="closeGame24()" style="position:absolute; top:20px; right:20px; background:red; color:#fff; border:none; padding:10px; font-size:20px; cursor:pointer; z-index:10001;">✖</button>
    <div id="game24Container" style="width:100%; height:100%; overflow:auto; background:#000; color:#fff;">
        <iframe src="jeux24.html" style="width:100vw; height:100vh; border:none; background:#000;" allowfullscreen></iframe>
    </div>
</div>
<!-- Overlay du Jeu 25 -->
</script>
<!-- Overlay du Jeu 22 -->
<div id="game22Overlay" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:#000; z-index:10000; overflow:auto;">
    <button onclick="closeGame22()" style="position:absolute; top:20px; right:20px; background:red; color:#fff; border:none; padding:10px; font-size:20px; cursor:pointer; z-index:10001;">✖</button>
    <div id="game22Container" style="width:100%; height:100%; overflow:auto; background:#000; color:#fff;">
        <iframe src="jeux22.html" style="width:100vw; height:100vh; border:none; background:#000;" allowfullscreen></iframe>

    </div>
</div>
<script>
function launchGame21() {
    document.getElementById('game21Overlay').style.display = 'block';
}
function closeGame21() {
    document.getElementById('game21Overlay').style.display = 'none';
}
document.addEventListener('keydown', function(e) {
    if (e.key === "Escape") {
        closeGame21();
    }
});
</script>
<!-- Overlay du Jeu 21 -->
<div id="game21Overlay" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:#000; z-index:10000; overflow:auto;">
    <button onclick="closeGame21()" style="position:absolute; top:20px; right:20px; background:red; color:#fff; border:none; padding:10px; font-size:20px; cursor:pointer; z-index:10001;">✖</button>
    <div id="game21Container" style="width:100%; height:100%; overflow:auto; background:#000; color:#fff;">
        <iframe src="jeux21.html" style="width:100vw; height:100vh; border:none; background:#000;" allowfullscreen></iframe>
    </div>
</div>
<script>
function launchGame20() {
    document.getElementById('game20Overlay').style.display = 'block';
}
function closeGame20() {
    document.getElementById('game20Overlay').style.display = 'none';
}
document.addEventListener('keydown', function(e) {
    if (e.key === "Escape") {
        closeGame20();
    }
});
</script>
<!-- Overlay du Jeu 20 -->
<div id="game20Overlay" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:#000; z-index:10000; overflow:auto;">
    <button onclick="closeGame20()" style="position:absolute; top:20px; right:20px; background:red; color:#fff; border:none; padding:10px; font-size:20px; cursor:pointer; z-index:10001;">✖</button>
    <div id="game20Container" style="width:100%; height:100%; overflow:auto; background:#000; color:#fff;">
        <iframe src="jeux20.html" style="width:100vw; height:100vh; border:none; background:#000;" allowfullscreen></iframe>
    </div>
</div>
<script>
function launchGame19() {
    document.getElementById('game19Overlay').style.display = 'block';
}
function closeGame19() {
    document.getElementById('game19Overlay').style.display = 'none';
}
document.addEventListener('keydown', function(e) {
    if (e.key === "Escape") {
        closeGame19();
    }
});
</script>
<!-- Overlay du Jeu 19 -->
<div id="game19Overlay" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:#000; z-index:10000; overflow:auto;">
    <button onclick="closeGame19()" style="position:absolute; top:20px; right:20px; background:red; color:#fff; border:none; padding:10px; font-size:20px; cursor:pointer; z-index:10001;">✖</button>
    <div id="game19Container" style="width:100%; height:100%; overflow:auto; background:#000; color:#fff;">
        <iframe src="jeux19.html" style="width:100vw; height:100vh; border:none; background:#000;" allowfullscreen></iframe>
    </div>
</div>
<script>
function launchGame18() {
    document.getElementById('game18Overlay').style.display = 'block';
}
function closeGame18() {
    document.getElementById('game18Overlay').style.display = 'none';
}
document.addEventListener('keydown', function(e) {
    if (e.key === "Escape") {
        closeGame18();
    }
});
</script>
<!-- Overlay du Jeu 18 -->
<div id="game18Overlay" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:#000; z-index:10000; overflow:auto;">
    <button onclick="closeGame18()" style="position:absolute; top:20px; right:20px; background:red; color:#fff; border:none; padding:10px; font-size:20px; cursor:pointer; z-index:10001;">✖</button>
    <div id="game18Container" style="width:100%; height:100%; overflow:auto; background:#000; color:#fff;">
        <iframe src="jeux18.html" style="width:100vw; height:100vh; border:none; background:#000;" allowfullscreen></iframe>
    </div>
</div>

<script>
function launchGame17() {
    document.getElementById('game17Overlay').style.display = 'block';
}
function closeGame17() {
    document.getElementById('game17Overlay').style.display = 'none';
}
document.addEventListener('keydown', function(e) {
    if (e.key === "Escape") {
        closeGame17();
    }
});
</script>
    <!-- Overlay du Jeu 17 -->
    <div id="game17Overlay" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:#000; z-index:10000; overflow:auto;">
        <button onclick="closeGame17()" style="position:absolute; top:20px; right:20px; background:red; color:#fff; border:none; padding:10px; font-size:20px; cursor:pointer; z-index:10001;">✖</button>
        <div id="game17Container" style="width:100%; height:100%; overflow:auto; background:#000; color:#fff;">
            <iframe src="jeux17.html" style="width:100vw; height:100vh; border:none; background:#000;" allowfullscreen></iframe>
        </div>
    </div>
    <!-- Particules d'arrière-plan -->
    <div class="particles"></div>

    <!-- Header -->
    <header class="header">
        <div class="logo">
            <h1>🧠 BRAINOVA</h1>
        </div>
        <nav class="nav">
            <button class="nav-btn rankings-btn" onclick="showComingSoon('Classements')">🏆 Classements</button>
            <button class="nav-btn settings-btn" onclick="showComingSoon('Paramètres')">⚙️ Paramètres</button>
            <button class="nav-btn profile-btn" onclick="showComingSoon('Profil')">👤 Profil</button>
            <div class="language-selector">
                <button class="nav-btn language-btn" onclick="toggleLanguageMenu()">🌐 <span id="currentLang">FR</span></button>
                <div class="language-menu" id="languageMenu">
                    <div class="language-option" onclick="changeLanguage('fr')">🇫🇷 Français</div>
                    <div class="language-option" onclick="changeLanguage('en')">🇬🇧 English</div>
                    <div class="language-option" onclick="changeLanguage('ar')">🇸🇦 العربية</div>
                    <div class="language-option" onclick="changeLanguage('es')">🇪🇸 Español</div>
                    <div class="language-option" onclick="changeLanguage('zh')">🇨🇳 中文</div>
                </div>
            </div>
        </nav>
    </header>

    <!-- Main Content -->
    <div class="main-content">
        <div class="hero-section">
            <h2>🎮 Découvrez nos 36 Jeux Intelligents</h2>
            <p>Entraînez votre cerveau avec notre collection complète de jeux adaptatifs alimentés par l'IA</p>
            <div class="category-buttons">
                <button class="category-btn active" onclick="filterGames('all')">🎮 Tous les Jeux</button>
                <button class="category-btn" onclick="filterGames('memory')">🧠 Mémoire</button>
                <button class="category-btn" onclick="filterGames('reflexion')">🧩 Réflexion</button>
                <button class="category-btn" onclick="filterGames('societe')">🎲 Société</button>
                <button class="category-btn" onclick="filterGames('arcade')">🕹️ Arcade</button>
                <button class="category-btn" onclick="filterGames('science')">🔬 Science</button>
                <button class="category-btn" onclick="filterGames('mystique')">🔮 Mystique</button>
            </div>
        </div>
        
        <div class="games-grid">
            <!-- Jeu 1 - Quantum Tetris -->
            <div class="game-card featured" data-category="arcade reflexion" onclick="playQuantumTetris()">
                <div class="game-header">
                    <div class="game-number">01</div>
                    <div class="game-status">🔥 POPULAIRE</div>
                </div>
                <div class="game-icon">🎮</div>
                <h3>Quantum Tetris 2077</h3>
                <p>Tetris futuriste avec IA quantique et effets spectaculaires</p>
                <div class="game-tags">
                    <span class="tag">⚡ IA Quantique</span>
                    <span class="tag">🧩 Puzzle</span>
                    <span class="tag">🌟 Futuriste</span>
                </div>
                <div class="game-stats">
                    <span>⭐ 4.9</span>
                    <span>👥 12.5K</span>
                </div>
            </div>
            
            <!-- Autres jeux (2-36) restent identiques -->
            <div class="game-card" data-category="memory" onclick="playMemoryQuantique()">
                <div class="game-header">
                    <div class="game-number">02</div>
                </div>
                <div class="game-icon">🧠</div>
                <h3>Memory Quantique</h3>
                <p>Entraînez votre mémoire avec l'IA neurale adaptative</p>
                <div class="game-tags">
                    <span class="tag">🧠 Mémoire</span>
                    <span class="tag">⚡ IA</span>
                    <span class="tag">🎯 Adaptatif</span>
                </div>
                <div class="game-stats">
                    <span>⭐ 4.8</span>
                    <span>👥 8.2K</span>
                </div>
            </div>

            
<!-- Jeu 3 - Neural Puzzle Master -->
<div class="game-card" id="card3" data-category="reflexion" onclick="launchGame3()">
  <div class="game-header">
    <div class="game-number">03</div>
    <div class="game-status">🔥 POPULAIRE</div>
  </div>
  <div class="game-icon">🧩</div>
  <h3>Neural Puzzle Master</h3>
  <p>Cliquez pour jouer !</p>
  <div class="game-tags">
    <span class="tag">🧩 Puzzle</span>
    <span class="tag">⚡ IA</span>
    <span class="tag">🧠 Adaptatif</span>
  </div>
</div>


            <!-- Jeu 4 - Quantum Chess -->
            <div class="game-card" data-category="reflexion societe" onclick="launchGame4()">
                <div class="game-header">
                    <div class="game-number">04</div>
                </div>
                <div class="game-icon">♛</div>
                <h3>Quantum Chess</h3>
                <p>Échecs quantiques multidimensionnels avec IA maître</p>
                <div class="game-tags">
                    <span class="tag">♛ Échecs</span>
                    <span class="tag">⚛️ Quantique</span>
                    <span class="tag">🧠 Stratégie</span>
                </div>
                <div class="game-stats">
                    <span>⭐ 4.9</span>
                    <span>👥 8.7K</span>
                </div>
            </div>

            <!-- Jeu 5 - Jeux de Dames -->
            <div class="game-card" data-category="reflexion societe" onclick="launchGame5()">
                <div class="game-header">
                    <div class="game-number">05</div>
                </div>
                <div class="game-icon">⚫</div>
                <h3>Jeux de Dames</h3>
                <p>Dames classiques avec IA stratégique et variantes mondiales</p>
                <div class="game-tags">
                    <span class="tag">⚫ Dames</span>
                    <span class="tag">🧠 Stratégie</span>
                    <span class="tag">🌍 Mondial</span>
                </div>
                <div class="game-stats">
                    <span>⭐ 4.7</span>
                    <span>👥 8.5K</span>
                </div>
            </div>

            <!-- Jeu 6 - Pac-Man -->
            <div class="game-card" data-category="arcade" onclick="launchGame6()">
                <div class="game-header">
                    <div class="game-number">06</div>
                    <div class="game-status">🔥 CLASSIQUE</div>
                </div>
                <div class="game-icon">🟡</div>
                <h3>Pac-Man</h3>
                <p>Le légendaire Pac-Man avec IA fantômes et labyrinthes infinis</p>
                <div class="game-tags">
                    <span class="tag">🟡 Arcade</span>
                    <span class="tag">👻 Fantômes</span>
                    <span class="tag">🌀 Labyrinthe</span>
                </div>
                <div class="game-stats">
                    <span>⭐ 4.9</span>
                    <span>👥 15.2K</span>
                </div>
            </div>

            <!-- Jeu 7 - Simon Says -->
            <div class="game-card" data-category="memory" onclick="launchGame7()">
                <div class="game-header">
                    <div class="game-number">07</div>
                </div>
                <div class="game-icon">🔴</div>
                <h3>Simon Says</h3>
                <p>Mémoire séquentielle avec IA adaptative et défis sonores</p>
                <div class="game-tags">
                    <span class="tag">🔴 Mémoire</span>
                    <span class="tag">🎵 Sonore</span>
                    <span class="tag">⚡ Séquence</span>
                </div>
                <div class="game-stats">
                    <span>⭐ 4.6</span>
                    <span>👥 9.8K</span>
                </div>
            </div>

            <!-- Jeu 8 - Speed Challenge -->
            <div class="game-card" data-category="arcade" onclick="launchGame8()">
                <div class="game-header">
                    <div class="game-number">08</div>
                    <div class="game-status">⚡ RAPIDE</div>
                </div>
                <div class="game-icon">⚡</div>
                <h3>Speed Challenge</h3>
                <p>Défis de vitesse avec IA chronométrée et réflexes quantiques</p>
                <div class="game-tags">
                    <span class="tag">⚡ Vitesse</span>
                    <span class="tag">⏱️ Chrono</span>
                    <span class="tag">🎯 Réflexes</span>
                </div>
                <div class="game-stats">
                    <span>⭐ 4.8</span>
                    <span>👥 12.1K</span>
                </div>
            </div>

            <!-- Jeu 9 - Cyber Checker -->
            <div class="game-card" data-category="reflexion" onclick="launchGame9()">
                <div class="game-header">
                    <div class="game-number">09</div>
                </div>
                <div class="game-icon">🔵</div>
                <h3>Cyber Checker</h3>
                <p>Vérificateur cyber avec IA de détection et sécurité quantique</p>
                <div class="game-tags">
                    <span class="tag">🔵 Cyber</span>
                    <span class="tag">🛡️ Sécurité</span>
                    <span class="tag">🔍 Détection</span>
                </div>
                <div class="game-stats">
                    <span>⭐ 4.5</span>
                    <span>👥 7.3K</span>
                </div>
            </div>

            <!-- Jeu 10 - Demo Playground -->
            <div class="game-card" data-category="arcade" onclick="launchGame10()">
                <div class="game-header">
                    <div class="game-number">10</div>
                    <div class="game-status">🎮 DÉMO</div>
                </div>
                <div class="game-icon">🎪</div>
                <h3>Demo Playground</h3>
                <p>Terrain de jeu interactif avec IA créative et expériences libres</p>
                <div class="game-tags">
                    <span class="tag">🎪 Créatif</span>
                    <span class="tag">🎨 Libre</span>
                    <span class="tag">🧪 Expérimental</span>
                </div>
                <div class="game-stats">
                    <span>⭐ 4.4</span>
                    <span>👥 6.9K</span>
                </div>
            </div>

            <!-- Jeu 11 - Quantum Monopoly -->
            <div class="game-card" data-category="societe" onclick="launchGame11()">
                <div class="game-header">
                    <div class="game-number">11</div>
                    <div class="game-status">💰 BUSINESS</div>
                </div>
                <div class="game-icon">🏠</div>
                <h3>Quantum Monopoly</h3>
                <p>Monopoly quantique avec IA économique et propriétés multidimensionnelles</p>
                <div class="game-tags">
                    <span class="tag">🏠 Immobilier</span>
                    <span class="tag">💰 Économie</span>
                    <span class="tag">⚛️ Quantique</span>
                </div>
                <div class="game-stats">
                    <span>⭐ 4.9</span>
                    <span>👥 11.7K</span>
                </div>
            </div>

            <!-- Jeu 12 - Neural Poker -->
            <div class="game-card" data-category="societe reflexion" onclick="launchGame12()">
                <div class="game-header">
                    <div class="game-number">12</div>
                </div>
                <div class="game-icon">♠️</div>
                <h3>Neural Poker</h3>
                <p>Poker intelligent avec IA psychologique et bluff quantique</p>
                <div class="game-tags">
                    <span class="tag">♠️ Poker</span>
                    <span class="tag">🧠 Psychologie</span>
                    <span class="tag">🎭 Bluff</span>
                </div>
                <div class="game-stats">
                    <span>⭐ 4.8</span>
                    <span>👥 10.4K</span>
                </div>
            </div>

<!-- Jeu 13 - Blackjack Quantum -->
<div class="game-card" onclick="launchGame13()" data-category="strategie">
  <div class="game-header">
    <div class="game-number">13</div>
    <div class="game-status">🧮 STRATÉGIE</div>
  </div>
  <div class="game-icon">🃏</div>
  <h3>Blackjack Quantum</h3>
  <p>Blackjack quantique avec IA croupier et probabilités avancées</p>
  <div class="game-tags">
    <span class="tag">🃏 Blackjack</span>
    <span class="tag">⚛️ Quantique</span>
    <span class="tag">📊 Probabilité</span>
  </div>
  <div class="game-stats">
    <span>⭐ 4.7</span>
    <span>👥 9.6K</span>
  </div>
</div>



            <!-- Jeu 13 - Blackjack Quantum -->
            <!-- DUPLICATE CARD 13 REMOVED
<div class="game-card" data-category="societe reflexion" onclick="showComingSoon('Blackjack Quantum')">
                <div class="game-header">
                    <div class="game-number">13</div>
                </div>
                <div class="game-icon">🃏</div>
                <h3>Blackjack Quantum</h3>
                <p>Blackjack quantique avec IA croupier et probabilités avancées</p>
                <div class="game-tags">
                    <span class="tag">🃏 Blackjack</span>
                    <span class="tag">⚛️ Quantique</span>
                    <span class="tag">📊 Probabilité</span>
                </div>
                <div class="game-stats">
                    <span>⭐ 4.7</span>
                    <span>👥 9.6K</span>
                </div>
            </div>
-->


            
<!-- Jeu 14 - Solitaire Fusion -->
<!-- Jeu 14 - Solitaire Fusion -->
<div class="game-card" onclick="launchGame14()" data-category="strategie">
  <div class="game-header">
    <div class="game-number">14</div>
    <div class="game-status">🂡 STRATÉGIE</div>
  </div>
  <div class="game-icon">🂡</div>
  <h3>Solitaire Fusion</h3>
  <p>Solitaire fusionné avec IA assistante et variantes infinies</p>
  <div class="game-tags">
    <span class="tag">🂡 Solitaire</span>
    <span class="tag">🔄 Fusion</span>
    <span class="tag">♦️ Variantes</span>
  </div>
  <div class="game-stats">
    <span>⭐ 4.6</span>
    <span>👥 8.8K</span>
  </div>
</div>


<!-- Overlay du Jeu 16 -->
<div id="game16Overlay" style="display:none; position:fixed; top:0; left:0;
     width:100%; height:100%; background:#000; z-index:10000; overflow:auto;">
  <button onclick="closeGame16()" 
          style="position:absolute; top:20px; right:20px; background:red; color:#fff;
                 border:none; padding:10px; font-size:20px; cursor:pointer; z-index:10001;">✖</button>
  <div id="game16Container" style="width:100%; height:100%; overflow:auto; background:#000; color:#fff;">
    <iframe srcdoc="&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;fr&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Enigma Hunter&lt;/title&gt;
    &lt;style&gt;
        body {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: &#x27;Courier New&#x27;, monospace;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 25%, #16213e 50%, #0f3460 75%, #533483 100%);
            min-height: 100vh;
            color: #00ff88;
            overflow-x: hidden;
            position: relative;
        }

        /* Animated quantum grid background */
        body::before {
            content: &#x27;&#x27;;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(0, 255, 136, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 136, 0.1) 1px, transparent 1px);
            background-size: 40px 40px;
            animation: quantumGrid 20s linear infinite;
            z-index: -1;
        }

        @keyframes quantumGrid {
            0% { transform: translate(0, 0) rotate(0deg); opacity: 0.3; }
            50% { opacity: 0.6; }
            100% { transform: translate(40px, 40px) rotate(360deg); opacity: 0.3; }
        }

        .quantum-particles {
            position: fixed;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: #00ccff;
            border-radius: 50%;
            animation: quantumFloat 12s linear infinite;
            box-shadow: 0 0 15px rgba(0, 204, 255, 0.8);
        }

        @keyframes quantumFloat {
            0% {
                transform: translateY(100vh) translateX(0) scale(0) rotate(0deg);
                opacity: 0;
            }
            10% {
                opacity: 1;
                transform: scale(1);
            }
            90% {
                opacity: 1;
            }
            100% {
                transform: translateY(-10vh) translateX(300px) scale(0) rotate(720deg);
                opacity: 0;
            }
        }

        .game-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            position: relative;
            z-index: 2;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            position: relative;
        }

        .title {
            font-size: 3rem;
            margin: 0;
            text-shadow: 0 0 40px rgba(0, 255, 136, 0.8);
            background: linear-gradient(45deg, #00ff88, #00ccff, #ff0088, #ffaa00, #8800ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: titlePulse 5s ease-in-out infinite;
            letter-spacing: 4px;
            text-transform: uppercase;
        }

        @keyframes titlePulse {
            0%, 100% { 
                filter: drop-shadow(0 0 30px rgba(0, 255, 136, 0.5));
                transform: scale(1);
            }
            50% { 
                filter: drop-shadow(0 0 60px rgba(0, 255, 136, 1));
                transform: scale(1.08);
            }
        }

        .subtitle {
            font-size: 1.4rem;
            color: #00ccff;
            margin: 15px 0;
            opacity: 0.9;
            letter-spacing: 3px;
            animation: subtitleGlow 3s ease-in-out infinite alternate;
        }

        @keyframes subtitleGlow {
            0% { text-shadow: 0 0 10px rgba(0, 204, 255, 0.5); }
            100% { text-shadow: 0 0 25px rgba(0, 204, 255, 1); }
        }

        .language-selector {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 1000;
        }

        .language-dropdown {
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #00ff88;
            border-radius: 10px;
            padding: 12px 18px;
            color: #00ff88;
            font-family: &#x27;Courier New&#x27;, monospace;
            font-size: 14px;
            cursor: pointer;
            outline: none;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.4);
            transition: all 0.3s ease;
        }

        .language-dropdown:hover {
            background: rgba(0, 255, 136, 0.1);
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.6);
            transform: scale(1.05);
        }

        .control-panel {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 30px 0;
            flex-wrap: wrap;
        }

        .quantum-btn {
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.2) 0%, rgba(0, 204, 255, 0.2) 100%);
            border: 2px solid #00ff88;
            padding: 12px 20px;
            border-radius: 8px;
            color: #00ff88;
            font-size: 1rem;
            font-family: &#x27;Courier New&#x27;, monospace;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 1px;
            min-width: 140px;
            font-weight: bold;
        }

        .quantum-btn::before {
            content: &#x27;&#x27;;
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 136, 0.4), transparent);
            transition: left 0.5s;
        }

        .quantum-btn:hover::before {
            left: 100%;
        }

        .quantum-btn:hover {
            transform: translateY(-4px);
            box-shadow: 0 20px 40px rgba(0, 255, 136, 0.4);
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.4) 0%, rgba(0, 204, 255, 0.4) 100%);
            border-color: #00ccff;
            color: #ffffff;
        }

        .quantum-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .quantum-btn:disabled:hover {
            transform: none;
            box-shadow: none;
        }

        .rules-btn {
            background: linear-gradient(135deg, rgba(255, 170, 0, 0.2) 0%, rgba(255, 136, 0, 0.2) 100%);
            border-color: #ffaa00;
            color: #ffaa00;
        }

        .rules-btn:hover {
            background: linear-gradient(135deg, rgba(255, 170, 0, 0.4) 0%, rgba(255, 136, 0, 0.4) 100%);
            border-color: #ff8800;
        }

        .pause-btn {
            background: linear-gradient(135deg, rgba(255, 0, 136, 0.2) 0%, rgba(136, 0, 255, 0.2) 100%);
            border-color: #ff0088;
            color: #ff0088;
        }

        .pause-btn:hover {
            background: linear-gradient(135deg, rgba(255, 0, 136, 0.4) 0%, rgba(136, 0, 255, 0.4) 100%);
            border-color: #cc0066;
        }

        .game-area {
            display: grid;
            grid-template-columns: 250px 1fr 250px;
            gap: 20px;
            margin: 20px 0;
            min-height: 500px;
        }

        .main-game {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ff88;
            border-radius: 15px;
            padding: 30px;
            position: relative;
            overflow: hidden;
        }

        .main-game::before {
            content: &#x27;&#x27;;
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, #00ff88, #00ccff, #ff0088, #ffaa00, #8800ff);
            border-radius: 17px;
            z-index: -1;
            animation: borderGlow 8s linear infinite;
        }

        @keyframes borderGlow {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }

        .side-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .ai-assistant {
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #00ccff;
            border-radius: 12px;
            padding: 15px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .ai-assistant::before {
            content: &#x27;&#x27;;
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, #00ccff, #0088ff, #0044ff);
            border-radius: 14px;
            z-index: -1;
            animation: aiGlow 4s ease-in-out infinite;
        }

        @keyframes aiGlow {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.8; }
        }

        .ai-avatar {
            width: 50px;
            height: 50px;
            margin: 0 auto 10px;
            border-radius: 50%;
            background: radial-gradient(circle, #00ccff 0%, #0088ff 50%, #0044ff 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            animation: aiPulse 3s ease-in-out infinite;
            box-shadow: 0 0 25px rgba(0, 204, 255, 0.8);
        }

        @keyframes aiPulse {
            0%, 100% { transform: scale(1) rotate(0deg); }
            50% { transform: scale(1.15) rotate(180deg); }
        }

        .ai-name {
            font-size: 1rem;
            color: #00ccff;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-weight: bold;
        }

        .ai-message {
            font-size: 0.85rem;
            line-height: 1.4;
            color: #88ffcc;
            background: rgba(0, 204, 255, 0.1);
            padding: 12px;
            border-radius: 6px;
            border-left: 3px solid #00ccff;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .stats-panel {
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #ffaa00;
            border-radius: 12px;
            padding: 15px;
        }

        .stats-title {
            font-size: 1rem;
            color: #ffaa00;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-align: center;
            font-weight: bold;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            padding: 6px;
            background: rgba(255, 170, 0, 0.1);
            border-radius: 4px;
            font-size: 0.8rem;
        }

        .stat-label {
            color: #ffcc66;
        }

        .stat-value {
            color: #ffaa00;
            font-weight: bold;
        }

        .enigma-display {
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #00ff88;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
            min-height: 120px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .enigma-text {
            font-size: 1.3rem;
            color: #00ff88;
            margin-bottom: 15px;
            line-height: 1.5;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        .enigma-input {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ccff;
            border-radius: 8px;
            padding: 15px;
            color: #00ccff;
            font-family: &#x27;Courier New&#x27;, monospace;
            font-size: 1.2rem;
            width: 100%;
            text-align: center;
            margin: 10px 0;
            box-shadow: 0 0 15px rgba(0, 204, 255, 0.3);
        }

        .enigma-input:focus {
            outline: none;
            box-shadow: 0 0 25px rgba(0, 204, 255, 0.6);
            border-color: #00ff88;
        }

        .progress-bar {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #ff0088;
            border-radius: 10px;
            padding: 10px;
            margin: 15px 0;
        }

        .progress-title {
            color: #ff0088;
            font-size: 0.9rem;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .progress-fill {
            background: linear-gradient(90deg, #ff0088, #ff44aa);
            height: 20px;
            border-radius: 10px;
            transition: width 0.5s ease;
            box-shadow: 0 0 15px rgba(255, 0, 136, 0.6);
        }

        .timer-display {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #ffaa00;
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            margin: 15px 0;
        }

        .timer-text {
            font-size: 2rem;
            color: #ffaa00;
            font-weight: bold;
            text-shadow: 0 0 20px rgba(255, 170, 0, 0.8);
        }

        .game-message {
            text-align: center;
            font-size: 1.2rem;
            margin: 20px 0;
            padding: 15px;
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #00ccff;
            color: #00ccff;
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .rules-panel, .pause-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #00ff88;
            border-radius: 20px;
            padding: 40px;
            z-index: 3000;
            display: none;
            min-width: 600px;
            max-width: 85vw;
            max-height: 85vh;
            overflow-y: auto;
        }

        .rules-content {
            color: #00ff88;
            line-height: 1.8;
        }

        .rules-content h3 {
            color: #00ccff;
            margin-top: 30px;
            margin-bottom: 20px;
            border-bottom: 2px solid #00ff88;
            padding-bottom: 10px;
            font-size: 1.4rem;
        }

        .rules-content ul {
            margin: 20px 0;
            padding-left: 30px;
        }

        .rules-content li {
            margin: 10px 0;
        }

        .pause-panel {
            text-align: center;
            border-color: #ff0088;
        }

        .pause-panel h3 {
            color: #ff0088;
            font-size: 2.5rem;
            margin-bottom: 30px;
        }

        .level-indicator {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #ffaa00;
            border-radius: 12px;
            padding: 12px 25px;
            color: #ffaa00;
            font-weight: bold;
            font-size: 1.1rem;
        }

        .hint-system {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #8800ff;
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
        }

        .hint-title {
            color: #8800ff;
            font-size: 0.9rem;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .hint-text {
            color: #cc88ff;
            font-size: 0.85rem;
            line-height: 1.4;
        }

        @media (max-width: 768px) {
            .game-area {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .title {
                font-size: 2.5rem;
            }
            
            .control-panel {
                gap: 15px;
            }
            
            .quantum-btn {
                min-width: 130px;
                padding: 15px 25px;
                font-size: 1.1rem;
            }
            
            .language-selector {
                top: 10px;
                right: 10px;
            }
            
            .rules-panel {
                min-width: 95vw;
                padding: 25px;
            }
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;quantum-particles&quot; id=&quot;particles&quot;&gt;&lt;/div&gt;
    
    &lt;div class=&quot;language-selector&quot;&gt;
        &lt;select class=&quot;language-dropdown&quot; id=&quot;languageSelect&quot;&gt;
            &lt;option value=&quot;fr&quot;&gt;🇫🇷 Français&lt;/option&gt;
            &lt;option value=&quot;en&quot;&gt;🇬🇧 English&lt;/option&gt;
            &lt;option value=&quot;ar&quot;&gt;🇸🇦 العربية&lt;/option&gt;
            &lt;option value=&quot;es&quot;&gt;🇪🇸 Español&lt;/option&gt;
            &lt;option value=&quot;de&quot;&gt;🇩🇪 Deutsch&lt;/option&gt;
            &lt;option value=&quot;zh&quot;&gt;🇨🇳 中文&lt;/option&gt;
        &lt;/select&gt;
    &lt;/div&gt;

    &lt;div class=&quot;level-indicator&quot; id=&quot;levelIndicator&quot;&gt;
        Niveau 1
    &lt;/div&gt;

    &lt;div class=&quot;game-container&quot;&gt;
        &lt;div class=&quot;header&quot;&gt;
            &lt;h1 class=&quot;title&quot; id=&quot;gameTitle&quot;&gt;Enigma Hunter&lt;/h1&gt;
            &lt;p class=&quot;subtitle&quot; id=&quot;gameSubtitle&quot;&gt;Chasseur d&#x27;Énigmes Quantiques avec IA&lt;/p&gt;
        &lt;/div&gt;

        &lt;div class=&quot;control-panel&quot;&gt;
            &lt;button class=&quot;quantum-btn rules-btn&quot; id=&quot;rulesBtn&quot; onclick=&quot;showRules()&quot;&gt;📖 Règles&lt;/button&gt;
            &lt;button class=&quot;quantum-btn&quot; id=&quot;startBtn&quot; onclick=&quot;startGame()&quot;&gt;🚀 Commencer&lt;/button&gt;
            &lt;button class=&quot;quantum-btn pause-btn&quot; id=&quot;pauseBtn&quot; onclick=&quot;togglePause()&quot; disabled&gt;⏸️ Pause&lt;/button&gt;
            &lt;button class=&quot;quantum-btn&quot; id=&quot;newGameBtn&quot; onclick=&quot;newGame()&quot;&gt;🔄 Nouveau Jeu&lt;/button&gt;
        &lt;/div&gt;

        &lt;div class=&quot;game-area&quot;&gt;
            &lt;div class=&quot;side-panel&quot;&gt;
                &lt;div class=&quot;ai-assistant&quot;&gt;
                    &lt;div class=&quot;ai-avatar&quot;&gt;🧠&lt;/div&gt;
                    &lt;div class=&quot;ai-name&quot; id=&quot;aiName&quot;&gt;CIPHER-AI&lt;/div&gt;
                    &lt;div class=&quot;ai-message&quot; id=&quot;aiMessage&quot;&gt;
                        Salut ! Je suis CIPHER-AI, votre assistant quantique. Prêt à résoudre des énigmes mystérieuses ?
                    &lt;/div&gt;
                &lt;/div&gt;

                &lt;div class=&quot;stats-panel&quot; style=&quot;padding: 12px;&quot;&gt;
                    &lt;div class=&quot;stats-title&quot; id=&quot;statsTitle&quot; style=&quot;font-size: 0.9rem; margin-bottom: 10px;&quot;&gt;Statistiques&lt;/div&gt;
                    &lt;div class=&quot;stat-item&quot; style=&quot;margin: 6px 0; padding: 4px; font-size: 0.75rem;&quot;&gt;
                        &lt;span class=&quot;stat-label&quot; id=&quot;solvedLabel&quot;&gt;Résolues:&lt;/span&gt;
                        &lt;span class=&quot;stat-value&quot; id=&quot;solvedValue&quot;&gt;0&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;stat-item&quot; style=&quot;margin: 6px 0; padding: 4px; font-size: 0.75rem;&quot;&gt;
                        &lt;span class=&quot;stat-label&quot; id=&quot;failedLabel&quot;&gt;Échouées:&lt;/span&gt;
                        &lt;span class=&quot;stat-value&quot; id=&quot;failedValue&quot;&gt;0&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;stat-item&quot; style=&quot;margin: 6px 0; padding: 4px; font-size: 0.75rem;&quot;&gt;
                        &lt;span class=&quot;stat-label&quot; id=&quot;streakLabel&quot;&gt;Série:&lt;/span&gt;
                        &lt;span class=&quot;stat-value&quot; id=&quot;streakValue&quot;&gt;0&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;stat-item&quot; style=&quot;margin: 6px 0; padding: 4px; font-size: 0.75rem;&quot;&gt;
                        &lt;span class=&quot;stat-label&quot; id=&quot;levelLabel&quot;&gt;Niveau:&lt;/span&gt;
                        &lt;span class=&quot;stat-value&quot; id=&quot;levelValue&quot;&gt;1&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;stat-item&quot; style=&quot;margin: 6px 0; padding: 4px; font-size: 0.75rem;&quot;&gt;
                        &lt;span class=&quot;stat-label&quot; id=&quot;scoreLabel&quot;&gt;Score:&lt;/span&gt;
                        &lt;span class=&quot;stat-value&quot; id=&quot;scoreValue&quot;&gt;0&lt;/span&gt;
                    &lt;/div&gt;
                &lt;/div&gt;


            &lt;/div&gt;

            &lt;div class=&quot;main-game&quot;&gt;
                &lt;div class=&quot;timer-display&quot; id=&quot;timerDisplay&quot;&gt;
    <iframe src="jeux17.html" style="width:100vw; height:100vh; border:none; background:#000;" allowfullscreen></iframe>
                    &lt;div class=&quot;timer-text&quot; id=&quot;timerText&quot;&gt;--:--&lt;/div&gt;
                &lt;/div&gt;

                &lt;div class=&quot;progress-bar&quot;&gt;
                    &lt;div class=&quot;progress-title&quot; id=&quot;progressTitle&quot;&gt;Progression du Niveau&lt;/div&gt;
                    &lt;div style=&quot;background: rgba(255, 0, 136, 0.2); border-radius: 10px;&quot;&gt;
                        &lt;div class=&quot;progress-fill&quot; id=&quot;progressFill&quot; style=&quot;width: 0%;&quot;&gt;&lt;/div&gt;
                    &lt;/div&gt;
                &lt;/div&gt;

                &lt;div class=&quot;enigma-display&quot; id=&quot;enigmaDisplay&quot;&gt;
                    &lt;div class=&quot;enigma-text&quot; id=&quot;enigmaText&quot;&gt;
                        Cliquez sur &quot;Commencer&quot; pour débuter votre aventure de chasseur d&#x27;énigmes !
                    &lt;/div&gt;
                    &lt;input type=&quot;text&quot; class=&quot;enigma-input&quot; id=&quot;enigmaInput&quot; placeholder=&quot;Tapez votre réponse ici...&quot; style=&quot;display: none;&quot;&gt;
                    &lt;button class=&quot;quantum-btn&quot; id=&quot;submitBtn&quot; onclick=&quot;submitAnswer()&quot; style=&quot;display: none; margin-top: 15px;&quot;&gt;Valider&lt;/button&gt;
                &lt;/div&gt;

                &lt;div class=&quot;game-message&quot; id=&quot;gameMessage&quot;&gt;
                    Bienvenue dans Enigma Hunter ! Résolvez des énigmes mystérieuses avec l&#x27;aide de votre IA.
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;div class=&quot;side-panel&quot;&gt;
                &lt;div class=&quot;ai-assistant&quot;&gt;
                    &lt;div class=&quot;ai-avatar&quot;&gt;📖&lt;/div&gt;
                    &lt;div class=&quot;ai-name&quot; id=&quot;rulesName&quot;&gt;OBJECTIF&lt;/div&gt;
                    &lt;div class=&quot;ai-message&quot; id=&quot;rulesMessage&quot;&gt;
                        Résolvez l&#x27;énigme avant la fin du temps imparti !
                    &lt;/div&gt;
                &lt;/div&gt;

                &lt;div class=&quot;hint-system&quot; id=&quot;hintSystemRight&quot; style=&quot;display: block;&quot;&gt;
                    &lt;div class=&quot;hint-title&quot; id=&quot;hintTitleRight&quot;&gt;💡 Indice &amp; Solution&lt;/div&gt;
                    &lt;div class=&quot;hint-text&quot; id=&quot;hintTextRight&quot;&gt;Utilisez un indice pour vous aider...&lt;/div&gt;
                    &lt;div style=&quot;display: flex; gap: 8px; margin-top: 10px;&quot;&gt;
                        &lt;button class=&quot;quantum-btn&quot; id=&quot;hintBtnRight&quot; onclick=&quot;useHint()&quot; style=&quot;min-width: 80px; padding: 8px 12px; font-size: 0.8rem;&quot;&gt;Indice&lt;/button&gt;
                        &lt;button class=&quot;quantum-btn&quot; id=&quot;solutionBtnRight&quot; onclick=&quot;showSolution()&quot; style=&quot;min-width: 80px; padding: 8px 12px; font-size: 0.8rem; background: linear-gradient(135deg, rgba(255, 0, 136, 0.2) 0%, rgba(136, 0, 255, 0.2) 100%); border-color: #ff0088; color: #ff0088;&quot;&gt;Solution&lt;/button&gt;
                    &lt;/div&gt;
                &lt;/div&gt;

                &lt;div class=&quot;stats-panel&quot; style=&quot;padding: 12px;&quot;&gt;
                    &lt;div class=&quot;stats-title&quot; id=&quot;difficultyTitle&quot; style=&quot;font-size: 0.9rem; margin-bottom: 10px;&quot;&gt;Difficulté&lt;/div&gt;
                    &lt;div class=&quot;stat-item&quot; style=&quot;margin: 6px 0; padding: 4px; font-size: 0.75rem;&quot;&gt;
                        &lt;span class=&quot;stat-label&quot; id=&quot;currentDiffLabel&quot;&gt;Actuelle:&lt;/span&gt;
                        &lt;span class=&quot;stat-value&quot; id=&quot;currentDiffValue&quot;&gt;Facile&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;stat-item&quot; style=&quot;margin: 6px 0; padding: 4px; font-size: 0.75rem;&quot;&gt;
                        &lt;span class=&quot;stat-label&quot; id=&quot;timeLeftLabel&quot;&gt;Temps:&lt;/span&gt;
                        &lt;span class=&quot;stat-value&quot; id=&quot;timeLeftValue&quot;&gt;--&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;stat-item&quot; style=&quot;margin: 6px 0; padding: 4px; font-size: 0.75rem;&quot;&gt;
                        &lt;span class=&quot;stat-label&quot; id=&quot;hintsLeftLabel&quot;&gt;Indices:&lt;/span&gt;
                        &lt;span class=&quot;stat-value&quot; id=&quot;hintsLeftValue&quot;&gt;3&lt;/span&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;!-- Rules Panel --&gt;
    &lt;div class=&quot;rules-panel&quot; id=&quot;rulesPanel&quot;&gt;
        &lt;h3 style=&quot;color: #00ff88; text-align: center; margin-bottom: 30px;&quot; id=&quot;rulesTitle&quot;&gt;📖 Règles d&#x27;Enigma Hunter&lt;/h3&gt;
        &lt;div class=&quot;rules-content&quot; id=&quot;rulesContent&quot;&gt;
            &lt;div id=&quot;rulesObjective&quot;&gt;
                &lt;h3 id=&quot;objectiveTitle&quot;&gt;🎯 Objectif&lt;/h3&gt;
                &lt;p id=&quot;objectiveText&quot;&gt;Résolvez des énigmes de plus en plus complexes en utilisant votre logique et l&#x27;aide de votre IA assistant CIPHER-AI.&lt;/p&gt;
            &lt;/div&gt;
            
            &lt;div id=&quot;rulesGameplay&quot;&gt;
                &lt;h3 id=&quot;gameplayTitle&quot;&gt;🎮 Gameplay&lt;/h3&gt;
                &lt;ul&gt;
                    &lt;li&gt;&lt;strong id=&quot;variedEnigmas&quot;&gt;Énigmes variées:&lt;/strong&gt; &lt;span id=&quot;variedEnigmasDesc&quot;&gt;Mathématiques, logique, mots, codes secrets&lt;/span&gt;&lt;/li&gt;
                    &lt;li&gt;&lt;strong id=&quot;timedChallenges&quot;&gt;Temps limité:&lt;/strong&gt; &lt;span id=&quot;timedChallengesDesc&quot;&gt;Chaque énigme a une limite de temps&lt;/span&gt;&lt;/li&gt;
                    &lt;li&gt;&lt;strong id=&quot;progressiveLevels&quot;&gt;Niveaux progressifs:&lt;/strong&gt; &lt;span id=&quot;progressiveLevelsDesc&quot;&gt;La difficulté augmente avec votre progression&lt;/span&gt;&lt;/li&gt;
                    &lt;li&gt;&lt;strong id=&quot;hintSystem&quot;&gt;Système d&#x27;indices:&lt;/strong&gt; &lt;span id=&quot;hintSystemDesc&quot;&gt;Utilisez des indices pour vous aider&lt;/span&gt;&lt;/li&gt;
                    &lt;li&gt;&lt;strong id=&quot;solutionSystem&quot;&gt;Bouton Solution:&lt;/strong&gt; &lt;span id=&quot;solutionSystemDesc&quot;&gt;Révélez la réponse si vous êtes bloqué&lt;/span&gt;&lt;/li&gt;
                &lt;/ul&gt;
            &lt;/div&gt;
            
            &lt;div id=&quot;rulesScoring&quot;&gt;
                &lt;h3 id=&quot;scoringTitle&quot;&gt;🏆 Système de Score&lt;/h3&gt;
                &lt;ul&gt;
                    &lt;li&gt;&lt;strong id=&quot;fastSolving&quot;&gt;Résolution rapide:&lt;/strong&gt; &lt;span id=&quot;fastSolvingDesc&quot;&gt;Plus vous êtes rapide, plus vous gagnez de points&lt;/span&gt;&lt;/li&gt;
                    &lt;li&gt;&lt;strong id=&quot;noHints&quot;&gt;Sans indices:&lt;/strong&gt; &lt;span id=&quot;noHintsDesc&quot;&gt;Bonus pour résoudre sans aide&lt;/span&gt;&lt;/li&gt;
                    &lt;li&gt;&lt;strong id=&quot;streaks&quot;&gt;Séries:&lt;/strong&gt; &lt;span id=&quot;streaksDesc&quot;&gt;Bonus pour les résolutions consécutives&lt;/span&gt;&lt;/li&gt;
                    &lt;li&gt;&lt;strong id=&quot;levelUnlock&quot;&gt;Niveaux:&lt;/strong&gt; &lt;span id=&quot;levelUnlockDesc&quot;&gt;Débloquez de nouveaux défis&lt;/span&gt;&lt;/li&gt;
                &lt;/ul&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;button class=&quot;quantum-btn&quot; onclick=&quot;hideRules()&quot; style=&quot;margin-top: 30px;&quot; id=&quot;closeRulesBtn&quot;&gt;Fermer&lt;/button&gt;
    &lt;/div&gt;

    &lt;!-- Pause Panel --&gt;
    &lt;div class=&quot;pause-panel&quot; id=&quot;pausePanel&quot;&gt;
        &lt;h3 id=&quot;pauseTitle&quot;&gt;⏸️ Jeu en Pause&lt;/h3&gt;
        &lt;p style=&quot;color: #ff88cc; margin: 30px 0; font-size: 1.2rem;&quot; id=&quot;pauseMessage&quot;&gt;Le jeu est actuellement en pause. Prenez votre temps !&lt;/p&gt;
        &lt;button class=&quot;quantum-btn&quot; onclick=&quot;togglePause()&quot; id=&quot;resumeBtn&quot;&gt;▶️ Reprendre&lt;/button&gt;
    &lt;/div&gt;

    &lt;script&gt;
        const translations = {
            fr: {
                title: &quot;Enigma Hunter&quot;,
                subtitle: &quot;Chasseur d&#x27;Énigmes Quantiques avec IA&quot;,
                start: &quot;🚀 Commencer&quot;,
                pause: &quot;⏸️ Pause&quot;,
                resume: &quot;▶️ Reprendre&quot;,
                rules: &quot;Règles&quot;,
                newGame: &quot;🔄 Nouveau Jeu&quot;,
                aiName: &quot;CIPHER-AI&quot;,
                aiWelcome: &quot;Salut ! Je suis CIPHER-AI, votre assistant quantique. Prêt à résoudre des énigmes mystérieuses ?&quot;,
                statsTitle: &quot;Statistiques&quot;,
                solved: &quot;Résolues:&quot;,
                failed: &quot;Échouées:&quot;,
                streak: &quot;Série:&quot;,
                level: &quot;Niveau:&quot;,
                score: &quot;Score:&quot;,
                difficultyTitle: &quot;Difficulté&quot;,
                currentDiff: &quot;Actuelle:&quot;,
                timeLeft: &quot;Temps:&quot;,
                hintsLeft: &quot;Indices:&quot;,
                objectiveName: &quot;OBJECTIF&quot;,
                rulesMessage: &quot;Résolvez l&#x27;énigme avant la fin du temps imparti !&quot;,
                startMessage: &quot;Cliquez sur \&quot;Commencer\&quot; pour débuter votre aventure de chasseur d&#x27;énigmes !&quot;,
                welcomeMessage: &quot;Bienvenue dans Enigma Hunter ! Résolvez des énigmes mystérieuses avec l&#x27;aide de votre IA.&quot;,
                rulesTitle: &quot;📖 Règles d&#x27;Enigma Hunter&quot;,
                pauseTitle: &quot;⏸️ Jeu en Pause&quot;,
                pauseMessage: &quot;Le jeu est actuellement en pause. Prenez votre temps !&quot;,
                levelIndicator: &quot;Niveau&quot;,
                closeBtn: &quot;Fermer&quot;,
                submitBtn: &quot;Valider&quot;,
                hintBtn: &quot;Indice&quot;,
                hintTitle: &quot;💡 Indice &amp; Solution&quot;,
                solutionBtn: &quot;Solution&quot;,
                progressTitle: &quot;Progression du Niveau&quot;,
                inputPlaceholder: &quot;Tapez votre réponse ici...&quot;,
                difficulties: {
                    easy: &quot;Facile&quot;,
                    medium: &quot;Moyen&quot;,
                    hard: &quot;Difficile&quot;,
                    expert: &quot;Expert&quot;
                },
                messages: {
                    correct: &quot;🎉 Excellent ! Bonne réponse !&quot;,
                    wrong: &quot;❌ Incorrect. Essayez encore !&quot;,
                    timeout: &quot;⏰ Temps écoulé ! Passons à la suivante.&quot;,
                    levelUp: &quot;🎊 Niveau supérieur ! Félicitations !&quot;,
                    gameOver: &quot;🏁 Partie terminée ! Score final :&quot;,
                    hint: &quot;💡 Voici un indice pour vous aider...&quot;,
                    noHints: &quot;❌ Plus d&#x27;indices disponibles !&quot;,
                    newRecord: &quot;🏆 Nouveau record personnel !&quot;,
                    solutionRevealed: &quot;Solution révélée ! Passage au niveau suivant...&quot;,
                    encourageAfterSolution: &quot;Ne vous découragez pas ! Chaque énigme est une leçon.&quot;
                },
                aiMessages: {
                    encouragement: [
                        &quot;Vous y êtes presque ! Continuez !&quot;,
                        &quot;Excellente logique ! Poursuivez !&quot;,
                        &quot;Votre raisonnement est bon !&quot;,
                        &quot;Fantastique ! Vous progressez bien !&quot;
                    ],
                    hints: [
                        &quot;Pensez différemment...&quot;,
                        &quot;La réponse est plus simple qu&#x27;elle n&#x27;y paraît.&quot;,
                        &quot;Regardez les détails attentivement.&quot;,
                        &quot;Utilisez la logique étape par étape.&quot;
                    ]
                },
                rules: {
                    objectiveTitle: &quot;🎯 Objectif&quot;,
                    objectiveText: &quot;Résolvez des énigmes de plus en plus complexes en utilisant votre logique et l&#x27;aide de votre IA assistant CIPHER-AI.&quot;,
                    gameplayTitle: &quot;🎮 Gameplay&quot;,
                    variedEnigmas: &quot;Énigmes variées:&quot;,
                    variedEnigmasDesc: &quot;Mathématiques, logique, mots, codes secrets&quot;,
                    timedChallenges: &quot;Temps limité:&quot;,
                    timedChallengesDesc: &quot;Chaque énigme a une limite de temps&quot;,
                    progressiveLevels: &quot;Niveaux progressifs:&quot;,
                    progressiveLevelsDesc: &quot;La difficulté augmente avec votre progression&quot;,
                    hintSystem: &quot;Système d&#x27;indices:&quot;,
                    hintSystemDesc: &quot;Utilisez des indices pour vous aider&quot;,
                    solutionSystem: &quot;Bouton Solution:&quot;,
                    solutionSystemDesc: &quot;Révélez la réponse si vous êtes bloqué&quot;,
                    scoringTitle: &quot;🏆 Système de Score&quot;,
                    fastSolving: &quot;Résolution rapide:&quot;,
                    fastSolvingDesc: &quot;Plus vous êtes rapide, plus vous gagnez de points&quot;,
                    noHints: &quot;Sans indices:&quot;,
                    noHintsDesc: &quot;Bonus pour résoudre sans aide&quot;,
                    streaks: &quot;Séries:&quot;,
                    streaksDesc: &quot;Bonus pour les résolutions consécutives&quot;,
                    levelUnlock: &quot;Niveaux:&quot;,
                    levelUnlockDesc: &quot;Débloquez de nouveaux défis&quot;
                }
            },
            en: {
                title: &quot;Enigma Hunter&quot;,
                subtitle: &quot;Quantum Enigma Hunter with AI&quot;,
                start: &quot;🚀 Start&quot;,
                pause: &quot;⏸️ Pause&quot;,
                resume: &quot;▶️ Resume&quot;,
                rules: &quot;Rules&quot;,
                newGame: &quot;🔄 New Game&quot;,
                aiName: &quot;CIPHER-AI&quot;,
                aiWelcome: &quot;Hi! I&#x27;m CIPHER-AI, your quantum assistant. Ready to solve mysterious enigmas?&quot;,
                statsTitle: &quot;Statistics&quot;,
                solved: &quot;Solved:&quot;,
                failed: &quot;Failed:&quot;,
                streak: &quot;Streak:&quot;,
                level: &quot;Level:&quot;,
                score: &quot;Score:&quot;,
                difficultyTitle: &quot;Difficulty&quot;,
                currentDiff: &quot;Current:&quot;,
                timeLeft: &quot;Time:&quot;,
                hintsLeft: &quot;Hints:&quot;,
                objectiveName: &quot;OBJECTIVE&quot;,
                rulesMessage: &quot;Solve the enigma before time runs out!&quot;,
                startMessage: &quot;Click \&quot;Start\&quot; to begin your enigma hunter adventure!&quot;,
                welcomeMessage: &quot;Welcome to Enigma Hunter! Solve mysterious enigmas with your AI&#x27;s help.&quot;,
                rulesTitle: &quot;📖 Enigma Hunter Rules&quot;,
                pauseTitle: &quot;⏸️ Game Paused&quot;,
                pauseMessage: &quot;The game is currently paused. Take your time!&quot;,
                levelIndicator: &quot;Level&quot;,
                closeBtn: &quot;Close&quot;,
                submitBtn: &quot;Submit&quot;,
                hintBtn: &quot;Hint&quot;,
                hintTitle: &quot;💡 Hint &amp; Solution&quot;,
                solutionBtn: &quot;Solution&quot;,
                progressTitle: &quot;Level Progress&quot;,
                inputPlaceholder: &quot;Type your answer here...&quot;,
                difficulties: {
                    easy: &quot;Easy&quot;,
                    medium: &quot;Medium&quot;,
                    hard: &quot;Hard&quot;,
                    expert: &quot;Expert&quot;
                },
                messages: {
                    correct: &quot;🎉 Excellent! Correct answer!&quot;,
                    wrong: &quot;❌ Incorrect. Try again!&quot;,
                    timeout: &quot;⏰ Time&#x27;s up! Moving to the next one.&quot;,
                    levelUp: &quot;🎊 Level up! Congratulations!&quot;,
                    gameOver: &quot;🏁 Game over! Final score:&quot;,
                    hint: &quot;💡 Here&#x27;s a hint to help you...&quot;,
                    noHints: &quot;❌ No more hints available!&quot;,
                    newRecord: &quot;🏆 New personal record!&quot;,
                    solutionRevealed: &quot;Solution revealed! Moving to next level...&quot;,
                    encourageAfterSolution: &quot;Don&#x27;t get discouraged! Every enigma is a lesson.&quot;
                },
                aiMessages: {
                    encouragement: [
                        &quot;You&#x27;re almost there! Keep going!&quot;,
                        &quot;Excellent logic! Continue!&quot;,
                        &quot;Your reasoning is good!&quot;,
                        &quot;Fantastic! You&#x27;re progressing well!&quot;
                    ],
                    hints: [
                        &quot;Think differently...&quot;,
                        &quot;The answer is simpler than it appears.&quot;,
                        &quot;Look at the details carefully.&quot;,
                        &quot;Use logic step by step.&quot;
                    ]
                },
                rules: {
                    objectiveTitle: &quot;🎯 Objective&quot;,
                    objectiveText: &quot;Solve increasingly complex enigmas using your logic and the help of your AI assistant CIPHER-AI.&quot;,
                    gameplayTitle: &quot;🎮 Gameplay&quot;,
                    variedEnigmas: &quot;Varied Enigmas:&quot;,
                    variedEnigmasDesc: &quot;Mathematics, logic, words, secret codes&quot;,
                    timedChallenges: &quot;Time Limited:&quot;,
                    timedChallengesDesc: &quot;Each enigma has a time limit&quot;,
                    progressiveLevels: &quot;Progressive Levels:&quot;,
                    progressiveLevelsDesc: &quot;Difficulty increases with your progression&quot;,
                    hintSystem: &quot;Hint System:&quot;,
                    hintSystemDesc: &quot;Use hints to help you&quot;,
                    solutionSystem: &quot;Solution Button:&quot;,
                    solutionSystemDesc: &quot;Reveal the answer if you&#x27;re stuck&quot;,
                    scoringTitle: &quot;🏆 Scoring System&quot;,
                    fastSolving: &quot;Fast Solving:&quot;,
                    fastSolvingDesc: &quot;The faster you are, the more points you earn&quot;,
                    noHints: &quot;No Hints:&quot;,
                    noHintsDesc: &quot;Bonus for solving without help&quot;,
                    streaks: &quot;Streaks:&quot;,
                    streaksDesc: &quot;Bonus for consecutive solutions&quot;,
                    levelUnlock: &quot;Levels:&quot;,
                    levelUnlockDesc: &quot;Unlock new challenges&quot;
                }
            },
            ar: {
                title: &quot;صائد الألغاز&quot;,
                subtitle: &quot;صائد الألغاز الكمي مع الذكاء الاصطناعي&quot;,
                start: &quot;🚀 ابدأ&quot;,
                pause: &quot;⏸️ توقف&quot;,
                resume: &quot;▶️ استئناف&quot;,
                rules: &quot;القواعد&quot;,
                newGame: &quot;🔄 لعبة جديدة&quot;,
                aiName: &quot;سايفر-إيه آي&quot;,
                aiWelcome: &quot;مرحباً! أنا سايفر-إيه آي، مساعدك الكمي. مستعد لحل الألغاز الغامضة؟&quot;,
                statsTitle: &quot;الإحصائيات&quot;,
                solved: &quot;محلولة:&quot;,
                failed: &quot;فاشلة:&quot;,
                streak: &quot;السلسلة:&quot;,
                level: &quot;المستوى:&quot;,
                score: &quot;النقاط:&quot;,
                difficultyTitle: &quot;الصعوبة&quot;,
                currentDiff: &quot;الحالية:&quot;,
                timeLeft: &quot;الوقت:&quot;,
                hintsLeft: &quot;التلميحات:&quot;,
                objectiveName: &quot;الهدف&quot;,
                rulesMessage: &quot;حل اللغز قبل انتهاء الوقت!&quot;,
                startMessage: &quot;انقر على \&quot;ابدأ\&quot; لبدء مغامرة صائد الألغاز!&quot;,
                welcomeMessage: &quot;مرحباً بك في صائد الألغاز! حل الألغاز الغامضة بمساعدة الذكاء الاصطناعي.&quot;,
                rulesTitle: &quot;📖 قواعد صائد الألغاز&quot;,
                pauseTitle: &quot;⏸️ اللعبة متوقفة&quot;,
                pauseMessage: &quot;اللعبة متوقفة حالياً. خذ وقتك!&quot;,
                levelIndicator: &quot;المستوى&quot;,
                closeBtn: &quot;إغلاق&quot;,
                submitBtn: &quot;إرسال&quot;,
                hintBtn: &quot;تلميح&quot;,
                hintTitle: &quot;💡 تلميح و الحل&quot;,
                solutionBtn: &quot;الحل&quot;,
                progressTitle: &quot;تقدم المستوى&quot;,
                inputPlaceholder: &quot;اكتب إجابتك هنا...&quot;,
                difficulties: {
                    easy: &quot;سهل&quot;,
                    medium: &quot;متوسط&quot;,
                    hard: &quot;صعب&quot;,
                    expert: &quot;خبير&quot;
                },
                messages: {
                    correct: &quot;🎉 ممتاز! إجابة صحيحة!&quot;,
                    wrong: &quot;❌ خطأ. حاول مرة أخرى!&quot;,
                    timeout: &quot;⏰ انتهى الوقت! ننتقل للتالي.&quot;,
                    levelUp: &quot;🎊 مستوى أعلى! تهانينا!&quot;,
                    gameOver: &quot;🏁 انتهت اللعبة! النقاط النهائية:&quot;,
                    hint: &quot;💡 إليك تلميح لمساعدتك...&quot;,
                    noHints: &quot;❌ لا توجد تلميحات متاحة!&quot;,
                    newRecord: &quot;🏆 رقم قياسي شخصي جديد!&quot;,
                    solutionRevealed: &quot;تم الكشف عن الحل! الانتقال للمستوى التالي...&quot;,
                    encourageAfterSolution: &quot;لا تيأس! كل لغز درس.&quot;
                },
                aiMessages: {
                    encouragement: [
                        &quot;أنت قريب جداً! استمر!&quot;,
                        &quot;منطق ممتاز! تابع!&quot;,
                        &quot;تفكيرك جيد!&quot;,
                        &quot;رائع! تتقدم بشكل جيد!&quot;
                    ],
                    hints: [
                        &quot;فكر بطريقة مختلفة...&quot;,
                        &quot;الإجابة أبسط مما تبدو.&quot;,
                        &quot;انظر للتفاصيل بعناية.&quot;,
                        &quot;استخدم المنطق خطوة بخطوة.&quot;
                    ]
                },
                rules: {
                    objectiveTitle: &quot;🎯 الهدف&quot;,
                    objectiveText: &quot;حل الألغاز المعقدة بشكل متزايد باستخدام منطقك ومساعدة مساعد الذكاء الاصطناعي سايفر-إيه آي.&quot;,
                    gameplayTitle: &quot;🎮 طريقة اللعب&quot;,
                    variedEnigmas: &quot;ألغاز متنوعة:&quot;,
                    variedEnigmasDesc: &quot;رياضيات، منطق، كلمات، رموز سرية&quot;,
                    timedChallenges: &quot;وقت محدود:&quot;,
                    timedChallengesDesc: &quot;كل لغز له حد زمني&quot;,
                    progressiveLevels: &quot;مستويات تدريجية:&quot;,
                    progressiveLevelsDesc: &quot;تزداد الصعوبة مع تقدمك&quot;,
                    hintSystem: &quot;نظام التلميحات:&quot;,
                    hintSystemDesc: &quot;استخدم التلميحات لمساعدتك&quot;,
                    solutionSystem: &quot;زر الحل:&quot;,
                    solutionSystemDesc: &quot;اكشف الإجابة إذا كنت عالقاً&quot;,
                    scoringTitle: &quot;🏆 نظام النقاط&quot;,
                    fastSolving: &quot;الحل السريع:&quot;,
                    fastSolvingDesc: &quot;كلما كنت أسرع، كلما حصلت على نقاط أكثر&quot;,
                    noHints: &quot;بدون تلميحات:&quot;,
                    noHintsDesc: &quot;مكافأة للحل بدون مساعدة&quot;,
                    streaks: &quot;السلاسل:&quot;,
                    streaksDesc: &quot;مكافأة للحلول المتتالية&quot;,
                    levelUnlock: &quot;المستويات:&quot;,
                    levelUnlockDesc: &quot;افتح تحديات جديدة&quot;
                }
            },
            es: {
                title: &quot;Enigma Hunter&quot;,
                subtitle: &quot;Cazador de Enigmas Cuántico con IA&quot;,
                start: &quot;🚀 Comenzar&quot;,
                pause: &quot;⏸️ Pausa&quot;,
                resume: &quot;▶️ Reanudar&quot;,
                rules: &quot;Reglas&quot;,
                newGame: &quot;🔄 Nuevo Juego&quot;,
                aiName: &quot;CIPHER-AI&quot;,
                aiWelcome: &quot;¡Hola! Soy CIPHER-AI, tu asistente cuántico. ¿Listo para resolver enigmas misteriosos?&quot;,
                statsTitle: &quot;Estadísticas&quot;,
                solved: &quot;Resueltos:&quot;,
                failed: &quot;Fallados:&quot;,
                streak: &quot;Racha:&quot;,
                level: &quot;Nivel:&quot;,
                score: &quot;Puntuación:&quot;,
                difficultyTitle: &quot;Dificultad&quot;,
                currentDiff: &quot;Actual:&quot;,
                timeLeft: &quot;Tiempo:&quot;,
                hintsLeft: &quot;Pistas:&quot;,
                objectiveName: &quot;OBJETIVO&quot;,
                rulesMessage: &quot;¡Resuelve el enigma antes de que se acabe el tiempo!&quot;,
                startMessage: &quot;¡Haz clic en \&quot;Comenzar\&quot; para iniciar tu aventura de cazador de enigmas!&quot;,
                welcomeMessage: &quot;¡Bienvenido a Enigma Hunter! Resuelve enigmas misteriosos con la ayuda de tu IA.&quot;,
                rulesTitle: &quot;📖 Reglas de Enigma Hunter&quot;,
                pauseTitle: &quot;⏸️ Juego Pausado&quot;,
                pauseMessage: &quot;El juego está actualmente pausado. ¡Tómate tu tiempo!&quot;,
                levelIndicator: &quot;Nivel&quot;,
                closeBtn: &quot;Cerrar&quot;,
                submitBtn: &quot;Enviar&quot;,
                hintBtn: &quot;Pista&quot;,
                hintTitle: &quot;💡 Pista y Solución&quot;,
                solutionBtn: &quot;Solución&quot;,
                progressTitle: &quot;Progreso del Nivel&quot;,
                inputPlaceholder: &quot;Escribe tu respuesta aquí...&quot;,
                difficulties: {
                    easy: &quot;Fácil&quot;,
                    medium: &quot;Medio&quot;,
                    hard: &quot;Difícil&quot;,
                    expert: &quot;Experto&quot;
                },
                messages: {
                    correct: &quot;🎉 ¡Excelente! ¡Respuesta correcta!&quot;,
                    wrong: &quot;❌ Incorrecto. ¡Inténtalo de nuevo!&quot;,
                    timeout: &quot;⏰ ¡Se acabó el tiempo! Pasando al siguiente.&quot;,
                    levelUp: &quot;🎊 ¡Subiste de nivel! ¡Felicitaciones!&quot;,
                    gameOver: &quot;🏁 ¡Juego terminado! Puntuación final:&quot;,
                    hint: &quot;💡 Aquí tienes una pista para ayudarte...&quot;,
                    noHints: &quot;❌ ¡No hay más pistas disponibles!&quot;,
                    newRecord: &quot;🏆 ¡Nuevo récord personal!&quot;,
                    solutionRevealed: &quot;¡Solución revelada! Pasando al siguiente nivel...&quot;,
                    encourageAfterSolution: &quot;¡No te desanimes! Cada enigma es una lección.&quot;
                },
                aiMessages: {
                    encouragement: [
                        &quot;¡Casi lo tienes! ¡Sigue así!&quot;,
                        &quot;¡Excelente lógica! ¡Continúa!&quot;,
                        &quot;¡Tu razonamiento es bueno!&quot;,
                        &quot;¡Fantástico! Estás progresando bien!&quot;
                    ],
                    hints: [
                        &quot;Piensa diferente...&quot;,
                        &quot;La respuesta es más simple de lo que parece.&quot;,
                        &quot;Mira los detalles cuidadosamente.&quot;,
                        &quot;Usa la lógica paso a paso.&quot;
                    ]
                },
                rules: {
                    objectiveTitle: &quot;🎯 Objetivo&quot;,
                    objectiveText: &quot;Resuelve enigmas cada vez más complejos usando tu lógica y la ayuda de tu asistente IA CIPHER-AI.&quot;,
                    gameplayTitle: &quot;🎮 Jugabilidad&quot;,
                    variedEnigmas: &quot;Enigmas Variados:&quot;,
                    variedEnigmasDesc: &quot;Matemáticas, lógica, palabras, códigos secretos&quot;,
                    timedChallenges: &quot;Tiempo Limitado:&quot;,
                    timedChallengesDesc: &quot;Cada enigma tiene un límite de tiempo&quot;,
                    progressiveLevels: &quot;Niveles Progresivos:&quot;,
                    progressiveLevelsDesc: &quot;La dificultad aumenta con tu progreso&quot;,
                    hintSystem: &quot;Sistema de Pistas:&quot;,
                    hintSystemDesc: &quot;Usa pistas para ayudarte&quot;,
                    solutionSystem: &quot;Botón Solución:&quot;,
                    solutionSystemDesc: &quot;Revela la respuesta si estás atascado&quot;,
                    scoringTitle: &quot;🏆 Sistema de Puntuación&quot;,
                    fastSolving: &quot;Resolución Rápida:&quot;,
                    fastSolvingDesc: &quot;Cuanto más rápido seas, más puntos ganas&quot;,
                    noHints: &quot;Sin Pistas:&quot;,
                    noHintsDesc: &quot;Bonificación por resolver sin ayuda&quot;,
                    streaks: &quot;Rachas:&quot;,
                    streaksDesc: &quot;Bonificación por soluciones consecutivas&quot;,
                    levelUnlock: &quot;Niveles:&quot;,
                    levelUnlockDesc: &quot;Desbloquea nuevos desafíos&quot;
                }
            },
            de: {
                title: &quot;Enigma Hunter&quot;,
                subtitle: &quot;Quantum Rätsel-Jäger mit KI&quot;,
                start: &quot;🚀 Starten&quot;,
                pause: &quot;⏸️ Pause&quot;,
                resume: &quot;▶️ Fortsetzen&quot;,
                rules: &quot;Regeln&quot;,
                newGame: &quot;🔄 Neues Spiel&quot;,
                aiName: &quot;CIPHER-AI&quot;,
                aiWelcome: &quot;Hallo! Ich bin CIPHER-AI, dein Quantum-Assistent. Bereit, geheimnisvolle Rätsel zu lösen?&quot;,
                statsTitle: &quot;Statistiken&quot;,
                solved: &quot;Gelöst:&quot;,
                failed: &quot;Gescheitert:&quot;,
                streak: &quot;Serie:&quot;,
                level: &quot;Level:&quot;,
                score: &quot;Punkte:&quot;,
                difficultyTitle: &quot;Schwierigkeit&quot;,
                currentDiff: &quot;Aktuell:&quot;,
                timeLeft: &quot;Zeit:&quot;,
                hintsLeft: &quot;Hinweise:&quot;,
                objectiveName: &quot;ZIEL&quot;,
                rulesMessage: &quot;Löse das Rätsel bevor die Zeit abläuft!&quot;,
                startMessage: &quot;Klicke \&quot;Starten\&quot; um dein Rätsel-Jäger Abenteuer zu beginnen!&quot;,
                welcomeMessage: &quot;Willkommen bei Enigma Hunter! Löse geheimnisvolle Rätsel mit Hilfe deiner KI.&quot;,
                rulesTitle: &quot;📖 Enigma Hunter Regeln&quot;,
                pauseTitle: &quot;⏸️ Spiel Pausiert&quot;,
                pauseMessage: &quot;Das Spiel ist derzeit pausiert. Lass dir Zeit!&quot;,
                levelIndicator: &quot;Level&quot;,
                closeBtn: &quot;Schließen&quot;,
                submitBtn: &quot;Senden&quot;,
                hintBtn: &quot;Hinweis&quot;,
                hintTitle: &quot;💡 Hinweis &amp; Lösung&quot;,
                solutionBtn: &quot;Lösung&quot;,
                progressTitle: &quot;Level-Fortschritt&quot;,
                inputPlaceholder: &quot;Gib deine Antwort hier ein...&quot;,
                difficulties: {
                    easy: &quot;Einfach&quot;,
                    medium: &quot;Mittel&quot;,
                    hard: &quot;Schwer&quot;,
                    expert: &quot;Experte&quot;
                },
                messages: {
                    correct: &quot;🎉 Ausgezeichnet! Richtige Antwort!&quot;,
                    wrong: &quot;❌ Falsch. Versuche es nochmal!&quot;,
                    timeout: &quot;⏰ Zeit ist um! Weiter zum nächsten.&quot;,
                    levelUp: &quot;🎊 Level aufgestiegen! Glückwunsch!&quot;,
                    gameOver: &quot;🏁 Spiel vorbei! Endpunktzahl:&quot;,
                    hint: &quot;💡 Hier ist ein Hinweis um dir zu helfen...&quot;,
                    noHints: &quot;❌ Keine Hinweise mehr verfügbar!&quot;,
                    newRecord: &quot;🏆 Neuer persönlicher Rekord!&quot;
                },
                aiMessages: {
                    encouragement: [
                        &quot;Du bist fast da! Mach weiter!&quot;,
                        &quot;Ausgezeichnete Logik! Weiter so!&quot;,
                        &quot;Deine Überlegung ist gut!&quot;,
                        &quot;Fantastisch! Du machst gute Fortschritte!&quot;
                    ],
                    hints: [
                        &quot;Denk anders...&quot;,
                        &quot;Die Antwort ist einfacher als sie scheint.&quot;,
                        &quot;Schau dir die Details genau an.&quot;,
                        &quot;Verwende Logik Schritt für Schritt.&quot;
                    ]
                },
                rules: {
                    objectiveTitle: &quot;🎯 Ziel&quot;,
                    objectiveText: &quot;Löse zunehmend komplexe Rätsel mit deiner Logik und der Hilfe deines KI-Assistenten CIPHER-AI.&quot;,
                    gameplayTitle: &quot;🎮 Spielweise&quot;,
                    variedEnigmas: &quot;Vielfältige Rätsel:&quot;,
                    variedEnigmasDesc: &quot;Mathematik, Logik, Wörter, Geheimcodes&quot;,
                    timedChallenges: &quot;Zeitbegrenzt:&quot;,
                    timedChallengesDesc: &quot;Jedes Rätsel hat ein Zeitlimit&quot;,
                    progressiveLevels: &quot;Progressive Level:&quot;,
                    progressiveLevelsDesc: &quot;Die Schwierigkeit steigt mit deinem Fortschritt&quot;,
                    hintSystem: &quot;Hinweis-System:&quot;,
                    hintSystemDesc: &quot;Verwende Hinweise um dir zu helfen&quot;,
                    solutionSystem: &quot;Lösungs-Button:&quot;,
                    solutionSystemDesc: &quot;Zeige die Antwort wenn du feststeckst&quot;,
                    scoringTitle: &quot;🏆 Punktesystem&quot;,
                    fastSolving: &quot;Schnelles Lösen:&quot;,
                    fastSolvingDesc: &quot;Je schneller du bist, desto mehr Punkte erhältst du&quot;,
                    noHints: &quot;Ohne Hinweise:&quot;,
                    noHintsDesc: &quot;Bonus für das Lösen ohne Hilfe&quot;,
                    streaks: &quot;Serien:&quot;,
                    streaksDesc: &quot;Bonus für aufeinanderfolgende Lösungen&quot;,
                    levelUnlock: &quot;Level:&quot;,
                    levelUnlockDesc: &quot;Schalte neue Herausforderungen frei&quot;
                }
            },
            zh: {
                title: &quot;谜题猎人&quot;,
                subtitle: &quot;量子谜题猎人与AI&quot;,
                start: &quot;🚀 开始&quot;,
                pause: &quot;⏸️ 暂停&quot;,
                resume: &quot;▶️ 继续&quot;,
                rules: &quot;规则&quot;,
                newGame: &quot;🔄 新游戏&quot;,
                aiName: &quot;密码-AI&quot;,
                aiWelcome: &quot;你好！我是密码-AI，你的量子助手。准备好解决神秘谜题了吗？&quot;,
                statsTitle: &quot;统计&quot;,
                solved: &quot;已解决:&quot;,
                failed: &quot;失败:&quot;,
                streak: &quot;连胜:&quot;,
                level: &quot;等级:&quot;,
                score: &quot;分数:&quot;,
                difficultyTitle: &quot;难度&quot;,
                currentDiff: &quot;当前:&quot;,
                timeLeft: &quot;时间:&quot;,
                hintsLeft: &quot;提示:&quot;,
                objectiveName: &quot;目标&quot;,
                rulesMessage: &quot;在时间用完之前解决谜题！&quot;,
                startMessage: &quot;点击\&quot;开始\&quot;开始你的谜题猎人冒险！&quot;,
                welcomeMessage: &quot;欢迎来到谜题猎人！在AI的帮助下解决神秘谜题。&quot;,
                rulesTitle: &quot;📖 谜题猎人规则&quot;,
                pauseTitle: &quot;⏸️ 游戏暂停&quot;,
                pauseMessage: &quot;游戏当前已暂停。慢慢来！&quot;,
                levelIndicator: &quot;等级&quot;,
                closeBtn: &quot;关闭&quot;,
                submitBtn: &quot;提交&quot;,
                hintBtn: &quot;提示&quot;,
                hintTitle: &quot;💡 提示与答案&quot;,
                solutionBtn: &quot;答案&quot;,
                progressTitle: &quot;等级进度&quot;,
                inputPlaceholder: &quot;在这里输入你的答案...&quot;,
                difficulties: {
                    easy: &quot;简单&quot;,
                    medium: &quot;中等&quot;,
                    hard: &quot;困难&quot;,
                    expert: &quot;专家&quot;
                },
                messages: {
                    correct: &quot;🎉 太棒了！答案正确！&quot;,
                    wrong: &quot;❌ 错误。再试一次！&quot;,
                    timeout: &quot;⏰ 时间到！进入下一题。&quot;,
                    levelUp: &quot;🎊 升级了！恭喜！&quot;,
                    gameOver: &quot;🏁 游戏结束！最终得分：&quot;,
                    hint: &quot;💡 这里有个提示帮助你...&quot;,
                    noHints: &quot;❌ 没有更多提示了！&quot;,
                    newRecord: &quot;🏆 新的个人记录！&quot;
                },
                aiMessages: {
                    encouragement: [
                        &quot;你快成功了！继续！&quot;,
                        &quot;逻辑很棒！继续！&quot;,
                        &quot;你的推理很好！&quot;,
                        &quot;太棒了！你进步很好！&quot;
                    ],
                    hints: [
                        &quot;换个角度思考...&quot;,
                        &quot;答案比看起来简单。&quot;,
                        &quot;仔细看细节。&quot;,
                        &quot;一步步使用逻辑。&quot;
                    ]
                },
                rules: {
                    objectiveTitle: &quot;🎯 目标&quot;,
                    objectiveText: &quot;使用你的逻辑和AI助手密码-AI的帮助解决越来越复杂的谜题。&quot;,
                    gameplayTitle: &quot;🎮 游戏玩法&quot;,
                    variedEnigmas: &quot;多样谜题:&quot;,
                    variedEnigmasDesc: &quot;数学、逻辑、文字、密码&quot;,
                    timedChallenges: &quot;限时挑战:&quot;,
                    timedChallengesDesc: &quot;每个谜题都有时间限制&quot;,
                    progressiveLevels: &quot;渐进等级:&quot;,
                    progressiveLevelsDesc: &quot;难度随着你的进步而增加&quot;,
                    hintSystem: &quot;提示系统:&quot;,
                    hintSystemDesc: &quot;使用提示来帮助你&quot;,
                    solutionSystem: &quot;答案按钮:&quot;,
                    solutionSystemDesc: &quot;如果卡住了就显示答案&quot;,
                    scoringTitle: &quot;🏆 计分系统&quot;,
                    fastSolving: &quot;快速解决:&quot;,
                    fastSolvingDesc: &quot;你越快，得到的分数越多&quot;,
                    noHints: &quot;无提示:&quot;,
                    noHintsDesc: &quot;无帮助解决的奖励&quot;,
                    streaks: &quot;连胜:&quot;,
                    streaksDesc: &quot;连续解决的奖励&quot;,
                    levelUnlock: &quot;等级:&quot;,
                    levelUnlockDesc: &quot;解锁新挑战&quot;
                }
            }
        };

        let currentLanguage = &#x27;fr&#x27;;
    var gameState = {
            isPlaying: false,
            isPaused: false,
            currentEnigma: null,
            level: 1,
            score: 0,
            solved: 0,
            failed: 0,jeu 16

            streak: 0,
            hintsLeft: 3,
            timeLeft: 0,
            timer: null,
            difficulty: &#x27;easy&#x27;,
            enigmasInLevel: 0,
            enigmasNeededForLevel: 3,
            usedEnigmas: {
                easy: [],
                medium: [],
                hard: []
            }
        };

        const enigmas = {
            fr: {
                easy: [
                    { question: &quot;Quel est le résultat de 15 + 27 ?&quot;, answer: &quot;42&quot;, hint: &quot;Additionnez simplement les deux nombres.&quot;, time: 30 },
                    { question: &quot;Complétez la séquence : 2, 4, 6, 8, ?&quot;, answer: &quot;10&quot;, hint: &quot;C&#x27;est une suite de nombres pairs.&quot;, time: 25 },
                    { question: &quot;Quel mot peut être lu de la même façon à l&#x27;endroit et à l&#x27;envers ?&quot;, answer: &quot;radar&quot;, hint: &quot;C&#x27;est un palindrome de 5 lettres utilisé pour détecter.&quot;, time: 40 },
                    { question: &quot;Combien font 8 × 7 ?&quot;, answer: &quot;56&quot;, hint: &quot;Multipliez 8 par 7.&quot;, time: 20 },
                    { question: &quot;Quel est le double de 25 ?&quot;, answer: &quot;50&quot;, hint: &quot;Multipliez 25 par 2.&quot;, time: 20 }
                ],
                medium: [
                    { question: &quot;Résolvez : 3x + 7 = 22. Que vaut x ?&quot;, answer: &quot;5&quot;, hint: &quot;Soustrayez 7 des deux côtés, puis divisez par 3.&quot;, time: 60 },
                    { question: &quot;Quel est l&#x27;anagramme de &#x27;LISTEN&#x27; ?&quot;, answer: &quot;silent&quot;, hint: &quot;Réarrangez les lettres pour former un mot opposé.&quot;, time: 50 },
                    { question: &quot;Dans une suite de Fibonacci, après 1, 1, 2, 3, 5, quel est le nombre suivant ?&quot;, answer: &quot;8&quot;, hint: &quot;Chaque nombre est la somme des deux précédents.&quot;, time: 40 }
                ],
                hard: [
                    { question: &quot;Décodez ce message César (décalage de 3) : &#x27;FDHVDU&#x27;&quot;, answer: &quot;caesar&quot;, hint: &quot;Reculez chaque lettre de 3 positions dans l&#x27;alphabet.&quot;, time: 90 },
                    { question: &quot;Quel est le plus petit nombre premier supérieur à 50 ?&quot;, answer: &quot;53&quot;, hint: &quot;Testez la divisibilité par les nombres premiers jusqu&#x27;à sa racine carrée.&quot;, time: 75 }
                ]
            },
            en: {
                easy: [
                    { question: &quot;What is 15 + 27?&quot;, answer: &quot;42&quot;, hint: &quot;Simply add the two numbers together.&quot;, time: 30 },
                    { question: &quot;Complete the sequence: 2, 4, 6, 8, ?&quot;, answer: &quot;10&quot;, hint: &quot;It&#x27;s a sequence of even numbers.&quot;, time: 25 },
                    { question: &quot;What word can be read the same forwards and backwards?&quot;, answer: &quot;radar&quot;, hint: &quot;It&#x27;s a 5-letter palindrome used for detection.&quot;, time: 40 },
                    { question: &quot;What is 8 × 7?&quot;, answer: &quot;56&quot;, hint: &quot;Multiply 8 by 7.&quot;, time: 20 },
                    { question: &quot;What is double 25?&quot;, answer: &quot;50&quot;, hint: &quot;Multiply 25 by 2.&quot;, time: 20 }
                ],
                medium: [
                    { question: &quot;Solve: 3x + 7 = 22. What is x?&quot;, answer: &quot;5&quot;, hint: &quot;Subtract 7 from both sides, then divide by 3.&quot;, time: 60 },
                    { question: &quot;What is the anagram of &#x27;LISTEN&#x27;?&quot;, answer: &quot;silent&quot;, hint: &quot;Rearrange the letters to form an opposite word.&quot;, time: 50 },
                    { question: &quot;In Fibonacci sequence, after 1, 1, 2, 3, 5, what&#x27;s next?&quot;, answer: &quot;8&quot;, hint: &quot;Each number is the sum of the two preceding ones.&quot;, time: 40 }
                ],
                hard: [
                    { question: &quot;Decode this Caesar cipher (shift 3): &#x27;FDHVDU&#x27;&quot;, answer: &quot;caesar&quot;, hint: &quot;Move each letter back 3 positions in the alphabet.&quot;, time: 90 },
                    { question: &quot;What is the smallest prime number greater than 50?&quot;, answer: &quot;53&quot;, hint: &quot;Test divisibility by prime numbers up to its square root.&quot;, time: 75 }
                ]
            },
            ar: {
                easy: [
                    { question: &quot;ما هو ناتج 15 + 27؟&quot;, answer: &quot;42&quot;, hint: &quot;اجمع الرقمين ببساطة.&quot;, time: 30 },
                    { question: &quot;أكمل التسلسل: 2، 4، 6، 8، ؟&quot;, answer: &quot;10&quot;, hint: &quot;إنه تسلسل من الأرقام الزوجية.&quot;, time: 25 },
                    { question: &quot;ما الكلمة التي تُقرأ بنفس الطريقة من الأمام والخلف؟&quot;, answer: &quot;رادار&quot;, hint: &quot;إنها كلمة متناظرة من 5 أحرف تُستخدم للكشف.&quot;, time: 40 },
                    { question: &quot;كم يساوي 8 × 7؟&quot;, answer: &quot;56&quot;, hint: &quot;اضرب 8 في 7.&quot;, time: 20 },
                    { question: &quot;ما هو ضعف 25؟&quot;, answer: &quot;50&quot;, hint: &quot;اضرب 25 في 2.&quot;, time: 20 }
                ],
                medium: [
                    { question: &quot;حل: 3س + 7 = 22. ما قيمة س؟&quot;, answer: &quot;5&quot;, hint: &quot;اطرح 7 من الطرفين، ثم اقسم على 3.&quot;, time: 60 },
                    { question: &quot;ما هو تبديل أحرف &#x27;LISTEN&#x27;؟&quot;, answer: &quot;silent&quot;, hint: &quot;أعد ترتيب الأحرف لتكوين كلمة معاكسة.&quot;, time: 50 },
                    { question: &quot;في متتالية فيبوناتشي، بعد 1، 1، 2، 3، 5، ما التالي؟&quot;, answer: &quot;8&quot;, hint: &quot;كل رقم هو مجموع الرقمين السابقين.&quot;, time: 40 }
                ],
                hard: [
                    { question: &quot;فك تشفير قيصر (إزاحة 3): &#x27;FDHVDU&#x27;&quot;, answer: &quot;caesar&quot;, hint: &quot;حرك كل حرف 3 مواضع للخلف في الأبجدية.&quot;, time: 90 },
                    { question: &quot;ما أصغر عدد أولي أكبر من 50؟&quot;, answer: &quot;53&quot;, hint: &quot;اختبر القسمة على الأعداد الأولية حتى جذره التربيعي.&quot;, time: 75 }
                ]
            },
            es: {
                easy: [
                    { question: &quot;¿Cuánto es 15 + 27?&quot;, answer: &quot;42&quot;, hint: &quot;Simplemente suma los dos números.&quot;, time: 30 },
                    { question: &quot;Completa la secuencia: 2, 4, 6, 8, ?&quot;, answer: &quot;10&quot;, hint: &quot;Es una secuencia de números pares.&quot;, time: 25 },
                    { question: &quot;¿Qué palabra se lee igual hacia adelante y hacia atrás?&quot;, answer: &quot;radar&quot;, hint: &quot;Es un palíndromo de 5 letras usado para detectar.&quot;, time: 40 },
                    { question: &quot;¿Cuánto es 8 × 7?&quot;, answer: &quot;56&quot;, hint: &quot;Multiplica 8 por 7.&quot;, time: 20 },
                    { question: &quot;¿Cuál es el doble de 25?&quot;, answer: &quot;50&quot;, hint: &quot;Multiplica 25 por 2.&quot;, time: 20 }
                ],
                medium: [
                    { question: &quot;Resuelve: 3x + 7 = 22. ¿Cuál es x?&quot;, answer: &quot;5&quot;, hint: &quot;Resta 7 de ambos lados, luego divide por 3.&quot;, time: 60 },
                    { question: &quot;¿Cuál es el anagrama de &#x27;LISTEN&#x27;?&quot;, answer: &quot;silent&quot;, hint: &quot;Reorganiza las letras para formar una palabra opuesta.&quot;, time: 50 },
                    { question: &quot;En la secuencia de Fibonacci, después de 1, 1, 2, 3, 5, ¿qué sigue?&quot;, answer: &quot;8&quot;, hint: &quot;Cada número es la suma de los dos anteriores.&quot;, time: 40 }
                ],
                hard: [
                    { question: &quot;Decodifica este cifrado César (desplazamiento 3): &#x27;FDHVDU&#x27;&quot;, answer: &quot;caesar&quot;, hint: &quot;Mueve cada letra 3 posiciones hacia atrás en el alfabeto.&quot;, time: 90 },
                    { question: &quot;¿Cuál es el número primo más pequeño mayor que 50?&quot;, answer: &quot;53&quot;, hint: &quot;Prueba la divisibilidad por números primos hasta su raíz cuadrada.&quot;, time: 75 }
                ]
            },
            de: {
                easy: [
                    { question: &quot;Was ist 15 + 27?&quot;, answer: &quot;42&quot;, hint: &quot;Addiere einfach die beiden Zahlen.&quot;, time: 30 },
                    { question: &quot;Vervollständige die Sequenz: 2, 4, 6, 8, ?&quot;, answer: &quot;10&quot;, hint: &quot;Es ist eine Folge gerader Zahlen.&quot;, time: 25 },
                    { question: &quot;Welches Wort kann vorwärts und rückwärts gleich gelesen werden?&quot;, answer: &quot;radar&quot;, hint: &quot;Es ist ein 5-Buchstaben-Palindrom zur Erkennung.&quot;, time: 40 },
                    { question: &quot;Was ist 8 × 7?&quot;, answer: &quot;56&quot;, hint: &quot;Multipliziere 8 mit 7.&quot;, time: 20 },
                    { question: &quot;Was ist das Doppelte von 25?&quot;, answer: &quot;50&quot;, hint: &quot;Multipliziere 25 mit 2.&quot;, time: 20 }
                ],
                medium: [
                    { question: &quot;Löse: 3x + 7 = 22. Was ist x?&quot;, answer: &quot;5&quot;, hint: &quot;Subtrahiere 7 von beiden Seiten, dann teile durch 3.&quot;, time: 60 },
                    { question: &quot;Was ist das Anagramm von &#x27;LISTEN&#x27;?&quot;, answer: &quot;silent&quot;, hint: &quot;Ordne die Buchstaben neu, um ein gegenteiliges Wort zu bilden.&quot;, time: 50 },
                    { question: &quot;In der Fibonacci-Folge, nach 1, 1, 2, 3, 5, was kommt als nächstes?&quot;, answer: &quot;8&quot;, hint: &quot;Jede Zahl ist die Summe der beiden vorhergehenden.&quot;, time: 40 }
                ],
                hard: [
                    { question: &quot;Entschlüssele diese Caesar-Chiffre (Verschiebung 3): &#x27;FDHVDU&#x27;&quot;, answer: &quot;caesar&quot;, hint: &quot;Bewege jeden Buchstaben 3 Positionen im Alphabet zurück.&quot;, time: 90 },
                    { question: &quot;Was ist die kleinste Primzahl größer als 50?&quot;, answer: &quot;53&quot;, hint: &quot;Teste die Teilbarkeit durch Primzahlen bis zu ihrer Quadratwurzel.&quot;, time: 75 }
                ]
            },
            zh: {
                easy: [
                    { question: &quot;15 + 27 等于多少？&quot;, answer: &quot;42&quot;, hint: &quot;简单地将两个数字相加。&quot;, time: 30 },
                    { question: &quot;完成序列：2, 4, 6, 8, ?&quot;, answer: &quot;10&quot;, hint: &quot;这是一个偶数序列。&quot;, time: 25 },
                    { question: &quot;什么词正读反读都一样？&quot;, answer: &quot;radar&quot;, hint: &quot;这是一个用于探测的5字母回文词。&quot;, time: 40 },
                    { question: &quot;8 × 7 等于多少？&quot;, answer: &quot;56&quot;, hint: &quot;将8乘以7。&quot;, time: 20 },
                    { question: &quot;25的两倍是多少？&quot;, answer: &quot;50&quot;, hint: &quot;将25乘以2。&quot;, time: 20 }
                ],
                medium: [
                    { question: &quot;解：3x + 7 = 22。x等于多少？&quot;, answer: &quot;5&quot;, hint: &quot;两边都减去7，然后除以3。&quot;, time: 60 },
                    { question: &quot;&#x27;LISTEN&#x27;的字母重组词是什么？&quot;, answer: &quot;silent&quot;, hint: &quot;重新排列字母形成一个相反的词。&quot;, time: 50 },
                    { question: &quot;在斐波那契数列中，1, 1, 2, 3, 5之后是什么？&quot;, answer: &quot;8&quot;, hint: &quot;每个数字都是前两个数字的和。&quot;, time: 40 }
                ],
                hard: [
                    { question: &quot;解码这个凯撒密码（移位3）：&#x27;FDHVDU&#x27;&quot;, answer: &quot;caesar&quot;, hint: &quot;将每个字母在字母表中向后移动3个位置。&quot;, time: 90 },
                    { question: &quot;大于50的最小质数是什么？&quot;, answer: &quot;53&quot;, hint: &quot;测试被质数整除直到其平方根。&quot;, time: 75 }
                ]
            }
        };

        function createParticles() {
            const particlesContainer = document.getElementById(&#x27;particles&#x27;);
            for (let i = 0; i &lt; 20; i++) {
                const particle = document.createElement(&#x27;div&#x27;);
                particle.className = &#x27;particle&#x27;;
                particle.style.left = Math.random() * 100 + &#x27;%&#x27;;
                particle.style.animationDelay = Math.random() * 12 + &#x27;s&#x27;;
                particle.style.animationDuration = (Math.random() * 6 + 6) + &#x27;s&#x27;;
                particlesContainer.appendChild(particle);
            }
        }

        function updateLanguage() {
            const lang = document.getElementById(&#x27;languageSelect&#x27;).value;
            currentLanguage = lang;
            const t = translations[lang];
            
            // Update UI elements
            document.getElementById(&#x27;gameTitle&#x27;).textContent = t.title;
            document.getElementById(&#x27;gameSubtitle&#x27;).textContent = t.subtitle;
            document.getElementById(&#x27;startBtn&#x27;).innerHTML = t.start;
            document.getElementById(&#x27;pauseBtn&#x27;).innerHTML = gameState.isPaused ? t.resume : t.pause;
            document.getElementById(&#x27;rulesBtn&#x27;).innerHTML = `📖 ${t.rules.replace(&#x27;📖 &#x27;, &#x27;&#x27;)}`;
            document.getElementById(&#x27;newGameBtn&#x27;).innerHTML = t.newGame;
            document.getElementById(&#x27;aiName&#x27;).textContent = t.aiName;
            document.getElementById(&#x27;aiMessage&#x27;).textContent = t.aiWelcome;
            document.getElementById(&#x27;statsTitle&#x27;).textContent = t.statsTitle;
            document.getElementById(&#x27;solvedLabel&#x27;).textContent = t.solved;
            document.getElementById(&#x27;failedLabel&#x27;).textContent = t.failed;
            document.getElementById(&#x27;streakLabel&#x27;).textContent = t.streak;
            document.getElementById(&#x27;levelLabel&#x27;).textContent = t.level;
            document.getElementById(&#x27;scoreLabel&#x27;).textContent = t.score;
            document.getElementById(&#x27;difficultyTitle&#x27;).textContent = t.difficultyTitle;
            document.getElementById(&#x27;currentDiffLabel&#x27;).textContent = t.currentDiff;
            document.getElementById(&#x27;timeLeftLabel&#x27;).textContent = t.timeLeft;
            document.getElementById(&#x27;hintsLeftLabel&#x27;).textContent = t.hintsLeft;
            document.getElementById(&#x27;rulesName&#x27;).textContent = t.objectiveName;
            document.getElementById(&#x27;rulesTitle&#x27;).textContent = t.rulesTitle;
            document.getElementById(&#x27;rulesMessage&#x27;).textContent = t.rulesMessage;
            document.getElementById(&#x27;levelIndicator&#x27;).textContent = t.levelIndicator + &#x27; &#x27; + gameState.level;
            document.getElementById(&#x27;submitBtn&#x27;).textContent = t.submitBtn;
            document.getElementById(&#x27;hintBtnRight&#x27;).textContent = t.hintBtn;
            document.getElementById(&#x27;solutionBtnRight&#x27;).textContent = t.solutionBtn;
            document.getElementById(&#x27;hintTitleRight&#x27;).textContent = t.hintTitle;

            document.getElementById(&#x27;progressTitle&#x27;).textContent = t.progressTitle;
            document.getElementById(&#x27;enigmaInput&#x27;).placeholder = t.inputPlaceholder;
            document.getElementById(&#x27;closeRulesBtn&#x27;).textContent = t.closeBtn;
            
            // Update rules content
            if (t.rules) {
                document.getElementById(&#x27;objectiveTitle&#x27;).textContent = t.rules.objectiveTitle;
                document.getElementById(&#x27;objectiveText&#x27;).textContent = t.rules.objectiveText;
                document.getElementById(&#x27;gameplayTitle&#x27;).textContent = t.rules.gameplayTitle;
                document.getElementById(&#x27;variedEnigmas&#x27;).textContent = t.rules.variedEnigmas;
                document.getElementById(&#x27;variedEnigmasDesc&#x27;).textContent = t.rules.variedEnigmasDesc;
                document.getElementById(&#x27;timedChallenges&#x27;).textContent = t.rules.timedChallenges;
                document.getElementById(&#x27;timedChallengesDesc&#x27;).textContent = t.rules.timedChallengesDesc;
                document.getElementById(&#x27;progressiveLevels&#x27;).textContent = t.rules.progressiveLevels;
                document.getElementById(&#x27;progressiveLevelsDesc&#x27;).textContent = t.rules.progressiveLevelsDesc;
                document.getElementById(&#x27;hintSystem&#x27;).textContent = t.rules.hintSystem;
                document.getElementById(&#x27;hintSystemDesc&#x27;).textContent = t.rules.hintSystemDesc;
                document.getElementById(&#x27;solutionSystem&#x27;).textContent = t.rules.solutionSystem;
                document.getElementById(&#x27;solutionSystemDesc&#x27;).textContent = t.rules.solutionSystemDesc;
                document.getElementById(&#x27;scoringTitle&#x27;).textContent = t.rules.scoringTitle;
                document.getElementById(&#x27;fastSolving&#x27;).textContent = t.rules.fastSolving;
                document.getElementById(&#x27;fastSolvingDesc&#x27;).textContent = t.rules.fastSolvingDesc;
                document.getElementById(&#x27;noHints&#x27;).textContent = t.rules.noHints;
                document.getElementById(&#x27;noHintsDesc&#x27;).textContent = t.rules.noHintsDesc;
                document.getElementById(&#x27;streaks&#x27;).textContent = t.rules.streaks;
                document.getElementById(&#x27;streaksDesc&#x27;).textContent = t.rules.streaksDesc;
                document.getElementById(&#x27;levelUnlock&#x27;).textContent = t.rules.levelUnlock;
                document.getElementById(&#x27;levelUnlockDesc&#x27;).textContent = t.rules.levelUnlockDesc;
            }
            
            // Update difficulty display
            document.getElementById(&#x27;currentDiffValue&#x27;).textContent = t.difficulties[gameState.difficulty];
            
            if (!gameState.isPlaying) {
                document.getElementById(&#x27;enigmaText&#x27;).textContent = t.startMessage;
                document.getElementById(&#x27;gameMessage&#x27;).textContent = t.welcomeMessage;
            }
            
            // Set text direction for Arabic
            if (lang === &#x27;ar&#x27;) {
                document.body.style.direction = &#x27;rtl&#x27;;
                document.body.style.textAlign = &#x27;right&#x27;;
            } else {
                document.body.style.direction = &#x27;ltr&#x27;;
                document.body.style.textAlign = &#x27;left&#x27;;
            }
        }

        function startGame() {
            gameState.isPlaying = true;
            gameState.isPaused = false;
            gameState.level = 1;
            gameState.score = 0;
            gameState.solved = 0;
            gameState.failed = 0;
            gameState.streak = 0;
            gameState.hintsLeft = 3;
            gameState.difficulty = &#x27;easy&#x27;;
            gameState.enigmasInLevel = 0;
            gameState.usedEnigmas = {
                easy: [],
                medium: [],
                hard: []
            };
            
            document.getElementById(&#x27;startBtn&#x27;).disabled = true;
            document.getElementById(&#x27;pauseBtn&#x27;).disabled = false;
            document.getElementById(&#x27;enigmaInput&#x27;).style.display = &#x27;block&#x27;;
            document.getElementById(&#x27;submitBtn&#x27;).style.display = &#x27;block&#x27;;

            document.getElementById(&#x27;hintSystemRight&#x27;).style.display = &#x27;block&#x27;;
            
            updateStats();
            nextEnigma();
            updateAIMessage(translations[currentLanguage].aiMessages.encouragement[0]);
        }

        function nextEnigma() {
            const enigmaList = enigmas[currentLanguage][gameState.difficulty];
            if (!enigmaList || enigmaList.length === 0) return;
            
            // Get unused enigmas for current difficulty
            const usedList = gameState.usedEnigmas[gameState.difficulty];
            const availableEnigmas = enigmaList.filter((_, index) =&gt; !usedList.includes(index));
            
            // If all enigmas used, reset the used list
            if (availableEnigmas.length === 0) {
                gameState.usedEnigmas[gameState.difficulty] = [];
                availableEnigmas.push(...enigmaList);
            }
            
            // Select random enigma from available ones
            const randomIndex = Math.floor(Math.random() * availableEnigmas.length);
            gameState.currentEnigma = availableEnigmas[randomIndex];
            
            // Mark this enigma as used
            const originalIndex = enigmaList.indexOf(gameState.currentEnigma);
            gameState.usedEnigmas[gameState.difficulty].push(originalIndex);
            
            gameState.timeLeft = gameState.currentEnigma.time;
            
            document.getElementById(&#x27;enigmaText&#x27;).textContent = gameState.currentEnigma.question;
            document.getElementById(&#x27;enigmaInput&#x27;).value = &#x27;&#x27;;
            document.getElementById(&#x27;enigmaInput&#x27;).focus();
            
            startTimer();
            updateGameMessage(translations[currentLanguage].targetMessage);
        }

        function startTimer() {
            if (gameState.timer) clearInterval(gameState.timer);
            
            gameState.timer = setInterval(() =&gt; {
                if (!gameState.isPaused &amp;&amp; gameState.timeLeft &gt; 0) {
                    gameState.timeLeft--;
                    updateTimerDisplay();
                    
                    if (gameState.timeLeft === 0) {
                        timeOut();
                    }
                }
            }, 1000);
        }

        function updateTimerDisplay() {
            const minutes = Math.floor(gameState.timeLeft / 60);
            const seconds = gameState.timeLeft % 60;
            document.getElementById(&#x27;timerText&#x27;).textContent = 
                `${minutes.toString().padStart(2, &#x27;0&#x27;)}:${seconds.toString().padStart(2, &#x27;0&#x27;)}`;
            document.getElementById(&#x27;timeLeftValue&#x27;).textContent = `${gameState.timeLeft}s`;
        }

        function submitAnswer() {
            const userAnswer = document.getElementById(&#x27;enigmaInput&#x27;).value.trim().toLowerCase();
            const correctAnswer = gameState.currentEnigma.answer.toLowerCase();
            
            if (userAnswer === correctAnswer) {
                correctAnswerHandler();
            } else {
                wrongAnswer();
            }
        }

        function correctAnswerHandler() {
            gameState.solved++;
            gameState.streak++;
            gameState.enigmasInLevel++;
            
            const timeBonus = Math.floor(gameState.timeLeft * 10);
            const streakBonus = gameState.streak * 50;
            const scoreGain = 100 + timeBonus + streakBonus;
            gameState.score += scoreGain;
            
            clearInterval(gameState.timer);
            updateStats();
            updateGameMessage(translations[currentLanguage].messages.correct);
            updateAIMessage(translations[currentLanguage].aiMessages.encouragement[Math.floor(Math.random() * translations[currentLanguage].aiMessages.encouragement.length)]);
            
            if (gameState.enigmasInLevel &gt;= gameState.enigmasNeededForLevel) {
                levelUp();
            } else {
                setTimeout(nextEnigma, 2000);
            }
        }

        function wrongAnswer() {
            gameState.failed++;
            gameState.streak = 0;
            updateStats();
            updateGameMessage(translations[currentLanguage].messages.wrong);
            updateAIMessage(translations[currentLanguage].aiMessages.hints[Math.floor(Math.random() * translations[currentLanguage].aiMessages.hints.length)]);
        }

        function timeOut() {
            gameState.failed++;
            gameState.streak = 0;
            clearInterval(gameState.timer);
            updateStats();
            updateGameMessage(translations[currentLanguage].messages.timeout);
            setTimeout(nextEnigma, 2000);
        }

        function levelUp() {
            gameState.level++;
            gameState.enigmasInLevel = 0;
            gameState.hintsLeft = 3;
            
            if (gameState.level &lt;= 3) gameState.difficulty = &#x27;easy&#x27;;
            else if (gameState.level &lt;= 6) gameState.difficulty = &#x27;medium&#x27;;
            else gameState.difficulty = &#x27;hard&#x27;;
            
            updateStats();
            updateGameMessage(translations[currentLanguage].messages.levelUp);
            updateAIMessage(`🎊 ${translations[currentLanguage].levelIndicator} ${gameState.level} !`);
            
            setTimeout(nextEnigma, 3000);
        }

        function useHint() {
            if (gameState.hintsLeft &gt; 0) {
                gameState.hintsLeft--;
                document.getElementById(&#x27;hintText&#x27;).textContent = gameState.currentEnigma.hint;
                document.getElementById(&#x27;hintTextRight&#x27;).textContent = gameState.currentEnigma.hint;
                updateStats();
                updateGameMessage(translations[currentLanguage].messages.hint);
            } else {
                updateGameMessage(translations[currentLanguage].messages.noHints);
            }
        }

        function showSolution() {
            if (gameState.currentEnigma) {
                // Show the solution
                document.getElementById(&#x27;enigmaInput&#x27;).value = gameState.currentEnigma.answer;
                document.getElementById(&#x27;hintText&#x27;).textContent = `💡 Solution: ${gameState.currentEnigma.answer}`;
                document.getElementById(&#x27;hintTextRight&#x27;).textContent = `💡 Solution: ${gameState.currentEnigma.answer}`;
                
                // Mark as failed but allow progression
                gameState.failed++;
                gameState.streak = 0;
                gameState.enigmasInLevel++;
                
                clearInterval(gameState.timer);
                updateStats();
                updateGameMessage(&quot;🔓 &quot; + translations[currentLanguage].messages.solutionRevealed || &quot;Solution révélée ! Passage au niveau suivant...&quot;);
                updateAIMessage(translations[currentLanguage].messages.encourageAfterSolution || &quot;Ne vous découragez pas ! Chaque énigme est une leçon.&quot;);
                
                if (gameState.enigmasInLevel &gt;= gameState.enigmasNeededForLevel) {
                    setTimeout(levelUp, 2000);
                } else {
                    setTimeout(nextEnigma, 2000);
                }
            }
        }

        function togglePause() {
            gameState.isPaused = !gameState.isPaused;
            
            if (gameState.isPaused) {
                document.getElementById(&#x27;pausePanel&#x27;).style.display = &#x27;block&#x27;;
                document.getElementById(&#x27;pauseBtn&#x27;).innerHTML = translations[currentLanguage].resume;
            } else {
                document.getElementById(&#x27;pausePanel&#x27;).style.display = &#x27;none&#x27;;
                document.getElementById(&#x27;pauseBtn&#x27;).innerHTML = translations[currentLanguage].pause;
            }
        }

        function newGame() {
            if (gameState.timer) clearInterval(gameState.timer);
            
            gameState.isPlaying = false;
            gameState.isPaused = false;
            gameState.currentEnigma = null;
            gameState.level = 1;
            gameState.score = 0;
            gameState.solved = 0;
            gameState.failed = 0;
            gameState.streak = 0;
            gameState.hintsLeft = 3;
            gameState.difficulty = &#x27;easy&#x27;;
            gameState.enigmasInLevel = 0;
            gameState.usedEnigmas = {
                easy: [],
                medium: [],
                hard: []
            };
            
            document.getElementById(&#x27;startBtn&#x27;).disabled = false;
            document.getElementById(&#x27;pauseBtn&#x27;).disabled = true;
            document.getElementById(&#x27;enigmaInput&#x27;).style.display = &#x27;none&#x27;;
            document.getElementById(&#x27;submitBtn&#x27;).style.display = &#x27;none&#x27;;

            document.getElementById(&#x27;hintSystemRight&#x27;).style.display = &#x27;none&#x27;;
            document.getElementById(&#x27;pausePanel&#x27;).style.display = &#x27;none&#x27;;
            
            document.getElementById(&#x27;enigmaText&#x27;).textContent = translations[currentLanguage].startMessage;
            document.getElementById(&#x27;gameMessage&#x27;).textContent = translations[currentLanguage].welcomeMessage;
            document.getElementById(&#x27;aiMessage&#x27;).textContent = translations[currentLanguage].aiWelcome;
            document.getElementById(&#x27;timerText&#x27;).textContent = &#x27;--:--&#x27;;
            document.getElementById(&#x27;progressFill&#x27;).style.width = &#x27;0%&#x27;;
            
            updateStats();
        }

        function updateStats() {
            document.getElementById(&#x27;solvedValue&#x27;).textContent = gameState.solved;
            document.getElementById(&#x27;failedValue&#x27;).textContent = gameState.failed;
            document.getElementById(&#x27;streakValue&#x27;).textContent = gameState.streak;
            document.getElementById(&#x27;levelValue&#x27;).textContent = gameState.level;
            document.getElementById(&#x27;scoreValue&#x27;).textContent = gameState.score;
            document.getElementById(&#x27;hintsLeftValue&#x27;).textContent = gameState.hintsLeft;
            document.getElementById(&#x27;currentDiffValue&#x27;).textContent = translations[currentLanguage].difficulties[gameState.difficulty];
            document.getElementById(&#x27;levelIndicator&#x27;).textContent = translations[currentLanguage].levelIndicator + &#x27; &#x27; + gameState.level;
            
            const progress = (gameState.enigmasInLevel / gameState.enigmasNeededForLevel) * 100;
            document.getElementById(&#x27;progressFill&#x27;).style.width = progress + &#x27;%&#x27;;
        }

        function updateGameMessage(message) {
            document.getElementById(&#x27;gameMessage&#x27;).textContent = message;
        }

        function updateAIMessage(message) {
            document.getElementById(&#x27;aiMessage&#x27;).textContent = message;
        }

        function showRules() {
            document.getElementById(&#x27;rulesPanel&#x27;).style.display = &#x27;block&#x27;;
        }

        function hideRules() {
            document.getElementById(&#x27;rulesPanel&#x27;).style.display = &#x27;none&#x27;;
        }

        // Event listeners
        document.getElementById(&#x27;languageSelect&#x27;).addEventListener(&#x27;change&#x27;, updateLanguage);
        document.getElementById(&#x27;enigmaInput&#x27;).addEventListener(&#x27;keypress&#x27;, function(e) {
            if (e.key === &#x27;Enter&#x27;) {
                submitAnswer();
            }
        });

        // Initialize
        createParticles();
        updateLanguage();
    &lt;/script&gt;
&lt;script&gt;(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement(&#x27;script&#x27;);d.innerHTML=&quot;window.__CF$cv$params={r:&#x27;98720769317ae23b&#x27;,t:&#x27;MTc1OTIxNzU3My4wMDAwMDA=&#x27;};var a=document.createElement(&#x27;script&#x27;);a.nonce=&#x27;&#x27;;a.src=&#x27;/cdn-cgi/challenge-platform/scripts/jsd/main.js&#x27;;document.getElementsByTagName(&#x27;head&#x27;)[0].appendChild(a);&quot;;b.getElementsByTagName(&#x27;head&#x27;)[0].appendChild(d)}}if(document.body){var a=document.createElement(&#x27;iframe&#x27;);a.height=1;a.width=1;a.style.position=&#x27;absolute&#x27;;a.style.top=0;a.style.left=0;a.style.border=&#x27;none&#x27;;a.style.visibility=&#x27;hidden&#x27;;document.body.appendChild(a);if(&#x27;loading&#x27;!==document.readyState)c();else if(window.addEventListener)document.addEventListener(&#x27;DOMContentLoaded&#x27;,c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);&#x27;loading&#x27;!==document.readyState&amp;&amp;(document.onreadystatechange=e,c())}}}})();&lt;/script&gt;&lt;/body&gt;
&lt;/html&gt;
" style="width:100%; height:100%; border:none;"></iframe>
  </div>
</div>

<div id="game14Overlay" style="display:none; position:fixed; top:0; left:0;
     width:100%; height:100%; background:#000; z-index:10000; overflow:auto;">
  <button onclick="closeGame14()" 
          style="position:absolute; top:20px; right:20px; background:red; color:#fff;
                 border:none; padding:10px; font-size:20px; cursor:pointer; z-index:10001;">✖</button>
  <div id="game14Container" style="width:100%; height:100%; overflow:auto; background:#000; color:#fff;">
    <style>
        body {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            color: #ffffff;
            min-height: 100vh;
            overflow-x: auto;
        }

        .quantum-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            background: radial-gradient(circle at 20% 80%, rgba(0, 255, 255, 0.3) 0%, transparent 50%),
                        radial-gradient(circle at 80% 20%, rgba(255, 0, 255, 0.3) 0%, transparent 50%),
                        radial-gradient(circle at 40% 40%, rgba(255, 215, 0, 0.2) 0%, transparent 50%);
        }

        .quantum-particle {
            position: absolute;
            width: 2px;
            height: 2px;
            background: #00ffff;
            border-radius: 50%;
            animation: float 6s ease-in-out infinite;
            box-shadow: 0 0 6px #00ffff;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px) rotate(0deg); opacity: 0.7; }
            50% { transform: translateY(-20px) rotate(180deg); opacity: 1; }
        }

        .main-container {
            max-width: 1400px;
            margin: 0 auto;
            position: relative;
            background: linear-gradient(135deg, rgba(15, 15, 35, 0.95) 0%, rgba(30, 30, 60, 0.95) 100%);
            border: 3px solid rgba(0, 255, 255, 0.4);
            border-radius: 25px;
            backdrop-filter: blur(20px);
            box-shadow: 
                0 0 50px rgba(0, 255, 255, 0.3),
                inset 0 0 50px rgba(0, 255, 255, 0.1);
            padding: 20px;
            margin: 20px auto;
            position: relative;
            overflow: hidden;
        }

        .main-container::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, #00ffff, #ff00ff, #ffff00, #00ffff);
            border-radius: 25px;
            z-index: -1;
            animation: borderGlow 3s linear infinite;
        }

        @keyframes borderGlow {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            background: linear-gradient(135deg, rgba(15, 15, 35, 0.95) 0%, rgba(30, 30, 60, 0.95) 100%);
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 15px;
            padding: 20px 25px;
            backdrop-filter: blur(15px);
            box-shadow: 0 8px 32px rgba(0, 255, 255, 0.2);
            position: relative;
            z-index: 10;
        }

        .game-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            background: linear-gradient(135deg, rgba(15, 15, 35, 0.95) 0%, rgba(30, 30, 60, 0.95) 100%);
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 15px;
            padding: 12px 20px;
            backdrop-filter: blur(15px);
            box-shadow: 0 8px 32px rgba(0, 255, 255, 0.2);
            position: relative;
            z-index: 1;
        }

        .game-title {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .game-title h1 {
            font-size: 28px;
            font-weight: bold;
            background: linear-gradient(135deg, #00ffff, #ff00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin: 0;
            text-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
            letter-spacing: 2px;
        }

        .game-logo {
            font-size: 32px;
            filter: drop-shadow(0 0 20px #00ffff);
            animation: pulse 3s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .language-selector {
            position: relative;
            display: inline-block;
        }

        .language-dropdown {
            background: linear-gradient(135deg, rgba(15, 15, 35, 0.95) 0%, rgba(30, 30, 60, 0.95) 100%);
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 8px;
            color: #00ffff;
            padding: 6px 10px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 255, 255, 0.2);
            display: flex;
            align-items: center;
            gap: 5px;
            font-weight: bold;
            min-width: 70px;
            justify-content: space-between;
        }

        .language-dropdown:hover {
            border-color: rgba(0, 255, 255, 0.8);
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.1) 0%, rgba(255, 0, 255, 0.1) 100%);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 255, 255, 0.3);
        }

        .language-options {
            position: absolute;
            top: 100%;
            right: 0;
            left: auto;
            min-width: 160px;
            background: linear-gradient(135deg, rgba(15, 15, 35, 0.98) 0%, rgba(30, 30, 60, 0.98) 100%);
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 15px;
            backdrop-filter: blur(15px);
            box-shadow: 0 8px 32px rgba(0, 255, 255, 0.3);
            z-index: 99999999;
            margin-top: 8px;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px);
            transition: all 0.3s ease;
        }

        .language-options.show {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .language-option {
            padding: 12px 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            color: #ffffff;
            font-weight: bold;
            border-bottom: 1px solid rgba(0, 255, 255, 0.1);
        }

        .language-option:last-child {
            border-bottom: none;
            border-radius: 0 0 13px 13px;
        }

        .language-option:first-child {
            border-radius: 13px 13px 0 0;
        }

        .language-option:hover {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.2) 0%, rgba(255, 0, 255, 0.2) 100%);
            color: #00ffff;
            transform: translateX(5px);
        }

        .language-option.active {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.3) 0%, rgba(255, 0, 255, 0.3) 100%);
            color: #00ffff;
        }

        .game-container {
            display: grid;
            grid-template-columns: 250px 1fr 250px;
            gap: 25px;
            min-height: 650px;
            margin-top: 5px;
        }

        .sidebar {
            background: linear-gradient(135deg, rgba(15, 15, 35, 0.95) 0%, rgba(30, 30, 60, 0.95) 100%);
            border: 3px solid rgba(0, 255, 255, 0.4);
            border-radius: 20px;
            padding: 20px;
            backdrop-filter: blur(15px);
            box-shadow: 
                0 10px 40px rgba(0, 255, 255, 0.2),
                inset 0 0 30px rgba(0, 255, 255, 0.05);
            height: fit-content;
            position: relative;
            overflow: hidden;
        }

        .sidebar::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, #00ffff, #ff00ff, #00ffff, transparent);
            animation: scanLine 2s linear infinite;
        }

        @keyframes scanLine {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .game-board {
            background: linear-gradient(135deg, rgba(15, 15, 35, 0.98) 0%, rgba(30, 30, 60, 0.98) 100%);
            border: 4px solid rgba(0, 255, 255, 0.6);
            border-radius: 20px;
            padding: 20px 25px;
            backdrop-filter: blur(20px);
            box-shadow: 
                0 0 60px rgba(0, 255, 255, 0.4),
                inset 0 0 40px rgba(0, 255, 255, 0.1);
            height: fit-content;
            max-height: 650px;
            width: 100%;
            max-width: 700px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        .section-title {
            font-size: 18px;
            font-weight: bold;
            color: #00ffff;
            margin-bottom: 15px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 2px;
            position: relative;
            z-index: 10;
        }

        .quantum-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            font-size: 12px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
            margin: 3px;
        }

        .quantum-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
            background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
        }

        .quantum-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .quantum-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transition: left 0.5s ease;
        }

        .quantum-btn:hover::before {
            left: 100%;
        }

        .action-btn {
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
            color: #1a1a2e;
        }

        .action-btn:hover:not(:disabled) {
            background: linear-gradient(135deg, #ffed4e 0%, #ffd700 100%);
            box-shadow: 0 6px 20px rgba(255, 215, 0, 0.6);
        }

        .danger-btn {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
        }

        .danger-btn:hover:not(:disabled) {
            background: linear-gradient(135deg, #ee5a24 0%, #ff6b6b 100%);
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.6);
        }

        .card {
            width: 60px;
            height: 85px;
            background: linear-gradient(135deg, #ffffff 0%, #f0f0f0 100%);
            border: 2px solid #333;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            padding: 5px;
            font-weight: bold;
            font-size: 14px;
            color: #333;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            cursor: pointer;
            margin: 2px;
            position: relative;
        }

        .card:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 8px 25px rgba(0, 255, 255, 0.4);
        }

        .card.red {
            color: #d63031;
        }

        .card.black {
            color: #2d3436;
        }

        .card.selected {
            border-color: #00ffff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.6);
            transform: translateY(-10px);
        }

        .card-back {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
        }

        .card-empty {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0.05) 100%);
            border: 2px dashed rgba(0, 255, 255, 0.3);
            color: rgba(0, 255, 255, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
        }

        .card-empty:hover {
            border-color: rgba(0, 255, 255, 0.6);
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.1) 0%, rgba(255, 0, 255, 0.1) 100%);
        }

        .foundation-area {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-bottom: 30px;
        }

        .tableau-area {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 10px;
            margin-bottom: 30px;
        }

        .stock-waste-area {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-bottom: 30px;
        }

        .card-pile {
            min-height: 85px;
            position: relative;
        }

        .tableau-pile {
            min-height: 200px;
        }

        .tableau-pile .card {
            position: absolute;
            top: 0;
        }

        .tableau-pile .card:nth-child(1) { top: 0px; }
        .tableau-pile .card:nth-child(2) { top: 20px; }
        .tableau-pile .card:nth-child(3) { top: 40px; }
        .tableau-pile .card:nth-child(4) { top: 60px; }
        .tableau-pile .card:nth-child(5) { top: 80px; }
        .tableau-pile .card:nth-child(6) { top: 100px; }
        .tableau-pile .card:nth-child(7) { top: 120px; }
        .tableau-pile .card:nth-child(8) { top: 140px; }
        .tableau-pile .card:nth-child(9) { top: 160px; }
        .tableau-pile .card:nth-child(10) { top: 180px; }
        .tableau-pile .card:nth-child(11) { top: 200px; }
        .tableau-pile .card:nth-child(12) { top: 220px; }
        .tableau-pile .card:nth-child(13) { top: 240px; }

        .stats-panel {
            background: rgba(30, 30, 60, 0.8);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            backdrop-filter: blur(5px);
            transition: all 0.3s ease;
        }

        .stats-panel:hover {
            border-color: rgba(0, 255, 255, 0.6);
            background: rgba(30, 30, 60, 0.9);
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .stat-value {
            font-weight: bold;
            color: #ffffff;
        }

        .ai-panel {
            background: linear-gradient(135deg, rgba(255, 0, 255, 0.1) 0%, rgba(0, 255, 255, 0.1) 100%);
            border: 2px solid rgba(255, 0, 255, 0.3);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            margin-bottom: 20px;
        }

        .ai-thinking {
            animation: thinking 2s ease-in-out infinite;
        }

        @keyframes thinking {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }

        .game-message {
            background: rgba(15, 15, 35, 0.9);
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 15px;
            padding: 15px;
            text-align: center;
            font-size: 16px;
            font-weight: bold;
            color: #00ffff;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            margin-bottom: 20px;
        }

        .difficulty-selector {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 20px;
        }

        .difficulty-btn {
            padding: 8px 16px;
            font-size: 12px;
            border-radius: 20px;
        }

        .difficulty-btn.active {
            background: linear-gradient(135deg, #00ff00 0%, #00cc00 100%);
            color: #000;
        }

        @media (max-width: 1200px) {
            .game-container {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .sidebar {
                order: 2;
            }
        }

        @media (max-width: 800px) {
            .foundation-area {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .tableau-area {
                grid-template-columns: repeat(4, 1fr);
            }
            
            .game-title h1 {
                font-size: 20px;
            }
        }

        @keyframes fall {
            to {
                transform: translateY(100vh) rotate(360deg);
            }
        }
    </style>
    <div class="quantum-bg"></div>
    
    <div class="main-container">
        <!-- En-tête du jeu -->
        <div class="game-header">
            <div class="game-title">
                <div class="game-logo">🃏</div>
                <h1 id="gameTitle">SOLITAIRE FUSION</h1>
            </div>
            
            <div class="language-selector">
                <div class="language-dropdown" onclick="toggleLanguageDropdown()">
                    <span id="currentLanguage">🇫🇷 FR</span>
                    <span style="font-size: 10px;">▼</span>
                </div>
                <div class="language-options" id="languageOptions">
                    <div class="language-option active" onclick="selectLanguage('fr', '🇫🇷 FR')">🇫🇷 Français</div>
                    <div class="language-option" onclick="selectLanguage('en', '🇬🇧 EN')">🇬🇧 English</div>
                    <div class="language-option" onclick="selectLanguage('es', '🇪🇸 ES')">🇪🇸 Español</div>
                    <div class="language-option" onclick="selectLanguage('ar', '🇸🇦 AR')">🇸🇦 العربية</div>
                    <div class="language-option" onclick="selectLanguage('de', '🇩🇪 DE')">🇩🇪 Deutsch</div>
                    <div class="language-option" onclick="selectLanguage('zh', '🇨🇳 ZH')">🇨🇳 中文</div>
                </div>
            </div>
        </div>

        <!-- Bloc de contrôles de jeu -->
        <div class="game-controls">
            <div style="display: flex; gap: 15px; flex-wrap: wrap;">
                <button class="quantum-btn action-btn" onclick="newGame()">🚀 <span id="newGameBtn">Nouvelle Partie</span></button>
                <button class="quantum-btn" onclick="undoMove()" id="undoBtn" disabled>↶ <span id="undoBtnText">Annuler</span></button>
                <button class="quantum-btn" onclick="getHint()" id="hintBtn">💡 <span id="hintBtnText">Indice</span></button>
                <button class="quantum-btn danger-btn" onclick="resetGame()">🔄 <span id="resetBtnText">Recommencer</span></button>
                <button class="quantum-btn" onclick="showRules()">📋 <span id="rulesBtn">Règles</span></button>
            </div>
            
            <div class="difficulty-selector">
                <button class="quantum-btn difficulty-btn active" onclick="setDifficulty('easy')" id="easyBtn">
                    <span id="easyBtnText">Facile</span>
                </button>
                <button class="quantum-btn difficulty-btn" onclick="setDifficulty('medium')" id="mediumBtn">
                    <span id="mediumBtnText">Moyen</span>
                </button>
                <button class="quantum-btn difficulty-btn" onclick="setDifficulty('hard')" id="hardBtn">
                    <span id="hardBtnText">Difficile</span>
                </button>
            </div>
        </div>

        <div class="game-container">
            <!-- Sidebar gauche - Statistiques -->
            <div class="sidebar">
                <div class="section-title" id="statsTitle">📊 Statistiques</div>
                
                <div class="stats-panel">
                    <div class="stat-item">
                        <span id="scoreLabel">Score:</span>
                        <span class="stat-value" id="scoreValue">0</span>
                    </div>
                    <div class="stat-item">
                        <span id="movesLabel">Coups:</span>
                        <span class="stat-value" id="movesValue">0</span>
                    </div>
                    <div class="stat-item">
                        <span id="timeLabel">Temps:</span>
                        <span class="stat-value" id="timeValue">00:00</span>
                    </div>
                    <div class="stat-item">
                        <span id="cardsLeftLabel">Cartes restantes:</span>
                        <span class="stat-value" id="cardsLeftValue">52</span>
                    </div>
                </div>

                <div class="section-title" id="progressTitle">🎯 Progression</div>
                <div class="stats-panel">
                    <div class="stat-item">
                        <span id="foundationsLabel">Fondations:</span>
                        <span class="stat-value" id="foundationsValue">0/4</span>
                    </div>
                    <div class="stat-item">
                        <span id="completionLabel">Complétion:</span>
                        <span class="stat-value" id="completionValue">0%</span>
                    </div>
                </div>

                <div class="section-title" id="bestScoresTitle">🏆 Meilleurs Scores</div>
                <div class="stats-panel" id="bestScoresPanel">
                    <div class="stat-item">
                        <span id="bestTimeLabel">Meilleur temps:</span>
                        <span class="stat-value" id="bestTimeValue">--:--</span>
                    </div>
                    <div class="stat-item">
                        <span id="bestScoreLabel">Meilleur score:</span>
                        <span class="stat-value" id="bestScoreValue">0</span>
                    </div>
                    <div class="stat-item">
                        <span id="gamesWonLabel">Parties gagnées:</span>
                        <span class="stat-value" id="gamesWonValue">0</span>
                    </div>
                </div>
            </div>

            <!-- Plateau de jeu principal -->
            <div class="game-board">
                <div class="game-message" id="gameMessage">
                    <span>Bienvenue au Solitaire Fusion! Cliquez sur "Nouvelle Partie" pour commencer.</span>
                </div>

                <!-- Zone des fondations -->
                <div class="section-title" id="foundationsTitle">🏛️ Fondations</div>
                <div class="foundation-area" id="foundationArea">
                    <div class="card-pile foundation-pile" data-suit="spades">
                        <div class="card card-empty">♠</div>
                    </div>
                    <div class="card-pile foundation-pile" data-suit="hearts">
                        <div class="card card-empty">♥</div>
                    </div>
                    <div class="card-pile foundation-pile" data-suit="diamonds">
                        <div class="card card-empty">♦</div>
                    </div>
                    <div class="card-pile foundation-pile" data-suit="clubs">
                        <div class="card card-empty">♣</div>
                    </div>
                </div>

                <!-- Zone stock et défausse -->
                <div class="section-title" id="stockWasteTitle">🎴 Stock & Défausse</div>
                <div class="stock-waste-area">
                    <div class="card-pile" id="stockPile">
                        <div class="card card-back">🃏</div>
                    </div>
                    <div class="card-pile" id="wastePile">
                        <div class="card card-empty">📤</div>
                    </div>
                </div>

                <!-- Zone tableau -->
                <div class="section-title" id="tableauTitle">🎯 Tableau</div>
                <div class="tableau-area" id="tableauArea">
                    <div class="card-pile tableau-pile" data-column="0"></div>
                    <div class="card-pile tableau-pile" data-column="1"></div>
                    <div class="card-pile tableau-pile" data-column="2"></div>
                    <div class="card-pile tableau-pile" data-column="3"></div>
                    <div class="card-pile tableau-pile" data-column="4"></div>
                    <div class="card-pile tableau-pile" data-column="5"></div>
                    <div class="card-pile tableau-pile" data-column="6"></div>
                </div>
            </div>

            <!-- Sidebar droite - IA et Aide -->
            <div class="sidebar">
                <div class="section-title" id="aiTitle">🤖 Assistant IA</div>
                <div class="ai-panel" id="aiPanel">
                    <div style="color: #00ffff; font-size: 14px; line-height: 1.4;" id="aiStatusText">
                        Assistant IA activé<br>
                        Analyse des coups possibles...
                    </div>
                </div>
                
                <div class="section-title" id="hintsTitle">💡 Indices</div>
                <div class="stats-panel">
                    <div class="stat-item">
                        <span id="hintsUsedLabel">Indices utilisés:</span>
                        <span class="stat-value" id="hintsUsedValue">0</span>
                    </div>
                    <div class="stat-item">
                        <span id="hintsAvailableLabel">Indices disponibles:</span>
                        <span class="stat-value" id="hintsAvailableValue">3</span>
                    </div>
                </div>

                <div class="section-title" id="actionsTitle">⚡ Actions Rapides</div>
                <div style="display: flex; flex-direction: column; gap: 10px;">
                    <button class="quantum-btn" onclick="autoMoveToFoundations()" id="autoMoveBtn">
                        🎯 <span id="autoMoveBtnText">Auto-placement</span>
                    </button>
                    <button class="quantum-btn" onclick="shuffleWaste()" id="shuffleBtn" disabled>
                        🔀 <span id="shuffleBtnText">Mélanger défausse</span>
                    </button>
                    <button class="quantum-btn action-btn" onclick="celebrateWin()" id="celebrateBtn" style="display: none;">
                        🎉 <span id="celebrateBtnText">Célébrer!</span>
                    </button>
                </div>

                <div class="section-title" id="difficultyTitle">⚙️ Difficulté</div>
                <div class="stats-panel">
                    <div style="text-align: center; color: #ffd700; font-weight: bold;" id="currentDifficultyText">
                        Mode: <span id="currentDifficultyValue">Facile</span>
                    </div>
                    <div style="font-size: 12px; text-align: center; margin-top: 10px; color: #aaa;" id="difficultyDescText">
                        Tirage par 1 carte, indices illimités
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // État du jeu
    var gameState = {
            isPlaying: false,
            currentLanguage: 'fr',
            difficulty: 'easy',
            score: 0,
            moves: 0,
            startTime: null,
            gameTime: 0,
            timer: null,
            deck: [],
            stock: [],
            waste: [],
            foundations: { spades: [], hearts: [], diamonds: [], clubs: [] },
            tableau: [[], [], [], [], [], [], []],
            selectedCard: null,
            selectedPile: null,
            hintsUsed: 0,
            hintsAvailable: 3,
            moveHistory: [],
            bestScores: JSON.parse(localStorage.getItem('solitaireFusionBestScores')) || {
                bestTime: null,
                bestScore: 0,
                gamesWon: 0
            }
        };

        // Traductions
        const translations = {
            fr: {
                gameTitle: 'SOLITAIRE FUSION',
                statsTitle: '📊 Statistiques',
                progressTitle: '🎯 Progression',
                bestScoresTitle: '🏆 Meilleurs Scores',
                aiTitle: '🤖 Assistant IA',
                hintsTitle: '💡 Indices',
                actionsTitle: '⚡ Actions Rapides',
                difficultyTitle: '⚙️ Difficulté',
                foundationsTitle: '🏛️ Fondations',
                stockWasteTitle: '🎴 Stock & Défausse',
                tableauTitle: '🎯 Tableau',
                welcomeMessage: 'Bienvenue au Solitaire Fusion! Cliquez sur "Nouvelle Partie" pour commencer.',
                gameStarted: 'Nouvelle partie commencée! Bonne chance!',
                gameWon: '🎉 Félicitations! Vous avez gagné!',
                scoreLabel: 'Score',
                movesLabel: 'Coups',
                timeLabel: 'Temps',
                cardsLeftLabel: 'Cartes restantes',
                foundationsLabel: 'Fondations',
                completionLabel: 'Complétion',
                bestTimeLabel: 'Meilleur temps',
                bestScoreLabel: 'Meilleur score',
                gamesWonLabel: 'Parties gagnées',
                hintsUsedLabel: 'Indices utilisés',
                hintsAvailableLabel: 'Indices disponibles',
                currentDifficultyText: 'Mode',
                newGameBtn: 'Nouvelle Partie',
                undoBtnText: 'Annuler',
                hintBtnText: 'Indice',
                resetBtnText: 'Recommencer',
                rulesBtn: 'Règles',
                easyBtnText: 'Facile',
                mediumBtnText: 'Moyen',
                hardBtnText: 'Difficile',
                autoMoveBtnText: 'Auto-placement',
                shuffleBtnText: 'Mélanger défausse',
                celebrateBtnText: 'Célébrer!',
                aiStatus: 'Assistant IA activé\nAnalyse des coups possibles...',
                difficultyDesc: {
                    easy: 'Tirage par 1 carte, indices illimités',
                    medium: 'Tirage par 3 cartes, 5 indices',
                    hard: 'Tirage par 3 cartes, 3 indices'
                },
                hints: {
                    noMoves: 'Aucun coup évident disponible.',
                    moveToFoundation: 'Vous pouvez placer {card} sur la fondation {suit}.',
                    revealCard: 'Retournez la carte dans la colonne {column}.',
                    moveCard: 'Déplacez {card} sur {target}.',
                    drawStock: 'Tirez une carte du stock.'
                }
            },
            es: {
                gameTitle: 'SOLITARIO FUSION',
                statsTitle: '📊 Estadísticas',
                progressTitle: '🎯 Progreso',
                bestScoresTitle: '🏆 Mejores Puntuaciones',
                aiTitle: '🤖 Asistente IA',
                hintsTitle: '💡 Pistas',
                actionsTitle: '⚡ Acciones Rápidas',
                difficultyTitle: '⚙️ Dificultad',
                foundationsTitle: '🏛️ Fundaciones',
                stockWasteTitle: '🎴 Mazo y Descarte',
                tableauTitle: '🎯 Tablero',
                welcomeMessage: '¡Bienvenido a Solitario Fusion! Haz clic en "Nueva Partida" para comenzar.',
                gameStarted: '¡Nueva partida iniciada! ¡Buena suerte!',
                gameWon: '🎉 ¡Felicitaciones! ¡Has ganado!',
                scoreLabel: 'Puntuación',
                movesLabel: 'Movimientos',
                timeLabel: 'Tiempo',
                cardsLeftLabel: 'Cartas restantes',
                foundationsLabel: 'Fundaciones',
                completionLabel: 'Completado',
                bestTimeLabel: 'Mejor tiempo',
                bestScoreLabel: 'Mejor puntuación',
                gamesWonLabel: 'Partidas ganadas',
                hintsUsedLabel: 'Pistas usadas',
                hintsAvailableLabel: 'Pistas disponibles',
                currentDifficultyText: 'Modo',
                newGameBtn: 'Nueva Partida',
                undoBtnText: 'Deshacer',
                hintBtnText: 'Pista',
                resetBtnText: 'Reiniciar',
                rulesBtn: 'Reglas',
                easyBtnText: 'Fácil',
                mediumBtnText: 'Medio',
                hardBtnText: 'Difícil',
                autoMoveBtnText: 'Auto-mover',
                shuffleBtnText: 'Mezclar descarte',
                celebrateBtnText: '¡Celebrar!',
                aiStatus: 'Asistente IA activado\nAnalizando movimientos posibles...',
                difficultyDesc: {
                    easy: 'Robar 1 carta, pistas ilimitadas',
                    medium: 'Robar 3 cartas, 5 pistas',
                    hard: 'Robar 3 cartas, 3 pistas'
                },
                hints: {
                    noMoves: 'No hay movimientos obvios disponibles.',
                    moveToFoundation: 'Puedes colocar {card} en la fundación {suit}.',
                    revealCard: 'Voltea la carta en la columna {column}.',
                    moveCard: 'Mueve {card} a {target}.',
                    drawStock: 'Roba una carta del mazo.'
                }
            },
            ar: {
                gameTitle: 'سوليتير فيوجن',
                statsTitle: '📊 الإحصائيات',
                progressTitle: '🎯 التقدم',
                bestScoresTitle: '🏆 أفضل النتائج',
                aiTitle: '🤖 مساعد الذكي',
                hintsTitle: '💡 التلميحات',
                actionsTitle: '⚡ إجراءات سريعة',
                difficultyTitle: '⚙️ الصعوبة',
                foundationsTitle: '🏛️ الأسس',
                stockWasteTitle: '🎴 المخزون والنفايات',
                tableauTitle: '🎯 اللوحة',
                welcomeMessage: 'مرحباً بك في سوليتير فيوجن! انقر على "لعبة جديدة" للبدء.',
                gameStarted: 'بدأت لعبة جديدة! حظاً سعيداً!',
                gameWon: '🎉 تهانينا! لقد فزت!',
                scoreLabel: 'النقاط',
                movesLabel: 'الحركات',
                timeLabel: 'الوقت',
                cardsLeftLabel: 'الأوراق المتبقية',
                foundationsLabel: 'الأسس',
                completionLabel: 'الإنجاز',
                bestTimeLabel: 'أفضل وقت',
                bestScoreLabel: 'أفضل نقاط',
                gamesWonLabel: 'الألعاب المكسوبة',
                hintsUsedLabel: 'التلميحات المستخدمة',
                hintsAvailableLabel: 'التلميحات المتاحة',
                currentDifficultyText: 'الوضع',
                newGameBtn: 'لعبة جديدة',
                undoBtnText: 'تراجع',
                hintBtnText: 'تلميح',
                resetBtnText: 'إعادة تعيين',
                rulesBtn: 'القواعد',
                easyBtnText: 'سهل',
                mediumBtnText: 'متوسط',
                hardBtnText: 'صعب',
                autoMoveBtnText: 'حركة تلقائية',
                shuffleBtnText: 'خلط النفايات',
                celebrateBtnText: 'احتفل!',
                aiStatus: 'تم تفعيل المساعد الذكي\nتحليل الحركات الممكنة...',
                difficultyDesc: {
                    easy: 'سحب ورقة واحدة، تلميحات غير محدودة',
                    medium: 'سحب 3 أوراق، 5 تلميحات',
                    hard: 'سحب 3 أوراق، 3 تلميحات'
                },
                hints: {
                    noMoves: 'لا توجد حركات واضحة متاحة.',
                    moveToFoundation: 'يمكنك وضع {card} على أساس {suit}.',
                    revealCard: 'اقلب الورقة في العمود {column}.',
                    moveCard: 'انقل {card} إلى {target}.',
                    drawStock: 'اسحب ورقة من المخزون.'
                }
            },
            de: {
                gameTitle: 'SOLITÄR FUSION',
                statsTitle: '📊 Statistiken',
                progressTitle: '🎯 Fortschritt',
                bestScoresTitle: '🏆 Beste Ergebnisse',
                aiTitle: '🤖 KI-Assistent',
                hintsTitle: '💡 Hinweise',
                actionsTitle: '⚡ Schnellaktionen',
                difficultyTitle: '⚙️ Schwierigkeit',
                foundationsTitle: '🏛️ Fundamente',
                stockWasteTitle: '🎴 Stapel & Abfall',
                tableauTitle: '🎯 Tableau',
                welcomeMessage: 'Willkommen bei Solitär Fusion! Klicken Sie auf "Neues Spiel" um zu beginnen.',
                gameStarted: 'Neues Spiel gestartet! Viel Glück!',
                gameWon: '🎉 Herzlichen Glückwunsch! Sie haben gewonnen!',
                scoreLabel: 'Punkte',
                movesLabel: 'Züge',
                timeLabel: 'Zeit',
                cardsLeftLabel: 'Karten übrig',
                foundationsLabel: 'Fundamente',
                completionLabel: 'Fertigstellung',
                bestTimeLabel: 'Beste Zeit',
                bestScoreLabel: 'Beste Punkte',
                gamesWonLabel: 'Gewonnene Spiele',
                hintsUsedLabel: 'Hinweise verwendet',
                hintsAvailableLabel: 'Hinweise verfügbar',
                currentDifficultyText: 'Modus',
                newGameBtn: 'Neues Spiel',
                undoBtnText: 'Rückgängig',
                hintBtnText: 'Hinweis',
                resetBtnText: 'Zurücksetzen',
                rulesBtn: 'Regeln',
                easyBtnText: 'Einfach',
                mediumBtnText: 'Mittel',
                hardBtnText: 'Schwer',
                autoMoveBtnText: 'Auto-Zug',
                shuffleBtnText: 'Abfall mischen',
                celebrateBtnText: 'Feiern!',
                aiStatus: 'KI-Assistent aktiviert\nAnalysiere mögliche Züge...',
                difficultyDesc: {
                    easy: '1 Karte ziehen, unbegrenzte Hinweise',
                    medium: '3 Karten ziehen, 5 Hinweise',
                    hard: '3 Karten ziehen, 3 Hinweise'
                },
                hints: {
                    noMoves: 'Keine offensichtlichen Züge verfügbar.',
                    moveToFoundation: 'Sie können {card} auf das {suit} Fundament legen.',
                    revealCard: 'Drehen Sie die Karte in Spalte {column} um.',
                    moveCard: 'Bewegen Sie {card} zu {target}.',
                    drawStock: 'Ziehen Sie eine Karte vom Stapel.'
                }
            },
            zh: {
                gameTitle: '纸牌融合',
                statsTitle: '📊 统计',
                progressTitle: '🎯 进度',
                bestScoresTitle: '🏆 最佳成绩',
                aiTitle: '🤖 AI助手',
                hintsTitle: '💡 提示',
                actionsTitle: '⚡ 快速操作',
                difficultyTitle: '⚙️ 难度',
                foundationsTitle: '🏛️ 基础堆',
                stockWasteTitle: '🎴 库存和废牌',
                tableauTitle: '🎯 牌桌',
                welcomeMessage: '欢迎来到纸牌融合！点击"新游戏"开始。',
                gameStarted: '新游戏开始！祝你好运！',
                gameWon: '🎉 恭喜！你赢了！',
                scoreLabel: '得分',
                movesLabel: '移动',
                timeLabel: '时间',
                cardsLeftLabel: '剩余牌数',
                foundationsLabel: '基础堆',
                completionLabel: '完成度',
                bestTimeLabel: '最佳时间',
                bestScoreLabel: '最高分',
                gamesWonLabel: '获胜游戏',
                hintsUsedLabel: '已用提示',
                hintsAvailableLabel: '可用提示',
                currentDifficultyText: '模式',
                newGameBtn: '新游戏',
                undoBtnText: '撤销',
                hintBtnText: '提示',
                resetBtnText: '重置',
                rulesBtn: '规则',
                easyBtnText: '简单',
                mediumBtnText: '中等',
                hardBtnText: '困难',
                autoMoveBtnText: '自动移动',
                shuffleBtnText: '洗废牌',
                celebrateBtnText: '庆祝！',
                aiStatus: 'AI助手已激活\n分析可能的移动...',
                difficultyDesc: {
                    easy: '抽1张牌，无限提示',
                    medium: '抽3张牌，5个提示',
                    hard: '抽3张牌，3个提示'
                },
                hints: {
                    noMoves: '没有明显的移动可用。',
                    moveToFoundation: '你可以将{card}放在{suit}基础堆上。',
                    revealCard: '翻转第{column}列的牌。',
                    moveCard: '将{card}移动到{target}。',
                    drawStock: '从库存中抽一张牌。'
                }
            },
            en: {
                gameTitle: 'SOLITAIRE FUSION',
                statsTitle: '📊 Statistics',
                progressTitle: '🎯 Progress',
                bestScoresTitle: '🏆 Best Scores',
                aiTitle: '🤖 AI Assistant',
                hintsTitle: '💡 Hints',
                actionsTitle: '⚡ Quick Actions',
                difficultyTitle: '⚙️ Difficulty',
                foundationsTitle: '🏛️ Foundations',
                stockWasteTitle: '🎴 Stock & Waste',
                tableauTitle: '🎯 Tableau',
                welcomeMessage: 'Welcome to Solitaire Fusion! Click "New Game" to start.',
                gameStarted: 'New game started! Good luck!',
                gameWon: '🎉 Congratulations! You won!',
                scoreLabel: 'Score',
                movesLabel: 'Moves',
                timeLabel: 'Time',
                cardsLeftLabel: 'Cards left',
                foundationsLabel: 'Foundations',
                completionLabel: 'Completion',
                bestTimeLabel: 'Best time',
                bestScoreLabel: 'Best score',
                gamesWonLabel: 'Games won',
                hintsUsedLabel: 'Hints used',
                hintsAvailableLabel: 'Hints available',
                currentDifficultyText: 'Mode',
                newGameBtn: 'New Game',
                undoBtnText: 'Undo',
                hintBtnText: 'Hint',
                resetBtnText: 'Reset',
                rulesBtn: 'Rules',
                easyBtnText: 'Easy',
                mediumBtnText: 'Medium',
                hardBtnText: 'Hard',
                autoMoveBtnText: 'Auto-move',
                shuffleBtnText: 'Shuffle waste',
                celebrateBtnText: 'Celebrate!',
                aiStatus: 'AI Assistant activated\nAnalyzing possible moves...',
                difficultyDesc: {
                    easy: 'Draw 1 card, unlimited hints',
                    medium: 'Draw 3 cards, 5 hints',
                    hard: 'Draw 3 cards, 3 hints'
                },
                hints: {
                    noMoves: 'No obvious moves available.',
                    moveToFoundation: 'You can place {card} on {suit} foundation.',
                    revealCard: 'Flip the card in column {column}.',
                    moveCard: 'Move {card} to {target}.',
                    drawStock: 'Draw a card from stock.'
                }
            }
        };

        // Créer un jeu de cartes
        function createDeck() {
            const suits = ['spades', 'hearts', 'diamonds', 'clubs'];
            const suitSymbols = { spades: '♠', hearts: '♥', diamonds: '♦', clubs: '♣' };
            const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
            const deck = [];
            
            for (let suit of suits) {
                for (let i = 0; i < ranks.length; i++) {
                    deck.push({
                        suit: suit,
                        rank: ranks[i],
                        value: i + 1,
                        symbol: suitSymbols[suit],
                        color: (suit === 'hearts' || suit === 'diamonds') ? 'red' : 'black',
                        faceUp: false
                    });
                }
            }
            
            return createWinnableDeck(shuffleDeck(deck));
        }

        // Créer un jeu avec 80% de chances de victoire
        function createWinnableDeck(deck) {
            // 80% de chance de créer une configuration gagnante
            if (Math.random() < 0.8) {
                return optimizeDeckForWinning(deck);
            }
            return deck;
        }

        // Optimiser le jeu pour augmenter les chances de victoire
        function optimizeDeckForWinning(deck) {
            // Placer plus d'As et de cartes basses dans les positions accessibles
            const aces = deck.filter(card => card.rank === 'A');
            const lowCards = deck.filter(card => card.value <= 4 && card.rank !== 'A');
            const otherCards = deck.filter(card => card.value > 4);
            
            // Mélanger chaque groupe séparément
            const shuffledAces = shuffleDeck([...aces]);
            const shuffledLowCards = shuffleDeck([...lowCards]);
            const shuffledOtherCards = shuffleDeck([...otherCards]);
            
            // Répartir de manière à favoriser l'accès aux cartes importantes
            const optimizedDeck = [];
            
            // Alterner les types de cartes pour une meilleure distribution
            let aceIndex = 0, lowIndex = 0, otherIndex = 0;
            
            for (let i = 0; i < 52; i++) {
                if (i % 4 === 0 && aceIndex < shuffledAces.length) {
                    optimizedDeck.push(shuffledAces[aceIndex++]);
                } else if (i % 3 === 0 && lowIndex < shuffledLowCards.length) {
                    optimizedDeck.push(shuffledLowCards[lowIndex++]);
                } else if (otherIndex < shuffledOtherCards.length) {
                    optimizedDeck.push(shuffledOtherCards[otherIndex++]);
                } else if (lowIndex < shuffledLowCards.length) {
                    optimizedDeck.push(shuffledLowCards[lowIndex++]);
                } else if (aceIndex < shuffledAces.length) {
                    optimizedDeck.push(shuffledAces[aceIndex++]);
                }
            }
            
            return optimizedDeck;
        }

        // Mélanger le jeu
        function shuffleDeck(deck) {
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
            return deck;
        }

        // Créer les particules quantiques
        function createQuantumParticles() {
            const bg = document.querySelector('.quantum-bg');
            for (let i = 0; i < 50; i++) {
                const particle = document.createElement('div');
                particle.className = 'quantum-particle';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.top = Math.random() * 100 + '%';
                particle.style.animationDelay = Math.random() * 6 + 's';
                particle.style.animationDuration = (Math.random() * 4 + 4) + 's';
                bg.appendChild(particle);
            }
        }

        // Basculer le dropdown de langue
        function toggleLanguageDropdown() {
            const options = document.getElementById('languageOptions');
            options.classList.toggle('show');
            
            document.addEventListener('click', function closeDropdown(e) {
                if (!e.target.closest('.language-selector')) {
                    options.classList.remove('show');
                    document.removeEventListener('click', closeDropdown);
                }
            });
        }

        // Sélectionner une langue
        function selectLanguage(langCode, langText) {
            gameState.currentLanguage = langCode;
            
            document.getElementById('currentLanguage').textContent = langText;
            
            document.querySelectorAll('.language-option').forEach(option => {
                option.classList.remove('active');
            });
            event.target.classList.add('active');
            
            document.getElementById('languageOptions').classList.remove('show');
            
            updateLanguageInterface();
        }

        // Mettre à jour l'interface selon la langue
        function updateLanguageInterface() {
            const t = translations[gameState.currentLanguage];
            
            // Titres principaux
            document.getElementById('gameTitle').textContent = t.gameTitle;
            document.getElementById('statsTitle').textContent = t.statsTitle;
            document.getElementById('progressTitle').textContent = t.progressTitle;
            document.getElementById('bestScoresTitle').textContent = t.bestScoresTitle;
            document.getElementById('aiTitle').textContent = t.aiTitle;
            document.getElementById('hintsTitle').textContent = t.hintsTitle;
            document.getElementById('actionsTitle').textContent = t.actionsTitle;
            document.getElementById('difficultyTitle').textContent = t.difficultyTitle;
            document.getElementById('foundationsTitle').textContent = t.foundationsTitle;
            document.getElementById('stockWasteTitle').textContent = t.stockWasteTitle;
            document.getElementById('tableauTitle').textContent = t.tableauTitle;
            
            // Labels des statistiques
            document.getElementById('scoreLabel').textContent = t.scoreLabel + ':';
            document.getElementById('movesLabel').textContent = t.movesLabel + ':';
            document.getElementById('timeLabel').textContent = t.timeLabel + ':';
            document.getElementById('cardsLeftLabel').textContent = t.cardsLeftLabel + ':';
            document.getElementById('foundationsLabel').textContent = t.foundationsLabel + ':';
            document.getElementById('completionLabel').textContent = t.completionLabel + ':';
            document.getElementById('bestTimeLabel').textContent = t.bestTimeLabel + ':';
            document.getElementById('bestScoreLabel').textContent = t.bestScoreLabel + ':';
            document.getElementById('gamesWonLabel').textContent = t.gamesWonLabel + ':';
            document.getElementById('hintsUsedLabel').textContent = t.hintsUsedLabel + ':';
            document.getElementById('hintsAvailableLabel').textContent = t.hintsAvailableLabel + ':';
            
            // Boutons
            document.getElementById('newGameBtn').textContent = t.newGameBtn;
            document.getElementById('undoBtnText').textContent = t.undoBtnText;
            document.getElementById('hintBtnText').textContent = t.hintBtnText;
            document.getElementById('resetBtnText').textContent = t.resetBtnText;
            document.getElementById('rulesBtn').textContent = t.rulesBtn;
            document.getElementById('easyBtnText').textContent = t.easyBtnText;
            document.getElementById('mediumBtnText').textContent = t.mediumBtnText;
            document.getElementById('hardBtnText').textContent = t.hardBtnText;
            document.getElementById('autoMoveBtnText').textContent = t.autoMoveBtnText;
            document.getElementById('shuffleBtnText').textContent = t.shuffleBtnText;
            document.getElementById('celebrateBtnText').textContent = t.celebrateBtnText;
            
            // Textes dynamiques
            document.getElementById('aiStatusText').innerHTML = t.aiStatus.replace(/\n/g, '<br>');
            document.getElementById('currentDifficultyText').innerHTML = `${t.currentDifficultyText}: <span id="currentDifficultyValue">${t[gameState.difficulty + 'BtnText']}</span>`;
            document.getElementById('difficultyDescText').textContent = t.difficultyDesc[gameState.difficulty];
            
            if (!gameState.isPlaying) {
                document.getElementById('gameMessage').innerHTML = `<span>${t.welcomeMessage}</span>`;
            }
        }

        // Définir la difficulté
        function setDifficulty(level) {
            gameState.difficulty = level;
            
            // Mettre à jour les boutons
            document.querySelectorAll('.difficulty-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(level + 'Btn').classList.add('active');
            
            // Ajuster les paramètres selon la difficulté
            switch(level) {
                case 'easy':
                    gameState.hintsAvailable = 999;
                    break;
                case 'medium':
                    gameState.hintsAvailable = 5;
                    break;
                case 'hard':
                    gameState.hintsAvailable = 3;
                    break;
            }
            
            updateLanguageInterface();
            updateDisplay();
        }

        // Nouvelle partie
        function newGame() {
            gameState.isPlaying = true;
            gameState.score = 0;
            gameState.moves = 0;
            gameState.startTime = Date.now();
            gameState.gameTime = 0;
            gameState.hintsUsed = 0;
            gameState.selectedCard = null;
            gameState.selectedPile = null;
            gameState.moveHistory = [];
            
            // Réinitialiser les piles
            gameState.foundations = { spades: [], hearts: [], diamonds: [], clubs: [] };
            gameState.tableau = [[], [], [], [], [], [], []];
            gameState.stock = [];
            gameState.waste = [];
            
            // Créer et distribuer les cartes
            gameState.deck = createDeck();
            dealCards();
            
            // Démarrer le timer
            if (gameState.timer) clearInterval(gameState.timer);
            gameState.timer = setInterval(updateTimer, 1000);
            
            // Activer les boutons
            document.getElementById('undoBtn').disabled = false;
            document.getElementById('hintBtn').disabled = false;
            
            updateDisplay();
            
            const t = translations[gameState.currentLanguage];
            showMessage(t.gameStarted);
        }

        // Distribuer les cartes
        function dealCards() {
            // Distribuer au tableau (1, 2, 3, 4, 5, 6, 7 cartes par colonne)
            for (let col = 0; col < 7; col++) {
                for (let row = 0; row <= col; row++) {
                    const card = gameState.deck.pop();
                    card.faceUp = (row === col); // Dernière carte face visible
                    gameState.tableau[col].push(card);
                }
            }
            
            // Le reste va au stock
            gameState.stock = [...gameState.deck];
            gameState.waste = [];
            
            renderBoard();
        }

        // Afficher le plateau
        function renderBoard() {
            renderFoundations();
            renderStock();
            renderWaste();
            renderTableau();
        }

        // Afficher les fondations
        function renderFoundations() {
            const suits = ['spades', 'hearts', 'diamonds', 'clubs'];
            suits.forEach((suit, index) => {
                const pile = document.querySelector(`[data-suit="${suit}"]`);
                pile.innerHTML = '';
                
                if (gameState.foundations[suit].length === 0) {
                    const suitSymbols = { spades: '♠', hearts: '♥', diamonds: '♦', clubs: '♣' };
                    const emptyCard = document.createElement('div');
                    emptyCard.className = 'card card-empty';
                    emptyCard.innerHTML = suitSymbols[suit];
                    emptyCard.onclick = () => handleFoundationClick(pile);
                    pile.appendChild(emptyCard);
                } else {
                    const topCard = gameState.foundations[suit][gameState.foundations[suit].length - 1];
                    const cardElement = createCardElement(topCard);
                    cardElement.onclick = () => handleFoundationClick(pile);
                    pile.appendChild(cardElement);
                }
            });
        }

        // Afficher le stock
        function renderStock() {
            const stockPile = document.getElementById('stockPile');
            stockPile.innerHTML = '';
            
            if (gameState.stock.length > 0) {
                const stockCard = document.createElement('div');
                stockCard.className = 'card card-back';
                stockCard.innerHTML = '🃏';
                stockCard.onclick = drawFromStock;
                stockPile.appendChild(stockCard);
            } else {
                const emptyCard = document.createElement('div');
                emptyCard.className = 'card card-empty';
                emptyCard.innerHTML = '🔄';
                emptyCard.onclick = drawFromStock;
                stockPile.appendChild(emptyCard);
            }
        }

        // Afficher la défausse
        function renderWaste() {
            const wastePile = document.getElementById('wastePile');
            wastePile.innerHTML = '';
            
            if (gameState.waste.length === 0) {
                const emptyCard = document.createElement('div');
                emptyCard.className = 'card card-empty';
                emptyCard.innerHTML = '📤';
                wastePile.appendChild(emptyCard);
            } else {
                const topCard = gameState.waste[gameState.waste.length - 1];
                const cardElement = createCardElement(topCard);
                cardElement.onclick = () => handleCardClick(topCard, 'waste', 0);
                cardElement.ondblclick = () => tryAutoMoveCard(topCard, 'waste', 0);
                wastePile.appendChild(cardElement);
            }
        }

        // Afficher le tableau
        function renderTableau() {
            for (let col = 0; col < 7; col++) {
                const pile = document.querySelector(`[data-column="${col}"]`);
                pile.innerHTML = '';
                
                const columnCards = gameState.tableau[col];
                
                if (columnCards.length === 0) {
                    const emptyCard = document.createElement('div');
                    emptyCard.className = 'card card-empty';
                    emptyCard.innerHTML = '👑';
                    emptyCard.onclick = () => handleTableauClick(col);
                    pile.appendChild(emptyCard);
                } else {
                    columnCards.forEach((card, index) => {
                        const cardElement = createCardElement(card);
                        cardElement.style.position = 'absolute';
                        cardElement.style.top = (index * 20) + 'px';
                        cardElement.style.zIndex = index + 1;
                        cardElement.onclick = () => handleCardClick(card, 'tableau', col);
                        cardElement.ondblclick = () => tryAutoMoveCard(card, 'tableau', col);
                        pile.appendChild(cardElement);
                    });
                }
            }
        }

        // Créer un élément carte
        function createCardElement(card) {
            const cardElement = document.createElement('div');
            cardElement.className = `card ${card.color}`;
            
            if (card.faceUp) {
                let centerContent = '';
                
                // Contenu central selon le rang
                if (card.rank === 'A') {
                    centerContent = `<div style="font-size: 40px; font-weight: bold; color: ${card.color === 'red' ? '#d63031' : '#2d3436'}; text-shadow: 0 0 3px rgba(0,0,0,0.4); display: flex; align-items: center; justify-content: center; height: 100%;">${card.symbol}</div>`;
                } else if (card.rank === 'J') {
                    centerContent = `<div style="font-size: 50px; font-weight: bold; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; width: 100%; color: ${card.color === 'red' ? '#d63031' : '#2d3436'}; text-shadow: 0 0 3px rgba(0,0,0,0.4);">
                        <div style="font-size: 40px; margin-bottom: 2px;">👨‍💼</div>
                        <div style="font-size: 24px; font-weight: bold; letter-spacing: 1px;">J</div>
                    </div>`;
                } else if (card.rank === 'Q') {
                    centerContent = `<div style="font-size: 50px; font-weight: bold; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; width: 100%; color: ${card.color === 'red' ? '#d63031' : '#2d3436'}; text-shadow: 0 0 3px rgba(0,0,0,0.4);">
                        <div style="font-size: 40px; margin-bottom: 2px;">👸</div>
                        <div style="font-size: 24px; font-weight: bold; letter-spacing: 1px;">Q</div>
                    </div>`;
                } else if (card.rank === 'K') {
                    centerContent = `<div style="font-size: 50px; font-weight: bold; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; width: 100%; color: ${card.color === 'red' ? '#d63031' : '#2d3436'}; text-shadow: 0 0 3px rgba(0,0,0,0.4);">
                        <div style="font-size: 40px; margin-bottom: 2px;">🤴</div>
                        <div style="font-size: 24px; font-weight: bold; letter-spacing: 1px;">K</div>
                    </div>`;
                } else {
                    // Cartes numériques (2-10) - afficher le nombre correct de symboles
                    const numValue = parseInt(card.rank);
                    if (numValue >= 2 && numValue <= 10) {
                        let symbolsArray = [];
                        for (let i = 0; i < numValue; i++) {
                            symbolsArray.push(`<span style="font-size: 18px; font-weight: bold; color: ${card.color === 'red' ? '#d63031' : '#2d3436'}; text-shadow: 0 0 2px rgba(0,0,0,0.3);">${card.symbol}</span>`);
                        }
                        
                        // Disposition équilibrée selon le nombre exact
                        if (numValue === 2) {
                            centerContent = `<div style="display: flex; flex-direction: column; align-items: center; justify-content: space-around; height: 80%; padding: 8px 0;">${symbolsArray.join('')}</div>`;
                        } else if (numValue === 3) {
                            centerContent = `<div style="display: flex; flex-direction: column; align-items: center; justify-content: space-around; height: 85%; padding: 6px 0;">${symbolsArray.join('')}</div>`;
                        } else if (numValue === 4) {
                            centerContent = `<div style="display: grid; grid-template-columns: 1fr 1fr; grid-template-rows: 1fr 1fr; gap: 4px; align-items: center; justify-items: center; height: 70%; width: 70%; margin: auto; justify-self: center;">${symbolsArray.join('')}</div>`;
                        } else if (numValue === 5) {
                            centerContent = `<div style="display: flex; flex-direction: column; align-items: center; justify-content: space-between; height: 85%; width: 100%; padding: 4px 0;">
                                <div style="display: flex; justify-content: space-around; width: 80%;">${symbolsArray[0]}${symbolsArray[1]}</div>
                                <div style="display: flex; justify-content: center; width: 80%;">${symbolsArray[2]}</div>
                                <div style="display: flex; justify-content: space-around; width: 80%;">${symbolsArray[3]}${symbolsArray[4]}</div>
                            </div>`;
                        } else if (numValue === 6) {
                            centerContent = `<div style="display: grid; grid-template-columns: 1fr 1fr; grid-template-rows: 1fr 1fr 1fr; gap: 2px; align-items: center; justify-items: center; height: 80%; width: 70%; margin: auto; justify-self: center;">${symbolsArray.join('')}</div>`;
                        } else if (numValue === 7) {
                            centerContent = `<div style="display: grid; grid-template-columns: 1fr 1fr 1fr; grid-template-rows: 1fr 1fr 1fr; gap: 1px; align-items: center; justify-items: center; height: 85%; width: 85%; margin: auto;">
                                ${symbolsArray[0]}${symbolsArray[1]}${symbolsArray[2]}<div></div>${symbolsArray[3]}<div></div>${symbolsArray[4]}${symbolsArray[5]}${symbolsArray[6]}
                            </div>`;
                        } else if (numValue === 8) {
                            centerContent = `<div style="display: flex; flex-direction: column; align-items: center; justify-content: space-between; height: 90%; width: 100%; padding: 2px 0;">
                                <div style="display: flex; justify-content: space-around; width: 85%;">${symbolsArray[0]}${symbolsArray[1]}${symbolsArray[2]}</div>
                                <div style="display: flex; justify-content: center; width: 85%; gap: 8px;">${symbolsArray[3]}${symbolsArray[4]}</div>
                                <div style="display: flex; justify-content: space-around; width: 85%;">${symbolsArray[5]}${symbolsArray[6]}${symbolsArray[7]}</div>
                            </div>`;
                        } else if (numValue === 9) {
                            centerContent = `<div style="display: grid; grid-template-columns: 1fr 1fr 1fr; grid-template-rows: 1fr 1fr 1fr; gap: 1px; align-items: center; justify-items: center; height: 85%; width: 85%; margin: auto;">${symbolsArray.join('')}</div>`;
                        } else if (numValue === 10) {
                            centerContent = `<div style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; grid-template-rows: 1fr 1fr 1fr; gap: 1px; align-items: center; justify-items: center; height: 85%; width: 90%; margin: auto;">
                                ${symbolsArray[0]}${symbolsArray[1]}${symbolsArray[2]}${symbolsArray[3]}${symbolsArray[4]}${symbolsArray[5]}${symbolsArray[6]}${symbolsArray[7]}${symbolsArray[8]}${symbolsArray[9]}
                            </div>`;
                        }
                    } else {
                        centerContent = `<div style="font-size: 32px; font-weight: bold;">${card.symbol}</div>`;
                    }
                }
                
                // Masquer les coins pour les figures (J, Q, K) pour un look plus classique
                const hideCornersForFigures = ['J', 'Q', 'K'].includes(card.rank);
                
                cardElement.innerHTML = `
                    <div style="position: absolute; top: 3px; left: 3px; font-size: 9px; font-weight: bold; line-height: 1; ${hideCornersForFigures ? 'opacity: 0.3;' : ''}">
                        <div>${card.rank}</div>
                        <div style="font-size: 8px;">${card.symbol}</div>
                    </div>
                    <div style="display: flex; align-items: center; justify-content: center; height: 100%; flex-direction: column;">
                        ${centerContent}
                    </div>
                    <div style="position: absolute; bottom: 3px; right: 3px; font-size: 9px; font-weight: bold; transform: rotate(180deg); line-height: 1; ${hideCornersForFigures ? 'opacity: 0.3;' : ''}">
                        <div>${card.rank}</div>
                        <div style="font-size: 8px;">${card.symbol}</div>
                    </div>
                `;
            } else {
                cardElement.className = 'card card-back';
                cardElement.innerHTML = '🃏';
            }
            
            cardElement.cardData = card;
            return cardElement;
        }

        // Gérer le clic sur une carte
        function handleCardClick(card, pileType, pileIndex) {
            if (!gameState.isPlaying) {
                showMessage('Commencez une nouvelle partie pour jouer!');
                return;
            }
            
            if (!card.faceUp && pileType === 'tableau') {
                // Retourner la carte si elle est face cachée
                card.faceUp = true;
                gameState.moves++;
                gameState.score += 5;
                addToHistory('flip', { card, pileType, pileIndex });
                renderBoard();
                updateDisplay();
                showMessage(`Carte ${card.rank}${card.symbol} retournée!`);
                return;
            }
            
            if (gameState.selectedCard) {
                // Tentative de déplacement
                if (gameState.selectedCard === card) {
                    // Désélectionner si on clique sur la même carte
                    clearSelection();
                    showMessage('Sélection annulée.');
                    return;
                }
                
                if (canMoveCard(gameState.selectedCard, card, pileType, pileIndex)) {
                    moveCard(gameState.selectedCard, gameState.selectedPile, card, pileType, pileIndex);
                    showMessage(`${gameState.selectedCard.rank}${gameState.selectedCard.symbol} déplacé sur ${card.rank}${card.symbol}!`);
                } else {
                    showMessage('Déplacement impossible! Vérifiez les règles.');
                }
                clearSelection();
            } else {
                // Sélectionner la carte
                if (card.faceUp && canSelectCard(card, pileType, pileIndex)) {
                    selectCard(card, pileType, pileIndex);
                    showMessage(`${card.rank}${card.symbol} sélectionné. Cliquez sur la destination.`);
                } else {
                    showMessage('Cette carte ne peut pas être sélectionnée.');
                }
            }
        }

        // Vérifier si une carte peut être sélectionnée
        function canSelectCard(card, pileType, pileIndex) {
            if (pileType === 'tableau') {
                const column = gameState.tableau[pileIndex];
                const cardIndex = column.indexOf(card);
                return cardIndex === column.length - 1 || isValidSequence(column, cardIndex);
            } else if (pileType === 'waste') {
                return gameState.waste[gameState.waste.length - 1] === card;
            } else if (pileType === 'foundation') {
                const suits = ['spades', 'hearts', 'diamonds', 'clubs'];
                const foundation = gameState.foundations[suits[pileIndex]];
                return foundation[foundation.length - 1] === card;
            }
            return false;
        }

        // Vérifier si les cartes forment une séquence valide
        function isValidSequence(column, startIndex) {
            for (let i = startIndex; i < column.length - 1; i++) {
                const current = column[i];
                const next = column[i + 1];
                if (current.color === next.color || current.value !== next.value + 1) {
                    return false;
                }
            }
            return true;
        }

        // Gérer le clic sur une colonne vide du tableau
        function handleTableauClick(columnIndex) {
            if (!gameState.isPlaying) {
                showMessage('Commencez une nouvelle partie pour jouer!');
                return;
            }
            
            if (gameState.selectedCard && gameState.selectedCard.rank === 'K') {
                moveCard(gameState.selectedCard, gameState.selectedPile, null, 'tableau', columnIndex);
                showMessage(`Roi ${gameState.selectedCard.symbol} placé sur colonne vide!`);
                clearSelection();
            } else if (gameState.selectedCard) {
                showMessage('Seuls les Rois peuvent être placés sur des colonnes vides!');
            }
        }

        // Sélectionner une carte
        function selectCard(card, pileType, pileIndex) {
            gameState.selectedCard = card;
            gameState.selectedPile = { type: pileType, index: pileIndex };
            
            document.querySelectorAll('.card').forEach(c => c.classList.remove('selected'));
            
            const cardElements = document.querySelectorAll('.card');
            cardElements.forEach(element => {
                if (element.cardData && 
                    element.cardData.rank === card.rank && 
                    element.cardData.suit === card.suit) {
                    element.classList.add('selected');
                }
            });
        }

        // Effacer la sélection
        function clearSelection() {
            gameState.selectedCard = null;
            gameState.selectedPile = null;
            document.querySelectorAll('.card').forEach(c => c.classList.remove('selected'));
        }

        // Vérifier si un déplacement est possible
        function canMoveCard(fromCard, toCard, toPileType, toPileIndex) {
            if (toPileType === 'foundation') {
                const suits = ['spades', 'hearts', 'diamonds', 'clubs'];
                return canMoveToFoundation(fromCard, suits[toPileIndex]);
            } else if (toPileType === 'tableau') {
                return canMoveToTableau(fromCard, toCard, toPileIndex);
            }
            return false;
        }

        // Vérifier si on peut déplacer vers une fondation
        function canMoveToFoundation(card, suit) {
            const foundation = gameState.foundations[suit];
            
            if (foundation.length === 0) {
                return card.rank === 'A';
            } else {
                const topCard = foundation[foundation.length - 1];
                return card.suit === suit && card.value === topCard.value + 1;
            }
        }

        // Vérifier si on peut déplacer vers le tableau
        function canMoveToTableau(card, targetCard, columnIndex) {
            const column = gameState.tableau[columnIndex];
            
            if (column.length === 0) {
                return card.rank === 'K';
            } else {
                return targetCard.color !== card.color && targetCard.value === card.value + 1;
            }
        }

        // Déplacer une carte ou une séquence
        function moveCard(fromCard, fromPile, toCard, toPileType, toPileIndex) {
            const cardsToMove = getCardsToMove(fromCard, fromPile);
            
            // Retirer les cartes de leur pile d'origine
            removeCardsFromPile(cardsToMove, fromPile);
            
            // Ajouter les cartes à leur nouvelle destination
            if (toPileType === 'foundation') {
                const suits = ['spades', 'hearts', 'diamonds', 'clubs'];
                gameState.foundations[suits[toPileIndex]].push(fromCard);
                gameState.score += 10;
            } else if (toPileType === 'tableau') {
                cardsToMove.forEach(card => {
                    gameState.tableau[toPileIndex].push(card);
                });
                gameState.score += cardsToMove.length * 5;
            }
            
            gameState.moves++;
            
            addToHistory('move', {
                cardsToMove, fromPile, toCard, toPileType, toPileIndex
            });
            
            renderBoard();
            updateDisplay();
            checkWinCondition();
        }

        // Obtenir les cartes à déplacer (carte seule ou séquence)
        function getCardsToMove(fromCard, fromPile) {
            if (fromPile.type === 'tableau') {
                const column = gameState.tableau[fromPile.index];
                const cardIndex = column.indexOf(fromCard);
                return column.slice(cardIndex);
            } else {
                return [fromCard];
            }
        }

        // Tirer du stock
        function drawFromStock() {
            if (!gameState.isPlaying) {
                showMessage('Commencez une nouvelle partie pour jouer!');
                return;
            }
            
            clearSelection();
            
            if (gameState.stock.length === 0) {
                if (gameState.waste.length === 0) {
                    showMessage('Plus de cartes disponibles!');
                    return;
                }
                
                // Remettre la défausse dans le stock
                gameState.stock = [...gameState.waste].reverse();
                gameState.waste = [];
                gameState.stock.forEach(card => card.faceUp = false);
                gameState.moves++;
                showMessage('Stock rechargé depuis la défausse!');
            } else {
                // Tirer des cartes selon la difficulté
                const drawCount = gameState.difficulty === 'easy' ? 1 : 3;
                const drawnCards = [];
                
                for (let i = 0; i < drawCount && gameState.stock.length > 0; i++) {
                    const card = gameState.stock.pop();
                    card.faceUp = true;
                    gameState.waste.push(card);
                    drawnCards.push(card);
                }
                
                gameState.moves++;
                
                if (drawnCards.length > 0) {
                    const lastCard = drawnCards[drawnCards.length - 1];
                    showMessage(`Carte tirée: ${lastCard.rank}${lastCard.symbol}`);
                }
            }
            
            renderBoard();
            updateDisplay();
        }

        // Gérer le clic sur une fondation
        function handleFoundationClick(element) {
            const suit = element.dataset.suit;
            const suits = ['spades', 'hearts', 'diamonds', 'clubs'];
            const suitIndex = suits.indexOf(suit);
            
            if (!gameState.isPlaying) {
                showMessage('Commencez une nouvelle partie pour jouer!');
                return;
            }
            
            if (gameState.selectedCard) {
                if (canMoveToFoundation(gameState.selectedCard, suit)) {
                    moveCard(gameState.selectedCard, gameState.selectedPile, null, 'foundation', suitIndex);
                    showMessage(`${gameState.selectedCard.rank}${gameState.selectedCard.symbol} placé sur la fondation!`);
                    clearSelection();
                } else {
                    showMessage('Cette carte ne peut pas être placée sur cette fondation!');
                }
            } else {
                // Sélectionner la carte du dessus de la fondation si elle existe
                const foundation = gameState.foundations[suit];
                if (foundation.length > 0) {
                    const topCard = foundation[foundation.length - 1];
                    selectCard(topCard, 'foundation', suitIndex);
                    showMessage(`${topCard.rank}${topCard.symbol} sélectionné depuis la fondation.`);
                }
            }
        }

        // Retirer des cartes de leur pile
        function removeCardsFromPile(cards, pile) {
            if (pile.type === 'tableau') {
                const column = gameState.tableau[pile.index];
                const firstCardIndex = column.indexOf(cards[0]);
                column.splice(firstCardIndex, cards.length);
                
                // Retourner la carte suivante si nécessaire
                if (column.length > 0 && !column[column.length - 1].faceUp) {
                    column[column.length - 1].faceUp = true;
                    gameState.score += 5;
                }
            } else if (pile.type === 'waste') {
                gameState.waste.pop();
            } else if (pile.type === 'foundation') {
                const suits = ['spades', 'hearts', 'diamonds', 'clubs'];
                gameState.foundations[suits[pile.index]].pop();
            }
        }

        // Ajouter à l'historique
        function addToHistory(action, data) {
            gameState.moveHistory.push({ action, data, timestamp: Date.now() });
        }

        // Annuler le dernier coup
        function undoMove() {
            if (gameState.moveHistory.length === 0) return;
            
            const lastMove = gameState.moveHistory.pop();
            
            gameState.moves = Math.max(0, gameState.moves - 1);
            renderBoard();
            updateDisplay();
        }

        // Obtenir un indice
        function getHint() {
            if (gameState.hintsAvailable <= 0) return;
            
            gameState.hintsUsed++;
            gameState.hintsAvailable--;
            
            const t = translations[gameState.currentLanguage];
            
            const hints = [
                t.hints.drawStock,
                t.hints.noMoves
            ];
            
            const randomHint = hints[Math.floor(Math.random() * hints.length)];
            showMessage(randomHint);
            
            const aiPanel = document.getElementById('aiPanel');
            aiPanel.classList.add('ai-thinking');
            setTimeout(() => {
                aiPanel.classList.remove('ai-thinking');
            }, 2000);
            
            updateDisplay();
        }

        // Auto-placement vers les fondations
        function autoMoveToFoundations() {
            if (!gameState.isPlaying) {
                showMessage('Commencez une nouvelle partie pour jouer!');
                return;
            }
            
            let moved = false;
            let movedCards = [];
            
            // Vérifier toutes les cartes visibles pour un placement automatique
            for (let col = 0; col < 7; col++) {
                const column = gameState.tableau[col];
                if (column.length > 0) {
                    const topCard = column[column.length - 1];
                    if (topCard.faceUp) {
                        for (let suit in gameState.foundations) {
                            if (canMoveToFoundation(topCard, suit)) {
                                gameState.foundations[suit].push(topCard);
                                column.pop();
                                
                                if (column.length > 0 && !column[column.length - 1].faceUp) {
                                    column[column.length - 1].faceUp = true;
                                    gameState.score += 5;
                                }
                                
                                gameState.moves++;
                                gameState.score += 10;
                                movedCards.push(`${topCard.rank}${topCard.symbol}`);
                                moved = true;
                                break;
                            }
                        }
                    }
                }
            }
            
            // Vérifier la défausse
            if (gameState.waste.length > 0) {
                const topCard = gameState.waste[gameState.waste.length - 1];
                for (let suit in gameState.foundations) {
                    if (canMoveToFoundation(topCard, suit)) {
                        gameState.foundations[suit].push(topCard);
                        gameState.waste.pop();
                        gameState.moves++;
                        gameState.score += 10;
                        movedCards.push(`${topCard.rank}${topCard.symbol}`);
                        moved = true;
                        break;
                    }
                }
            }
            
            if (moved) {
                showMessage(`Auto-placement: ${movedCards.join(', ')} déplacé(s)!`);
                renderBoard();
                updateDisplay();
                checkWinCondition();
            } else {
                showMessage('Aucun auto-placement possible pour le moment.');
            }
        }

        // Essayer de déplacer automatiquement une carte
        function tryAutoMoveCard(card, pileType, pileIndex) {
            if (!gameState.isPlaying) return;
            
            // Essayer de placer sur une fondation
            for (let suit in gameState.foundations) {
                if (canMoveToFoundation(card, suit)) {
                    const suits = ['spades', 'hearts', 'diamonds', 'clubs'];
                    const suitIndex = suits.indexOf(suit);
                    moveCard(card, { type: pileType, index: pileIndex }, null, 'foundation', suitIndex);
                    showMessage(`${card.rank}${card.symbol} auto-placé sur la fondation!`);
                    return;
                }
            }
            
            // Essayer de placer sur le tableau
            for (let col = 0; col < 7; col++) {
                const column = gameState.tableau[col];
                if (column.length === 0 && card.rank === 'K') {
                    moveCard(card, { type: pileType, index: pileIndex }, null, 'tableau', col);
                    showMessage(`${card.rank}${card.symbol} auto-placé sur colonne vide!`);
                    return;
                } else if (column.length > 0) {
                    const topCard = column[column.length - 1];
                    if (canMoveToTableau(card, topCard, col)) {
                        moveCard(card, { type: pileType, index: pileIndex }, topCard, 'tableau', col);
                        showMessage(`${card.rank}${card.symbol} auto-placé sur ${topCard.rank}${topCard.symbol}!`);
                        return;
                    }
                }
            }
            
            showMessage(`Aucun placement automatique possible pour ${card.rank}${card.symbol}.`);
        }

        // Mélanger la défausse
        function shuffleWaste() {
            if (gameState.waste.length > 0) {
                gameState.waste = shuffleDeck(gameState.waste);
                renderBoard();
                showMessage('Défausse mélangée!');
            }
        }

        // Vérifier la condition de victoire
        function checkWinCondition() {
            const totalFoundationCards = Object.values(gameState.foundations)
                .reduce((sum, pile) => sum + pile.length, 0);
            
            if (totalFoundationCards === 52) {
                winGame();
            }
        }

        // Gagner le jeu
        function winGame() {
            clearInterval(gameState.timer);
            gameState.isPlaying = false;
            
            // Mettre à jour les meilleurs scores
            const currentTime = gameState.gameTime;
            if (!gameState.bestScores.bestTime || currentTime < gameState.bestScores.bestTime) {
                gameState.bestScores.bestTime = currentTime;
            }
            if (gameState.score > gameState.bestScores.bestScore) {
                gameState.bestScores.bestScore = gameState.score;
            }
            gameState.bestScores.gamesWon++;
            
            localStorage.setItem('solitaireFusionBestScores', JSON.stringify(gameState.bestScores));
            
            const t = translations[gameState.currentLanguage];
            showMessage(t.gameWon);
            
            document.getElementById('celebrateBtn').style.display = 'block';
            updateDisplay();
        }

        // Célébrer la victoire
        function celebrateWin() {
            const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57'];
            
            for (let i = 0; i < 50; i++) {
                setTimeout(() => {
                    const confetti = document.createElement('div');
                    confetti.style.position = 'fixed';
                    confetti.style.left = Math.random() * 100 + 'vw';
                    confetti.style.top = '-10px';
                    confetti.style.width = '10px';
                    confetti.style.height = '10px';
                    confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                    confetti.style.borderRadius = '50%';
                    confetti.style.zIndex = '9999';
                    confetti.style.animation = 'fall 3s linear forwards';
                    
                    document.body.appendChild(confetti);
                    
                    setTimeout(() => {
                        confetti.remove();
                    }, 3000);
                }, i * 100);
            }
        }

        // Réinitialiser le jeu
        function resetGame() {
            if (gameState.timer) clearInterval(gameState.timer);
            gameState.isPlaying = false;
            gameState.selectedCard = null;
            gameState.selectedPile = null;
            
            document.getElementById('celebrateBtn').style.display = 'none';
            
            const t = translations[gameState.currentLanguage];
            showMessage(t.welcomeMessage);
            
            updateDisplay();
        }

        // Mettre à jour le timer
        function updateTimer() {
            if (gameState.isPlaying) {
                gameState.gameTime = Math.floor((Date.now() - gameState.startTime) / 1000);
                const minutes = Math.floor(gameState.gameTime / 60);
                const seconds = gameState.gameTime % 60;
                document.getElementById('timeValue').textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
        }

        // Mettre à jour l'affichage
        function updateDisplay() {
            document.getElementById('scoreValue').textContent = gameState.score;
            document.getElementById('movesValue').textContent = gameState.moves;
            
            const cardsLeft = gameState.stock.length + gameState.waste.length + 
                gameState.tableau.reduce((sum, col) => sum + col.length, 0);
            document.getElementById('cardsLeftValue').textContent = cardsLeft;
            
            const foundationsComplete = Object.values(gameState.foundations)
                .filter(pile => pile.length === 13).length;
            document.getElementById('foundationsValue').textContent = `${foundationsComplete}/4`;
            
            const completion = Math.floor((Object.values(gameState.foundations)
                .reduce((sum, pile) => sum + pile.length, 0) / 52) * 100);
            document.getElementById('completionValue').textContent = `${completion}%`;
            
            document.getElementById('hintsUsedValue').textContent = gameState.hintsUsed;
            document.getElementById('hintsAvailableValue').textContent = gameState.hintsAvailable;
            
            // Meilleurs scores
            const bestTime = gameState.bestScores.bestTime;
            if (bestTime) {
                const minutes = Math.floor(bestTime / 60);
                const seconds = bestTime % 60;
                document.getElementById('bestTimeValue').textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
            document.getElementById('bestScoreValue').textContent = gameState.bestScores.bestScore;
            document.getElementById('gamesWonValue').textContent = gameState.bestScores.gamesWon;
            
            // Activer/désactiver les boutons
            document.getElementById('undoBtn').disabled = gameState.moveHistory.length === 0;
            document.getElementById('hintBtn').disabled = gameState.hintsAvailable <= 0;
            document.getElementById('shuffleBtn').disabled = gameState.waste.length === 0;
        }

        // Afficher un message
        function showMessage(message) {
            const messageElement = document.getElementById('gameMessage');
            messageElement.innerHTML = `<span>${message}</span>`;
        }

        // Afficher les règles
        function showRules() {
            const t = translations[gameState.currentLanguage];
            alert(`Règles du Solitaire Fusion:

1. Déplacez toutes les cartes vers les fondations
2. Les fondations se construisent par couleur de A à K
3. Dans le tableau, alternez les couleurs en ordre décroissant
4. Seuls les Rois peuvent être placés sur des colonnes vides
5. Utilisez le stock pour révéler de nouvelles cartes
6. Gagnez en complétant les 4 fondations!`);
        }

        // Initialisation
        document.addEventListener('DOMContentLoaded', function() {
            createQuantumParticles();
            updateLanguageInterface();
            updateDisplay();
            setDifficulty('easy');
        });
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'9862d4071073e1d5',t:'MTc1OTA1ODE4Mi4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script>
    <script>
        // État du jeu
    var gameState = {
            isPlaying: false,
            currentLanguage: 'fr',
            difficulty: 'easy',
            score: 0,
            moves: 0,
            startTime: null,
            gameTime: 0,
            timer: null,
            deck: [],
            stock: [],
            waste: [],
            foundations: { spades: [], hearts: [], diamonds: [], clubs: [] },
            tableau: [[], [], [], [], [], [], []],
            selectedCard: null,
            selectedPile: null,
            hintsUsed: 0,
            hintsAvailable: 3,
            moveHistory: [],
            bestScores: JSON.parse(localStorage.getItem('solitaireFusionBestScores')) || {
                bestTime: null,
                bestScore: 0,
                gamesWon: 0
            }
        };

        // Traductions
        const translations = {
            fr: {
                gameTitle: 'SOLITAIRE FUSION',
                statsTitle: '📊 Statistiques',
                progressTitle: '🎯 Progression',
                bestScoresTitle: '🏆 Meilleurs Scores',
                aiTitle: '🤖 Assistant IA',
                hintsTitle: '💡 Indices',
                actionsTitle: '⚡ Actions Rapides',
                difficultyTitle: '⚙️ Difficulté',
                foundationsTitle: '🏛️ Fondations',
                stockWasteTitle: '🎴 Stock & Défausse',
                tableauTitle: '🎯 Tableau',
                welcomeMessage: 'Bienvenue au Solitaire Fusion! Cliquez sur "Nouvelle Partie" pour commencer.',
                gameStarted: 'Nouvelle partie commencée! Bonne chance!',
                gameWon: '🎉 Félicitations! Vous avez gagné!',
                scoreLabel: 'Score',
                movesLabel: 'Coups',
                timeLabel: 'Temps',
                cardsLeftLabel: 'Cartes restantes',
                foundationsLabel: 'Fondations',
                completionLabel: 'Complétion',
                bestTimeLabel: 'Meilleur temps',
                bestScoreLabel: 'Meilleur score',
                gamesWonLabel: 'Parties gagnées',
                hintsUsedLabel: 'Indices utilisés',
                hintsAvailableLabel: 'Indices disponibles',
                currentDifficultyText: 'Mode',
                newGameBtn: 'Nouvelle Partie',
                undoBtnText: 'Annuler',
                hintBtnText: 'Indice',
                resetBtnText: 'Recommencer',
                rulesBtn: 'Règles',
                easyBtnText: 'Facile',
                mediumBtnText: 'Moyen',
                hardBtnText: 'Difficile',
                autoMoveBtnText: 'Auto-placement',
                shuffleBtnText: 'Mélanger défausse',
                celebrateBtnText: 'Célébrer!',
                aiStatus: 'Assistant IA activé\nAnalyse des coups possibles...',
                difficultyDesc: {
                    easy: 'Tirage par 1 carte, indices illimités',
                    medium: 'Tirage par 3 cartes, 5 indices',
                    hard: 'Tirage par 3 cartes, 3 indices'
                },
                hints: {
                    noMoves: 'Aucun coup évident disponible.',
                    moveToFoundation: 'Vous pouvez placer {card} sur la fondation {suit}.',
                    revealCard: 'Retournez la carte dans la colonne {column}.',
                    moveCard: 'Déplacez {card} sur {target}.',
                    drawStock: 'Tirez une carte du stock.'
                }
            },
            es: {
                gameTitle: 'SOLITARIO FUSION',
                statsTitle: '📊 Estadísticas',
                progressTitle: '🎯 Progreso',
                bestScoresTitle: '🏆 Mejores Puntuaciones',
                aiTitle: '🤖 Asistente IA',
                hintsTitle: '💡 Pistas',
                actionsTitle: '⚡ Acciones Rápidas',
                difficultyTitle: '⚙️ Dificultad',
                foundationsTitle: '🏛️ Fundaciones',
                stockWasteTitle: '🎴 Mazo y Descarte',
                tableauTitle: '🎯 Tablero',
                welcomeMessage: '¡Bienvenido a Solitario Fusion! Haz clic en "Nueva Partida" para comenzar.',
                gameStarted: '¡Nueva partida iniciada! ¡Buena suerte!',
                gameWon: '🎉 ¡Felicitaciones! ¡Has ganado!',
                scoreLabel: 'Puntuación',
                movesLabel: 'Movimientos',
                timeLabel: 'Tiempo',
                cardsLeftLabel: 'Cartas restantes',
                foundationsLabel: 'Fundaciones',
                completionLabel: 'Completado',
                bestTimeLabel: 'Mejor tiempo',
                bestScoreLabel: 'Mejor puntuación',
                gamesWonLabel: 'Partidas ganadas',
                hintsUsedLabel: 'Pistas usadas',
                hintsAvailableLabel: 'Pistas disponibles',
                currentDifficultyText: 'Modo',
                newGameBtn: 'Nueva Partida',
                undoBtnText: 'Deshacer',
                hintBtnText: 'Pista',
                resetBtnText: 'Reiniciar',
                rulesBtn: 'Reglas',
                easyBtnText: 'Fácil',
                mediumBtnText: 'Medio',
                hardBtnText: 'Difícil',
                autoMoveBtnText: 'Auto-mover',
                shuffleBtnText: 'Mezclar descarte',
                celebrateBtnText: '¡Celebrar!',
                aiStatus: 'Asistente IA activado\nAnalizando movimientos posibles...',
                difficultyDesc: {
                    easy: 'Robar 1 carta, pistas ilimitadas',
                    medium: 'Robar 3 cartas, 5 pistas',
                    hard: 'Robar 3 cartas, 3 pistas'
                },
                hints: {
                    noMoves: 'No hay movimientos obvios disponibles.',
                    moveToFoundation: 'Puedes colocar {card} en la fundación {suit}.',
                    revealCard: 'Voltea la carta en la columna {column}.',
                    moveCard: 'Mueve {card} a {target}.',
                    drawStock: 'Roba una carta del mazo.'
                }
            },
            ar: {
                gameTitle: 'سوليتير فيوجن',
                statsTitle: '📊 الإحصائيات',
                progressTitle: '🎯 التقدم',
                bestScoresTitle: '🏆 أفضل النتائج',
                aiTitle: '🤖 مساعد الذكي',
                hintsTitle: '💡 التلميحات',
                actionsTitle: '⚡ إجراءات سريعة',
                difficultyTitle: '⚙️ الصعوبة',
                foundationsTitle: '🏛️ الأسس',
                stockWasteTitle: '🎴 المخزون والنفايات',
                tableauTitle: '🎯 اللوحة',
                welcomeMessage: 'مرحباً بك في سوليتير فيوجن! انقر على "لعبة جديدة" للبدء.',
                gameStarted: 'بدأت لعبة جديدة! حظاً سعيداً!',
                gameWon: '🎉 تهانينا! لقد فزت!',
                scoreLabel: 'النقاط',
                movesLabel: 'الحركات',
                timeLabel: 'الوقت',
                cardsLeftLabel: 'الأوراق المتبقية',
                foundationsLabel: 'الأسس',
                completionLabel: 'الإنجاز',
                bestTimeLabel: 'أفضل وقت',
                bestScoreLabel: 'أفضل نقاط',
                gamesWonLabel: 'الألعاب المكسوبة',
                hintsUsedLabel: 'التلميحات المستخدمة',
                hintsAvailableLabel: 'التلميحات المتاحة',
                currentDifficultyText: 'الوضع',
                newGameBtn: 'لعبة جديدة',
                undoBtnText: 'تراجع',
                hintBtnText: 'تلميح',
                resetBtnText: 'إعادة تعيين',
                rulesBtn: 'القواعد',
                easyBtnText: 'سهل',
                mediumBtnText: 'متوسط',
                hardBtnText: 'صعب',
                autoMoveBtnText: 'حركة تلقائية',
                shuffleBtnText: 'خلط النفايات',
                celebrateBtnText: 'احتفل!',
                aiStatus: 'تم تفعيل المساعد الذكي\nتحليل الحركات الممكنة...',
                difficultyDesc: {
                    easy: 'سحب ورقة واحدة، تلميحات غير محدودة',
                    medium: 'سحب 3 أوراق، 5 تلميحات',
                    hard: 'سحب 3 أوراق، 3 تلميحات'
                },
                hints: {
                    noMoves: 'لا توجد حركات واضحة متاحة.',
                    moveToFoundation: 'يمكنك وضع {card} على أساس {suit}.',
                    revealCard: 'اقلب الورقة في العمود {column}.',
                    moveCard: 'انقل {card} إلى {target}.',
                    drawStock: 'اسحب ورقة من المخزون.'
                }
            },
            de: {
                gameTitle: 'SOLITÄR FUSION',
                statsTitle: '📊 Statistiken',
                progressTitle: '🎯 Fortschritt',
                bestScoresTitle: '🏆 Beste Ergebnisse',
                aiTitle: '🤖 KI-Assistent',
                hintsTitle: '💡 Hinweise',
                actionsTitle: '⚡ Schnellaktionen',
                difficultyTitle: '⚙️ Schwierigkeit',
                foundationsTitle: '🏛️ Fundamente',
                stockWasteTitle: '🎴 Stapel & Abfall',
                tableauTitle: '🎯 Tableau',
                welcomeMessage: 'Willkommen bei Solitär Fusion! Klicken Sie auf "Neues Spiel" um zu beginnen.',
                gameStarted: 'Neues Spiel gestartet! Viel Glück!',
                gameWon: '🎉 Herzlichen Glückwunsch! Sie haben gewonnen!',
                scoreLabel: 'Punkte',
                movesLabel: 'Züge',
                timeLabel: 'Zeit',
                cardsLeftLabel: 'Karten übrig',
                foundationsLabel: 'Fundamente',
                completionLabel: 'Fertigstellung',
                bestTimeLabel: 'Beste Zeit',
                bestScoreLabel: 'Beste Punkte',
                gamesWonLabel: 'Gewonnene Spiele',
                hintsUsedLabel: 'Hinweise verwendet',
                hintsAvailableLabel: 'Hinweise verfügbar',
                currentDifficultyText: 'Modus',
                newGameBtn: 'Neues Spiel',
                undoBtnText: 'Rückgängig',
                hintBtnText: 'Hinweis',
                resetBtnText: 'Zurücksetzen',
                rulesBtn: 'Regeln',
                easyBtnText: 'Einfach',
                mediumBtnText: 'Mittel',
                hardBtnText: 'Schwer',
                autoMoveBtnText: 'Auto-Zug',
                shuffleBtnText: 'Abfall mischen',
                celebrateBtnText: 'Feiern!',
                aiStatus: 'KI-Assistent aktiviert\nAnalysiere mögliche Züge...',
                difficultyDesc: {
                    easy: '1 Karte ziehen, unbegrenzte Hinweise',
                    medium: '3 Karten ziehen, 5 Hinweise',
                    hard: '3 Karten ziehen, 3 Hinweise'
                },
                hints: {
                    noMoves: 'Keine offensichtlichen Züge verfügbar.',
                    moveToFoundation: 'Sie können {card} auf das {suit} Fundament legen.',
                    revealCard: 'Drehen Sie die Karte in Spalte {column} um.',
                    moveCard: 'Bewegen Sie {card} zu {target}.',
                    drawStock: 'Ziehen Sie eine Karte vom Stapel.'
                }
            },
            zh: {
                gameTitle: '纸牌融合',
                statsTitle: '📊 统计',
                progressTitle: '🎯 进度',
                bestScoresTitle: '🏆 最佳成绩',
                aiTitle: '🤖 AI助手',
                hintsTitle: '💡 提示',
                actionsTitle: '⚡ 快速操作',
                difficultyTitle: '⚙️ 难度',
                foundationsTitle: '🏛️ 基础堆',
                stockWasteTitle: '🎴 库存和废牌',
                tableauTitle: '🎯 牌桌',
                welcomeMessage: '欢迎来到纸牌融合！点击"新游戏"开始。',
                gameStarted: '新游戏开始！祝你好运！',
                gameWon: '🎉 恭喜！你赢了！',
                scoreLabel: '得分',
                movesLabel: '移动',
                timeLabel: '时间',
                cardsLeftLabel: '剩余牌数',
                foundationsLabel: '基础堆',
                completionLabel: '完成度',
                bestTimeLabel: '最佳时间',
                bestScoreLabel: '最高分',
                gamesWonLabel: '获胜游戏',
                hintsUsedLabel: '已用提示',
                hintsAvailableLabel: '可用提示',
                currentDifficultyText: '模式',
                newGameBtn: '新游戏',
                undoBtnText: '撤销',
                hintBtnText: '提示',
                resetBtnText: '重置',
                rulesBtn: '规则',
                easyBtnText: '简单',
                mediumBtnText: '中等',
                hardBtnText: '困难',
                autoMoveBtnText: '自动移动',
                shuffleBtnText: '洗废牌',
                celebrateBtnText: '庆祝！',
                aiStatus: 'AI助手已激活\n分析可能的移动...',
                difficultyDesc: {
                    easy: '抽1张牌，无限提示',
                    medium: '抽3张牌，5个提示',
                    hard: '抽3张牌，3个提示'
                },
                hints: {
                    noMoves: '没有明显的移动可用。',
                    moveToFoundation: '你可以将{card}放在{suit}基础堆上。',
                    revealCard: '翻转第{column}列的牌。',
                    moveCard: '将{card}移动到{target}。',
                    drawStock: '从库存中抽一张牌。'
                }
            },
            en: {
                gameTitle: 'SOLITAIRE FUSION',
                statsTitle: '📊 Statistics',
                progressTitle: '🎯 Progress',
                bestScoresTitle: '🏆 Best Scores',
                aiTitle: '🤖 AI Assistant',
                hintsTitle: '💡 Hints',
                actionsTitle: '⚡ Quick Actions',
                difficultyTitle: '⚙️ Difficulty',
                foundationsTitle: '🏛️ Foundations',
                stockWasteTitle: '🎴 Stock & Waste',
                tableauTitle: '🎯 Tableau',
                welcomeMessage: 'Welcome to Solitaire Fusion! Click "New Game" to start.',
                gameStarted: 'New game started! Good luck!',
                gameWon: '🎉 Congratulations! You won!',
                scoreLabel: 'Score',
                movesLabel: 'Moves',
                timeLabel: 'Time',
                cardsLeftLabel: 'Cards left',
                foundationsLabel: 'Foundations',
                completionLabel: 'Completion',
                bestTimeLabel: 'Best time',
                bestScoreLabel: 'Best score',
                gamesWonLabel: 'Games won',
                hintsUsedLabel: 'Hints used',
                hintsAvailableLabel: 'Hints available',
                currentDifficultyText: 'Mode',
                newGameBtn: 'New Game',
                undoBtnText: 'Undo',
                hintBtnText: 'Hint',
                resetBtnText: 'Reset',
                rulesBtn: 'Rules',
                easyBtnText: 'Easy',
                mediumBtnText: 'Medium',
                hardBtnText: 'Hard',
                autoMoveBtnText: 'Auto-move',
                shuffleBtnText: 'Shuffle waste',
                celebrateBtnText: 'Celebrate!',
                aiStatus: 'AI Assistant activated\nAnalyzing possible moves...',
                difficultyDesc: {
                    easy: 'Draw 1 card, unlimited hints',
                    medium: 'Draw 3 cards, 5 hints',
                    hard: 'Draw 3 cards, 3 hints'
                },
                hints: {
                    noMoves: 'No obvious moves available.',
                    moveToFoundation: 'You can place {card} on {suit} foundation.',
                    revealCard: 'Flip the card in column {column}.',
                    moveCard: 'Move {card} to {target}.',
                    drawStock: 'Draw a card from stock.'
                }
            }
        };

        // Créer un jeu de cartes
        function createDeck() {
            const suits = ['spades', 'hearts', 'diamonds', 'clubs'];
            const suitSymbols = { spades: '♠', hearts: '♥', diamonds: '♦', clubs: '♣' };
            const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
            const deck = [];
            
            for (let suit of suits) {
                for (let i = 0; i < ranks.length; i++) {
                    deck.push({
                        suit: suit,
                        rank: ranks[i],
                        value: i + 1,
                        symbol: suitSymbols[suit],
                        color: (suit === 'hearts' || suit === 'diamonds') ? 'red' : 'black',
                        faceUp: false
                    });
                }
            }
            
            return createWinnableDeck(shuffleDeck(deck));
        }

        // Créer un jeu avec 80% de chances de victoire
        function createWinnableDeck(deck) {
            // 80% de chance de créer une configuration gagnante
            if (Math.random() < 0.8) {
                return optimizeDeckForWinning(deck);
            }
            return deck;
        }

        // Optimiser le jeu pour augmenter les chances de victoire
        function optimizeDeckForWinning(deck) {
            // Placer plus d'As et de cartes basses dans les positions accessibles
            const aces = deck.filter(card => card.rank === 'A');
            const lowCards = deck.filter(card => card.value <= 4 && card.rank !== 'A');
            const otherCards = deck.filter(card => card.value > 4);
            
            // Mélanger chaque groupe séparément
            const shuffledAces = shuffleDeck([...aces]);
            const shuffledLowCards = shuffleDeck([...lowCards]);
            const shuffledOtherCards = shuffleDeck([...otherCards]);
            
            // Répartir de manière à favoriser l'accès aux cartes importantes
            const optimizedDeck = [];
            
            // Alterner les types de cartes pour une meilleure distribution
            let aceIndex = 0, lowIndex = 0, otherIndex = 0;
            
            for (let i = 0; i < 52; i++) {
                if (i % 4 === 0 && aceIndex < shuffledAces.length) {
                    optimizedDeck.push(shuffledAces[aceIndex++]);
                } else if (i % 3 === 0 && lowIndex < shuffledLowCards.length) {
                    optimizedDeck.push(shuffledLowCards[lowIndex++]);
                } else if (otherIndex < shuffledOtherCards.length) {
                    optimizedDeck.push(shuffledOtherCards[otherIndex++]);
                } else if (lowIndex < shuffledLowCards.length) {
                    optimizedDeck.push(shuffledLowCards[lowIndex++]);
                } else if (aceIndex < shuffledAces.length) {
                    optimizedDeck.push(shuffledAces[aceIndex++]);
                }
            }
            
            return optimizedDeck;
        }

        // Mélanger le jeu
        function shuffleDeck(deck) {
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
            return deck;
        }

        // Créer les particules quantiques
        function createQuantumParticles() {
            const bg = document.querySelector('.quantum-bg');
            for (let i = 0; i < 50; i++) {
                const particle = document.createElement('div');
                particle.className = 'quantum-particle';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.top = Math.random() * 100 + '%';
                particle.style.animationDelay = Math.random() * 6 + 's';
                particle.style.animationDuration = (Math.random() * 4 + 4) + 's';
                bg.appendChild(particle);
            }
        }

        // Basculer le dropdown de langue
        function toggleLanguageDropdown() {
            const options = document.getElementById('languageOptions');
            options.classList.toggle('show');
            
            document.addEventListener('click', function closeDropdown(e) {
                if (!e.target.closest('.language-selector')) {
                    options.classList.remove('show');
                    document.removeEventListener('click', closeDropdown);
                }
            });
        }

        // Sélectionner une langue
        function selectLanguage(langCode, langText) {
            gameState.currentLanguage = langCode;
            
            document.getElementById('currentLanguage').textContent = langText;
            
            document.querySelectorAll('.language-option').forEach(option => {
                option.classList.remove('active');
            });
            event.target.classList.add('active');
            
            document.getElementById('languageOptions').classList.remove('show');
            
            updateLanguageInterface();
        }

        // Mettre à jour l'interface selon la langue
        function updateLanguageInterface() {
            const t = translations[gameState.currentLanguage];
            
            // Titres principaux
            document.getElementById('gameTitle').textContent = t.gameTitle;
            document.getElementById('statsTitle').textContent = t.statsTitle;
            document.getElementById('progressTitle').textContent = t.progressTitle;
            document.getElementById('bestScoresTitle').textContent = t.bestScoresTitle;
            document.getElementById('aiTitle').textContent = t.aiTitle;
            document.getElementById('hintsTitle').textContent = t.hintsTitle;
            document.getElementById('actionsTitle').textContent = t.actionsTitle;
            document.getElementById('difficultyTitle').textContent = t.difficultyTitle;
            document.getElementById('foundationsTitle').textContent = t.foundationsTitle;
            document.getElementById('stockWasteTitle').textContent = t.stockWasteTitle;
            document.getElementById('tableauTitle').textContent = t.tableauTitle;
            
            // Labels des statistiques
            document.getElementById('scoreLabel').textContent = t.scoreLabel + ':';
            document.getElementById('movesLabel').textContent = t.movesLabel + ':';
            document.getElementById('timeLabel').textContent = t.timeLabel + ':';
            document.getElementById('cardsLeftLabel').textContent = t.cardsLeftLabel + ':';
            document.getElementById('foundationsLabel').textContent = t.foundationsLabel + ':';
            document.getElementById('completionLabel').textContent = t.completionLabel + ':';
            document.getElementById('bestTimeLabel').textContent = t.bestTimeLabel + ':';
            document.getElementById('bestScoreLabel').textContent = t.bestScoreLabel + ':';
            document.getElementById('gamesWonLabel').textContent = t.gamesWonLabel + ':';
            document.getElementById('hintsUsedLabel').textContent = t.hintsUsedLabel + ':';
            document.getElementById('hintsAvailableLabel').textContent = t.hintsAvailableLabel + ':';
            
            // Boutons
            document.getElementById('newGameBtn').textContent = t.newGameBtn;
            document.getElementById('undoBtnText').textContent = t.undoBtnText;
            document.getElementById('hintBtnText').textContent = t.hintBtnText;
            document.getElementById('resetBtnText').textContent = t.resetBtnText;
            document.getElementById('rulesBtn').textContent = t.rulesBtn;
            document.getElementById('easyBtnText').textContent = t.easyBtnText;
            document.getElementById('mediumBtnText').textContent = t.mediumBtnText;
            document.getElementById('hardBtnText').textContent = t.hardBtnText;
            document.getElementById('autoMoveBtnText').textContent = t.autoMoveBtnText;
            document.getElementById('shuffleBtnText').textContent = t.shuffleBtnText;
            document.getElementById('celebrateBtnText').textContent = t.celebrateBtnText;
            
            // Textes dynamiques
            document.getElementById('aiStatusText').innerHTML = t.aiStatus.replace(/\n/g, '<br>');
            document.getElementById('currentDifficultyText').innerHTML = `${t.currentDifficultyText}: <span id="currentDifficultyValue">${t[gameState.difficulty + 'BtnText']}</span>`;
            document.getElementById('difficultyDescText').textContent = t.difficultyDesc[gameState.difficulty];
            
            if (!gameState.isPlaying) {
                document.getElementById('gameMessage').innerHTML = `<span>${t.welcomeMessage}</span>`;
            }
        }

        // Définir la difficulté
        function setDifficulty(level) {
            gameState.difficulty = level;
            
            // Mettre à jour les boutons
            document.querySelectorAll('.difficulty-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(level + 'Btn').classList.add('active');
            
            // Ajuster les paramètres selon la difficulté
            switch(level) {
                case 'easy':
                    gameState.hintsAvailable = 999;
                    break;
                case 'medium':
                    gameState.hintsAvailable = 5;
                    break;
                case 'hard':
                    gameState.hintsAvailable = 3;
                    break;
            }
            
            updateLanguageInterface();
            updateDisplay();
        }

        // Nouvelle partie
        function newGame() {
            gameState.isPlaying = true;
            gameState.score = 0;
            gameState.moves = 0;
            gameState.startTime = Date.now();
            gameState.gameTime = 0;
            gameState.hintsUsed = 0;
            gameState.selectedCard = null;
            gameState.selectedPile = null;
            gameState.moveHistory = [];
            
            // Réinitialiser les piles
            gameState.foundations = { spades: [], hearts: [], diamonds: [], clubs: [] };
            gameState.tableau = [[], [], [], [], [], [], []];
            gameState.stock = [];
            gameState.waste = [];
            
            // Créer et distribuer les cartes
            gameState.deck = createDeck();
            dealCards();
            
            // Démarrer le timer
            if (gameState.timer) clearInterval(gameState.timer);
            gameState.timer = setInterval(updateTimer, 1000);
            
            // Activer les boutons
            document.getElementById('undoBtn').disabled = false;
            document.getElementById('hintBtn').disabled = false;
            
            updateDisplay();
            
            const t = translations[gameState.currentLanguage];
            showMessage(t.gameStarted);
        }

        // Distribuer les cartes
        function dealCards() {
            // Distribuer au tableau (1, 2, 3, 4, 5, 6, 7 cartes par colonne)
            for (let col = 0; col < 7; col++) {
                for (let row = 0; row <= col; row++) {
                    const card = gameState.deck.pop();
                    card.faceUp = (row === col); // Dernière carte face visible
                    gameState.tableau[col].push(card);
                }
            }
            
            // Le reste va au stock
            gameState.stock = [...gameState.deck];
            gameState.waste = [];
            
            renderBoard();
        }

        // Afficher le plateau
        function renderBoard() {
            renderFoundations();
            renderStock();
            renderWaste();
            renderTableau();
        }

        // Afficher les fondations
        function renderFoundations() {
            const suits = ['spades', 'hearts', 'diamonds', 'clubs'];
            suits.forEach((suit, index) => {
                const pile = document.querySelector(`[data-suit="${suit}"]`);
                pile.innerHTML = '';
                
                if (gameState.foundations[suit].length === 0) {
                    const suitSymbols = { spades: '♠', hearts: '♥', diamonds: '♦', clubs: '♣' };
                    const emptyCard = document.createElement('div');
                    emptyCard.className = 'card card-empty';
                    emptyCard.innerHTML = suitSymbols[suit];
                    emptyCard.onclick = () => handleFoundationClick(pile);
                    pile.appendChild(emptyCard);
                } else {
                    const topCard = gameState.foundations[suit][gameState.foundations[suit].length - 1];
                    const cardElement = createCardElement(topCard);
                    cardElement.onclick = () => handleFoundationClick(pile);
                    pile.appendChild(cardElement);
                }
            });
        }

        // Afficher le stock
        function renderStock() {
            const stockPile = document.getElementById('stockPile');
            stockPile.innerHTML = '';
            
            if (gameState.stock.length > 0) {
                const stockCard = document.createElement('div');
                stockCard.className = 'card card-back';
                stockCard.innerHTML = '🃏';
                stockCard.onclick = drawFromStock;
                stockPile.appendChild(stockCard);
            } else {
                const emptyCard = document.createElement('div');
                emptyCard.className = 'card card-empty';
                emptyCard.innerHTML = '🔄';
                emptyCard.onclick = drawFromStock;
                stockPile.appendChild(emptyCard);
            }
        }

        // Afficher la défausse
        function renderWaste() {
            const wastePile = document.getElementById('wastePile');
            wastePile.innerHTML = '';
            
            if (gameState.waste.length === 0) {
                const emptyCard = document.createElement('div');
                emptyCard.className = 'card card-empty';
                emptyCard.innerHTML = '📤';
                wastePile.appendChild(emptyCard);
            } else {
                const topCard = gameState.waste[gameState.waste.length - 1];
                const cardElement = createCardElement(topCard);
                cardElement.onclick = () => handleCardClick(topCard, 'waste', 0);
                cardElement.ondblclick = () => tryAutoMoveCard(topCard, 'waste', 0);
                wastePile.appendChild(cardElement);
            }
        }

        // Afficher le tableau
        function renderTableau() {
            for (let col = 0; col < 7; col++) {
                const pile = document.querySelector(`[data-column="${col}"]`);
                pile.innerHTML = '';
                
                const columnCards = gameState.tableau[col];
                
                if (columnCards.length === 0) {
                    const emptyCard = document.createElement('div');
                    emptyCard.className = 'card card-empty';
                    emptyCard.innerHTML = '👑';
                    emptyCard.onclick = () => handleTableauClick(col);
                    pile.appendChild(emptyCard);
                } else {
                    columnCards.forEach((card, index) => {
                        const cardElement = createCardElement(card);
                        cardElement.style.position = 'absolute';
                        cardElement.style.top = (index * 20) + 'px';
                        cardElement.style.zIndex = index + 1;
                        cardElement.onclick = () => handleCardClick(card, 'tableau', col);
                        cardElement.ondblclick = () => tryAutoMoveCard(card, 'tableau', col);
                        pile.appendChild(cardElement);
                    });
                }
            }
        }

        // Créer un élément carte
        function createCardElement(card) {
            const cardElement = document.createElement('div');
            cardElement.className = `card ${card.color}`;
            
            if (card.faceUp) {
                let centerContent = '';
                
                // Contenu central selon le rang
                if (card.rank === 'A') {
                    centerContent = `<div style="font-size: 40px; font-weight: bold; color: ${card.color === 'red' ? '#d63031' : '#2d3436'}; text-shadow: 0 0 3px rgba(0,0,0,0.4); display: flex; align-items: center; justify-content: center; height: 100%;">${card.symbol}</div>`;
                } else if (card.rank === 'J') {
                    centerContent = `<div style="font-size: 50px; font-weight: bold; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; width: 100%; color: ${card.color === 'red' ? '#d63031' : '#2d3436'}; text-shadow: 0 0 3px rgba(0,0,0,0.4);">
                        <div style="font-size: 40px; margin-bottom: 2px;">👨‍💼</div>
                        <div style="font-size: 24px; font-weight: bold; letter-spacing: 1px;">J</div>
                    </div>`;
                } else if (card.rank === 'Q') {
                    centerContent = `<div style="font-size: 50px; font-weight: bold; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; width: 100%; color: ${card.color === 'red' ? '#d63031' : '#2d3436'}; text-shadow: 0 0 3px rgba(0,0,0,0.4);">
                        <div style="font-size: 40px; margin-bottom: 2px;">👸</div>
                        <div style="font-size: 24px; font-weight: bold; letter-spacing: 1px;">Q</div>
                    </div>`;
                } else if (card.rank === 'K') {
                    centerContent = `<div style="font-size: 50px; font-weight: bold; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; width: 100%; color: ${card.color === 'red' ? '#d63031' : '#2d3436'}; text-shadow: 0 0 3px rgba(0,0,0,0.4);">
                        <div style="font-size: 40px; margin-bottom: 2px;">🤴</div>
                        <div style="font-size: 24px; font-weight: bold; letter-spacing: 1px;">K</div>
                    </div>`;
                } else {
                    // Cartes numériques (2-10) - afficher le nombre correct de symboles
                    const numValue = parseInt(card.rank);
                    if (numValue >= 2 && numValue <= 10) {
                        let symbolsArray = [];
                        for (let i = 0; i < numValue; i++) {
                            symbolsArray.push(`<span style="font-size: 18px; font-weight: bold; color: ${card.color === 'red' ? '#d63031' : '#2d3436'}; text-shadow: 0 0 2px rgba(0,0,0,0.3);">${card.symbol}</span>`);
                        }
                        
                        // Disposition équilibrée selon le nombre exact
                        if (numValue === 2) {
                            centerContent = `<div style="display: flex; flex-direction: column; align-items: center; justify-content: space-around; height: 80%; padding: 8px 0;">${symbolsArray.join('')}</div>`;
                        } else if (numValue === 3) {
                            centerContent = `<div style="display: flex; flex-direction: column; align-items: center; justify-content: space-around; height: 85%; padding: 6px 0;">${symbolsArray.join('')}</div>`;
                        } else if (numValue === 4) {
                            centerContent = `<div style="display: grid; grid-template-columns: 1fr 1fr; grid-template-rows: 1fr 1fr; gap: 4px; align-items: center; justify-items: center; height: 70%; width: 70%; margin: auto; justify-self: center;">${symbolsArray.join('')}</div>`;
                        } else if (numValue === 5) {
                            centerContent = `<div style="display: flex; flex-direction: column; align-items: center; justify-content: space-between; height: 85%; width: 100%; padding: 4px 0;">
                                <div style="display: flex; justify-content: space-around; width: 80%;">${symbolsArray[0]}${symbolsArray[1]}</div>
                                <div style="display: flex; justify-content: center; width: 80%;">${symbolsArray[2]}</div>
                                <div style="display: flex; justify-content: space-around; width: 80%;">${symbolsArray[3]}${symbolsArray[4]}</div>
                            </div>`;
                        } else if (numValue === 6) {
                            centerContent = `<div style="display: grid; grid-template-columns: 1fr 1fr; grid-template-rows: 1fr 1fr 1fr; gap: 2px; align-items: center; justify-items: center; height: 80%; width: 70%; margin: auto; justify-self: center;">${symbolsArray.join('')}</div>`;
                        } else if (numValue === 7) {
                            centerContent = `<div style="display: grid; grid-template-columns: 1fr 1fr 1fr; grid-template-rows: 1fr 1fr 1fr; gap: 1px; align-items: center; justify-items: center; height: 85%; width: 85%; margin: auto;">
                                ${symbolsArray[0]}${symbolsArray[1]}${symbolsArray[2]}<div></div>${symbolsArray[3]}<div></div>${symbolsArray[4]}${symbolsArray[5]}${symbolsArray[6]}
                            </div>`;
                        } else if (numValue === 8) {
                            centerContent = `<div style="display: flex; flex-direction: column; align-items: center; justify-content: space-between; height: 90%; width: 100%; padding: 2px 0;">
                                <div style="display: flex; justify-content: space-around; width: 85%;">${symbolsArray[0]}${symbolsArray[1]}${symbolsArray[2]}</div>
                                <div style="display: flex; justify-content: center; width: 85%; gap: 8px;">${symbolsArray[3]}${symbolsArray[4]}</div>
                                <div style="display: flex; justify-content: space-around; width: 85%;">${symbolsArray[5]}${symbolsArray[6]}${symbolsArray[7]}</div>
                            </div>`;
                        } else if (numValue === 9) {
                            centerContent = `<div style="display: grid; grid-template-columns: 1fr 1fr 1fr; grid-template-rows: 1fr 1fr 1fr; gap: 1px; align-items: center; justify-items: center; height: 85%; width: 85%; margin: auto;">${symbolsArray.join('')}</div>`;
                        } else if (numValue === 10) {
                            centerContent = `<div style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; grid-template-rows: 1fr 1fr 1fr; gap: 1px; align-items: center; justify-items: center; height: 85%; width: 90%; margin: auto;">
                                ${symbolsArray[0]}${symbolsArray[1]}${symbolsArray[2]}${symbolsArray[3]}${symbolsArray[4]}${symbolsArray[5]}${symbolsArray[6]}${symbolsArray[7]}${symbolsArray[8]}${symbolsArray[9]}
                            </div>`;
                        }
                    } else {
                        centerContent = `<div style="font-size: 32px; font-weight: bold;">${card.symbol}</div>`;
                    }
                }
                
                // Masquer les coins pour les figures (J, Q, K) pour un look plus classique
                const hideCornersForFigures = ['J', 'Q', 'K'].includes(card.rank);
                
                cardElement.innerHTML = `
                    <div style="position: absolute; top: 3px; left: 3px; font-size: 9px; font-weight: bold; line-height: 1; ${hideCornersForFigures ? 'opacity: 0.3;' : ''}">
                        <div>${card.rank}</div>
                        <div style="font-size: 8px;">${card.symbol}</div>
                    </div>
                    <div style="display: flex; align-items: center; justify-content: center; height: 100%; flex-direction: column;">
                        ${centerContent}
                    </div>
                    <div style="position: absolute; bottom: 3px; right: 3px; font-size: 9px; font-weight: bold; transform: rotate(180deg); line-height: 1; ${hideCornersForFigures ? 'opacity: 0.3;' : ''}">
                        <div>${card.rank}</div>
                        <div style="font-size: 8px;">${card.symbol}</div>
                    </div>
                `;
            } else {
                cardElement.className = 'card card-back';
                cardElement.innerHTML = '🃏';
            }
            
            cardElement.cardData = card;
            return cardElement;
        }

        // Gérer le clic sur une carte
        function handleCardClick(card, pileType, pileIndex) {
            if (!gameState.isPlaying) {
                showMessage('Commencez une nouvelle partie pour jouer!');
                return;
            }
            
            if (!card.faceUp && pileType === 'tableau') {
                // Retourner la carte si elle est face cachée
                card.faceUp = true;
                gameState.moves++;
                gameState.score += 5;
                addToHistory('flip', { card, pileType, pileIndex });
                renderBoard();
                updateDisplay();
                showMessage(`Carte ${card.rank}${card.symbol} retournée!`);
                return;
            }
            
            if (gameState.selectedCard) {
                // Tentative de déplacement
                if (gameState.selectedCard === card) {
                    // Désélectionner si on clique sur la même carte
                    clearSelection();
                    showMessage('Sélection annulée.');
                    return;
                }
                
                if (canMoveCard(gameState.selectedCard, card, pileType, pileIndex)) {
                    moveCard(gameState.selectedCard, gameState.selectedPile, card, pileType, pileIndex);
                    showMessage(`${gameState.selectedCard.rank}${gameState.selectedCard.symbol} déplacé sur ${card.rank}${card.symbol}!`);
                } else {
                    showMessage('Déplacement impossible! Vérifiez les règles.');
                }
                clearSelection();
            } else {
                // Sélectionner la carte
                if (card.faceUp && canSelectCard(card, pileType, pileIndex)) {
                    selectCard(card, pileType, pileIndex);
                    showMessage(`${card.rank}${card.symbol} sélectionné. Cliquez sur la destination.`);
                } else {
                    showMessage('Cette carte ne peut pas être sélectionnée.');
                }
            }
        }

        // Vérifier si une carte peut être sélectionnée
        function canSelectCard(card, pileType, pileIndex) {
            if (pileType === 'tableau') {
                const column = gameState.tableau[pileIndex];
                const cardIndex = column.indexOf(card);
                return cardIndex === column.length - 1 || isValidSequence(column, cardIndex);
            } else if (pileType === 'waste') {
                return gameState.waste[gameState.waste.length - 1] === card;
            } else if (pileType === 'foundation') {
                const suits = ['spades', 'hearts', 'diamonds', 'clubs'];
                const foundation = gameState.foundations[suits[pileIndex]];
                return foundation[foundation.length - 1] === card;
            }
            return false;
        }

        // Vérifier si les cartes forment une séquence valide
        function isValidSequence(column, startIndex) {
            for (let i = startIndex; i < column.length - 1; i++) {
                const current = column[i];
                const next = column[i + 1];
                if (current.color === next.color || current.value !== next.value + 1) {
                    return false;
                }
            }
            return true;
        }

        // Gérer le clic sur une colonne vide du tableau
        function handleTableauClick(columnIndex) {
            if (!gameState.isPlaying) {
                showMessage('Commencez une nouvelle partie pour jouer!');
                return;
            }
            
            if (gameState.selectedCard && gameState.selectedCard.rank === 'K') {
                moveCard(gameState.selectedCard, gameState.selectedPile, null, 'tableau', columnIndex);
                showMessage(`Roi ${gameState.selectedCard.symbol} placé sur colonne vide!`);
                clearSelection();
            } else if (gameState.selectedCard) {
                showMessage('Seuls les Rois peuvent être placés sur des colonnes vides!');
            }
        }

        // Sélectionner une carte
        function selectCard(card, pileType, pileIndex) {
            gameState.selectedCard = card;
            gameState.selectedPile = { type: pileType, index: pileIndex };
            
            document.querySelectorAll('.card').forEach(c => c.classList.remove('selected'));
            
            const cardElements = document.querySelectorAll('.card');
            cardElements.forEach(element => {
                if (element.cardData && 
                    element.cardData.rank === card.rank && 
                    element.cardData.suit === card.suit) {
                    element.classList.add('selected');
                }
            });
        }

        // Effacer la sélection
        function clearSelection() {
            gameState.selectedCard = null;
            gameState.selectedPile = null;
            document.querySelectorAll('.card').forEach(c => c.classList.remove('selected'));
        }

        // Vérifier si un déplacement est possible
        function canMoveCard(fromCard, toCard, toPileType, toPileIndex) {
            if (toPileType === 'foundation') {
                const suits = ['spades', 'hearts', 'diamonds', 'clubs'];
                return canMoveToFoundation(fromCard, suits[toPileIndex]);
            } else if (toPileType === 'tableau') {
                return canMoveToTableau(fromCard, toCard, toPileIndex);
            }
            return false;
        }

        // Vérifier si on peut déplacer vers une fondation
        function canMoveToFoundation(card, suit) {
            const foundation = gameState.foundations[suit];
            
            if (foundation.length === 0) {
                return card.rank === 'A';
            } else {
                const topCard = foundation[foundation.length - 1];
                return card.suit === suit && card.value === topCard.value + 1;
            }
        }

        // Vérifier si on peut déplacer vers le tableau
        function canMoveToTableau(card, targetCard, columnIndex) {
            const column = gameState.tableau[columnIndex];
            
            if (column.length === 0) {
                return card.rank === 'K';
            } else {
                return targetCard.color !== card.color && targetCard.value === card.value + 1;
            }
        }

        // Déplacer une carte ou une séquence
        function moveCard(fromCard, fromPile, toCard, toPileType, toPileIndex) {
            const cardsToMove = getCardsToMove(fromCard, fromPile);
            
            // Retirer les cartes de leur pile d'origine
            removeCardsFromPile(cardsToMove, fromPile);
            
            // Ajouter les cartes à leur nouvelle destination
            if (toPileType === 'foundation') {
                const suits = ['spades', 'hearts', 'diamonds', 'clubs'];
                gameState.foundations[suits[toPileIndex]].push(fromCard);
                gameState.score += 10;
            } else if (toPileType === 'tableau') {
                cardsToMove.forEach(card => {
                    gameState.tableau[toPileIndex].push(card);
                });
                gameState.score += cardsToMove.length * 5;
            }
            
            gameState.moves++;
            
            addToHistory('move', {
                cardsToMove, fromPile, toCard, toPileType, toPileIndex
            });
            
            renderBoard();
            updateDisplay();
            checkWinCondition();
        }

        // Obtenir les cartes à déplacer (carte seule ou séquence)
        function getCardsToMove(fromCard, fromPile) {
            if (fromPile.type === 'tableau') {
                const column = gameState.tableau[fromPile.index];
                const cardIndex = column.indexOf(fromCard);
                return column.slice(cardIndex);
            } else {
                return [fromCard];
            }
        }

        // Tirer du stock
        function drawFromStock() {
            if (!gameState.isPlaying) {
                showMessage('Commencez une nouvelle partie pour jouer!');
                return;
            }
            
            clearSelection();
            
            if (gameState.stock.length === 0) {
                if (gameState.waste.length === 0) {
                    showMessage('Plus de cartes disponibles!');
                    return;
                }
                
                // Remettre la défausse dans le stock
                gameState.stock = [...gameState.waste].reverse();
                gameState.waste = [];
                gameState.stock.forEach(card => card.faceUp = false);
                gameState.moves++;
                showMessage('Stock rechargé depuis la défausse!');
            } else {
                // Tirer des cartes selon la difficulté
                const drawCount = gameState.difficulty === 'easy' ? 1 : 3;
                const drawnCards = [];
                
                for (let i = 0; i < drawCount && gameState.stock.length > 0; i++) {
                    const card = gameState.stock.pop();
                    card.faceUp = true;
                    gameState.waste.push(card);
                    drawnCards.push(card);
                }
                
                gameState.moves++;
                
                if (drawnCards.length > 0) {
                    const lastCard = drawnCards[drawnCards.length - 1];
                    showMessage(`Carte tirée: ${lastCard.rank}${lastCard.symbol}`);
                }
            }
            
            renderBoard();
            updateDisplay();
        }

        // Gérer le clic sur une fondation
        function handleFoundationClick(element) {
            const suit = element.dataset.suit;
            const suits = ['spades', 'hearts', 'diamonds', 'clubs'];
            const suitIndex = suits.indexOf(suit);
            
            if (!gameState.isPlaying) {
                showMessage('Commencez une nouvelle partie pour jouer!');
                return;
            }
            
            if (gameState.selectedCard) {
                if (canMoveToFoundation(gameState.selectedCard, suit)) {
                    moveCard(gameState.selectedCard, gameState.selectedPile, null, 'foundation', suitIndex);
                    showMessage(`${gameState.selectedCard.rank}${gameState.selectedCard.symbol} placé sur la fondation!`);
                    clearSelection();
                } else {
                    showMessage('Cette carte ne peut pas être placée sur cette fondation!');
                }
            } else {
                // Sélectionner la carte du dessus de la fondation si elle existe
                const foundation = gameState.foundations[suit];
                if (foundation.length > 0) {
                    const topCard = foundation[foundation.length - 1];
                    selectCard(topCard, 'foundation', suitIndex);
                    showMessage(`${topCard.rank}${topCard.symbol} sélectionné depuis la fondation.`);
                }
            }
        }

        // Retirer des cartes de leur pile
        function removeCardsFromPile(cards, pile) {
            if (pile.type === 'tableau') {
                const column = gameState.tableau[pile.index];
                const firstCardIndex = column.indexOf(cards[0]);
                column.splice(firstCardIndex, cards.length);
                
                // Retourner la carte suivante si nécessaire
                if (column.length > 0 && !column[column.length - 1].faceUp) {
                    column[column.length - 1].faceUp = true;
                    gameState.score += 5;
                }
            } else if (pile.type === 'waste') {
                gameState.waste.pop();
            } else if (pile.type === 'foundation') {
                const suits = ['spades', 'hearts', 'diamonds', 'clubs'];
                gameState.foundations[suits[pile.index]].pop();
            }
        }

        // Ajouter à l'historique
        function addToHistory(action, data) {
            gameState.moveHistory.push({ action, data, timestamp: Date.now() });
        }

        // Annuler le dernier coup
        function undoMove() {
            if (gameState.moveHistory.length === 0) return;
            
            const lastMove = gameState.moveHistory.pop();
            
            gameState.moves = Math.max(0, gameState.moves - 1);
            renderBoard();
            updateDisplay();
        }

        // Obtenir un indice
        function getHint() {
            if (gameState.hintsAvailable <= 0) return;
            
            gameState.hintsUsed++;
            gameState.hintsAvailable--;
            
            const t = translations[gameState.currentLanguage];
            
            const hints = [
                t.hints.drawStock,
                t.hints.noMoves
            ];
            
            const randomHint = hints[Math.floor(Math.random() * hints.length)];
            showMessage(randomHint);
            
            const aiPanel = document.getElementById('aiPanel');
            aiPanel.classList.add('ai-thinking');
            setTimeout(() => {
                aiPanel.classList.remove('ai-thinking');
            }, 2000);
            
            updateDisplay();
        }

        // Auto-placement vers les fondations
        function autoMoveToFoundations() {
            if (!gameState.isPlaying) {
                showMessage('Commencez une nouvelle partie pour jouer!');
                return;
            }
            
            let moved = false;
            let movedCards = [];
            
            // Vérifier toutes les cartes visibles pour un placement automatique
            for (let col = 0; col < 7; col++) {
                const column = gameState.tableau[col];
                if (column.length > 0) {
                    const topCard = column[column.length - 1];
                    if (topCard.faceUp) {
                        for (let suit in gameState.foundations) {
                            if (canMoveToFoundation(topCard, suit)) {
                                gameState.foundations[suit].push(topCard);
                                column.pop();
                                
                                if (column.length > 0 && !column[column.length - 1].faceUp) {
                                    column[column.length - 1].faceUp = true;
                                    gameState.score += 5;
                                }
                                
                                gameState.moves++;
                                gameState.score += 10;
                                movedCards.push(`${topCard.rank}${topCard.symbol}`);
                                moved = true;
                                break;
                            }
                        }
                    }
                }
            }
            
            // Vérifier la défausse
            if (gameState.waste.length > 0) {
                const topCard = gameState.waste[gameState.waste.length - 1];
                for (let suit in gameState.foundations) {
                    if (canMoveToFoundation(topCard, suit)) {
                        gameState.foundations[suit].push(topCard);
                        gameState.waste.pop();
                        gameState.moves++;
                        gameState.score += 10;
                        movedCards.push(`${topCard.rank}${topCard.symbol}`);
                        moved = true;
                        break;
                    }
                }
            }
            
            if (moved) {
                showMessage(`Auto-placement: ${movedCards.join(', ')} déplacé(s)!`);
                renderBoard();
                updateDisplay();
                checkWinCondition();
            } else {
                showMessage('Aucun auto-placement possible pour le moment.');
            }
        }

        // Essayer de déplacer automatiquement une carte
        function tryAutoMoveCard(card, pileType, pileIndex) {
            if (!gameState.isPlaying) return;
            
            // Essayer de placer sur une fondation
            for (let suit in gameState.foundations) {
                if (canMoveToFoundation(card, suit)) {
                    const suits = ['spades', 'hearts', 'diamonds', 'clubs'];
                    const suitIndex = suits.indexOf(suit);
                    moveCard(card, { type: pileType, index: pileIndex }, null, 'foundation', suitIndex);
                    showMessage(`${card.rank}${card.symbol} auto-placé sur la fondation!`);
                    return;
                }
            }
            
            // Essayer de placer sur le tableau
            for (let col = 0; col < 7; col++) {
                const column = gameState.tableau[col];
                if (column.length === 0 && card.rank === 'K') {
                    moveCard(card, { type: pileType, index: pileIndex }, null, 'tableau', col);
                    showMessage(`${card.rank}${card.symbol} auto-placé sur colonne vide!`);
                    return;
                } else if (column.length > 0) {
                    const topCard = column[column.length - 1];
                    if (canMoveToTableau(card, topCard, col)) {
                        moveCard(card, { type: pileType, index: pileIndex }, topCard, 'tableau', col);
                        showMessage(`${card.rank}${card.symbol} auto-placé sur ${topCard.rank}${topCard.symbol}!`);
                        return;
                    }
                }
            }
            
            showMessage(`Aucun placement automatique possible pour ${card.rank}${card.symbol}.`);
        }

        // Mélanger la défausse
        function shuffleWaste() {
            if (gameState.waste.length > 0) {
                gameState.waste = shuffleDeck(gameState.waste);
                renderBoard();
                showMessage('Défausse mélangée!');
            }
        }

        // Vérifier la condition de victoire
        function checkWinCondition() {
            const totalFoundationCards = Object.values(gameState.foundations)
                .reduce((sum, pile) => sum + pile.length, 0);
            
            if (totalFoundationCards === 52) {
                winGame();
            }
        }

        // Gagner le jeu
        function winGame() {
            clearInterval(gameState.timer);
            gameState.isPlaying = false;
            
            // Mettre à jour les meilleurs scores
            const currentTime = gameState.gameTime;
            if (!gameState.bestScores.bestTime || currentTime < gameState.bestScores.bestTime) {
                gameState.bestScores.bestTime = currentTime;
            }
            if (gameState.score > gameState.bestScores.bestScore) {
                gameState.bestScores.bestScore = gameState.score;
            }
            gameState.bestScores.gamesWon++;
            
            localStorage.setItem('solitaireFusionBestScores', JSON.stringify(gameState.bestScores));
            
            const t = translations[gameState.currentLanguage];
            showMessage(t.gameWon);
            
            document.getElementById('celebrateBtn').style.display = 'block';
            updateDisplay();
        }

        // Célébrer la victoire
        function celebrateWin() {
            const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57'];
            
            for (let i = 0; i < 50; i++) {
                setTimeout(() => {
                    const confetti = document.createElement('div');
                    confetti.style.position = 'fixed';
                    confetti.style.left = Math.random() * 100 + 'vw';
                    confetti.style.top = '-10px';
                    confetti.style.width = '10px';
                    confetti.style.height = '10px';
                    confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                    confetti.style.borderRadius = '50%';
                    confetti.style.zIndex = '9999';
                    confetti.style.animation = 'fall 3s linear forwards';
                    
                    document.body.appendChild(confetti);
                    
                    setTimeout(() => {
                        confetti.remove();
                    }, 3000);
                }, i * 100);
            }
        }

        // Réinitialiser le jeu
        function resetGame() {
            if (gameState.timer) clearInterval(gameState.timer);
            gameState.isPlaying = false;
            gameState.selectedCard = null;
            gameState.selectedPile = null;
            
            document.getElementById('celebrateBtn').style.display = 'none';
            
            const t = translations[gameState.currentLanguage];
            showMessage(t.welcomeMessage);
            
            updateDisplay();
        }

        // Mettre à jour le timer
        function updateTimer() {
            if (gameState.isPlaying) {
                gameState.gameTime = Math.floor((Date.now() - gameState.startTime) / 1000);
                const minutes = Math.floor(gameState.gameTime / 60);
                const seconds = gameState.gameTime % 60;
                document.getElementById('timeValue').textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
        }

        // Mettre à jour l'affichage
        function updateDisplay() {
            document.getElementById('scoreValue').textContent = gameState.score;
            document.getElementById('movesValue').textContent = gameState.moves;
            
            const cardsLeft = gameState.stock.length + gameState.waste.length + 
                gameState.tableau.reduce((sum, col) => sum + col.length, 0);
            document.getElementById('cardsLeftValue').textContent = cardsLeft;
            
            const foundationsComplete = Object.values(gameState.foundations)
                .filter(pile => pile.length === 13).length;
            document.getElementById('foundationsValue').textContent = `${foundationsComplete}/4`;
            
            const completion = Math.floor((Object.values(gameState.foundations)
                .reduce((sum, pile) => sum + pile.length, 0) / 52) * 100);
            document.getElementById('completionValue').textContent = `${completion}%`;
            
            document.getElementById('hintsUsedValue').textContent = gameState.hintsUsed;
            document.getElementById('hintsAvailableValue').textContent = gameState.hintsAvailable;
            
            // Meilleurs scores
            const bestTime = gameState.bestScores.bestTime;
            if (bestTime) {
                const minutes = Math.floor(bestTime / 60);
                const seconds = bestTime % 60;
                document.getElementById('bestTimeValue').textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
            document.getElementById('bestScoreValue').textContent = gameState.bestScores.bestScore;
            document.getElementById('gamesWonValue').textContent = gameState.bestScores.gamesWon;
            
            // Activer/désactiver les boutons
            document.getElementById('undoBtn').disabled = gameState.moveHistory.length === 0;
            document.getElementById('hintBtn').disabled = gameState.hintsAvailable <= 0;
            document.getElementById('shuffleBtn').disabled = gameState.waste.length === 0;
        }

        // Afficher un message
        function showMessage(message) {
            const messageElement = document.getElementById('gameMessage');
            messageElement.innerHTML = `<span>${message}</span>`;
        }

        // Afficher les règles
        function showRules() {
            const t = translations[gameState.currentLanguage];
            alert(`Règles du Solitaire Fusion:

1. Déplacez toutes les cartes vers les fondations
2. Les fondations se construisent par couleur de A à K
3. Dans le tableau, alternez les couleurs en ordre décroissant
4. Seuls les Rois peuvent être placés sur des colonnes vides
5. Utilisez le stock pour révéler de nouvelles cartes
6. Gagnez en complétant les 4 fondations!`);
        }

        // Initialisation
        document.addEventListener('DOMContentLoaded', function() {
            createQuantumParticles();
            updateLanguageInterface();
            updateDisplay();
            setDifficulty('easy');
        });
    </script><script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'9862d4071073e1d5',t:'MTc1OTA1ODE4Mi4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script>
  </div>
</div>

<!-- <!-- Jeu 15 - Mystic Forest Quest -->
            <!-- Jeu 15 - Hyper Sudoku -->
<div class="game-card" onclick="launchGame15()" data-category="strategie">
  <div class="game-header">
    <div class="game-number">15</div>
    <div class="game-status">🧩 STRATÉGIE</div>
  </div>
  <div class="game-icon">🧠</div>
  <h3>Neurosynth Explorer</h3>
  <p>Exploration cognitive assistée par IA et cartographie neuronale</p>
  <div class="game-tags"><span class="tag">🧠 Neurosciences</span>
    <span class="tag">🔬 Exploration</span>
    <span class="tag">🤖 IA</span></div>
  <div class="game-stats"><span>⭐ 4.9</span>
    <span>👥 12.4K</span></div>
</div> 

<!-- Jeu 16 - Enigma Hunter -->
<div class="game-card" data-category="reflexion mystique" onclick="launchGame16()">
    <div class="game-header">
        <div class="game-number">16</div>
        <div class="game-status">🕵️‍♂️ ENIGME</div>
    </div>
    <div class="game-icon">🔍</div>
    <h3>Enigma Hunter</h3>
    <p>Résolvez des énigmes cachées avec l’IA assistante</p>
    <div class="game-tags">
        <span class="tag">🧩 Énigme</span>
        <span class="tag">🔮 Mystique</span>
        <span class="tag">⚡ Réflexion</span>
    </div>
</div>
            

            <!-- Jeu 17 - Neural Racing -->
            <div class="game-card" data-category="arcade" onclick="launchGame17()">
                <div class="game-header">
                    <div class="game-number">17</div>
                </div>
                <div class="game-icon">🏎️</div>
                <h3>Neural Racing</h3>
                <p>Course futuriste avec IA pilote et circuits adaptatifs</p>
                <div class="game-tags">
                    <span class="tag">🏎️ Course</span>
                    <span class="tag">🧠 Neural</span>
                    <span class="tag">🛣️ Adaptatif</span>
                </div>
                <div class="game-stats">
                    <span>⭐ 4.7</span>
                    <span>👥 9.8K</span>
                </div>
            </div>

            <!-- Jeu 18 - Cyber Shooter -->
            <div class="game-card" data-category="arcade" onclick="launchGame18()">
                <div class="game-header">
                    <div class="game-number">18</div>
                </div>
                <div class="game-icon">🎯</div>
                <h3>Cyber Shooter</h3>
                <p>Tir spatial avec IA ennemie et armes quantiques</p>
                <div class="game-tags">
                    <span class="tag">🎯 Tir</span>
                    <span class="tag">🌐 Cyber</span>
                    <span class="tag">⚛️ Armes</span>
                </div>
                <div class="game-stats">
                    <span>⭐ 4.6</span>
                    <span>👥 11.5K</span>
                </div>
            </div>

            <!-- Jeu 19 - Quantum Dots -->
            <div class="game-card" data-category="reflexion" onclick="launchGame19()">
                <div class="game-header">
                    <div class="game-number">19</div>
                </div>
                <div class="game-icon">⚫</div>
                <h3>Quantum Dots</h3>
                <p>Connexion de points quantiques avec IA prédictive</p>
                <div class="game-tags">
                    <span class="tag">⚫ Points</span>
                    <span class="tag">⚛️ Quantique</span>
                    <span class="tag">🔮 Prédictif</span>
                </div>
                <div class="game-stats">
                    <span>⭐ 4.3</span>
                    <span>👥 5.7K</span>
                </div>
            </div>

            <!-- Jeu 20 - Neural Rhythm -->
            <div class="game-card" data-category="arcade memory" onclick="launchGame20()">
                <div class="game-header">
                    <div class="game-number">20</div>
                </div>
                <div class="game-icon">🎵</div>
                <h3>Neural Rhythm</h3>
                <p>Jeu de rythme avec IA musicale et génération adaptative</p>
                <div class="game-tags">
                    <span class="tag">🎵 Rythme</span>
                    <span class="tag">🧠 Neural</span>
                    <span class="tag">🎼 Musical</span>
                </div>
                <div class="game-stats">
                    <span>⭐ 4.8</span>
                    <span>👥 8.6K</span>
                </div>
            </div>

            <!-- Jeu 21 - Cyber Pinball -->
            <div class="game-card" data-category="arcade" onclick="launchGame21()">
                <div class="game-header">
                    <div class="game-number">21</div>
                </div>
                <div class="game-icon">⚪</div>
                <h3>Cyber Pinball</h3>
                <p>Flipper futuriste avec IA et tables quantiques</p>
                <div class="game-tags">
                    <span class="tag">⚪ Flipper</span>
                    <span class="tag">🌐 Cyber</span>
                    <span class="tag">⚛️ Tables</span>
                </div>
                <div class="game-stats">
                    <span>⭐ 4.4</span>
                    <span>👥 7.2K</span>
                </div>
            </div>

            <!-- Jeu 22 - Quantum Pipes -->
            <div class="game-card" data-category="reflexion" onclick="launchGame22()">
                <div class="game-header">
                    <div class="game-number">22</div>
                </div>
                <div class="game-icon">🔧</div>
                <h3>Quantum Pipes</h3>
                <p>Connexion de tuyaux quantiques avec IA logique</p>
                <div class="game-tags">
                    <span class="tag">🔧 Tuyaux</span>
                    <span class="tag">⚛️ Quantique</span>
                    <span class="tag">🧠 Logique</span>
                </div>
                <div class="game-stats">
                    <span>⭐ 4.5</span>
                    <span>👥 6.8K</span>
                </div>
            </div>

            <!-- Jeu 23 - Neural Slots -->
            <div class="game-card" data-category="arcade" onclick="launchGame23()">
                <div class="game-header">
                    <div class="game-number">23</div>
                </div>
                <div class="game-icon">🎰</div>
                <h3>Neural Slots</h3>
                <p>Machine à sous intelligente avec IA et bonus adaptatifs</p>
                <div class="game-tags">
                    <span class="tag">🎰 Slots</span>
                    <span class="tag">🧠 Neural</span>
                    <span class="tag">🎁 Bonus</span>
                </div>
                <div class="game-stats">
                    <span>⭐ 4.2</span>
                    <span>👥 9.4K</span>
                </div>
            </div>

            <!-- Jeu 24 - Cyber Darts -->
            <div class="game-card" data-category="arcade" onclick="launchGame24()">
                <div class="game-header">
                    <div class="game-number">24</div>
                </div>
                <div class="game-icon">🎯</div>
                <h3>Cyber Darts</h3>
                <p>Fléchettes futuristes avec IA et cibles quantiques</p>
                <div class="game-tags">
                    <span class="tag">🎯 Fléchettes</span>
                    <span class="tag">🌐 Cyber</span>
                    <span class="tag">⚛️ Cibles</span>
                </div>
                <div class="game-stats">
                    <span>⭐ 4.3</span>
                    <span>👥 5.9K</span>
                </div>
            </div>

            <!-- Jeu 25 - Quantum Bubbles -->
            <div class="game-card" data-category="arcade reflexion" onclick="launchGame25()">
                <div class="game-header">
                    <div class="game-number">25</div>
                </div>
                <div class="game-icon">🫧</div>
                <h3>Quantum Bubbles</h3>
                <p>Bulles quantiques avec IA et physique avancée</p>
                <div class="game-tags">
                    <span class="tag">🫧 Bulles</span>
                    <span class="tag">⚛️ Quantique</span>
                    <span class="tag">⚡ Physique</span>
                </div>
                <div class="game-stats">
                    <span>⭐ 4.4</span>
                    <span>👥 8.1K</span>
                </div>
            </div>

<script>
function launchGame26() {
    document.getElementById('game26Overlay').style.display = 'block';
}
function closeGame26() {
    document.getElementById('game26Overlay').style.display = 'none';
}
document.addEventListener('keydown', function(e) {
    if (e.key === "Escape") {
        closeGame26();
    }
});
</script>
<!-- Overlay du Jeu 26 -->
<div id="game26Overlay" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:#000; z-index:10000; overflow:auto;">
    <button onclick="closeGame26()" style="position:absolute; top:20px; right:20px; background:red; color:#fff; border:none; padding:10px; font-size:20px; cursor:pointer; z-index:10001;">✖</button>
    <div id="game26Container" style="width:100%; height:100%; overflow:auto; background:#000; color:#fff;">
        <iframe src="jeux26.html" style="width:100vw; height:100vh; border:none; background:#000;" allowfullscreen></iframe>
    </div>
</div>
            <!-- Jeu 26 - Neural Dice -->
            <div class="game-card" data-category="societe" onclick="launchGame26()">
                <div class="game-header">
                    <div class="game-number">26</div>
                </div>
                <div class="game-icon">🎲</div>
                <h3>Neural Dice</h3>
                <p>Jeux de dés intelligents avec IA probabiliste</p>
                <div class="game-tags">
                    <span class="tag">🎲 Dés</span>
                    <span class="tag">🧠 Neural</span>
                    <span class="tag">📊 Probabilité</span>
                </div>
                <div class="game-stats">
                    <span>⭐ 4.1</span>
                    <span>👥 6.3K</span>
                </div>
            </div>

            <!-- Jeu 27 - Cyber Pool -->
            <div class="game-card" data-category="societe arcade" onclick="launchGame27()">
                <div class="game-header">
                    <div class="game-number">27</div>
                </div>
                <div class="game-icon">🎱</div>
                <h3>Cyber Pool</h3>
                <p>Billard futuriste avec IA et physique quantique</p>
                <div class="game-tags">
                    <span class="tag">🎱 Billard</span>
                    <span class="tag">🌐 Cyber</span>
                    <span class="tag">⚛️ Physique</span>
                </div>
                <div class="game-stats">
                    <span>⭐ 4.6</span>
                    <span>👥 7.7K</span>
                </div>
            </div>

            <!-- Jeu 28 - Quantum Tiles -->
            <div class="game-card" data-category="reflexion" onclick="launchGame28()">
                <div class="game-header">
                    <div class="game-number">28</div>
                </div>
                <div class="game-icon">🔲</div>
                <h3>Quantum Tiles</h3>
                <p>Tuiles quantiques avec IA et patterns adaptatifs</p>
                <div class="game-tags">
                    <span class="tag">🔲 Tuiles</span>
                    <span class="tag">⚛️ Quantique</span>
                    <span class="tag">🎨 Patterns</span>
                </div>
                <div class="game-stats">
                    <span>⭐ 4.3</span>
                    <span>👥 5.4K</span>
                </div>
            </div>

            <!-- Jeu 29 - Neural Trivia -->
            <div class="game-card" data-category="memory reflexion" onclick="launchGame29()">
                <div class="game-header">
                    <div class="game-number">29</div>
                </div>
                <div class="game-icon">❓</div>
                <h3>Neural Trivia</h3>
                <p>Quiz intelligent avec IA et questions adaptatives</p>
                <div class="game-tags">
                    <span class="tag">❓ Quiz</span>
                    <span class="tag">🧠 Neural</span>
                    <span class="tag">📚 Adaptatif</span>
                </div>
                <div class="game-stats">
                    <span>⭐ 4.7</span>
                    <span>👥 10.1K</span>
                </div>
            </div>

            <!-- Jeu 30 - Cyber Asteroids -->
            <div class="game-card" data-category="arcade" onclick="launchGame30()">
                <div class="game-header">
                    <div class="game-number">30</div>
                </div>
                <div class="game-icon">☄️</div>
                <h3>Cyber Asteroids</h3>
                <p>Astéroïdes futuristes avec IA et armes quantiques</p>
                <div class="game-tags">
                    <span class="tag">☄️ Espace</span>
                    <span class="tag">🌐 Cyber</span>
                    <span class="tag">⚛️ Armes</span>
                </div>
                <div class="game-stats">
                    <span>⭐ 4.5</span>
                    <span>👥 8.9K</span>
                </div>
            </div>

            <!-- Jeu 31 - Quantum Crystals -->
            <div class="game-card" data-category="mystique" onclick="launchGame31()">
                <div class="game-header">
                    <div class="game-number">31</div>
                </div>
                <div class="game-icon">💎</div>
                <h3>Quantum Crystals</h3>
                <p>Cristaux quantiques avec IA et résonance harmonique</p>
                <div class="game-tags">
                    <span class="tag">💎 Cristaux</span>
                    <span class="tag">⚛️ Quantique</span>
                    <span class="tag">🎵 Harmonique</span>
                </div>
                <div class="game-stats">
                    <span>⭐ 4.8</span>
                    <span>👥 6.7K</span>
                </div>
            </div>

            <!-- Jeu 32 - Neural Infinity -->
            <div class="game-card featured" data-category="science mystique" onclick="launchGame32()">
                <div class="game-header">
                    <div class="game-number">32</div>
                    <div class="game-status">🌟 ULTIME</div>
                </div>
                <div class="game-icon">∞</div>
                <h3>Neural Infinity</h3>
                <p>L'expérience ultime : IA générative infinie et évolutive</p>
                <div class="game-tags">
                    <span class="tag">∞ Infini</span>
                    <span class="tag">🧠 Neural</span>
                    <span class="tag">🌟 Ultime</span>
                </div>
                <div class="game-stats">
                    <span>⭐ 5.0</span>
                    <span>👥 15.8K</span>
                </div>
            </div>

            <!-- Jeu 33 - Algorithme Visuel -->
            <div class="game-card featured" data-category="science" onclick="launchGame33()">
                <div class="game-header">
                    <div class="game-number">33</div>
                    <div class="game-status">🔬 NOUVEAU</div>
                </div>
                <div class="game-icon">🔬</div>
                <h3>Algorithme Visuel</h3>
                <p>Visualisation interactive d'algorithmes avec IA pédagogique</p>
                <div class="game-tags">
                    <span class="tag">🔬 Algorithme</span>
                    <span class="tag">👁️ Visuel</span>
                    <span class="tag">📚 Éducatif</span>
                </div>
                <div class="game-stats">
                    <span>⭐ 4.9</span>
                    <span>👥 7.8K</span>
                </div>
            </div>


            <!-- Jeu 34 - Physique Quantique -->
            <div class="game-card featured" data-category="science" onclick="launchGame34()">
                <div class="game-header">
                    <div class="game-number">34</div>
                    <div class="game-status">⚛️ SCIENCE</div>
                </div>
                <div class="game-icon">⚛️</div>
                <h3>Physique Quantique</h3>
                <p>Simulation quantique interactive avec IA scientifique avancée</p>
                <div class="game-tags">
                    <span class="tag">⚛️ Quantique</span>
                    <span class="tag">🔬 Physique</span>
                    <span class="tag">🧪 Simulation</span>
                </div>
                <div class="game-stats">
                    <span>⭐ 5.0</span>
                    <span>👥 9.2K</span>
                </div>
            </div>

            <!-- Jeu 35 - Géométrie Sacrée -->
            <div class="game-card featured" data-category="mystique" onclick="launchGame35()">
                <div class="game-header">
                    <div class="game-number">35</div>
                    <div class="game-status">🔮 MYSTIQUE</div>
                </div>
                <div class="game-icon">🔮</div>
                <h3>Géométrie Sacrée</h3>
                <p>Exploration des formes sacrées avec IA spirituelle et harmonies</p>
                <div class="game-tags">
                    <span class="tag">🔮 Sacré</span>
                    <span class="tag">📐 Géométrie</span>
                    <span class="tag">🎵 Harmonie</span>
                </div>
                <div class="game-stats">
                    <span>⭐ 4.8</span>
                    <span>👥 6.5K</span>
                </div>
            </div>
                <script>
                function launchGame35() {
                    document.getElementById('game35Overlay').style.display = 'block';
                }
                function closeGame35() {
                    document.getElementById('game35Overlay').style.display = 'none';
                }
                document.addEventListener('keydown', function(e) {
                    if (e.key === "Escape") {
                        closeGame35();
                    }
                });
                </script>
                <!-- Overlay du Jeu 35 -->
                <div id="game35Overlay" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:#000; z-index:10000; overflow:auto;">
                    <button onclick="closeGame35()" style="position:absolute; top:20px; right:20px; background:red; color:#fff; border:none; padding:10px; font-size:20px; cursor:pointer; z-index:10001;">✖</button>
                    <div id="game35Container" style="width:100%; height:100%; overflow:auto; background:#000; color:#fff;">
                        <iframe src="jeux35.html" style="width:100vw; height:100vh; border:none; background:#000;" allowfullscreen></iframe>
                    </div>
                </div>

            <!-- Jeu 36 - Conscience Artificielle -->
            <div class="game-card featured" data-category="science mystique" onclick="launchGame36()">
                <div class="game-header">
                    <div class="game-number">36</div>
                    <div class="game-status">🤖 RÉVOLUTION</div>
                </div>
                <div class="game-icon">🤖</div>
                <h3>Conscience Artificielle</h3>
                <p>Dialogue philosophique avec IA consciente et réflexion existentielle</p>
                <div class="game-tags">
                    <span class="tag">🤖 Conscience</span>
                    <span class="tag">🧠 Philosophie</span>
                    <span class="tag">💭 Existentiel</span>
                </div>
                <div class="game-stats">
                    <span>⭐ 5.0</span>
                    <span>👥 11.3K</span>
                </div>
            </div>

                <script>
                function launchGame36() {
                    document.getElementById('game36Overlay').style.display = 'block';
                }
                function closeGame36() {
                    document.getElementById('game36Overlay').style.display = 'none';
                }
                document.addEventListener('keydown', function(e) {
                    if (e.key === "Escape") {
                        closeGame36();
                    }
                });
                </script>
                <!-- Overlay du Jeu 36 -->
                <div id="game36Overlay" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:#000; z-index:10000; overflow:auto;">
                    <button onclick="closeGame36()" style="position:absolute; top:20px; right:20px; background:red; color:#fff; border:none; padding:10px; font-size:20px; cursor:pointer; z-index:10001;">✖</button>
                    <div id="game36Container" style="width:100%; height:100%; overflow:auto; background:#000; color:#fff;">
                        <iframe src="jeux36.html" style="width:100vw; height:100vh; border:none; background:#000;" allowfullscreen></iframe>
                    </div>
                </div>
        </div>
    </div>

    <script>
        // Variables globales
        let currentLanguage = 'fr';

        // Créer les particules d'arrière-plan
        function createParticles() {
            const particlesContainer = document.querySelector('.particles');
            for (let i = 0; i < 50; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.animationDelay = Math.random() * 6 + 's';
                particle.style.animationDuration = (Math.random() * 3 + 3) + 's';
                particlesContainer.appendChild(particle);
            }
        }

        // Gestion des langues principales
        function toggleLanguageMenu() {
            const menu = document.getElementById('languageMenu');
            menu.classList.toggle('active');
        }

        function changeLanguage(lang) {
            currentLanguage = lang;
            const langMap = {
                'fr': 'FR',
                'en': 'EN',
                'ar': 'AR',
                'es': 'ES',
                'zh': 'ZH'
            };
            document.getElementById('currentLang').textContent = langMap[lang];
            document.getElementById('languageMenu').classList.remove('active');
            
            // Traduire tous les éléments de l'interface
            translateInterface(lang);
            
            // Traduire aussi les descriptions et noms des jeux
            translateGameCards(lang);
            
            // Forcer la mise à jour de l'affichage
            setTimeout(() => {
                translateGameCards(lang);
            }, 100);
        }

        function translateInterface(lang) {
            const translations = {
                fr: {
                    rankings: '🏆 Classements',
                    settings: '⚙️ Paramètres',
                    profile: '👤 Profil',
                    heroTitle: '🎮 Découvrez nos 36 Jeux Intelligents',
                    heroDesc: 'Entraînez votre cerveau avec notre collection complète de jeux adaptatifs alimentés par l\'IA',
                    allGames: '🎮 Tous les Jeux',
                    memory: '🧠 Mémoire',
                    reflexion: '🧩 Réflexion',
                    societe: '🎲 Société',
                    arcade: '🕹️ Arcade',
                    science: '🔬 Science',
                    mystique: '🔮 Mystique'
                },
                en: {
                    rankings: '🏆 Rankings',
                    settings: '⚙️ Settings',
                    profile: '👤 Profile',
                    heroTitle: '🎮 Discover our 36 Smart Games',
                    heroDesc: 'Train your brain with our complete collection of AI-powered adaptive games',
                    allGames: '🎮 All Games',
                    memory: '🧠 Memory',
                    reflexion: '🧩 Puzzle',
                    societe: '🎲 Board Games',
                    arcade: '🕹️ Arcade',
                    science: '🔬 Science',
                    mystique: '🔮 Mystical'
                },
                ar: {
                    rankings: '🏆 التصنيفات',
                    settings: '⚙️ الإعدادات',
                    profile: '👤 الملف الشخصي',
                    heroTitle: '🎮 اكتشف ألعابنا الذكية الـ36',
                    heroDesc: 'درب عقلك مع مجموعتنا الكاملة من الألعاب التكيفية المدعومة بالذكاء الاصطناعي',
                    allGames: '🎮 جميع الألعاب',
                    memory: '🧠 الذاكرة',
                    reflexion: '🧩 التفكير',
                    societe: '🎲 ألعاب المجتمع',
                    arcade: '🕹️ أركيد',
                    science: '🔬 العلوم',
                    mystique: '🔮 الغموض'
                },
                es: {
                    rankings: '🏆 Clasificaciones',
                    settings: '⚙️ Configuración',
                    profile: '👤 Perfil',
                    heroTitle: '🎮 Descubre nuestros 36 Juegos Inteligentes',
                    heroDesc: 'Entrena tu cerebro con nuestra colección completa de juegos adaptativos impulsados por IA',
                    allGames: '🎮 Todos los Juegos',
                    memory: '🧠 Memoria',
                    reflexion: '🧩 Reflexión',
                    societe: '🎲 Sociedad',
                    arcade: '🕹️ Arcade',
                    science: '🔬 Ciencia',
                    mystique: '🔮 Místico'
                },
                zh: {
                    rankings: '🏆 排行榜',
                    settings: '⚙️ 设置',
                    profile: '👤 个人资料',
                    heroTitle: '🎮 发现我们的36款智能游戏',
                    heroDesc: '用我们完整的AI驱动自适应游戏集合训练您的大脑',
                    allGames: '🎮 所有游戏',
                    memory: '🧠 记忆',
                    reflexion: '🧩 思考',
                    societe: '🎲 社交',
                    arcade: '🕹️ 街机',
                    science: '🔬 科学',
                    mystique: '🔮 神秘'
                }
            };

            const t = translations[lang] || translations.fr;

            // Traduire les boutons de navigation
            const rankingsBtn = document.querySelector('.rankings-btn');
            const settingsBtn = document.querySelector('.settings-btn');
            const profileBtn = document.querySelector('.profile-btn');
            
            if (rankingsBtn) rankingsBtn.textContent = t.rankings;
            if (settingsBtn) settingsBtn.textContent = t.settings;
            if (profileBtn) profileBtn.textContent = t.profile;

            // Traduire le titre et la description
            const heroTitle = document.querySelector('.hero-section h2');
            const heroDesc = document.querySelector('.hero-section p');
            
            if (heroTitle) heroTitle.textContent = t.heroTitle;
            if (heroDesc) heroDesc.textContent = t.heroDesc;

            // Traduire les boutons de catégories
            const categoryButtons = document.querySelectorAll('.category-btn');
            const categoryTexts = [t.allGames, t.memory, t.reflexion, t.societe, t.arcade, t.science, t.mystique];
            
            categoryButtons.forEach((btn, index) => {
                if (categoryTexts[index]) {
                    btn.textContent = categoryTexts[index];
                }
            });
        }

        // Fonction pour traduire les cartes de jeux
        function translateGameCards(lang) {
            // Sauvegarder les textes originaux français si pas encore fait
            if (!window.originalGameTexts) {
                window.originalGameTexts = {
                    titles: [],
                    descriptions: [],
                    statuses: [],
                    tags: []
                };
                
                document.querySelectorAll('.game-card h3').forEach(title => {
                    window.originalGameTexts.titles.push(title.textContent);
                });
                
                document.querySelectorAll('.game-card p').forEach(desc => {
                    window.originalGameTexts.descriptions.push(desc.textContent);
                });
                
                document.querySelectorAll('.game-status').forEach(status => {
                    window.originalGameTexts.statuses.push(status.textContent);
                });
                
                document.querySelectorAll('.tag').forEach(tag => {
                    window.originalGameTexts.tags.push(tag.textContent);
                });
            }
            
            const gameTranslations = {
                fr: {
                    games: {
                        'Quantum Tetris 2077': 'Quantum Tetris 2077',
                        'Memory Quantique': 'Memory Quantique',
                        'Neural Puzzle Master': 'Neural Puzzle Master',
                        'Quantum Chess': 'Quantum Chess',
                        'Jeux de Dames': 'Jeux de Dames',
                        'Pac-Man': 'Pac-Man',
                        'Simon Says': 'Simon Says',
                        'Speed Challenge': 'Speed Challenge',
                        'Cyber Checker': 'Cyber Checker',
                        'Demo Playground': 'Demo Playground',
                        'Quantum Monopoly': 'Quantum Monopoly',
                        'Neural Poker': 'Neural Poker',
                        'Blackjack Quantum': 'Blackjack Quantum',
                        'Solitaire Fusion': 'Solitaire Fusion',
                        'Mystic Forest Quest': 'Mystic Forest Quest',
                        'Enigma Hunter': 'Enigma Hunter',
                        'Neural Racing': 'Neural Racing',
                        'Cyber Shooter': 'Cyber Shooter',
                        'Quantum Dots': 'Quantum Dots',
                        'Neural Rhythm': 'Neural Rhythm',
                        'Cyber Pinball': 'Cyber Pinball',
                        'Quantum Pipes': 'Quantum Pipes',
                        'Neural Slots': 'Neural Slots',
                        'Cyber Darts': 'Cyber Darts',
                        'Quantum Bubbles': 'Quantum Bubbles',
                        'Neural Dice': 'Neural Dice',
                        'Cyber Pool': 'Cyber Pool',
                        'Quantum Tiles': 'Quantum Tiles',
                        'Neural Trivia': 'Neural Trivia',
                        'Cyber Asteroids': 'Cyber Asteroids',
                        'Quantum Crystals': 'Quantum Crystals',
                        'Neural Infinity': 'Neural Infinity',
                        'Algorithme Visuel': 'Algorithme Visuel',
                        'Physique Quantique': 'Physique Quantique',
                        'Géométrie Sacrée': 'Géométrie Sacrée',
                        'Conscience Artificielle': 'Conscience Artificielle'
                    },
                    descriptions: {
                        'Tetris futuriste avec IA quantique et effets spectaculaires': 'Tetris futuriste avec IA quantique et effets spectaculaires',
                        'Entraînez votre mémoire avec l\'IA neurale adaptative': 'Entraînez votre mémoire avec l\'IA neurale adaptative',
                        'Puzzles adaptatifs avec IA avancée et défis évolutifs': 'Puzzles adaptatifs avec IA avancée et défis évolutifs',
                        'Échecs quantiques multidimensionnels avec IA maître': 'Échecs quantiques multidimensionnels avec IA maître',
                        'Dames classiques avec IA stratégique et variantes mondiales': 'Dames classiques avec IA stratégique et variantes mondiales',
                        'Le légendaire Pac-Man avec IA fantômes et labyrinthes infinis': 'Le légendaire Pac-Man avec IA fantômes et labyrinthes infinis',
                        'Mémoire séquentielle avec IA adaptative et défis sonores': 'Mémoire séquentielle avec IA adaptative et défis sonores',
                        'Défis de vitesse avec IA chronométrée et réflexes quantiques': 'Défis de vitesse avec IA chronométrée et réflexes quantiques',
                        'Vérificateur cyber avec IA de détection et sécurité quantique': 'Vérificateur cyber avec IA de détection et sécurité quantique',
                        'Terrain de jeu interactif avec IA créative et expériences libres': 'Terrain de jeu interactif avec IA créative et expériences libres',
                        'Monopoly quantique avec IA économique et propriétés multidimensionnelles': 'Monopoly quantique avec IA économique et propriétés multidimensionnelles',
                        'Poker intelligent avec IA psychologique et bluff quantique': 'Poker intelligent avec IA psychologique et bluff quantique',
                        'Blackjack quantique avec IA croupier et probabilités avancées': 'Blackjack quantique avec IA croupier et probabilités avancées',
                        'Solitaire fusionné avec IA assistante et variantes infinies': 'Solitaire fusionné avec IA assistante et variantes infinies',
                        'Quête mystique avec IA narrative et forêt enchantée évolutive': 'Quête mystique avec IA narrative et forêt enchantée évolutive',
                        'Chasseur d\'énigmes avec IA détective et mystères génératifs': 'Chasseur d\'énigmes avec IA détective et mystères génératifs',
                        'Course futuriste avec IA pilote et circuits adaptatifs': 'Course futuriste avec IA pilote et circuits adaptatifs',
                        'Tir spatial avec IA ennemie et armes quantiques': 'Tir spatial avec IA ennemie et armes quantiques',
                        'Connexion de points quantiques avec IA prédictive': 'Connexion de points quantiques avec IA prédictive',
                        'Jeu de rythme avec IA musicale et génération adaptative': 'Jeu de rythme avec IA musicale et génération adaptative',
                        'Flipper futuriste avec IA et tables quantiques': 'Flipper futuriste avec IA et tables quantiques',
                        'Connexion de tuyaux quantiques avec IA logique': 'Connexion de tuyaux quantiques avec IA logique',
                        'Machine à sous intelligente avec IA et bonus adaptatifs': 'Machine à sous intelligente avec IA et bonus adaptatifs',
                        'Fléchettes futuristes avec IA et cibles quantiques': 'Fléchettes futuristes avec IA et cibles quantiques',
                        'Bulles quantiques avec IA et physique avancée': 'Bulles quantiques avec IA et physique avancée',
                        'Jeux de dés intelligents avec IA probabiliste': 'Jeux de dés intelligents avec IA probabiliste',
                        'Billard futuriste avec IA et physique quantique': 'Billard futuriste avec IA et physique quantique',
                        'Tuiles quantiques avec IA et patterns adaptatifs': 'Tuiles quantiques avec IA et patterns adaptatifs',
                        'Quiz intelligent avec IA et questions adaptatives': 'Quiz intelligent avec IA et questions adaptatives',
                        'Astéroïdes futuristes avec IA et armes quantiques': 'Astéroïdes futuristes avec IA et armes quantiques',
                        'Cristaux quantiques avec IA et résonance harmonique': 'Cristaux quantiques avec IA et résonance harmonique',
                        'L\'expérience ultime : IA générative infinie et évolutive': 'L\'expérience ultime : IA générative infinie et évolutive',
                        'Visualisation interactive d\'algorithmes avec IA pédagogique': 'Visualisation interactive d\'algorithmes avec IA pédagogique',
                        'Simulation quantique interactive avec IA scientifique avancée': 'Simulation quantique interactive avec IA scientifique avancée',
                        'Exploration des formes sacrées avec IA spirituelle et harmonies': 'Exploration des formes sacrées avec IA spirituelle et harmonies',
                        'Dialogue philosophique avec IA consciente et réflexion existentielle': 'Dialogue philosophique avec IA consciente et réflexion existentielle'
                    },
                    status: {
                        '🔥 POPULAIRE': '🔥 POPULAIRE',
                        '🔥 CLASSIQUE': '🔥 CLASSIQUE',
                        '⚡ RAPIDE': '⚡ RAPIDE',
                        '🎮 DÉMO': '🎮 DÉMO',
                        '💰 BUSINESS': '💰 BUSINESS',
                        '🌟 AVENTURE': '🌟 AVENTURE',
                        '🌟 ULTIME': '🌟 ULTIME',
                        '🔬 NOUVEAU': '🔬 NOUVEAU',
                        '⚛️ SCIENCE': '⚛️ SCIENCE',
                        '🔮 MYSTIQUE': '🔮 MYSTIQUE',
                        '🤖 RÉVOLUTION': '🤖 RÉVOLUTION'
                    },
                    tags: {
                        '⚡ IA Quantique': '⚡ IA Quantique',
                        '🧩 Puzzle': '🧩 Puzzle',
                        '🌟 Futuriste': '🌟 Futuriste',
                        '🧠 Mémoire': '🧠 Mémoire',
                        '⚡ IA': '⚡ IA',
                        '🎯 Adaptatif': '🎯 Adaptatif',
                        '🧠 Adaptatif': '🧠 Adaptatif',
                        '♛ Échecs': '♛ Échecs',
                        '⚛️ Quantique': '⚛️ Quantique',
                        '🧠 Stratégie': '🧠 Stratégie',
                        '⚫ Dames': '⚫ Dames',
                        '🌍 Mondial': '🌍 Mondial',
                        '🟡 Arcade': '🟡 Arcade',
                        '👻 Fantômes': '👻 Fantômes',
                        '🌀 Labyrinthe': '🌀 Labyrinthe',
                        '🔴 Mémoire': '🔴 Mémoire',
                        '🎵 Sonore': '🎵 Sonore',
                        '⚡ Séquence': '⚡ Séquence',
                        '⚡ Vitesse': '⚡ Vitesse',
                        '⏱️ Chrono': '⏱️ Chrono',
                        '🎯 Réflexes': '🎯 Réflexes',
                        '🔵 Cyber': '🔵 Cyber',
                        '🛡️ Sécurité': '🛡️ Sécurité',
                        '🔍 Détection': '🔍 Détection',
                        '🎪 Créatif': '🎪 Créatif',
                        '🎨 Libre': '🎨 Libre',
                        '🧪 Expérimental': '🧪 Expérimental',
                        '🏠 Immobilier': '🏠 Immobilier',
                        '💰 Économie': '💰 Économie',
                        '♠️ Poker': '♠️ Poker',
                        '🧠 Psychologie': '🧠 Psychologie',
                        '🎭 Bluff': '🎭 Bluff',
                        '🃏 Blackjack': '🃏 Blackjack',
                        '📊 Probabilité': '📊 Probabilité',
                        '🂡 Solitaire': '🂡 Solitaire',
                        '🔄 Fusion': '🔄 Fusion',
                        '♦️ Variantes': '♦️ Variantes',
                        '🌲 Aventure': '🌲 Aventure',
                        '🔮 Mystique': '🔮 Mystique',
                        '📖 Narrative': '📖 Narrative',
                        '🔍 Enquête': '🔍 Enquête',
                        '🕵️ Détective': '🕵️ Détective',
                        '❓ Énigmes': '❓ Énigmes',
                        '🏎️ Course': '🏎️ Course',
                        '🧠 Neural': '🧠 Neural',
                        '🛣️ Adaptatif': '🛣️ Adaptatif',
                        '🎯 Tir': '🎯 Tir',
                        '🌐 Cyber': '🌐 Cyber',
                        '⚛️ Armes': '⚛️ Armes',
                        '⚫ Points': '⚫ Points',
                        '🔮 Prédictif': '🔮 Prédictif',
                        '🎵 Rythme': '🎵 Rythme',
                        '🎼 Musical': '🎼 Musical',
                        '⚪ Flipper': '⚪ Flipper',
                        '⚛️ Tables': '⚛️ Tables',
                        '🔧 Tuyaux': '🔧 Tuyaux',
                        '🧠 Logique': '🧠 Logique',
                        '🎰 Slots': '🎰 Slots',
                        '🎁 Bonus': '🎁 Bonus',
                        '🎯 Fléchettes': '🎯 Fléchettes',
                        '⚛️ Cibles': '⚛️ Cibles',
                        '🫧 Bulles': '🫧 Bulles',
                        '⚡ Physique': '⚡ Physique',
                        '🎲 Dés': '🎲 Dés',
                        '🎱 Billard': '🎱 Billard',
                        '🔲 Tuiles': '🔲 Tuiles',
                        '🎨 Patterns': '🎨 Patterns',
                        '❓ Quiz': '❓ Quiz',
                        '📚 Adaptatif': '📚 Adaptatif',
                        '☄️ Espace': '☄️ Espace',
                        '💎 Cristaux': '💎 Cristaux',
                        '🎵 Harmonique': '🎵 Harmonique',
                        '∞ Infini': '∞ Infini',
                        '🌟 Ultime': '🌟 Ultime',
                        '🔬 Algorithme': '🔬 Algorithme',
                        '👁️ Visuel': '👁️ Visuel',
                        '📚 Éducatif': '📚 Éducatif',
                        '🔬 Physique': '🔬 Physique',
                        '🧪 Simulation': '🧪 Simulation',
                        '🔮 Sacré': '🔮 Sacré',
                        '📐 Géométrie': '📐 Géométrie',
                        '🎵 Harmonie': '🎵 Harmonie',
                        '🤖 Conscience': '🤖 Conscience',
                        '🧠 Philosophie': '🧠 Philosophie',
                        '💭 Existentiel': '💭 Existentiel'
                    }
                },
                en: {
                    games: {
                        'Quantum Tetris 2077': 'Quantum Tetris 2077',
                        'Memory Quantique': 'Quantum Memory',
                        'Neural Puzzle Master': 'Neural Puzzle Master',
                        'Quantum Chess': 'Quantum Chess',
                        'Jeux de Dames': 'Checkers Game',
                        'Pac-Man': 'Pac-Man',
                        'Simon Says': 'Simon Says',
                        'Speed Challenge': 'Speed Challenge',
                        'Cyber Checker': 'Cyber Checker',
                        'Demo Playground': 'Demo Playground',
                        'Quantum Monopoly': 'Quantum Monopoly',
                        'Neural Poker': 'Neural Poker',
                        'Blackjack Quantum': 'Quantum Blackjack',
                        'Solitaire Fusion': 'Solitaire Fusion',
                        'Mystic Forest Quest': 'Mystic Forest Quest',
                        'Enigma Hunter': 'Enigma Hunter',
                        'Neural Racing': 'Neural Racing',
                        'Cyber Shooter': 'Cyber Shooter',
                        'Quantum Dots': 'Quantum Dots',
                        'Neural Rhythm': 'Neural Rhythm',
                        'Cyber Pinball': 'Cyber Pinball',
                        'Quantum Pipes': 'Quantum Pipes',
                        'Neural Slots': 'Neural Slots',
                        'Cyber Darts': 'Cyber Darts',
                        'Quantum Bubbles': 'Quantum Bubbles',
                        'Neural Dice': 'Neural Dice',
                        'Cyber Pool': 'Cyber Pool',
                        'Quantum Tiles': 'Quantum Tiles',
                        'Neural Trivia': 'Neural Trivia',
                        'Cyber Asteroids': 'Cyber Asteroids',
                        'Quantum Crystals': 'Quantum Crystals',
                        'Neural Infinity': 'Neural Infinity',
                        'Algorithme Visuel': 'Visual Algorithm',
                        'Physique Quantique': 'Quantum Physics',
                        'Géométrie Sacrée': 'Sacred Geometry',
                        'Conscience Artificielle': 'Artificial Consciousness'
                    },
                    descriptions: {
                        'Tetris futuriste avec IA quantique et effets spectaculaires': 'Futuristic Tetris with quantum AI and spectacular effects',
                        'Entraînez votre mémoire avec l\'IA neurale adaptative': 'Train your memory with adaptive neural AI',
                        'Puzzles adaptatifs avec IA avancée et défis évolutifs': 'Adaptive puzzles with advanced AI and evolving challenges',
                        'Échecs quantiques multidimensionnels avec IA maître': 'Multidimensional quantum chess with master AI',
                        'Dames classiques avec IA stratégique et variantes mondiales': 'Classic checkers with strategic AI and global variants',
                        'Le légendaire Pac-Man avec IA fantômes et labyrinthes infinis': 'The legendary Pac-Man with AI ghosts and infinite mazes',
                        'Mémoire séquentielle avec IA adaptative et défis sonores': 'Sequential memory with adaptive AI and sound challenges',
                        'Défis de vitesse avec IA chronométrée et réflexes quantiques': 'Speed challenges with timed AI and quantum reflexes',
                        'Vérificateur cyber avec IA de détection et sécurité quantique': 'Cyber checker with detection AI and quantum security',
                        'Terrain de jeu interactif avec IA créative et expériences libres': 'Interactive playground with creative AI and free experiences',
                        'Monopoly quantique avec IA économique et propriétés multidimensionnelles': 'Quantum Monopoly with economic AI and multidimensional properties',
                        'Poker intelligent avec IA psychologique et bluff quantique': 'Smart poker with psychological AI and quantum bluffing',
                        'Blackjack quantique avec IA croupier et probabilités avancées': 'Quantum blackjack with dealer AI and advanced probabilities',
                        'Solitaire fusionné avec IA assistante et variantes infinies': 'Fusion solitaire with assistant AI and infinite variants',
                        'Quête mystique avec IA narrative et forêt enchantée évolutive': 'Mystical quest with narrative AI and evolving enchanted forest',
                        'Chasseur d\'énigmes avec IA détective et mystères génératifs': 'Enigma hunter with detective AI and generative mysteries',
                        'Course futuriste avec IA pilote et circuits adaptatifs': 'Futuristic racing with pilot AI and adaptive circuits',
                        'Tir spatial avec IA ennemie et armes quantiques': 'Space shooting with enemy AI and quantum weapons',
                        'Connexion de points quantiques avec IA prédictive': 'Quantum dots connection with predictive AI',
                        'Jeu de rythme avec IA musicale et génération adaptative': 'Rhythm game with musical AI and adaptive generation',
                        'Flipper futuriste avec IA et tables quantiques': 'Futuristic pinball with AI and quantum tables',
                        'Connexion de tuyaux quantiques avec IA logique': 'Quantum pipes connection with logic AI',
                        'Machine à sous intelligente avec IA et bonus adaptatifs': 'Smart slot machine with AI and adaptive bonuses',
                        'Fléchettes futuristes avec IA et cibles quantiques': 'Futuristic darts with AI and quantum targets',
                        'Bulles quantiques avec IA et physique avancée': 'Quantum bubbles with AI and advanced physics',
                        'Jeux de dés intelligents avec IA probabiliste': 'Smart dice games with probabilistic AI',
                        'Billard futuriste avec IA et physique quantique': 'Futuristic pool with AI and quantum physics',
                        'Tuiles quantiques avec IA et patterns adaptatifs': 'Quantum tiles with AI and adaptive patterns',
                        'Quiz intelligent avec IA et questions adaptatives': 'Smart trivia with AI and adaptive questions',
                        'Astéroïdes futuristes avec IA et armes quantiques': 'Futuristic asteroids with AI and quantum weapons',
                        'Cristaux quantiques avec IA et résonance harmonique': 'Quantum crystals with AI and harmonic resonance',
                        'L\'expérience ultime : IA générative infinie et évolutive': 'The ultimate experience: infinite and evolving generative AI',
                        'Visualisation interactive d\'algorithmes avec IA pédagogique': 'Interactive algorithm visualization with educational AI',
                        'Simulation quantique interactive avec IA scientifique avancée': 'Interactive quantum simulation with advanced scientific AI',
                        'Exploration des formes sacrées avec IA spirituelle et harmonies': 'Sacred geometry exploration with spiritual AI and harmonies',
                        'Dialogue philosophique avec IA consciente et réflexion existentielle': 'Philosophical dialogue with conscious AI and existential reflection'
                    },
                    status: {
                        '🔥 POPULAIRE': '🔥 POPULAR',
                        '🔥 CLASSIQUE': '🔥 CLASSIC',
                        '⚡ RAPIDE': '⚡ FAST',
                        '🎮 DÉMO': '🎮 DEMO',
                        '💰 BUSINESS': '💰 BUSINESS',
                        '🌟 AVENTURE': '🌟 ADVENTURE',
                        '🌟 ULTIME': '🌟 ULTIMATE',
                        '🔬 NOUVEAU': '🔬 NEW',
                        '⚛️ SCIENCE': '⚛️ SCIENCE',
                        '🔮 MYSTIQUE': '🔮 MYSTICAL',
                        '🤖 RÉVOLUTION': '🤖 REVOLUTION'
                    },
                    tags: {
                        '⚡ IA Quantique': '⚡ Quantum AI',
                        '🧩 Puzzle': '🧩 Puzzle',
                        '🌟 Futuriste': '🌟 Futuristic',
                        '🧠 Mémoire': '🧠 Memory',
                        '⚡ IA': '⚡ AI',
                        '🎯 Adaptatif': '🎯 Adaptive',
                        '🧠 Adaptatif': '🧠 Adaptive',
                        '♛ Échecs': '♛ Chess',
                        '⚛️ Quantique': '⚛️ Quantum',
                        '🧠 Stratégie': '🧠 Strategy',
                        '⚫ Dames': '⚫ Checkers',
                        '🌍 Mondial': '🌍 Global',
                        '🟡 Arcade': '🟡 Arcade',
                        '👻 Fantômes': '👻 Ghosts',
                        '🌀 Labyrinthe': '🌀 Maze',
                        '🔴 Mémoire': '🔴 Memory',
                        '🎵 Sonore': '🎵 Sound',
                        '⚡ Séquence': '⚡ Sequence',
                        '⚡ Vitesse': '⚡ Speed',
                        '⏱️ Chrono': '⏱️ Timer',
                        '🎯 Réflexes': '🎯 Reflexes',
                        '🔵 Cyber': '🔵 Cyber',
                        '🛡️ Sécurité': '🛡️ Security',
                        '🔍 Détection': '🔍 Detection',
                        '🎪 Créatif': '🎪 Creative',
                        '🎨 Libre': '🎨 Free',
                        '🧪 Expérimental': '🧪 Experimental',
                        '🏠 Immobilier': '🏠 Real Estate',
                        '💰 Économie': '💰 Economy',
                        '♠️ Poker': '♠️ Poker',
                        '🧠 Psychologie': '🧠 Psychology',
                        '🎭 Bluff': '🎭 Bluff',
                        '🃏 Blackjack': '🃏 Blackjack',
                        '📊 Probabilité': '📊 Probability',
                        '🂡 Solitaire': '🂡 Solitaire',
                        '🔄 Fusion': '🔄 Fusion',
                        '♦️ Variantes': '♦️ Variants',
                        '🌲 Aventure': '🌲 Adventure',
                        '🔮 Mystique': '🔮 Mystical',
                        '📖 Narrative': '📖 Narrative',
                        '🔍 Enquête': '🔍 Investigation',
                        '🕵️ Détective': '🕵️ Detective',
                        '❓ Énigmes': '❓ Enigmas',
                        '🏎️ Course': '🏎️ Racing',
                        '🧠 Neural': '🧠 Neural',
                        '🛣️ Adaptatif': '🛣️ Adaptive',
                        '🎯 Tir': '🎯 Shooting',
                        '🌐 Cyber': '🌐 Cyber',
                        '⚛️ Armes': '⚛️ Weapons',
                        '⚫ Points': '⚫ Dots',
                        '🔮 Prédictif': '🔮 Predictive',
                        '🎵 Rythme': '🎵 Rhythm',
                        '🎼 Musical': '🎼 Musical',
                        '⚪ Flipper': '⚪ Pinball',
                        '⚛️ Tables': '⚛️ Tables',
                        '🔧 Tuyaux': '🔧 Pipes',
                        '🧠 Logique': '🧠 Logic',
                        '🎰 Slots': '🎰 Slots',
                        '🎁 Bonus': '🎁 Bonus',
                        '🎯 Fléchettes': '🎯 Darts',
                        '⚛️ Cibles': '⚛️ Targets',
                        '🫧 Bulles': '🫧 Bubbles',
                        '⚡ Physique': '⚡ Physics',
                        '🎲 Dés': '🎲 Dice',
                        '🎱 Billard': '🎱 Pool',
                        '🔲 Tuiles': '🔲 Tiles',
                        '🎨 Patterns': '🎨 Patterns',
                        '❓ Quiz': '❓ Trivia',
                        '📚 Adaptatif': '📚 Adaptive',
                        '☄️ Espace': '☄️ Space',
                        '💎 Cristaux': '💎 Crystals',
                        '🎵 Harmonique': '🎵 Harmonic',
                        '∞ Infini': '∞ Infinite',
                        '🌟 Ultime': '🌟 Ultimate',
                        '🔬 Algorithme': '🔬 Algorithm',
                        '👁️ Visuel': '👁️ Visual',
                        '📚 Éducatif': '📚 Educational',
                        '🔬 Physique': '🔬 Physics',
                        '🧪 Simulation': '🧪 Simulation',
                        '🔮 Sacré': '🔮 Sacred',
                        '📐 Géométrie': '📐 Geometry',
                        '🎵 Harmonie': '🎵 Harmony',
                        '🤖 Conscience': '🤖 Consciousness',
                        '🧠 Philosophie': '🧠 Philosophy',
                        '💭 Existentiel': '💭 Existential'
                    }
                },
                ar: {
                    games: {
                        'Quantum Tetris 2077': 'تيتريس الكمي 2077',
                        'Memory Quantique': 'الذاكرة الكمية',
                        'Neural Puzzle Master': 'سيد الألغاز العصبية',
                        'Quantum Chess': 'الشطرنج الكمي',
                        'Jeux de Dames': 'لعبة الداما',
                        'Pac-Man': 'باك مان',
                        'Simon Says': 'سايمون يقول',
                        'Speed Challenge': 'تحدي السرعة',
                        'Cyber Checker': 'فاحص السايبر',
                        'Demo Playground': 'ملعب التجريب',
                        'Quantum Monopoly': 'مونوبولي الكمي',
                        'Neural Poker': 'البوكر العصبي',
                        'Blackjack Quantum': 'بلاك جاك الكمي',
                        'Solitaire Fusion': 'سوليتير الاندماج',
                        'Mystic Forest Quest': 'مهمة الغابة الغامضة',
                        'Enigma Hunter': 'صائد الألغاز',
                        'Neural Racing': 'السباق العصبي',
                        'Cyber Shooter': 'رامي السايبر',
                        'Quantum Dots': 'النقاط الكمية',
                        'Neural Rhythm': 'الإيقاع العصبي',
                        'Cyber Pinball': 'البينبول السايبري',
                        'Quantum Pipes': 'الأنابيب الكمية',
                        'Neural Slots': 'الفتحات العصبية',
                        'Cyber Darts': 'سهام السايبر',
                        'Quantum Bubbles': 'الفقاعات الكمية',
                        'Neural Dice': 'النرد العصبي',
                        'Cyber Pool': 'بلياردو السايبر',
                        'Quantum Tiles': 'البلاط الكمي',
                        'Neural Trivia': 'المعلومات العامة العصبية',
                        'Cyber Asteroids': 'كويكبات السايبر',
                        'Quantum Crystals': 'البلورات الكمية',
                        'Neural Infinity': 'اللانهاية العصبية',
                        'Algorithme Visuel': 'الخوارزمية البصرية',
                        'Physique Quantique': 'الفيزياء الكمية',
                        'Géométrie Sacrée': 'الهندسة المقدسة',
                        'Conscience Artificielle': 'الوعي الاصطناعي'
                    },
                    descriptions: {
                        'Tetris futuriste avec IA quantique et effets spectaculaires': 'تيتريس مستقبلي مع ذكاء اصطناعي كمي وتأثيرات مذهلة',
                        'Entraînez votre mémoire avec l\'IA neurale adaptative': 'درب ذاكرتك مع الذكاء الاصطناعي العصبي التكيفي',
                        'Puzzles adaptatifs avec IA avancée et défis évolutifs': 'ألغاز تكيفية مع ذكاء اصطناعي متقدم وتحديات متطورة',
                        'Échecs quantiques multidimensionnels avec IA maître': 'شطرنج كمي متعدد الأبعاد مع ذكاء اصطناعي خبير',
                        'Dames classiques avec IA stratégique et variantes mondiales': 'داما كلاسيكية مع ذكاء اصطناعي استراتيجي ومتغيرات عالمية',
                        'Le légendaire Pac-Man avec IA fantômes et labyrinthes infinis': 'باك مان الأسطوري مع أشباح ذكية ومتاهات لا نهائية'
                    },
                    status: {
                        '🔥 POPULAIRE': '🔥 شائع',
                        '🔥 CLASSIQUE': '🔥 كلاسيكي',
                        '⚡ RAPIDE': '⚡ سريع',
                        '🎮 DÉMO': '🎮 تجريبي',
                        '💰 BUSINESS': '💰 أعمال',
                        '🌟 AVENTURE': '🌟 مغامرة',
                        '🌟 ULTIME': '🌟 نهائي',
                        '🔬 NOUVEAU': '🔬 جديد',
                        '⚛️ SCIENCE': '⚛️ علوم',
                        '🔮 MYSTIQUE': '🔮 غامض',
                        '🤖 RÉVOLUTION': '🤖 ثورة'
                    },
                    tags: {
                        '⚡ IA Quantique': '⚡ ذكاء كمي',
                        '🧩 Puzzle': '🧩 لغز',
                        '🌟 Futuriste': '🌟 مستقبلي',
                        '🧠 Mémoire': '🧠 ذاكرة',
                        '⚡ IA': '⚡ ذكاء',
                        '🎯 Adaptatif': '🎯 تكيفي',
                        '🧠 Adaptatif': '🧠 تكيفي',
                        '♛ Échecs': '♛ شطرنج',
                        '⚛️ Quantique': '⚛️ كمي',
                        '🧠 Stratégie': '🧠 استراتيجية',
                        '⚫ Dames': '⚫ داما',
                        '🌍 Mondial': '🌍 عالمي',
                        '🟡 Arcade': '🟡 أركيد',
                        '👻 Fantômes': '👻 أشباح',
                        '🌀 Labyrinthe': '🌀 متاهة',
                        '🔴 Mémoire': '🔴 ذاكرة',
                        '🎵 Sonore': '🎵 صوتي',
                        '⚡ Séquence': '⚡ تسلسل',
                        '⚡ Vitesse': '⚡ سرعة',
                        '⏱️ Chrono': '⏱️ مؤقت',
                        '🎯 Réflexes': '🎯 ردود فعل',
                        '🔵 Cyber': '🔵 سايبر',
                        '🛡️ Sécurité': '🛡️ أمان',
                        '🔍 Détection': '🔍 كشف',
                        '🎪 Créatif': '🎪 إبداعي',
                        '🎨 Libre': '🎨 حر',
                        '🧪 Expérimental': '🧪 تجريبي',
                        '🏠 Immobilier': '🏠 عقارات',
                        '💰 Économie': '💰 اقتصاد',
                        '♠️ Poker': '♠️ بوكر',
                        '🧠 Psychologie': '🧠 علم نفس',
                        '🎭 Bluff': '🎭 خداع',
                        '🃏 Blackjack': '🃏 بلاك جاك',
                        '📊 Probabilité': '📊 احتمالية',
                        '🂡 Solitaire': '🂡 سوليتير',
                        '🔄 Fusion': '🔄 اندماج',
                        '♦️ Variantes': '♦️ متغيرات',
                        '🌲 Aventure': '🌲 مغامرة',
                        '🔮 Mystique': '🔮 غامض',
                        '📖 Narrative': '📖 سردي',
                        '🔍 Enquête': '🔍 تحقيق',
                        '🕵️ Détective': '🕵️ محقق',
                        '❓ Énigmes': '❓ ألغاز',
                        '🏎️ Course': '🏎️ سباق',
                        '🧠 Neural': '🧠 عصبي',
                        '🛣️ Adaptatif': '🛣️ تكيفي',
                        '🎯 Tir': '🎯 رماية',
                        '🌐 Cyber': '🌐 سايبر',
                        '⚛️ Armes': '⚛️ أسلحة',
                        '⚫ Points': '⚫ نقاط',
                        '🔮 Prédictif': '🔮 تنبؤي',
                        '🎵 Rythme': '🎵 إيقاع',
                        '🎼 Musical': '🎼 موسيقي',
                        '⚪ Flipper': '⚪ فليبر',
                        '⚛️ Tables': '⚛️ طاولات',
                        '🔧 Tuyaux': '🔧 أنابيب',
                        '🧠 Logique': '🧠 منطق',
                        '🎰 Slots': '🎰 فتحات',
                        '🎁 Bonus': '🎁 مكافآت',
                        '🎯 Fléchettes': '🎯 سهام',
                        '⚛️ Cibles': '⚛️ أهداف',
                        '🫧 Bulles': '🫧 فقاعات',
                        '⚡ Physique': '⚡ فيزياء',
                        '🎲 Dés': '🎲 نرد',
                        '🎱 Billard': '🎱 بلياردو',
                        '🔲 Tuiles': '🔲 بلاط',
                        '🎨 Patterns': '🎨 أنماط',
                        '❓ Quiz': '❓ اختبار',
                        '📚 Adaptatif': '📚 تكيفي',
                        '☄️ Espace': '☄️ فضاء',
                        '💎 Cristaux': '💎 بلورات',
                        '🎵 Harmonique': '🎵 توافقي',
                        '∞ Infini': '∞ لانهائي',
                        '🌟 Ultime': '🌟 نهائي',
                        '🔬 Algorithme': '🔬 خوارزمية',
                        '👁️ Visuel': '👁️ بصري',
                        '📚 Éducatif': '📚 تعليمي',
                        '🔬 Physique': '🔬 فيزياء',
                        '🧪 Simulation': '🧪 محاكاة',
                        '🔮 Sacré': '🔮 مقدس',
                        '📐 Géométrie': '📐 هندسة',
                        '🎵 Harmonie': '🎵 انسجام',
                        '🤖 Conscience': '🤖 وعي',
                        '🧠 Philosophie': '🧠 فلسفة',
                        '💭 Existentiel': '💭 وجودي'
                    }
                },
                es: {
                    games: {
                        'Quantum Tetris 2077': 'Quantum Tetris 2077',
                        'Memory Quantique': 'Memoria Cuántica',
                        'Neural Puzzle Master': 'Maestro de Puzzles Neurales',
                        'Quantum Chess': 'Ajedrez Cuántico',
                        'Jeux de Dames': 'Juego de Damas',
                        'Pac-Man': 'Pac-Man',
                        'Simon Says': 'Simón Dice',
                        'Speed Challenge': 'Desafío de Velocidad',
                        'Cyber Checker': 'Verificador Cibernético',
                        'Demo Playground': 'Patio de Demostración',
                        'Quantum Monopoly': 'Monopoly Cuántico',
                        'Neural Poker': 'Póker Neural',
                        'Blackjack Quantum': 'Blackjack Cuántico',
                        'Solitaire Fusion': 'Solitario Fusión',
                        'Mystic Forest Quest': 'Búsqueda del Bosque Místico',
                        'Enigma Hunter': 'Cazador de Enigmas',
                        'Neural Racing': 'Carreras Neurales',
                        'Cyber Shooter': 'Tirador Cibernético',
                        'Quantum Dots': 'Puntos Cuánticos',
                        'Neural Rhythm': 'Ritmo Neural',
                        'Cyber Pinball': 'Pinball Cibernético',
                        'Quantum Pipes': 'Tuberías Cuánticas',
                        'Neural Slots': 'Tragamonedas Neurales',
                        'Cyber Darts': 'Dardos Cibernéticos',
                        'Quantum Bubbles': 'Burbujas Cuánticas',
                        'Neural Dice': 'Dados Neurales',
                        'Cyber Pool': 'Billar Cibernético',
                        'Quantum Tiles': 'Azulejos Cuánticos',
                        'Neural Trivia': 'Trivia Neural',
                        'Cyber Asteroids': 'Asteroides Cibernéticos',
                        'Quantum Crystals': 'Cristales Cuánticos',
                        'Neural Infinity': 'Infinito Neural',
                        'Algorithme Visuel': 'Algoritmo Visual',
                        'Physique Quantique': 'Física Cuántica',
                        'Géométrie Sacrée': 'Geometría Sagrada',
                        'Conscience Artificielle': 'Conciencia Artificial'
                    },
                    descriptions: {
                        'Tetris futuriste avec IA quantique et effets spectaculaires': 'Tetris futurista con IA cuántica y efectos espectaculares',
                        'Entraînez votre mémoire avec l\'IA neurale adaptative': 'Entrena tu memoria con IA neural adaptativa',
                        'Puzzles adaptatifs avec IA avancée et défis évolutifs': 'Puzzles adaptativos con IA avanzada y desafíos evolutivos',
                        'Échecs quantiques multidimensionnels avec IA maître': 'Ajedrez cuántico multidimensional con IA maestra',
                        'Dames classiques avec IA stratégique et variantes mondiales': 'Damas clásicas con IA estratégica y variantes mundiales',
                        'Le légendaire Pac-Man avec IA fantômes et labyrinthes infinis': 'El legendario Pac-Man con fantasmas IA y laberintos infinitos',
                        'Mémoire séquentielle avec IA adaptative et défis sonores': 'Memoria secuencial con IA adaptativa y desafíos sonoros',
                        'Défis de vitesse avec IA chronométrée et réflexes quantiques': 'Desafíos de velocidad con IA cronometrada y reflejos cuánticos',
                        'Vérificateur cyber avec IA de détection et sécurité quantique': 'Verificador cibernético con IA de detección y seguridad cuántica',
                        'Terrain de jeu interactif avec IA créative et expériences libres': 'Patio de juegos interactivo con IA creativa y experiencias libres',
                        'Monopoly quantique avec IA économique et propriétés multidimensionnelles': 'Monopoly cuántico con IA económica y propiedades multidimensionales',
                        'Poker intelligent avec IA psychologique et bluff quantique': 'Póker inteligente con IA psicológica y farol cuántico',
                        'Blackjack quantique avec IA croupier et probabilités avancées': 'Blackjack cuántico con IA crupier y probabilidades avanzadas',
                        'Solitaire fusionné avec IA assistante et variantes infinies': 'Solitario fusionado con IA asistente y variantes infinitas',
                        'Quête mystique avec IA narrative et forêt enchantée évolutive': 'Búsqueda mística con IA narrativa y bosque encantado evolutivo',
                        'Chasseur d\'énigmes avec IA détective et mystères génératifs': 'Cazador de enigmas con IA detective y misterios generativos',
                        'Course futuriste avec IA pilote et circuits adaptatifs': 'Carreras futuristas con IA piloto y circuitos adaptativos',
                        'Tir spatial avec IA ennemie et armes quantiques': 'Tiro espacial con IA enemiga y armas cuánticas',
                        'Connexion de points quantiques avec IA prédictive': 'Conexión de puntos cuánticos con IA predictiva',
                        'Jeu de rythme avec IA musicale et génération adaptative': 'Juego de ritmo con IA musical y generación adaptativa',
                        'Flipper futuriste avec IA et tables quantiques': 'Pinball futurista con IA y mesas cuánticas',
                        'Connexion de tuyaux quantiques avec IA logique': 'Conexión de tuberías cuánticas con IA lógica',
                        'Machine à sous intelligente avec IA et bonus adaptatifs': 'Máquina tragamonedas inteligente con IA y bonos adaptativos',
                        'Fléchettes futuristes avec IA et cibles quantiques': 'Dardos futuristas con IA y objetivos cuánticos',
                        'Bulles quantiques avec IA et physique avancée': 'Burbujas cuánticas con IA y física avanzada',
                        'Jeux de dés intelligents avec IA probabiliste': 'Juegos de dados inteligentes con IA probabilística',
                        'Billard futuriste avec IA et physique quantique': 'Billar futurista con IA y física cuántica',
                        'Tuiles quantiques avec IA et patterns adaptatifs': 'Azulejos cuánticos con IA y patrones adaptativos',
                        'Quiz intelligent avec IA et questions adaptatives': 'Trivia inteligente con IA y preguntas adaptativas',
                        'Astéroïdes futuristes avec IA et armes quantiques': 'Asteroides futuristas con IA y armas cuánticas',
                        'Cristaux quantiques avec IA et résonance harmonique': 'Cristales cuánticos con IA y resonancia armónica',
                        'L\'expérience ultime : IA générative infinie et évolutive': 'La experiencia definitiva: IA generativa infinita y evolutiva',
                        'Visualisation interactive d\'algorithmes avec IA pédagogique': 'Visualización interactiva de algoritmos con IA pedagógica',
                        'Simulation quantique interactive avec IA scientifique avancée': 'Simulación cuántica interactiva con IA científica avanzada',
                        'Exploration des formes sacrées avec IA spirituelle et harmonies': 'Exploración de formas sagradas con IA espiritual y armonías',
                        'Dialogue philosophique avec IA consciente et réflexion existentielle': 'Diálogo filosófico con IA consciente y reflexión existencial'
                    },
                    status: {
                        '🔥 POPULAIRE': '🔥 POPULAR',
                        '🔥 CLASSIQUE': '🔥 CLÁSICO',
                        '⚡ RAPIDE': '⚡ RÁPIDO',
                        '🎮 DÉMO': '🎮 DEMO',
                        '💰 BUSINESS': '💰 NEGOCIOS',
                        '🌟 AVENTURE': '🌟 AVENTURA',
                        '🌟 ULTIME': '🌟 ÚLTIMO',
                        '🔬 NOUVEAU': '🔬 NUEVO',
                        '⚛️ SCIENCE': '⚛️ CIENCIA',
                        '🔮 MYSTIQUE': '🔮 MÍSTICO',
                        '🤖 RÉVOLUTION': '🤖 REVOLUCIÓN'
                    },
                    tags: {
                        '⚡ IA Quantique': '⚡ IA Cuántica',
                        '🧩 Puzzle': '🧩 Puzzle',
                        '🌟 Futuriste': '🌟 Futurista',
                        '🧠 Mémoire': '🧠 Memoria',
                        '⚡ IA': '⚡ IA',
                        '🎯 Adaptatif': '🎯 Adaptativo',
                        '🧠 Adaptatif': '🧠 Adaptativo',
                        '♛ Échecs': '♛ Ajedrez',
                        '⚛️ Quantique': '⚛️ Cuántico',
                        '🧠 Stratégie': '🧠 Estrategia',
                        '⚫ Dames': '⚫ Damas',
                        '🌍 Mondial': '🌍 Mundial',
                        '🟡 Arcade': '🟡 Arcade',
                        '👻 Fantômes': '👻 Fantasmas',
                        '🌀 Labyrinthe': '🌀 Laberinto',
                        '🔴 Mémoire': '🔴 Memoria',
                        '🎵 Sonore': '🎵 Sonido',
                        '⚡ Séquence': '⚡ Secuencia',
                        '⚡ Vitesse': '⚡ Velocidad',
                        '⏱️ Chrono': '⏱️ Cronómetro',
                        '🎯 Réflexes': '🎯 Reflejos',
                        '🔵 Cyber': '🔵 Cibernético',
                        '🛡️ Sécurité': '🛡️ Seguridad',
                        '🔍 Détection': '🔍 Detección',
                        '🎪 Créatif': '🎪 Creativo',
                        '🎨 Libre': '🎨 Libre',
                        '🧪 Expérimental': '🧪 Experimental',
                        '🏠 Immobilier': '🏠 Inmobiliario',
                        '💰 Économie': '💰 Economía',
                        '♠️ Poker': '♠️ Póker',
                        '🧠 Psychologie': '🧠 Psicología',
                        '🎭 Bluff': '🎭 Farol',
                        '🃏 Blackjack': '🃏 Blackjack',
                        '📊 Probabilité': '📊 Probabilidad',
                        '🂡 Solitaire': '🂡 Solitario',
                        '🔄 Fusion': '🔄 Fusión',
                        '♦️ Variantes': '♦️ Variantes',
                        '🌲 Aventure': '🌲 Aventura',
                        '🔮 Mystique': '🔮 Místico',
                        '📖 Narrative': '📖 Narrativo',
                        '🔍 Enquête': '🔍 Investigación',
                        '🕵️ Détective': '🕵️ Detective',
                        '❓ Énigmes': '❓ Enigmas',
                        '🏎️ Course': '🏎️ Carreras',
                        '🧠 Neural': '🧠 Neural',
                        '🛣️ Adaptatif': '🛣️ Adaptativo',
                        '🎯 Tir': '🎯 Tiro',
                        '🌐 Cyber': '🌐 Cibernético',
                        '⚛️ Armes': '⚛️ Armas',
                        '⚫ Points': '⚫ Puntos',
                        '🔮 Prédictif': '🔮 Predictivo',
                        '🎵 Rythme': '🎵 Ritmo',
                        '🎼 Musical': '🎼 Musical',
                        '⚪ Flipper': '⚪ Pinball',
                        '⚛️ Tables': '⚛️ Mesas',
                        '🔧 Tuyaux': '🔧 Tuberías',
                        '🧠 Logique': '🧠 Lógica',
                        '🎰 Slots': '🎰 Tragamonedas',
                        '🎁 Bonus': '🎁 Bonificación',
                        '🎯 Fléchettes': '🎯 Dardos',
                        '⚛️ Cibles': '⚛️ Objetivos',
                        '🫧 Bulles': '🫧 Burbujas',
                        '⚡ Physique': '⚡ Física',
                        '🎲 Dés': '🎲 Dados',
                        '🎱 Billard': '🎱 Billar',
                        '🔲 Tuiles': '🔲 Azulejos',
                        '🎨 Patterns': '🎨 Patrones',
                        '❓ Quiz': '❓ Trivia',
                        '📚 Adaptatif': '📚 Adaptativo',
                        '☄️ Espace': '☄️ Espacio',
                        '💎 Cristaux': '💎 Cristales',
                        '🎵 Harmonique': '🎵 Armónico',
                        '∞ Infini': '∞ Infinito',
                        '🌟 Ultime': '🌟 Último',
                        '🔬 Algorithme': '🔬 Algoritmo',
                        '👁️ Visuel': '👁️ Visual',
                        '📚 Éducatif': '📚 Educativo',
                        '🔬 Physique': '🔬 Física',
                        '🧪 Simulation': '🧪 Simulación',
                        '🔮 Sacré': '🔮 Sagrado',
                        '📐 Géométrie': '📐 Geometría',
                        '🎵 Harmonie': '🎵 Armonía',
                        '🤖 Conscience': '🤖 Conciencia',
                        '🧠 Philosophie': '🧠 Filosofía',
                        '💭 Existentiel': '💭 Existencial'
                    }
                },
                zh: {
                    games: {
                        'Quantum Tetris 2077': '量子俄罗斯方块 2077',
                        'Memory Quantique': '量子记忆',
                        'Neural Puzzle Master': '神经拼图大师',
                        'Quantum Chess': '量子国际象棋',
                        'Jeux de Dames': '跳棋游戏',
                        'Pac-Man': '吃豆人',
                        'Simon Says': '西蒙说',
                        'Speed Challenge': '速度挑战',
                        'Cyber Checker': '网络检查器',
                        'Demo Playground': '演示游乐场',
                        'Quantum Monopoly': '量子大富翁',
                        'Neural Poker': '神经扑克',
                        'Blackjack Quantum': '量子21点',
                        'Solitaire Fusion': '纸牌融合',
                        'Mystic Forest Quest': '神秘森林探索',
                        'Enigma Hunter': '谜题猎人',
                        'Neural Racing': '神经赛车',
                        'Cyber Shooter': '网络射击',
                        'Quantum Dots': '量子点',
                        'Neural Rhythm': '神经节拍',
                        'Cyber Pinball': '网络弹球',
                        'Quantum Pipes': '量子管道',
                        'Neural Slots': '神经老虎机',
                        'Cyber Darts': '网络飞镖',
                        'Quantum Bubbles': '量子泡泡',
                        'Neural Dice': '神经骰子',
                        'Cyber Pool': '网络台球',
                        'Quantum Tiles': '量子瓷砖',
                        'Neural Trivia': '神经问答',
                        'Cyber Asteroids': '网络小行星',
                        'Quantum Crystals': '量子水晶',
                        'Neural Infinity': '神经无限',
                        'Algorithme Visuel': '可视算法',
                        'Physique Quantique': '量子物理',
                        'Géométrie Sacrée': '神圣几何',
                        'Conscience Artificielle': '人工意识'
                    },
                    descriptions: {
                        'Tetris futuriste avec IA quantique et effets spectaculaires': '未来主义俄罗斯方块，配备量子AI和壮观效果',
                        'Entraînez votre mémoire avec l\'IA neurale adaptative': '用自适应神经AI训练你的记忆',
                        'Puzzles adaptatifs avec IA avancée et défis évolutifs': '具有高级AI和进化挑战的自适应拼图',
                        'Échecs quantiques multidimensionnels avec IA maître': '多维量子国际象棋，配备大师级AI',
                        'Dames classiques avec IA stratégique et variantes mondiales': '经典跳棋，配备战略AI和全球变体',
                        'Le légendaire Pac-Man avec IA fantômes et labyrinthes infinis': '传奇吃豆人，配备AI幽灵和无限迷宫',
                        'Mémoire séquentielle avec IA adaptative et défis sonores': '序列记忆，配备自适应AI和声音挑战',
                        'Défis de vitesse avec IA chronométrée et réflexes quantiques': '速度挑战，配备计时AI和量子反射',
                        'Vérificateur cyber avec IA de détection et sécurité quantique': '网络验证器，配备检测AI和量子安全',
                        'Terrain de jeu interactif avec IA créative et expériences libres': '互动游乐场，配备创意AI和自由体验',
                        'Monopoly quantique avec IA économique et propriétés multidimensionnelles': '量子大富翁，配备经济AI和多维属性',
                        'Poker intelligent avec IA psychologique et bluff quantique': '智能扑克，配备心理AI和量子虚张声势',
                        'Blackjack quantique avec IA croupier et probabilités avancées': '量子21点，配备荷官AI和高级概率',
                        'Solitaire fusionné avec IA assistante et variantes infinies': '融合纸牌，配备助手AI和无限变体',
                        'Quête mystique avec IA narrative et forêt enchantée évolutive': '神秘探索，配备叙事AI和进化魔法森林',
                        'Chasseur d\'énigmes avec IA détective et mystères génératifs': '谜题猎人，配备侦探AI和生成式谜题',
                        'Course futuriste avec IA pilote et circuits adaptatifs': '未来赛车，配备飞行员AI和自适应赛道',
                        'Tir spatial avec IA ennemie et armes quantiques': '太空射击，配备敌方AI和量子武器',
                        'Connexion de points quantiques avec IA prédictive': '量子点连接，配备预测AI',
                        'Jeu de rythme avec IA musicale et génération adaptative': '节拍游戏，配备音乐AI和自适应生成',
                        'Flipper futuriste avec IA et tables quantiques': '未来弹球，配备AI和量子桌面',
                        'Connexion de tuyaux quantiques avec IA logique': '量子管道连接，配备逻辑AI',
                        'Machine à sous intelligente avec IA et bonus adaptatifs': '智能老虎机，配备AI和自适应奖励',
                        'Fléchettes futuristes avec IA et cibles quantiques': '未来飞镖，配备AI和量子目标',
                        'Bulles quantiques avec IA et physique avancée': '量子泡泡，配备AI和高级物理',
                        'Jeux de dés intelligents avec IA probabiliste': '智能骰子游戏，配备概率AI',
                        'Billard futuriste avec IA et physique quantique': '未来台球，配备AI和量子物理',
                        'Tuiles quantiques avec IA et patterns adaptatifs': '量子瓷砖，配备AI和自适应图案',
                        'Quiz intelligent avec IA et questions adaptatives': '智能问答，配备AI和自适应问题',
                        'Astéroïdes futuristes avec IA et armes quantiques': '未来小行星，配备AI和量子武器',
                        'Cristaux quantiques avec IA et résonance harmonique': '量子水晶，配备AI和谐波共振',
                        'L\'expérience ultime : IA générative infinie et évolutive': '终极体验：无限进化的生成AI',
                        'Visualisation interactive d\'algorithmes avec IA pédagogique': '算法交互可视化，配备教学AI',
                        'Simulation quantique interactive avec IA scientifique avancée': '交互量子模拟，配备高级科学AI',
                        'Exploration des formes sacrées avec IA spirituelle et harmonies': '神圣几何探索，配备精神AI和和谐',
                        'Dialogue philosophique avec IA consciente et réflexion existentielle': '哲学对话，配备有意识AI和存在主义反思'
                    },
                    status: {
                        '🔥 POPULAIRE': '🔥 热门',
                        '🔥 CLASSIQUE': '🔥 经典',
                        '⚡ RAPIDE': '⚡ 快速',
                        '🎮 DÉMO': '🎮 演示',
                        '💰 BUSINESS': '💰 商业',
                        '🌟 AVENTURE': '🌟 冒险',
                        '🌟 ULTIME': '🌟 终极',
                        '🔬 NOUVEAU': '🔬 新品',
                        '⚛️ SCIENCE': '⚛️ 科学',
                        '🔮 MYSTIQUE': '🔮 神秘',
                        '🤖 RÉVOLUTION': '🤖 革命'
                    },
                    tags: {
                        '⚡ IA Quantique': '⚡ 量子AI',
                        '🧩 Puzzle': '🧩 拼图',
                        '🌟 Futuriste': '🌟 未来主义',
                        '🧠 Mémoire': '🧠 记忆',
                        '⚡ IA': '⚡ AI',
                        '🎯 Adaptatif': '🎯 自适应',
                        '🧠 Adaptatif': '🧠 自适应',
                        '♛ Échecs': '♛ 国际象棋',
                        '⚛️ Quantique': '⚛️ 量子',
                        '🧠 Stratégie': '🧠 策略',
                        '⚫ Dames': '⚫ 跳棋',
                        '🌍 Mondial': '🌍 全球',
                        '🟡 Arcade': '🟡 街机',
                        '👻 Fantômes': '👻 幽灵',
                        '🌀 Labyrinthe': '🌀 迷宫',
                        '🔴 Mémoire': '🔴 记忆',
                        '🎵 Sonore': '🎵 声音',
                        '⚡ Séquence': '⚡ 序列',
                        '⚡ Vitesse': '⚡ 速度',
                        '⏱️ Chrono': '⏱️ 计时器',
                        '🎯 Réflexes': '🎯 反射',
                        '🔵 Cyber': '🔵 网络',
                        '🛡️ Sécurité': '🛡️ 安全',
                        '🔍 Détection': '🔍 检测',
                        '🎪 Créatif': '🎪 创意',
                        '🎨 Libre': '🎨 自由',
                        '🧪 Expérimental': '🧪 实验',
                        '🏠 Immobilier': '🏠 房地产',
                        '💰 Économie': '💰 经济',
                        '♠️ Poker': '♠️ 扑克',
                        '🧠 Psychologie': '🧠 心理学',
                        '🎭 Bluff': '🎭 虚张声势',
                        '🃏 Blackjack': '🃏 21点',
                        '📊 Probabilité': '📊 概率',
                        '🂡 Solitaire': '🂡 纸牌',
                        '🔄 Fusion': '🔄 融合',
                        '♦️ Variantes': '♦️ 变体',
                        '🌲 Aventure': '🌲 冒险',
                        '🔮 Mystique': '🔮 神秘',
                        '📖 Narrative': '📖 叙事',
                        '🔍 Enquête': '🔍 调查',
                        '🕵️ Détective': '🕵️ 侦探',
                        '❓ Énigmes': '❓ 谜题',
                        '🏎️ Course': '🏎️ 赛车',
                        '🧠 Neural': '🧠 神经',
                        '🛣️ Adaptatif': '🛣️ 自适应',
                        '🎯 Tir': '🎯 射击',
                        '🌐 Cyber': '🌐 网络',
                        '⚛️ Armes': '⚛️ 武器',
                        '⚫ Points': '⚫ 点',
                        '🔮 Prédictif': '🔮 预测',
                        '🎵 Rythme': '🎵 节拍',
                        '🎼 Musical': '🎼 音乐',
                        '⚪ Flipper': '⚪ 弹球',
                        '⚛️ Tables': '⚛️ 桌子',
                        '🔧 Tuyaux': '🔧 管道',
                        '🧠 Logique': '🧠 逻辑',
                        '🎰 Slots': '🎰 老虎机',
                        '🎁 Bonus': '🎁 奖励',
                        '🎯 Fléchettes': '🎯 飞镖',
                        '⚛️ Cibles': '⚛️ 目标',
                        '🫧 Bulles': '🫧 泡泡',
                        '⚡ Physique': '⚡ 物理',
                        '🎲 Dés': '🎲 骰子',
                        '🎱 Billard': '🎱 台球',
                        '🔲 Tuiles': '🔲 瓷砖',
                        '🎨 Patterns': '🎨 图案',
                        '❓ Quiz': '❓ 问答',
                        '📚 Adaptatif': '📚 自适应',
                        '☄️ Espace': '☄️ 太空',
                        '💎 Cristaux': '💎 水晶',
                        '🎵 Harmonique': '🎵 和谐',
                        '∞ Infini': '∞ 无限',
                        '🌟 Ultime': '🌟 终极',
                        '🔬 Algorithme': '🔬 算法',
                        '👁️ Visuel': '👁️ 视觉',
                        '📚 Éducatif': '📚 教育',
                        '🔬 Physique': '🔬 物理',
                        '🧪 Simulation': '🧪 模拟',
                        '🔮 Sacré': '🔮 神圣',
                        '📐 Géométrie': '📐 几何',
                        '🎵 Harmonie': '🎵 和谐',
                        '🤖 Conscience': '🤖 意识',
                        '🧠 Philosophie': '🧠 哲学',
                        '💭 Existentiel': '💭 存在主义'
                    }
                }
            };

            const t = gameTranslations[lang] || gameTranslations.fr;

            // Traduire les titres des jeux en utilisant les textes originaux
            document.querySelectorAll('.game-card h3').forEach((title, index) => {
                const originalText = window.originalGameTexts.titles[index];
                if (originalText && t.games[originalText]) {
                    title.textContent = t.games[originalText];
                } else if (originalText) {
                    title.textContent = originalText; // Retour au français si pas de traduction
                }
            });

            // Traduire les descriptions des jeux en utilisant les textes originaux
            document.querySelectorAll('.game-card p').forEach((desc, index) => {
                const originalText = window.originalGameTexts.descriptions[index];
                if (originalText && t.descriptions[originalText]) {
                    desc.textContent = t.descriptions[originalText];
                } else if (originalText) {
                    desc.textContent = originalText; // Retour au français si pas de traduction
                }
            });

            // Traduire les statuts des jeux en utilisant les textes originaux
            document.querySelectorAll('.game-status').forEach((status, index) => {
                const originalText = window.originalGameTexts.statuses[index];
                if (originalText && t.status[originalText]) {
                    status.textContent = t.status[originalText];
                } else if (originalText) {
                    status.textContent = originalText; // Retour au français si pas de traduction
                }
            });

            // Traduire les tags des jeux en utilisant les textes originaux
            document.querySelectorAll('.tag').forEach((tag, index) => {
                const originalText = window.originalGameTexts.tags[index];
                if (originalText && t.tags && t.tags[originalText]) {
                    tag.textContent = t.tags[originalText];
                } else if (originalText) {
                    tag.textContent = originalText; // Retour au français si pas de traduction
                }
            });
        }

        // Fermer les menus en cliquant ailleurs
        document.addEventListener('click', function(event) {
            const languageSelector = document.querySelector('.language-selector');
            const tetrisLanguageSelector = document.querySelector('.tetris-language-selector');
            
            if (languageSelector && !languageSelector.contains(event.target)) {
                document.getElementById('languageMenu').classList.remove('active');
            }
            
            if (tetrisLanguageSelector && !tetrisLanguageSelector.contains(event.target)) {
                const tetrisMenu = document.getElementById('tetris-language-menu');
                if (tetrisMenu) {
                    tetrisMenu.classList.remove('active');
                }
            }
        });

        // Filtrer les jeux par catégorie
        function filterGames(category) {
            const gameCards = document.querySelectorAll('.game-card');
            const categoryButtons = document.querySelectorAll('.category-btn');
            
            // Réinitialiser les classes des boutons
            categoryButtons.forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Mettre en évidence le bouton actif
            event.target.classList.add('active');
            
            gameCards.forEach(card => {
                if (category === 'all') {
                    card.style.display = 'block';
                    card.style.opacity = '1';
                    card.style.transform = 'scale(1)';
                    card.style.filter = 'none';
                    card.style.animation = 'fadeInScale 0.5s ease-out';
                } else {
                    const cardCategories = card.getAttribute('data-category');
                    if (cardCategories && cardCategories.includes(category)) {
                        card.style.display = 'block';
                        card.style.opacity = '1';
                        card.style.transform = 'scale(1)';
                        card.style.filter = 'none';
                        card.style.animation = 'fadeInScale 0.5s ease-out';
                    } else {
                        card.style.display = 'none';
                    }
                }
            });
            
            // Mettre à jour le titre avec compteur
            const heroTitle = document.querySelector('.hero-section h2');
            const heroDescription = document.querySelector('.hero-section p');
            
            const visibleGames = document.querySelectorAll('.game-card[style*="display: block"], .game-card:not([style*="display: none"])');
            const gameCount = category === 'all' ? 36 : visibleGames.length;
            
            const categoryNames = {
                'all': `🎮 Découvrez nos ${gameCount} Jeux Intelligents`,
                'memory': `🧠 Jeux de Mémoire (${gameCount} jeux)`,
                'reflexion': `🧩 Jeux de Réflexion (${gameCount} jeux)`,
                'societe': `🎲 Jeux de Société (${gameCount} jeux)`,
                'arcade': `🕹️ Jeux d'Arcade (${gameCount} jeux)`,
                'science': `🔬 Jeux Scientifiques (${gameCount} jeux)`,
                'mystique': `🔮 Jeux Mystiques (${gameCount} jeux)`
            };
            
            const categoryDescriptions = {
                'all': 'Entraînez votre cerveau avec notre collection complète de jeux adaptatifs alimentés par l\'IA',
                'memory': 'Développez votre mémoire avec des défis adaptatifs et des exercices neuronaux avancés',
                'reflexion': 'Stimulez votre logique et votre raisonnement avec des puzzles intelligents',
                'societe': 'Partagez des moments conviviaux avec des jeux multijoueurs enrichis par l\'IA',
                'arcade': 'Testez vos réflexes et votre adresse avec des jeux d\'action futuristes',
                'science': 'Explorez les sciences et apprenez en vous amusant avec des simulations interactives',
                'mystique': 'Découvrez l\'inconnu et explorez des dimensions spirituelles et mystérieuses'
            };
            
            heroTitle.textContent = categoryNames[category] || heroTitle.textContent;
            heroDescription.textContent = categoryDescriptions[category] || heroDescription.textContent;
        }

        // Variables pour les jeux
        let currentGame = null;
    var gameState = {};

        // Quantum Tetris 2077 - Version Futuriste avec IA
        function playQuantumTetris() {
            currentGame = 'tetris';
            gameState = {
                board: Array(16).fill().map(() => Array(10).fill(0)),
                currentPiece: null,
                nextPiece: null,
                holdPiece: null,
                score: 0,
                level: 1,
                lines: 0,
                combo: 0,
                aiMode: false,
                quantumMode: false,
                gameRunning: false,
                dropTime: 1000,
                lastDrop: 0,
                aiPrediction: [],
                quantumEffects: [],
                language: currentLanguage || 'fr'
            };
            
            const translations = {
                fr: {
                    title: "🎮 Quantum Tetris 2077",
                    score: "Score",
                    level: "Niveau",
                    lines: "Lignes",
                    combo: "Combo",
                    next: "Suivant",
                    hold: "Réserve",
                    aiMode: "Mode IA",
                    quantumMode: "Mode Quantique",
                    aiPrediction: "Prédiction IA",
                    start: "▶️ Démarrer",
                    pause: "⏸️ Pause",
                    reset: "🔄 Reset",
                    settings: "⚙️ Paramètres",
                    language: "🌐 Langue"
                },
                en: {
                    title: "🎮 Quantum Tetris 2077",
                    score: "Score",
                    level: "Level",
                    lines: "Lines",
                    combo: "Combo",
                    next: "Next",
                    hold: "Hold",
                    aiMode: "AI Mode",
                    quantumMode: "Quantum Mode",
                    aiPrediction: "AI Prediction",
                    start: "▶️ Start",
                    pause: "⏸️ Pause",
                    reset: "🔄 Reset",
                    settings: "⚙️ Settings",
                    language: "🌐 Language"
                },
                ar: {
                    title: "🎮 تيتريس الكمي 2077",
                    score: "النقاط",
                    level: "المستوى",
                    lines: "الخطوط",
                    combo: "التسلسل",
                    next: "التالي",
                    hold: "الاحتياط",
                    aiMode: "وضع الذكاء الاصطناعي",
                    quantumMode: "الوضع الكمي",
                    aiPrediction: "توقع الذكاء الاصطناعي",
                    start: "▶️ ابدأ",
                    pause: "⏸️ توقف",
                    reset: "🔄 إعادة تعيين",
                    settings: "⚙️ الإعدادات",
                    language: "🌐 اللغة"
                },
                es: {
                    title: "🎮 Quantum Tetris 2077",
                    score: "Puntuación",
                    level: "Nivel",
                    lines: "Líneas",
                    combo: "Combo",
                    next: "Siguiente",
                    hold: "Reserva",
                    aiMode: "Modo IA",
                    quantumMode: "Modo Cuántico",
                    aiPrediction: "Predicción IA",
                    start: "▶️ Iniciar",
                    pause: "⏸️ Pausa",
                    reset: "🔄 Reiniciar",
                    settings: "⚙️ Configuración",
                    language: "🌐 Idioma"
                },
                zh: {
                    title: "🎮 量子俄罗斯方块 2077",
                    score: "分数",
                    level: "等级",
                    lines: "行数",
                    combo: "连击",
                    next: "下一个",
                    hold: "保留",
                    aiMode: "AI模式",
                    quantumMode: "量子模式",
                    aiPrediction: "AI预测",
                    start: "▶️ 开始",
                    pause: "⏸️ 暂停",
                    reset: "🔄 重置",
                    settings: "⚙️ 设置",
                    language: "🌐 语言"
                }
            };
            
            const t = translations[gameState.language] || translations.fr;
            
            showGameModal(`
                <div class="quantum-tetris-game">
                    <div class="tetris-header">
                        <h3 id="tetris-title">${t.title}</h3>
                        <div class="tetris-language-selector">
                            <button class="tetris-lang-btn" onclick="toggleTetrisLanguageMenu()">
                                🌐 <span id="tetris-current-lang">${gameState.language.toUpperCase()}</span>
                            </button>
                            <div class="tetris-language-menu" id="tetris-language-menu">
                                <div class="tetris-language-option" onclick="changeTetrisLanguage('fr')">🇫🇷 Français</div>
                                <div class="tetris-language-option" onclick="changeTetrisLanguage('en')">🇬🇧 English</div>
                                <div class="tetris-language-option" onclick="changeTetrisLanguage('ar')">🇸🇦 العربية</div>
                                <div class="tetris-language-option" onclick="changeTetrisLanguage('es')">🇪🇸 Español</div>
                                <div class="tetris-language-option" onclick="changeTetrisLanguage('zh')">🇨🇳 中文</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="tetris-main-container">
                        <div class="tetris-left-panel">
                            <div class="tetris-hold-area">
                                <h4>${t.hold}</h4>
                                <div id="tetris-hold-piece" class="piece-preview"></div>
                                <button onclick="holdTetrisPiece()" class="hold-btn">📦 Hold</button>
                            </div>
                            
                            <div class="tetris-stats">
                                <div class="stat-item">
                                    <span>${t.score}:</span>
                                    <span id="tetris-score" class="stat-value">0</span>
                                </div>
                                <div class="stat-item">
                                    <span>${t.level}:</span>
                                    <span id="tetris-level" class="stat-value">1</span>
                                </div>
                                <div class="stat-item">
                                    <span>${t.lines}:</span>
                                    <span id="tetris-lines" class="stat-value">0</span>
                                </div>
                                <div class="stat-item">
                                    <span>${t.combo}:</span>
                                    <span id="tetris-combo" class="stat-value">0</span>
                                </div>
                            </div>
                            
                            <div class="tetris-ai-panel">
                                <h4>🤖 ${t.aiPrediction}</h4>
                                <div id="tetris-ai-suggestion" class="ai-suggestion">
                                    <div class="ai-thinking">🧠 Analyse en cours...</div>
                                </div>
                                <div class="ai-confidence">
                                    <span>Confiance: </span>
                                    <div class="confidence-bar">
                                        <div id="ai-confidence-fill" class="confidence-fill"></div>
                                    </div>
                                    <span id="ai-confidence-text">0%</span>
                                </div>
                            </div>
                        </div>
                        
                        <div class="tetris-game-area">
                            <div class="tetris-main-controls">
                                <button onclick="toggleTetrisGame()" id="tetris-play-btn" class="control-btn primary">${t.start}</button>
                                <button onclick="resetTetrisGame()" class="control-btn">${t.reset}</button>
                            </div>
                            
                            <div class="tetris-board-container">
                                <div id="tetris-board" class="tetris-board"></div>
                                <div id="tetris-quantum-effects" class="quantum-effects"></div>
                            </div>
                            
                            <div class="tetris-controls">
                                <div class="control-row">
                                    <button onclick="moveTetrisPiece('left')" class="control-btn">⬅️</button>
                                    <button onclick="rotateTetrisPiece()" class="control-btn">🔄</button>
                                    <button onclick="moveTetrisPiece('right')" class="control-btn">➡️</button>
                                </div>
                                <div class="control-row">
                                    <button onclick="softDropTetris()" class="control-btn">⬇️</button>
                                    <button onclick="hardDropTetris()" class="control-btn">⚡</button>
                                    <button onclick="holdTetrisPiece()" class="control-btn">📦</button>
                                </div>
                            </div>
                        </div>
                        
                        <div class="tetris-right-panel">
                            <div class="tetris-next-area">
                                <h4>${t.next}</h4>
                                <div id="tetris-next-piece" class="piece-preview"></div>
                            </div>
                            
                            <div class="tetris-modes">
                                <div class="mode-toggle">
                                    <label class="switch">
                                        <input type="checkbox" id="ai-mode-toggle" onchange="toggleAIMode()">
                                        <span class="slider"></span>
                                    </label>
                                    <span>${t.aiMode}</span>
                                </div>
                                
                                <div class="mode-toggle">
                                    <label class="switch">
                                        <input type="checkbox" id="quantum-mode-toggle" onchange="toggleQuantumMode()">
                                        <span class="slider quantum"></span>
                                    </label>
                                    <span>${t.quantumMode}</span>
                                </div>
                            </div>
                            
                            <div class="tetris-effects-panel">
                                <h4>⚛️ Effets Quantiques</h4>
                                <div id="quantum-effects-list" class="effects-list">
                                    <div class="effect-item">🌀 Superposition</div>
                                    <div class="effect-item">⚡ Téléportation</div>
                                    <div class="effect-item">🔮 Prédiction</div>
                                </div>
                            </div>
                            
                            <div class="tetris-achievements">
                                <h4>🏆 Succès</h4>
                                <div id="achievements-list" class="achievements-list">
                                    <div class="achievement locked">🥉 Première ligne</div>
                                    <div class="achievement locked">🥈 Tetris Master</div>
                                    <div class="achievement locked">🥇 Quantum God</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `);
            
            initQuantumTetrisBoard();
            generateTetrisPieces();
            updateTetrisDisplay();
            startTetrisAI();
        }

        // Memory Quantique - Version Futuriste avec IA
        function playMemoryQuantique() {
            currentGame = 'memory';
            
            // Générateur d'icônes quantiques infinies
            const quantumIcons = [
                // Niveau 1-3: Symboles de base
                ['🧠', '⚡', '🔮', '💎', '🌟', '⚛️', '🎯', '🚀', '🌀', '💫'],
                // Niveau 4-6: Technologie
                ['🤖', '🛸', '🔬', '🧪', '⚙️', '🔋', '💻', '📡', '🛰️', '🔭'],
                // Niveau 7-9: Énergie cosmique
                ['🌌', '🌠', '☄️', '🌙', '☀️', '🪐', '🌍', '🌊', '⚡', '🔥'],
                // Niveau 10-12: Dimensions
                ['🎭', '🎪', '🎨', '🎵', '🎼', '🎹', '🎸', '🥁', '🎺', '🎻'],
                // Niveau 13-15: Transcendance
                ['👁️', '🧿', '🔯', '☯️', '🕉️', '🔱', '⚕️', '♾️', '🌈', '✨']
            ];
            
            gameState = {
                level: 1,
                maxLevel: 15,
                pairsCount: 2,
                cards: [],
                flipped: [],
                matched: [],
                moves: 0,
                timer: 0,
                score: 0,
                streak: 0,
                aiDifficulty: 1,
                quantumEffects: true,
                morphingEnabled: true,
                morphTimer: null,
                aiHints: 0,
                perfectMatches: 0,
                language: currentLanguage || 'fr'
            };
            
            const translations = {
                fr: {
                    title: "🧠 Memory Quantique 2077",
                    level: "Niveau",
                    pairs: "Paires",
                    moves: "Coups",
                    time: "Temps",
                    score: "Score",
                    streak: "Série",
                    aiDifficulty: "Difficulté IA",
                    quantumEffects: "Effets Quantiques",
                    morphing: "Morphing Infini",
                    aiHint: "💡 Indice IA",
                    reset: "🔄 Reset",
                    nextLevel: "➡️ Niveau Suivant",
                    prevLevel: "⬅️ Niveau Précédent",
                    aiAnalysis: "🤖 Analyse IA",
                    quantumField: "⚛️ Champ Quantique",
                    neuralNetwork: "🧠 Réseau Neural",
                    performance: "📊 Performance"
                },
                en: {
                    title: "🧠 Quantum Memory 2077",
                    level: "Level",
                    pairs: "Pairs",
                    moves: "Moves",
                    time: "Time",
                    score: "Score",
                    streak: "Streak",
                    aiDifficulty: "AI Difficulty",
                    quantumEffects: "Quantum Effects",
                    morphing: "Infinite Morphing",
                    aiHint: "💡 AI Hint",
                    reset: "🔄 Reset",
                    nextLevel: "➡️ Next Level",
                    prevLevel: "⬅️ Previous Level",
                    aiAnalysis: "🤖 AI Analysis",
                    quantumField: "⚛️ Quantum Field",
                    neuralNetwork: "🧠 Neural Network",
                    performance: "📊 Performance"
                },
                ar: {
                    title: "🧠 الذاكرة الكمية 2077",
                    level: "المستوى",
                    pairs: "الأزواج",
                    moves: "الحركات",
                    time: "الوقت",
                    score: "النقاط",
                    streak: "السلسلة",
                    aiDifficulty: "صعوبة الذكاء الاصطناعي",
                    quantumEffects: "التأثيرات الكمية",
                    morphing: "التحول اللانهائي",
                    aiHint: "💡 تلميح الذكاء الاصطناعي",
                    reset: "🔄 إعادة تعيين",
                    nextLevel: "➡️ المستوى التالي",
                    prevLevel: "⬅️ المستوى السابق",
                    aiAnalysis: "🤖 تحليل الذكاء الاصطناعي",
                    quantumField: "⚛️ المجال الكمي",
                    neuralNetwork: "🧠 الشبكة العصبية",
                    performance: "📊 الأداء"
                },
                es: {
                    title: "🧠 Memoria Cuántica 2077",
                    level: "Nivel",
                    pairs: "Pares",
                    moves: "Movimientos",
                    time: "Tiempo",
                    score: "Puntuación",
                    streak: "Racha",
                    aiDifficulty: "Dificultad IA",
                    quantumEffects: "Efectos Cuánticos",
                    morphing: "Morfismo Infinito",
                    aiHint: "💡 Pista IA",
                    reset: "🔄 Reiniciar",
                    nextLevel: "➡️ Siguiente Nivel",
                    prevLevel: "⬅️ Nivel Anterior",
                    aiAnalysis: "🤖 Análisis IA",
                    quantumField: "⚛️ Campo Cuántico",
                    neuralNetwork: "🧠 Red Neural",
                    performance: "📊 Rendimiento"
                },
                zh: {
                    title: "🧠 量子记忆 2077",
                    level: "等级",
                    pairs: "配对",
                    moves: "移动",
                    time: "时间",
                    score: "分数",
                    streak: "连击",
                    aiDifficulty: "AI难度",
                    quantumEffects: "量子效应",
                    morphing: "无限变形",
                    aiHint: "💡 AI提示",
                    reset: "🔄 重置",
                    nextLevel: "➡️ 下一级",
                    prevLevel: "⬅️ 上一级",
                    aiAnalysis: "🤖 AI分析",
                    quantumField: "⚛️ 量子场",
                    neuralNetwork: "🧠 神经网络",
                    performance: "📊 性能"
                }
            };
            
            const t = translations[gameState.language] || translations.fr;
            
            showGameModal(`
                <div class="quantum-memory-game">
                    <div class="memory-header">
                        <h3 id="memory-title">${t.title}</h3>
                        <div class="memory-language-selector">
                            <button class="memory-lang-btn" onclick="toggleMemoryLanguageMenu()">
                                🌐 <span id="memory-current-lang">${gameState.language.toUpperCase()}</span>
                            </button>
                            <div class="memory-language-menu" id="memory-language-menu">
                                <div class="memory-language-option" onclick="changeMemoryLanguage('fr')">🇫🇷 Français</div>
                                <div class="memory-language-option" onclick="changeMemoryLanguage('en')">🇬🇧 English</div>
                                <div class="memory-language-option" onclick="changeMemoryLanguage('ar')">🇸🇦 العربية</div>
                                <div class="memory-language-option" onclick="changeMemoryLanguage('es')">🇪🇸 Español</div>
                                <div class="memory-language-option" onclick="changeMemoryLanguage('zh')">🇨🇳 中文</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="memory-main-container">
                        <div class="memory-left-panel">
                            <div class="memory-stats">
                                <div class="stat-group">
                                    <div class="stat-item">
                                        <span>${t.level}:</span>
                                        <span id="memory-level" class="stat-value">1</span>
                                    </div>
                                    <div class="stat-item">
                                        <span>${t.pairs}:</span>
                                        <span id="memory-pairs" class="stat-value">2</span>
                                    </div>
                                    <div class="stat-item">
                                        <span>${t.moves}:</span>
                                        <span id="memory-moves" class="stat-value">0</span>
                                    </div>
                                    <div class="stat-item">
                                        <span>${t.time}:</span>
                                        <span id="memory-timer" class="stat-value">0s</span>
                                    </div>
                                </div>
                                
                                <div class="stat-group">
                                    <div class="stat-item">
                                        <span>${t.score}:</span>
                                        <span id="memory-score" class="stat-value">0</span>
                                    </div>
                                    <div class="stat-item">
                                        <span>${t.streak}:</span>
                                        <span id="memory-streak" class="stat-value">0</span>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="memory-ai-panel">
                                <h4>🤖 ${t.aiAnalysis}</h4>
                                <div id="memory-ai-analysis" class="ai-analysis">
                                    <div class="ai-thinking">🧠 Initialisation...</div>
                                </div>
                                <div class="ai-difficulty">
                                    <span>${t.aiDifficulty}: </span>
                                    <div class="difficulty-bar">
                                        <div id="ai-difficulty-fill" class="difficulty-fill"></div>
                                    </div>
                                    <span id="ai-difficulty-text">1</span>
                                </div>
                                <button onclick="getAIHint()" class="ai-hint-btn">${t.aiHint} (3)</button>
                            </div>
                            
                            <div class="memory-quantum-panel">
                                <h4>⚛️ ${t.quantumField}</h4>
                                <div class="quantum-visualizer" id="quantum-visualizer">
                                    <div class="quantum-particle"></div>
                                    <div class="quantum-particle"></div>
                                    <div class="quantum-particle"></div>
                                </div>
                                <div class="quantum-controls">
                                    <label class="quantum-switch">
                                        <input type="checkbox" id="quantum-effects-toggle" checked onchange="toggleQuantumEffects()">
                                        <span class="quantum-slider"></span>
                                    </label>
                                    <span>${t.quantumEffects}</span>
                                </div>
                                <div class="quantum-controls">
                                    <label class="quantum-switch">
                                        <input type="checkbox" id="morphing-toggle" checked onchange="toggleMorphing()">
                                        <span class="quantum-slider morphing"></span>
                                    </label>
                                    <span>${t.morphing}</span>
                                </div>
                            </div>
                        </div>
                        
                        <div class="memory-game-area">
                            <div class="memory-controls">
                                <button onclick="previousMemoryLevel()" class="memory-control-btn secondary" id="prev-level-btn" style="display:none">${t.prevLevel}</button>
                                <button onclick="resetMemoryGame()" class="memory-control-btn">${t.reset}</button>
                                <button onclick="nextMemoryLevel()" class="memory-control-btn primary" id="next-level-btn" style="display:none">${t.nextLevel}</button>
                            </div>
                            
                            <div class="memory-board-container">
                                <div id="memory-board" class="memory-board"></div>
                                <div id="memory-effects" class="memory-effects"></div>
                            </div>
                            
                            <div class="memory-progress">
                                <div class="progress-bar">
                                    <div id="level-progress" class="progress-fill"></div>
                                </div>
                                <div class="progress-text">
                                    <span>Progression: </span>
                                    <span id="progress-percentage">0%</span>
                                </div>
                            </div>
                        </div>
                        
                        <div class="memory-right-panel">
                            <div class="memory-neural-panel">
                                <h4>🧠 ${t.neuralNetwork}</h4>
                                <div class="neural-network" id="neural-network">
                                    <div class="neural-layer">
                                        <div class="neuron active"></div>
                                        <div class="neuron"></div>
                                        <div class="neuron"></div>
                                    </div>
                                    <div class="neural-layer">
                                        <div class="neuron"></div>
                                        <div class="neuron active"></div>
                                        <div class="neuron"></div>
                                        <div class="neuron"></div>
                                    </div>
                                    <div class="neural-layer">
                                        <div class="neuron"></div>
                                        <div class="neuron"></div>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="memory-performance-panel">
                                <h4>📊 ${t.performance}</h4>
                                <div class="performance-metrics">
                                    <div class="metric">
                                        <span>Précision:</span>
                                        <span id="accuracy-metric">100%</span>
                                    </div>
                                    <div class="metric">
                                        <span>Vitesse:</span>
                                        <span id="speed-metric">0.0s</span>
                                    </div>
                                    <div class="metric">
                                        <span>Efficacité:</span>
                                        <span id="efficiency-metric">0%</span>
                                    </div>
                                </div>
                                <div class="performance-graph" id="performance-graph">
                                    <div class="graph-bar" style="height: 20%"></div>
                                    <div class="graph-bar" style="height: 40%"></div>
                                    <div class="graph-bar" style="height: 60%"></div>
                                    <div class="graph-bar" style="height: 30%"></div>
                                    <div class="graph-bar" style="height: 80%"></div>
                                </div>
                            </div>
                            
                            <div class="memory-achievements">
                                <h4>🏆 Succès Quantiques</h4>
                                <div class="achievements-list">
                                    <div class="achievement locked" id="first-match">🥉 Premier Match</div>
                                    <div class="achievement locked" id="perfect-level">🥈 Niveau Parfait</div>
                                    <div class="achievement locked" id="speed-demon">⚡ Démon de Vitesse</div>
                                    <div class="achievement locked" id="memory-master">🧠 Maître Mémoire</div>
                                    <div class="achievement locked" id="quantum-god">🥇 Dieu Quantique</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `);
            
            initQuantumMemoryGame();
            startMemoryTimer();
            startQuantumEffects();
            startMorphingSystem();
        }

        // Neural Puzzle Master
        function playNeuralPuzzle() {
            currentGame = 'puzzle';
            const puzzleSize = 4;
            let numbers = Array.from({length: puzzleSize * puzzleSize - 1}, (_, i) => i + 1);
            numbers.push(0); // Case vide
            
            // Mélanger le puzzle
            for (let i = 0; i < 1000; i++) {
                const emptyIndex = numbers.indexOf(0);
                const possibleMoves = [];
                
                if (emptyIndex % puzzleSize !== 0) possibleMoves.push(emptyIndex - 1);
                if (emptyIndex % puzzleSize !== puzzleSize - 1) possibleMoves.push(emptyIndex + 1);
                if (emptyIndex >= puzzleSize) possibleMoves.push(emptyIndex - puzzleSize);
                if (emptyIndex < puzzleSize * (puzzleSize - 1)) possibleMoves.push(emptyIndex + puzzleSize);
                
                const randomMove = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                [numbers[emptyIndex], numbers[randomMove]] = [numbers[randomMove], numbers[emptyIndex]];
            }
            
            gameState = {
                puzzle: numbers,
                moves: 0,
                size: puzzleSize
            };
            
            showGameModal(`
                <div class="puzzle-game">
                    <div class="puzzle-header">
                        <h3>🧩 Neural Puzzle Master</h3>
                        <div class="puzzle-stats">
                            <div>Coups: <span id="puzzle-moves">0</span></div>
                        </div>
                    </div>
                    <div class="puzzle-board" id="puzzle-board">
                        ${numbers.map((num, index) => `
                            <div class="puzzle-tile ${num === 0 ? 'empty' : ''}" 
                                 data-index="${index}" 
                                 onclick="movePuzzleTile(${index})">
                                ${num === 0 ? '' : num}
                            </div>
                        `).join('')}
                    </div>
                    <button onclick="shufflePuzzle()" class="puzzle-shuffle">🔄 Mélanger</button>
                </div>
            `);
        }

        // Pac-Man
        function playPacMan() {
            currentGame = 'pacman';
            gameState = {
                pacman: {x: 9, y: 15},
                ghosts: [
                    {x: 9, y: 9, color: '👻'},
                    {x: 8, y: 9, color: '👾'},
                    {x: 10, y: 9, color: '🤖'},
                    {x: 11, y: 9, color: '👹'}
                ],
                score: 0,
                dots: 0,
                gameRunning: false
            };
            
            showGameModal(`
                <div class="pacman-game">
                    <div class="pacman-header">
                        <h3>🟡 Pac-Man Quantique</h3>
                        <div class="pacman-stats">
                            <div>Score: <span id="pacman-score">0</span></div>
                            <div>Dots: <span id="pacman-dots">0</span></div>
                        </div>
                    </div>
                    <div class="pacman-board" id="pacman-board"></div>
                    <div class="pacman-controls">
                        <div class="pacman-control-row">
                            <button onclick="movePacman('up')">⬆️</button>
                        </div>
                        <div class="pacman-control-row">
                            <button onclick="movePacman('left')">⬅️</button>
                            <button onclick="togglePacmanGame()">⏯️</button>
                            <button onclick="movePacman('right')">➡️</button>
                        </div>
                        <div class="pacman-control-row">
                            <button onclick="movePacman('down')">⬇️</button>
                        </div>
                    </div>
                </div>
            `);
            
            initPacmanBoard();
        }

        // Simon Says
        function playSimonSays() {
            currentGame = 'simon';
            gameState = {
                sequence: [],
                playerSequence: [],
                level: 1,
                isPlaying: false,
                isPlayerTurn: false
            };
            
            showGameModal(`
                <div class="simon-game">
                    <div class="simon-header">
                        <h3>🔴 Simon Says Quantique</h3>
                        <div class="simon-stats">
                            <div>Niveau: <span id="simon-level">1</span></div>
                        </div>
                    </div>
                    <div class="simon-board">
                        <div class="simon-button red" data-color="red" onclick="simonButtonClick('red')"></div>
                        <div class="simon-button blue" data-color="blue" onclick="simonButtonClick('blue')"></div>
                        <div class="simon-button green" data-color="green" onclick="simonButtonClick('green')"></div>
                        <div class="simon-button yellow" data-color="yellow" onclick="simonButtonClick('yellow')"></div>
                    </div>
                    <div class="simon-controls">
                        <button onclick="launchGame7()" id="simon-start">🎮 Commencer</button>
                        <button onclick="launchGame7()">🔄 Reset</button>
                    </div>
                    <div class="simon-message" id="simon-message">Cliquez sur Commencer!</div>
                </div>
            `);
        }

        // Fonctions utilitaires pour les jeux
        function showGameModal(content) {
            const modal = document.createElement('div');
            modal.className = 'game-modal';
            modal.innerHTML = `
                <div class="game-modal-content">
                    <button class="game-modal-close" onclick="closeGameModal()">❌</button>
                    ${content}
                </div>
            `;
            document.body.appendChild(modal);
            
            // Ajouter les styles pour le modal
            if (!document.getElementById('game-modal-styles')) {
                const styles = document.createElement('style');
                styles.id = 'game-modal-styles';
                styles.textContent = `
                    .game-modal {
                        position: fixed;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: rgba(0, 0, 0, 0.9);
                        display: flex;
                        justify-content: center;
                        align-items: center;
                        z-index: 10000;
                        backdrop-filter: blur(10px);
                    }
                    
                    .game-modal-content {
                        background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(26, 26, 46, 0.95));
                        border: 2px solid #00d4ff;
                        border-radius: 20px;
                        padding: 15px;
                        max-width: 95vw;
                        max-height: 85vh;
                        overflow-y: auto;
                        position: relative;
                        box-shadow: 0 0 50px rgba(0, 212, 255, 0.5);
                    }
                    
                    .game-modal-close {
                        position: absolute;
                        top: 10px;
                        right: 10px;
                        background: linear-gradient(45deg, #ff0096, #ff4757);
                        border: none;
                        border-radius: 50%;
                        width: 40px;
                        height: 40px;
                        color: white;
                        font-size: 1.2rem;
                        cursor: pointer;
                        transition: all 0.3s ease;
                    }
                    
                    .game-modal-close:hover {
                        transform: scale(1.1);
                        box-shadow: 0 0 20px rgba(255, 0, 150, 0.5);
                    }
                    
                    /* Styles Quantum Tetris 2077 */
                    .quantum-tetris-game {
                        color: white;
                        font-family: 'Rajdhani', sans-serif;
                        max-width: 1200px;
                        margin: 0 auto;
                    }
                    
                    .tetris-header {
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                        margin-bottom: 20px;
                        padding: 15px;
                        background: linear-gradient(135deg, rgba(0, 212, 255, 0.1), rgba(255, 0, 150, 0.1));
                        border-radius: 15px;
                        border: 1px solid rgba(0, 212, 255, 0.3);
                    }
                    
                    .tetris-language-selector {
                        position: relative;
                        display: inline-block;
                    }
                    
                    .tetris-lang-btn {
                        background: linear-gradient(45deg, #1a1a2e, #16213e);
                        border: 2px solid #00d4ff;
                        border-radius: 10px;
                        color: white;
                        padding: 8px 12px;
                        font-family: 'Rajdhani', sans-serif;
                        font-weight: bold;
                        cursor: pointer;
                        transition: all 0.3s ease;
                    }
                    
                    .tetris-lang-btn:hover {
                        background: linear-gradient(45deg, #00d4ff, #ff0096);
                        transform: scale(1.05);
                    }
                    
                    .tetris-language-menu {
                        position: absolute;
                        top: 100%;
                        right: 0;
                        background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(26, 26, 46, 0.95));
                        backdrop-filter: blur(20px);
                        border: 2px solid #00d4ff;
                        border-radius: 15px;
                        min-width: 180px;
                        box-shadow: 0 10px 30px rgba(0, 212, 255, 0.4);
                        opacity: 0;
                        visibility: hidden;
                        transform: translateY(-10px) scale(0.95);
                        transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
                        z-index: 1000;
                        overflow: hidden;
                    }
                    
                    .tetris-language-menu.active {
                        opacity: 1;
                        visibility: visible;
                        transform: translateY(0) scale(1);
                    }
                    
                    .tetris-language-option {
                        padding: 12px 16px;
                        color: #ffffff;
                        cursor: pointer;
                        transition: all 0.3s ease;
                        font-family: 'Rajdhani', sans-serif;
                        font-weight: 600;
                        border-bottom: 1px solid rgba(0, 212, 255, 0.2);
                        position: relative;
                        overflow: hidden;
                    }
                    
                    .tetris-language-option:last-child {
                        border-bottom: none;
                    }
                    
                    .tetris-language-option:hover {
                        background: linear-gradient(90deg, rgba(0, 212, 255, 0.2), rgba(255, 0, 150, 0.2));
                        color: #00d4ff;
                        transform: translateX(5px);
                        text-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
                    }
                    
                    .tetris-main-container {
                        display: grid;
                        grid-template-columns: 250px 1fr 250px;
                        gap: 20px;
                        align-items: start;
                    }
                    
                    .tetris-left-panel, .tetris-right-panel {
                        background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(26, 26, 46, 0.8));
                        border: 2px solid #00d4ff;
                        border-radius: 15px;
                        padding: 15px;
                        backdrop-filter: blur(10px);
                    }
                    
                    .tetris-game-area {
                        text-align: center;
                    }
                    
                    .tetris-board-container {
                        position: relative;
                        display: inline-block;
                        margin-bottom: 20px;
                    }
                    
                    .tetris-board {
                        display: grid;
                        grid-template-columns: repeat(10, 25px);
                        grid-template-rows: repeat(16, 25px);
                        gap: 1px;
                        background: #000;
                        border: 3px solid #00d4ff;
                        border-radius: 10px;
                        padding: 5px;
                        position: relative;
                        box-shadow: 0 0 30px rgba(0, 212, 255, 0.5);
                    }
                    
                    .tetris-cell {
                        width: 25px;
                        height: 25px;
                        background: #111;
                        border: 1px solid #333;
                        border-radius: 3px;
                        position: relative;
                        transition: all 0.3s ease;
                    }
                    
                    .tetris-cell.filled {
                        background: linear-gradient(45deg, #00d4ff, #ff0096);
                        border-color: #00d4ff;
                        box-shadow: 0 0 10px rgba(0, 212, 255, 0.7);
                        animation: tetrisPulse 2s infinite;
                    }
                    
                    .tetris-cell.quantum {
                        background: linear-gradient(45deg, #ff0096, #00ff88, #ffd700);
                        background-size: 200% 200%;
                        animation: quantumShift 1s infinite, tetrisPulse 2s infinite;
                    }
                    
                    .tetris-cell.current-piece {
                        box-shadow: 0 0 15px rgba(0, 212, 255, 0.8);
                        animation: currentPiecePulse 1s infinite;
                    }
                    
                    @keyframes currentPiecePulse {
                        0%, 100% { box-shadow: 0 0 15px rgba(0, 212, 255, 0.8); }
                        50% { box-shadow: 0 0 25px rgba(0, 212, 255, 1); }
                    }
                    
                    @keyframes tetrisPulse {
                        0%, 100% { box-shadow: 0 0 10px rgba(0, 212, 255, 0.7); }
                        50% { box-shadow: 0 0 20px rgba(0, 212, 255, 1); }
                    }
                    
                    @keyframes quantumShift {
                        0% { background-position: 0% 50%; }
                        50% { background-position: 100% 50%; }
                        100% { background-position: 0% 50%; }
                    }
                    

                    
                    .quantum-effects {
                        position: absolute;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        pointer-events: none;
                        overflow: hidden;
                    }
                    
                    .quantum-particle {
                        position: absolute;
                        width: 4px;
                        height: 4px;
                        background: #00d4ff;
                        border-radius: 50%;
                        animation: quantumFloat 3s infinite linear;
                    }
                    
                    @keyframes quantumFloat {
                        0% { transform: translateY(100%) rotate(0deg); opacity: 0; }
                        10% { opacity: 1; }
                        90% { opacity: 1; }
                        100% { transform: translateY(-100%) rotate(360deg); opacity: 0; }
                    }
                    
                    .tetris-stats {
                        margin: 15px 0;
                    }
                    
                    .stat-item {
                        display: flex;
                        justify-content: space-between;
                        margin: 8px 0;
                        padding: 5px 10px;
                        background: rgba(0, 212, 255, 0.1);
                        border-radius: 8px;
                        border: 1px solid rgba(0, 212, 255, 0.3);
                    }
                    
                    .stat-value {
                        font-weight: bold;
                        color: #00d4ff;
                    }
                    
                    .tetris-ai-panel {
                        margin-top: 20px;
                        padding: 15px;
                        background: linear-gradient(135deg, rgba(0, 255, 136, 0.1), rgba(255, 215, 0, 0.1));
                        border: 2px solid #00ff88;
                        border-radius: 10px;
                    }
                    
                    .ai-suggestion {
                        background: rgba(0, 0, 0, 0.5);
                        border-radius: 8px;
                        padding: 10px;
                        margin: 10px 0;
                        min-height: 40px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    }
                    
                    .ai-thinking {
                        color: #00ff88;
                        animation: aiThinking 2s infinite;
                    }
                    
                    @keyframes aiThinking {
                        0%, 100% { opacity: 0.5; }
                        50% { opacity: 1; }
                    }
                    
                    .ai-confidence {
                        display: flex;
                        align-items: center;
                        gap: 10px;
                        margin-top: 10px;
                    }
                    
                    .confidence-bar {
                        flex: 1;
                        height: 8px;
                        background: rgba(0, 0, 0, 0.5);
                        border-radius: 4px;
                        overflow: hidden;
                    }
                    
                    .confidence-fill {
                        height: 100%;
                        background: linear-gradient(90deg, #ff0096, #00ff88);
                        width: 0%;
                        transition: width 0.5s ease;
                    }
                    
                    .piece-preview {
                        width: 80px;
                        height: 80px;
                        background: rgba(0, 0, 0, 0.5);
                        border: 2px solid #00d4ff;
                        border-radius: 10px;
                        margin: 10px auto;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        position: relative;
                    }
                    
                    .tetris-main-controls {
                        display: flex;
                        gap: 15px;
                        justify-content: center;
                        margin-bottom: 15px;
                    }
                    
                    .tetris-controls {
                        display: flex;
                        flex-direction: column;
                        gap: 10px;
                        align-items: center;
                        margin-top: 15px;
                    }
                    
                    .control-row {
                        display: flex;
                        gap: 10px;
                    }
                    
                    .control-btn {
                        background: linear-gradient(45deg, #00d4ff, #ff0096);
                        border: none;
                        border-radius: 10px;
                        padding: 12px 16px;
                        color: white;
                        font-size: 1.1rem;
                        font-weight: bold;
                        cursor: pointer;
                        transition: all 0.3s ease;
                        min-width: 50px;
                    }
                    
                    .control-btn:hover {
                        transform: scale(1.05);
                        box-shadow: 0 0 20px rgba(0, 212, 255, 0.6);
                    }
                    
                    .control-btn.primary {
                        background: linear-gradient(45deg, #00ff88, #ffd700);
                        color: #000;
                        font-size: 1.2rem;
                        padding: 15px 25px;
                    }
                    
                    .tetris-modes {
                        margin: 20px 0;
                    }
                    
                    .mode-toggle {
                        display: flex;
                        align-items: center;
                        gap: 10px;
                        margin: 15px 0;
                    }
                    
                    .switch {
                        position: relative;
                        display: inline-block;
                        width: 50px;
                        height: 24px;
                    }
                    
                    .switch input {
                        opacity: 0;
                        width: 0;
                        height: 0;
                    }
                    
                    .slider {
                        position: absolute;
                        cursor: pointer;
                        top: 0;
                        left: 0;
                        right: 0;
                        bottom: 0;
                        background-color: #333;
                        transition: .4s;
                        border-radius: 24px;
                        border: 2px solid #00d4ff;
                    }
                    
                    .slider:before {
                        position: absolute;
                        content: "";
                        height: 16px;
                        width: 16px;
                        left: 2px;
                        bottom: 2px;
                        background-color: #00d4ff;
                        transition: .4s;
                        border-radius: 50%;
                    }
                    
                    input:checked + .slider {
                        background: linear-gradient(45deg, #00d4ff, #ff0096);
                    }
                    
                    input:checked + .slider:before {
                        transform: translateX(24px);
                        background-color: white;
                    }
                    
                    .slider.quantum {
                        border-color: #00ff88;
                    }
                    
                    .slider.quantum:before {
                        background-color: #00ff88;
                    }
                    
                    input:checked + .slider.quantum {
                        background: linear-gradient(45deg, #00ff88, #ffd700);
                    }
                    
                    .effects-list, .achievements-list {
                        margin-top: 10px;
                    }
                    
                    .effect-item, .achievement {
                        padding: 8px 12px;
                        margin: 5px 0;
                        background: rgba(0, 212, 255, 0.1);
                        border: 1px solid rgba(0, 212, 255, 0.3);
                        border-radius: 8px;
                        font-size: 0.9rem;
                        transition: all 0.3s ease;
                    }
                    
                    .effect-item:hover {
                        background: rgba(0, 212, 255, 0.2);
                        transform: translateX(5px);
                    }
                    
                    .achievement.locked {
                        opacity: 0.5;
                        filter: grayscale(1);
                    }
                    
                    .achievement.unlocked {
                        background: linear-gradient(45deg, rgba(0, 255, 136, 0.2), rgba(255, 215, 0, 0.2));
                        border-color: #00ff88;
                        animation: achievementGlow 2s infinite;
                    }
                    
                    @keyframes achievementGlow {
                        0%, 100% { box-shadow: 0 0 10px rgba(0, 255, 136, 0.5); }
                        50% { box-shadow: 0 0 20px rgba(0, 255, 136, 0.8); }
                    }
                    
                    .hold-btn {
                        background: linear-gradient(45deg, #ff0096, #ffd700);
                        border: none;
                        border-radius: 8px;
                        padding: 8px 16px;
                        color: white;
                        font-weight: bold;
                        cursor: pointer;
                        width: 100%;
                        margin-top: 10px;
                        transition: all 0.3s ease;
                    }
                    
                    .hold-btn:hover {
                        transform: scale(1.05);
                        box-shadow: 0 0 15px rgba(255, 0, 150, 0.5);
                    }
                    
                    /* Responsive pour Tetris */
                    @media (max-width: 1024px) {
                        .tetris-main-container {
                            grid-template-columns: 1fr;
                            grid-template-rows: auto auto auto;
                        }
                        
                        .tetris-left-panel, .tetris-right-panel {
                            display: grid;
                            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                            gap: 15px;
                        }
                    }
                    
                    @media (max-width: 768px) {
                        .tetris-board {
                            grid-template-columns: repeat(10, 25px);
                            grid-template-rows: repeat(20, 25px);
                        }
                        
                        .tetris-cell {
                            width: 25px;
                            height: 25px;
                        }
                        
                        .control-btn {
                            padding: 10px 12px;
                            font-size: 1rem;
                        }
                    }
                    
                    /* Styles Quantum Memory 2077 */
                    .quantum-memory-game {
                        color: white;
                        font-family: 'Rajdhani', sans-serif;
                        max-width: 1400px;
                        margin: 0 auto;
                    }
                    
                    .memory-header {
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                        margin-bottom: 20px;
                        padding: 15px;
                        background: linear-gradient(135deg, rgba(0, 212, 255, 0.1), rgba(255, 0, 150, 0.1));
                        border-radius: 15px;
                        border: 1px solid rgba(0, 212, 255, 0.3);
                    }
                    
                    .memory-language-selector {
                        position: relative;
                        display: inline-block;
                    }
                    
                    .memory-lang-btn {
                        background: linear-gradient(45deg, #1a1a2e, #16213e);
                        border: 2px solid #00d4ff;
                        border-radius: 10px;
                        color: white;
                        padding: 8px 12px;
                        font-family: 'Rajdhani', sans-serif;
                        font-weight: bold;
                        cursor: pointer;
                        transition: all 0.3s ease;
                    }
                    
                    .memory-lang-btn:hover {
                        background: linear-gradient(45deg, #00d4ff, #ff0096);
                        transform: scale(1.05);
                    }
                    
                    .memory-language-menu {
                        position: absolute;
                        top: 100%;
                        right: 0;
                        background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(26, 26, 46, 0.95));
                        backdrop-filter: blur(20px);
                        border: 2px solid #00d4ff;
                        border-radius: 15px;
                        min-width: 180px;
                        box-shadow: 0 10px 30px rgba(0, 212, 255, 0.4);
                        opacity: 0;
                        visibility: hidden;
                        transform: translateY(-10px) scale(0.95);
                        transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
                        z-index: 1000;
                        overflow: hidden;
                    }
                    
                    .memory-language-menu.active {
                        opacity: 1;
                        visibility: visible;
                        transform: translateY(0) scale(1);
                    }
                    
                    .memory-language-option {
                        padding: 12px 16px;
                        color: #ffffff;
                        cursor: pointer;
                        transition: all 0.3s ease;
                        font-family: 'Rajdhani', sans-serif;
                        font-weight: 600;
                        border-bottom: 1px solid rgba(0, 212, 255, 0.2);
                    }
                    
                    .memory-language-option:last-child {
                        border-bottom: none;
                    }
                    
                    .memory-language-option:hover {
                        background: linear-gradient(90deg, rgba(0, 212, 255, 0.2), rgba(255, 0, 150, 0.2));
                        color: #00d4ff;
                        transform: translateX(5px);
                    }
                    
                    .memory-main-container {
                        display: grid;
                        grid-template-columns: 240px 1fr 240px;
                        gap: 15px;
                        align-items: start;
                    }
                    
                    .memory-left-panel, .memory-right-panel {
                        background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(26, 26, 46, 0.8));
                        border: 2px solid #00d4ff;
                        border-radius: 15px;
                        padding: 10px;
                        backdrop-filter: blur(10px);
                    }
                    
                    .memory-game-area {
                        text-align: center;
                    }
                    
                    .memory-stats {
                        margin-bottom: 20px;
                    }
                    
                    .stat-group {
                        margin-bottom: 15px;
                        padding: 10px;
                        background: rgba(0, 212, 255, 0.05);
                        border-radius: 10px;
                        border: 1px solid rgba(0, 212, 255, 0.2);
                    }
                    
                    .stat-item {
                        display: flex;
                        justify-content: space-between;
                        margin: 8px 0;
                        padding: 5px 10px;
                        background: rgba(0, 212, 255, 0.1);
                        border-radius: 8px;
                        border: 1px solid rgba(0, 212, 255, 0.3);
                    }
                    
                    .stat-value {
                        font-weight: bold;
                        color: #00d4ff;
                    }
                    
                    .memory-ai-panel {
                        margin: 15px 0;
                        padding: 12px;
                        background: linear-gradient(135deg, rgba(0, 255, 136, 0.1), rgba(255, 215, 0, 0.1));
                        border: 2px solid #00ff88;
                        border-radius: 10px;
                    }
                    
                    .ai-analysis {
                        background: rgba(0, 0, 0, 0.5);
                        border-radius: 8px;
                        padding: 10px;
                        margin: 10px 0;
                        min-height: 40px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    }
                    
                    .ai-thinking {
                        color: #00ff88;
                        animation: aiThinking 2s infinite;
                    }
                    
                    .ai-difficulty {
                        display: flex;
                        align-items: center;
                        gap: 10px;
                        margin: 10px 0;
                    }
                    
                    .difficulty-bar {
                        flex: 1;
                        height: 8px;
                        background: rgba(0, 0, 0, 0.5);
                        border-radius: 4px;
                        overflow: hidden;
                    }
                    
                    .difficulty-fill {
                        height: 100%;
                        background: linear-gradient(90deg, #00ff88, #ffd700);
                        width: 10%;
                        transition: width 0.5s ease;
                    }
                    
                    .ai-hint-btn {
                        background: linear-gradient(45deg, #00ff88, #ffd700);
                        border: none;
                        border-radius: 8px;
                        padding: 8px 16px;
                        color: #000;
                        font-weight: bold;
                        cursor: pointer;
                        width: 100%;
                        margin-top: 10px;
                        transition: all 0.3s ease;
                    }
                    
                    .ai-hint-btn:hover {
                        transform: scale(1.05);
                        box-shadow: 0 0 15px rgba(0, 255, 136, 0.5);
                    }
                    
                    .memory-quantum-panel {
                        margin: 15px 0;
                        padding: 12px;
                        background: linear-gradient(135deg, rgba(255, 0, 150, 0.1), rgba(138, 43, 226, 0.1));
                        border: 2px solid #ff0096;
                        border-radius: 10px;
                    }
                    
                    .quantum-visualizer {
                        position: relative;
                        height: 80px;
                        background: rgba(0, 0, 0, 0.5);
                        border-radius: 8px;
                        margin: 10px 0;
                        overflow: hidden;
                    }
                    
                    .quantum-particle {
                        position: absolute;
                        width: 6px;
                        height: 6px;
                        background: #ff0096;
                        border-radius: 50%;
                        animation: quantumFloat 4s infinite linear;
                        box-shadow: 0 0 10px #ff0096;
                    }
                    
                    @keyframes quantumFloat {
                        0% { transform: translate(0, 0) rotate(0deg); opacity: 0.3; }
                        50% { opacity: 1; }
                        100% { transform: translate(100px, -50px) rotate(360deg); opacity: 0.3; }
                    }
                    
                    .quantum-controls {
                        display: flex;
                        align-items: center;
                        gap: 10px;
                        margin: 10px 0;
                    }
                    
                    .quantum-switch {
                        position: relative;
                        display: inline-block;
                        width: 50px;
                        height: 24px;
                    }
                    
                    .quantum-switch input {
                        opacity: 0;
                        width: 0;
                        height: 0;
                    }
                    
                    .quantum-slider {
                        position: absolute;
                        cursor: pointer;
                        top: 0;
                        left: 0;
                        right: 0;
                        bottom: 0;
                        background-color: #333;
                        transition: .4s;
                        border-radius: 24px;
                        border: 2px solid #ff0096;
                    }
                    
                    .quantum-slider:before {
                        position: absolute;
                        content: "";
                        height: 16px;
                        width: 16px;
                        left: 2px;
                        bottom: 2px;
                        background-color: #ff0096;
                        transition: .4s;
                        border-radius: 50%;
                    }
                    
                    input:checked + .quantum-slider {
                        background: linear-gradient(45deg, #ff0096, #00d4ff);
                    }
                    
                    input:checked + .quantum-slider:before {
                        transform: translateX(24px);
                        background-color: white;
                    }
                    
                    .quantum-slider.morphing {
                        border-color: #00ff88;
                    }
                    
                    .quantum-slider.morphing:before {
                        background-color: #00ff88;
                    }
                    
                    input:checked + .quantum-slider.morphing {
                        background: linear-gradient(45deg, #00ff88, #ffd700);
                    }
                    
                    .memory-board-container {
                        position: relative;
                        display: inline-block;
                        margin: 20px 0;
                    }
                    
                    .memory-board {
                        display: grid;
                        gap: 8px;
                        justify-content: center;
                        padding: 15px;
                        background: rgba(0, 0, 0, 0.3);
                        border: 3px solid #00d4ff;
                        border-radius: 15px;
                        backdrop-filter: blur(10px);
                        box-shadow: 0 0 30px rgba(0, 212, 255, 0.3);
                    }
                    
                    .quantum-memory-card {
                        width: 60px;
                        height: 60px;
                        perspective: 1000px;
                        cursor: pointer;
                        transition: all 0.3s ease;
                    }
                    
                    .quantum-memory-card:hover {
                        transform: scale(1.05);
                    }
                    
                    .quantum-card-inner {
                        position: relative;
                        width: 100%;
                        height: 100%;
                        text-align: center;
                        transition: transform 0.8s;
                        transform-style: preserve-3d;
                    }
                    
                    .quantum-memory-card.flipped .quantum-card-inner {
                        transform: rotateY(180deg);
                    }
                    
                    .quantum-card-front, .quantum-card-back {
                        position: absolute;
                        width: 100%;
                        height: 100%;
                        backface-visibility: hidden;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        border-radius: 12px;
                        border: 2px solid #00d4ff;
                        overflow: hidden;
                    }
                    
                    .quantum-card-front {
                        background: linear-gradient(135deg, #1a1a2e, #16213e);
                        flex-direction: column;
                    }
                    
                    .quantum-pattern {
                        font-size: 1.5rem;
                        color: #00d4ff;
                        margin-bottom: 5px;
                        animation: patternPulse 3s infinite;
                    }
                    
                    @keyframes patternPulse {
                        0%, 100% { opacity: 0.6; transform: scale(1); }
                        50% { opacity: 1; transform: scale(1.1); }
                    }
                    
                    .card-number {
                        font-size: 0.7rem;
                        color: #666;
                        font-weight: bold;
                    }
                    
                    .quantum-card-back {
                        background: linear-gradient(135deg, #00d4ff, #ff0096);
                        transform: rotateY(180deg);
                        position: relative;
                    }
                    
                    .card-icon {
                        font-size: 2rem;
                        z-index: 2;
                        position: relative;
                    }
                    
                    .quantum-glow {
                        position: absolute;
                        top: 0;
                        left: 0;
                        right: 0;
                        bottom: 0;
                        background: radial-gradient(circle, rgba(255, 255, 255, 0.3) 0%, transparent 70%);
                        animation: glowPulse 2s infinite;
                    }
                    
                    @keyframes glowPulse {
                        0%, 100% { opacity: 0.3; }
                        50% { opacity: 0.8; }
                    }
                    
                    .quantum-memory-card.matched {
                        animation: matchedGlow 2s infinite;
                    }
                    
                    @keyframes matchedGlow {
                        0%, 100% { box-shadow: 0 0 20px rgba(0, 255, 136, 0.5); }
                        50% { box-shadow: 0 0 40px rgba(0, 255, 136, 0.8); }
                    }
                    
                    .quantum-memory-card.ai-hint {
                        animation: aiHintPulse 1s infinite;
                    }
                    
                    @keyframes aiHintPulse {
                        0%, 100% { box-shadow: 0 0 15px rgba(255, 215, 0, 0.5); }
                        50% { box-shadow: 0 0 30px rgba(255, 215, 0, 1); }
                    }
                    
                    @keyframes quantumMatch {
                        0% { transform: scale(1); }
                        50% { transform: scale(1.2) rotate(10deg); }
                        100% { transform: scale(1) rotate(0deg); }
                    }
                    
                    .memory-effects {
                        position: absolute;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        pointer-events: none;
                        overflow: hidden;
                    }
                    
                    .celebration-particle {
                        position: absolute;
                        width: 8px;
                        height: 8px;
                        background: #ffd700;
                        border-radius: 50%;
                        animation: celebrate 3s ease-out forwards;
                    }
                    
                    @keyframes celebrate {
                        0% { transform: translateY(0) scale(1); opacity: 1; }
                        100% { transform: translateY(-200px) scale(0); opacity: 0; }
                    }
                    
                    .memory-controls {
                        display: flex;
                        gap: 15px;
                        justify-content: center;
                        margin-bottom: 20px;
                    }
                    
                    .memory-control-btn {
                        background: linear-gradient(45deg, #00d4ff, #ff0096);
                        border: none;
                        border-radius: 10px;
                        padding: 12px 20px;
                        color: white;
                        font-size: 1rem;
                        font-weight: bold;
                        cursor: pointer;
                        transition: all 0.3s ease;
                        font-family: 'Rajdhani', sans-serif;
                    }
                    
                    .memory-control-btn:hover {
                        transform: scale(1.05);
                        box-shadow: 0 0 20px rgba(0, 212, 255, 0.6);
                    }
                    
                    .memory-control-btn.primary {
                        background: linear-gradient(45deg, #00ff88, #ffd700);
                        color: #000;
                    }
                    
                    .memory-control-btn.secondary {
                        background: linear-gradient(45deg, #ff6b6b, #ffa500);
                        color: white;
                    }
                    
                    .memory-progress {
                        margin-top: 20px;
                    }
                    
                    .progress-bar {
                        width: 100%;
                        height: 12px;
                        background: rgba(0, 0, 0, 0.5);
                        border-radius: 6px;
                        overflow: hidden;
                        border: 2px solid #00d4ff;
                    }
                    
                    .progress-fill {
                        height: 100%;
                        background: linear-gradient(90deg, #00d4ff, #ff0096, #00ff88);
                        width: 0%;
                        transition: width 1s ease;
                        animation: progressGlow 2s infinite;
                    }
                    
                    @keyframes progressGlow {
                        0%, 100% { box-shadow: 0 0 10px rgba(0, 212, 255, 0.5); }
                        50% { box-shadow: 0 0 20px rgba(0, 212, 255, 0.8); }
                    }
                    
                    .progress-text {
                        margin-top: 10px;
                        font-weight: bold;
                        color: #00d4ff;
                    }
                    
                    .memory-neural-panel {
                        margin: 15px 0;
                        padding: 12px;
                        background: linear-gradient(135deg, rgba(138, 43, 226, 0.1), rgba(75, 0, 130, 0.1));
                        border: 2px solid #8a2be2;
                        border-radius: 10px;
                    }
                    
                    .neural-network {
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                        height: 100px;
                        margin: 15px 0;
                    }
                    
                    .neural-layer {
                        display: flex;
                        flex-direction: column;
                        gap: 10px;
                    }
                    
                    .neuron {
                        width: 20px;
                        height: 20px;
                        border-radius: 50%;
                        background: #333;
                        border: 2px solid #8a2be2;
                        transition: all 0.3s ease;
                    }
                    
                    .neuron.active {
                        background: #8a2be2;
                        box-shadow: 0 0 15px #8a2be2;
                        animation: neuronPulse 1.5s infinite;
                    }
                    
                    @keyframes neuronPulse {
                        0%, 100% { transform: scale(1); }
                        50% { transform: scale(1.2); }
                    }
                    
                    .memory-performance-panel {
                        margin: 20px 0;
                        padding: 15px;
                        background: linear-gradient(135deg, rgba(255, 165, 0, 0.1), rgba(255, 69, 0, 0.1));
                        border: 2px solid #ffa500;
                        border-radius: 10px;
                    }
                    
                    .performance-metrics {
                        margin: 15px 0;
                    }
                    
                    .metric {
                        display: flex;
                        justify-content: space-between;
                        margin: 8px 0;
                        padding: 5px 10px;
                        background: rgba(255, 165, 0, 0.1);
                        border-radius: 8px;
                        border: 1px solid rgba(255, 165, 0, 0.3);
                    }
                    
                    .performance-graph {
                        display: flex;
                        align-items: end;
                        height: 60px;
                        gap: 5px;
                        margin: 15px 0;
                        padding: 10px;
                        background: rgba(0, 0, 0, 0.3);
                        border-radius: 8px;
                    }
                    
                    .graph-bar {
                        flex: 1;
                        background: linear-gradient(to top, #ffa500, #ff6347);
                        border-radius: 3px;
                        transition: height 0.5s ease;
                        min-height: 10px;
                    }
                    
                    .memory-achievements {
                        margin: 20px 0;
                    }
                    
                    .achievements-list {
                        margin-top: 10px;
                    }
                    
                    .achievement {
                        padding: 8px 12px;
                        margin: 5px 0;
                        background: rgba(0, 212, 255, 0.1);
                        border: 1px solid rgba(0, 212, 255, 0.3);
                        border-radius: 8px;
                        font-size: 0.9rem;
                        transition: all 0.3s ease;
                    }
                    
                    .achievement.locked {
                        opacity: 0.5;
                        filter: grayscale(1);
                    }
                    
                    .achievement.unlocked {
                        background: linear-gradient(45deg, rgba(0, 255, 136, 0.2), rgba(255, 215, 0, 0.2));
                        border-color: #00ff88;
                        animation: achievementGlow 2s infinite;
                    }
                    
                    @keyframes achievementUnlock {
                        0% { transform: scale(1); }
                        50% { transform: scale(1.1); box-shadow: 0 0 30px #00ff88; }
                        100% { transform: scale(1); }
                    }
                    
                    /* Responsive pour Memory */
                    @media (max-width: 1024px) {
                        .memory-main-container {
                            grid-template-columns: 1fr;
                            grid-template-rows: auto auto auto;
                        }
                        
                        .memory-left-panel, .memory-right-panel {
                            display: grid;
                            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
                            gap: 15px;
                        }
                    }
                    
                    @media (max-width: 768px) {
                        .quantum-memory-card {
                            width: 60px;
                            height: 60px;
                        }
                        
                        .card-icon {
                            font-size: 1.5rem;
                        }
                        
                        .quantum-pattern {
                            font-size: 1.2rem;
                        }
                    }
                    
                    /* Styles Puzzle */
                    .puzzle-game {
                        text-align: center;
                        color: white;
                        font-family: 'Rajdhani', sans-serif;
                    }
                    
                    .puzzle-board {
                        display: grid;
                        grid-template-columns: repeat(4, 60px);
                        grid-template-rows: repeat(4, 60px);
                        gap: 2px;
                        justify-content: center;
                        margin: 20px 0;
                        background: #000;
                        padding: 10px;
                        border: 2px solid #00d4ff;
                        border-radius: 10px;
                    }
                    
                    .puzzle-tile {
                        width: 60px;
                        height: 60px;
                        background: linear-gradient(45deg, #00d4ff, #ff0096);
                        border: 1px solid #fff;
                        border-radius: 5px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-weight: bold;
                        font-size: 1.2rem;
                        cursor: pointer;
                        transition: all 0.3s ease;
                    }
                    
                    .puzzle-tile:hover {
                        transform: scale(1.05);
                        box-shadow: 0 0 15px rgba(0, 212, 255, 0.5);
                    }
                    
                    .puzzle-tile.empty {
                        background: transparent;
                        border: 1px dashed #666;
                    }
                    
                    .puzzle-shuffle {
                        background: linear-gradient(45deg, #00ff88, #ffd700);
                        border: none;
                        border-radius: 10px;
                        padding: 10px 20px;
                        color: #000;
                        font-weight: bold;
                        cursor: pointer;
                        margin-top: 20px;
                        transition: all 0.3s ease;
                    }
                    
                    .puzzle-shuffle:hover {
                        transform: scale(1.05);
                        box-shadow: 0 0 15px rgba(0, 255, 136, 0.5);
                    }
                    
                    /* Styles Simon */
                    .simon-game {
                        text-align: center;
                        color: white;
                        font-family: 'Rajdhani', sans-serif;
                    }
                    
                    .simon-board {
                        display: grid;
                        grid-template-columns: repeat(2, 100px);
                        grid-template-rows: repeat(2, 100px);
                        gap: 10px;
                        justify-content: center;
                        margin: 20px 0;
                    }
                    
                    .simon-button {
                        width: 100px;
                        height: 100px;
                        border-radius: 15px;
                        cursor: pointer;
                        transition: all 0.3s ease;
                        border: 3px solid #333;
                    }
                    
                    .simon-button.red {
                        background: #ff4757;
                    }
                    
                    .simon-button.blue {
                        background: #3742fa;
                    }
                    
                    .simon-button.green {
                        background: #2ed573;
                    }
                    
                    .simon-button.yellow {
                        background: #ffa502;
                    }
                    
                    .simon-button.active {
                        transform: scale(1.1);
                        box-shadow: 0 0 30px currentColor;
                        filter: brightness(1.5);
                    }
                    
                    .simon-controls {
                        margin: 20px 0;
                    }
                    
                    .simon-controls button {
                        background: linear-gradient(45deg, #00d4ff, #ff0096);
                        border: none;
                        border-radius: 10px;
                        padding: 10px 20px;
                        color: white;
                        font-weight: bold;
                        cursor: pointer;
                        margin: 0 10px;
                        transition: all 0.3s ease;
                    }
                    
                    .simon-controls button:hover {
                        transform: scale(1.05);
                        box-shadow: 0 0 15px rgba(0, 212, 255, 0.5);
                    }
                    
                    .simon-message {
                        margin-top: 20px;
                        font-size: 1.2rem;
                        font-weight: bold;
                        color: #00d4ff;
                    }
                `;
                document.head.appendChild(styles);
            }
        }

        function closeGameModal() {
            const modal = document.querySelector('.game-modal');
            if (modal) {
                modal.remove();
            }
            currentGame = null;
            gameState = {};
        }

        // Fonctions Quantum Memory 2077
        function initQuantumMemoryGame() {
            generateQuantumCards();
            renderMemoryBoard();
            updateMemoryDisplay();
            initNeuralNetwork();
        }

        function generateQuantumCards() {
            const quantumIcons = [
                // Niveau 1-3: Symboles de base
                ['🧠', '⚡', '🔮', '💎', '🌟', '⚛️', '🎯', '🚀', '🌀', '💫', '🔥', '💧', '🌪️', '⭐', '🌙'],
                // Niveau 4-6: Technologie
                ['🤖', '🛸', '🔬', '🧪', '⚙️', '🔋', '💻', '📡', '🛰️', '🔭', '🎮', '📱', '💾', '🖥️', '⌚'],
                // Niveau 7-9: Énergie cosmique
                ['🌌', '🌠', '☄️', '🌙', '☀️', '🪐', '🌍', '🌊', '⚡', '🔥', '🌈', '🌋', '❄️', '🌸', '🍃'],
                // Niveau 10-12: Dimensions
                ['🎭', '🎪', '🎨', '🎵', '🎼', '🎹', '🎸', '🥁', '🎺', '🎻', '🎬', '🎯', '🎲', '🃏', '🎰'],
                // Niveau 13-15: Transcendance
                ['👁️', '🧿', '🔯', '☯️', '🕉️', '🔱', '⚕️', '♾️', '🌈', '✨', '🦋', '🕊️', '🌺', '🍀', '💫'],
                // Niveau 16+: Univers infini
                ['🌠', '🪐', '🌌', '🔮', '💎', '⚛️', '🧬', '🌀', '💫', '✨', '🎆', '🎇', '💥', '⭐', '🌟'],
                // Animaux mystiques
                ['🦄', '🐉', '🦅', '🐺', '🦊', '🐯', '🦁', '🐙', '🦋', '🕷️', '🐝', '🦗', '🐞', '🦂', '🕊️'],
                // Cristaux et gemmes
                ['💎', '💍', '👑', '🔮', '💰', '🏆', '🥇', '🥈', '🥉', '🎖️', '🏅', '⭐', '🌟', '✨', '💫'],
                // Éléments naturels
                ['🌊', '🔥', '🌪️', '❄️', '⚡', '🌈', '☀️', '🌙', '⭐', '🌟', '☄️', '🌠', '🌌', '🪐', '🌍'],
                // Symboles sacrés
                ['☯️', '🕉️', '🔯', '✡️', '☪️', '✝️', '☦️', '🛐', '⚛️', '🔱', '⚕️', '♾️', '🧿', '👁️', '🌀']
            ];
            
            // Calculer le groupe d'icônes basé sur le niveau avec rotation infinie
            const levelGroup = (gameState.level - 1) % quantumIcons.length;
            let availableIcons = quantumIcons[levelGroup];
            
            // Mélanger les icônes pour chaque niveau pour plus de variété
            const shuffledIcons = [...availableIcons].sort(() => Math.random() - 0.5);
            
            // Sélectionner les icônes pour ce niveau
            const selectedIcons = [];
            for (let i = 0; i < gameState.pairsCount; i++) {
                selectedIcons.push(shuffledIcons[i % shuffledIcons.length]);
            }
            
            // Créer les paires et mélanger
            gameState.cards = [...selectedIcons, ...selectedIcons].sort(() => Math.random() - 0.5);
        }

        function renderMemoryBoard() {
            const board = document.getElementById('memory-board');
            const gridSize = Math.ceil(Math.sqrt(gameState.cards.length));
            
            board.style.gridTemplateColumns = `repeat(${gridSize}, 1fr)`;
            board.innerHTML = '';
            
            gameState.cards.forEach((card, index) => {
                const cardElement = document.createElement('div');
                cardElement.className = 'quantum-memory-card';
                cardElement.dataset.index = index;
                cardElement.onclick = () => flipQuantumCard(index);
                
                cardElement.innerHTML = `
                    <div class="quantum-card-inner">
                        <div class="quantum-card-front">
                            <div class="quantum-pattern"></div>
                            <div class="card-number">${index + 1}</div>
                        </div>
                        <div class="quantum-card-back">
                            <div class="card-icon">${card}</div>
                            <div class="quantum-glow"></div>
                        </div>
                    </div>
                `;
                
                board.appendChild(cardElement);
            });
        }

        function flipQuantumCard(index) {
            if (gameState.flipped.length >= 2 || gameState.flipped.includes(index) || gameState.matched.includes(index)) {
                return;
            }
            
            const card = document.querySelector(`[data-index="${index}"]`);
            card.classList.add('flipped');
            gameState.flipped.push(index);
            
            // Effet sonore et visuel
            triggerQuantumFlipEffect(card);
            
            if (gameState.flipped.length === 2) {
                gameState.moves++;
                updateMemoryDisplay();
                
                setTimeout(() => {
                    checkQuantumMatch();
                }, 1000);
            }
            
            // Mise à jour de l'IA
            updateAIAnalysis();
        }

        function checkQuantumMatch() {
            const [first, second] = gameState.flipped;
            const firstCard = document.querySelector(`[data-index="${first}"]`);
            const secondCard = document.querySelector(`[data-index="${second}"]`);
            
            if (gameState.cards[first] === gameState.cards[second]) {
                // Match trouvé!
                gameState.matched.push(first, second);
                gameState.streak++;
                gameState.score += (100 * gameState.level) + (gameState.streak * 50);
                
                firstCard.classList.add('matched');
                secondCard.classList.add('matched');
                
                triggerQuantumMatchEffect(firstCard, secondCard);
                unlockMemoryAchievement('first-match');
                
                // Vérifier si le niveau est terminé
                if (gameState.matched.length === gameState.cards.length) {
                    levelComplete();
                }
            } else {
                // Pas de match
                gameState.streak = 0;
                firstCard.classList.remove('flipped');
                secondCard.classList.remove('flipped');
                
                triggerQuantumMissEffect();
            }
            
            gameState.flipped = [];
            updateMemoryDisplay();
            updatePerformanceMetrics();
        }

        function levelComplete() {
            const timeBonus = Math.max(0, 300 - gameState.timer) * gameState.level;
            const moveBonus = Math.max(0, (gameState.pairsCount * 2 - gameState.moves)) * 25;
            gameState.score += timeBonus + moveBonus;
            
            // Vérifier niveau parfait
            if (gameState.moves === gameState.pairsCount) {
                unlockMemoryAchievement('perfect-level');
                gameState.perfectMatches++;
            }
            
            // Vérifier vitesse
            if (gameState.timer < 30) {
                unlockMemoryAchievement('speed-demon');
            }
            
            // Progression
            const progress = (gameState.level / gameState.maxLevel) * 100;
            document.getElementById('level-progress').style.width = progress + '%';
            document.getElementById('progress-percentage').textContent = Math.round(progress) + '%';
            
            // Afficher le bouton niveau suivant
            if (gameState.level < gameState.maxLevel) {
                document.getElementById('next-level-btn').style.display = 'block';
            } else {
                unlockMemoryAchievement('quantum-god');
                alert('🎉 Félicitations! Vous avez maîtrisé tous les niveaux de Memory Quantique 2077!');
            }
            
            triggerLevelCompleteEffect();
        }

        function nextMemoryLevel() {
            gameState.level++;
            gameState.pairsCount = Math.min(15, gameState.level + 1);
            gameState.moves = 0;
            gameState.timer = 0;
            gameState.flipped = [];
            gameState.matched = [];
            gameState.aiDifficulty = Math.min(10, Math.floor(gameState.level / 2) + 1);
            
            document.getElementById('next-level-btn').style.display = 'none';
            
            // Afficher le bouton précédent si niveau > 1
            if (gameState.level > 1) {
                document.getElementById('prev-level-btn').style.display = 'inline-block';
            }
            
            generateQuantumCards();
            renderMemoryBoard();
            updateMemoryDisplay();
            
            // Réinitialiser les effets
            if (gameState.morphingEnabled) {
                startMorphingSystem();
            }
        }

        function previousMemoryLevel() {
            if (gameState.level <= 1) return;
            
            gameState.level--;
            gameState.pairsCount = Math.min(15, gameState.level + 1);
            gameState.moves = 0;
            gameState.timer = 0;
            gameState.flipped = [];
            gameState.matched = [];
            gameState.aiDifficulty = Math.min(10, Math.floor(gameState.level / 2) + 1);
            
            document.getElementById('next-level-btn').style.display = 'none';
            
            // Masquer le bouton précédent si niveau = 1
            if (gameState.level <= 1) {
                document.getElementById('prev-level-btn').style.display = 'none';
            }
            
            generateQuantumCards();
            renderMemoryBoard();
            updateMemoryDisplay();
            
            // Réinitialiser les effets
            if (gameState.morphingEnabled) {
                startMorphingSystem();
            }
        }

        function resetMemoryGame() {
            gameState.level = 1;
            gameState.pairsCount = 2;
            gameState.moves = 0;
            gameState.timer = 0;
            gameState.score = 0;
            gameState.streak = 0;
            gameState.flipped = [];
            gameState.matched = [];
            gameState.aiDifficulty = 1;
            gameState.perfectMatches = 0;
            
            document.getElementById('next-level-btn').style.display = 'none';
            
            generateQuantumCards();
            renderMemoryBoard();
            updateMemoryDisplay();
            resetAchievements();
            
            if (gameState.morphingEnabled) {
                startMorphingSystem();
            }
        }

        function updateMemoryDisplay() {
            document.getElementById('memory-level').textContent = gameState.level;
            document.getElementById('memory-pairs').textContent = gameState.pairsCount;
            document.getElementById('memory-moves').textContent = gameState.moves;
            document.getElementById('memory-score').textContent = gameState.score.toLocaleString();
            document.getElementById('memory-streak').textContent = gameState.streak;
            
            // Mise à jour de la difficulté IA
            const difficultyPercent = (gameState.aiDifficulty / 10) * 100;
            document.getElementById('ai-difficulty-fill').style.width = difficultyPercent + '%';
            document.getElementById('ai-difficulty-text').textContent = gameState.aiDifficulty;
        }

        function startMemoryTimer() {
            setInterval(() => {
                if (currentGame === 'memory' && gameState.matched.length < gameState.cards.length) {
                    gameState.timer++;
                    const timerElement = document.getElementById('memory-timer');
                    if (timerElement) {
                        timerElement.textContent = gameState.timer + 's';
                    }
                }
            }, 1000);
        }

        function startQuantumEffects() {
            const visualizer = document.getElementById('quantum-visualizer');
            if (!visualizer) return;
            
            setInterval(() => {
                if (gameState.quantumEffects) {
                    const particles = visualizer.querySelectorAll('.quantum-particle');
                    particles.forEach(particle => {
                        const x = Math.random() * 100;
                        const y = Math.random() * 100;
                        particle.style.left = x + '%';
                        particle.style.top = y + '%';
                        particle.style.opacity = Math.random() * 0.8 + 0.2;
                    });
                }
            }, 2000);
        }

        function startMorphingSystem() {
            if (gameState.morphTimer) {
                clearInterval(gameState.morphTimer);
            }
            
            if (!gameState.morphingEnabled) return;
            
            gameState.morphTimer = setInterval(() => {
                const cards = document.querySelectorAll('.quantum-memory-card:not(.flipped):not(.matched)');
                cards.forEach(card => {
                    if (Math.random() < 0.3) {
                        const front = card.querySelector('.quantum-pattern');
                        if (front) {
                            // Changer le motif quantique
                            const patterns = ['◆', '◇', '◈', '◉', '◎', '●', '○', '◐', '◑', '◒'];
                            front.textContent = patterns[Math.floor(Math.random() * patterns.length)];
                            front.style.color = `hsl(${Math.random() * 360}, 70%, 60%)`;
                        }
                    }
                });
            }, 3000);
        }

        function updateAIAnalysis() {
            const suggestions = [
                "🎯 Analysing patterns...",
                "🧠 Processing memory data...",
                "⚡ Calculating probabilities...",
                "🔮 Predicting next moves...",
                "🌟 Optimizing strategy...",
                "⚛️ Quantum analysis active...",
                "🚀 Neural pathways mapped...",
                "💎 Pattern recognition enhanced..."
            ];
            
            const analysis = document.getElementById('memory-ai-analysis');
            if (analysis) {
                const suggestion = suggestions[Math.floor(Math.random() * suggestions.length)];
                analysis.innerHTML = `<div style="color: #00ff88;">${suggestion}</div>`;
            }
        }

        function getAIHint() {
            if (gameState.aiHints >= 3) {
                alert('Plus d\'indices disponibles pour ce niveau!');
                return;
            }
            
            const unmatched = [];
            for (let i = 0; i < gameState.cards.length; i++) {
                if (!gameState.matched.includes(i)) {
                    unmatched.push(i);
                }
            }
            
            if (unmatched.length >= 2) {
                // Trouver une paire
                for (let i = 0; i < unmatched.length; i++) {
                    for (let j = i + 1; j < unmatched.length; j++) {
                        if (gameState.cards[unmatched[i]] === gameState.cards[unmatched[j]]) {
                            const card1 = document.querySelector(`[data-index="${unmatched[i]}"]`);
                            const card2 = document.querySelector(`[data-index="${unmatched[j]}"]`);
                            
                            card1.classList.add('ai-hint');
                            card2.classList.add('ai-hint');
                            
                            setTimeout(() => {
                                card1.classList.remove('ai-hint');
                                card2.classList.remove('ai-hint');
                            }, 3000);
                            
                            gameState.aiHints++;
                            const btn = document.querySelector('.ai-hint-btn');
                            btn.textContent = btn.textContent.replace(/\(\d+\)/, `(${3 - gameState.aiHints})`);
                            
                            return;
                        }
                    }
                }
            }
        }

        function toggleQuantumEffects() {
            gameState.quantumEffects = !gameState.quantumEffects;
            
            if (!gameState.quantumEffects) {
                const visualizer = document.getElementById('quantum-visualizer');
                if (visualizer) {
                    visualizer.style.opacity = '0.3';
                }
            } else {
                const visualizer = document.getElementById('quantum-visualizer');
                if (visualizer) {
                    visualizer.style.opacity = '1';
                }
            }
        }

        function toggleMorphing() {
            gameState.morphingEnabled = !gameState.morphingEnabled;
            
            if (gameState.morphingEnabled) {
                startMorphingSystem();
            } else {
                if (gameState.morphTimer) {
                    clearInterval(gameState.morphTimer);
                    gameState.morphTimer = null;
                }
            }
        }

        function triggerQuantumFlipEffect(card) {
            if (!gameState.quantumEffects) return;
            
            card.style.boxShadow = '0 0 30px #00d4ff';
            setTimeout(() => {
                card.style.boxShadow = '';
            }, 500);
        }

        function triggerQuantumMatchEffect(card1, card2) {
            if (!gameState.quantumEffects) return;
            
            [card1, card2].forEach(card => {
                card.style.animation = 'quantumMatch 1s ease-out';
                setTimeout(() => {
                    card.style.animation = '';
                }, 1000);
            });
        }

        function triggerQuantumMissEffect() {
            if (!gameState.quantumEffects) return;
            
            const board = document.getElementById('memory-board');
            board.style.filter = 'hue-rotate(180deg)';
            setTimeout(() => {
                board.style.filter = '';
            }, 300);
        }

        function triggerLevelCompleteEffect() {
            if (!gameState.quantumEffects) return;
            
            const effects = document.getElementById('memory-effects');
            if (effects) {
                for (let i = 0; i < 20; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'celebration-particle';
                    particle.style.left = Math.random() * 100 + '%';
                    particle.style.top = Math.random() * 100 + '%';
                    particle.style.animationDelay = Math.random() * 2 + 's';
                    effects.appendChild(particle);
                    
                    setTimeout(() => particle.remove(), 3000);
                }
            }
        }

        function initNeuralNetwork() {
            const network = document.getElementById('neural-network');
            if (!network) return;
            
            setInterval(() => {
                const neurons = network.querySelectorAll('.neuron');
                neurons.forEach(neuron => {
                    neuron.classList.remove('active');
                    if (Math.random() < 0.3) {
                        neuron.classList.add('active');
                    }
                });
            }, 1500);
        }

        function updatePerformanceMetrics() {
            const accuracy = gameState.moves > 0 ? Math.round((gameState.matched.length / 2) / gameState.moves * 100) : 100;
            const avgTime = gameState.matched.length > 0 ? (gameState.timer / (gameState.matched.length / 2)).toFixed(1) : 0;
            const efficiency = Math.min(100, Math.round((gameState.score / (gameState.level * 1000)) * 100));
            
            document.getElementById('accuracy-metric').textContent = accuracy + '%';
            document.getElementById('speed-metric').textContent = avgTime + 's';
            document.getElementById('efficiency-metric').textContent = efficiency + '%';
            
            // Mise à jour du graphique
            const bars = document.querySelectorAll('.graph-bar');
            bars.forEach((bar, index) => {
                const height = Math.random() * 80 + 20;
                bar.style.height = height + '%';
            });
        }

        function unlockMemoryAchievement(type) {
            const achievement = document.getElementById(type);
            if (achievement && achievement.classList.contains('locked')) {
                achievement.classList.remove('locked');
                achievement.classList.add('unlocked');
                
                // Effet visuel
                achievement.style.animation = 'achievementUnlock 2s ease-out';
                setTimeout(() => {
                    achievement.style.animation = '';
                }, 2000);
            }
            
            // Vérifications spéciales
            if (gameState.level >= 10) {
                unlockMemoryAchievement('memory-master');
            }
        }

        function resetAchievements() {
            const achievements = document.querySelectorAll('.achievement');
            achievements.forEach(achievement => {
                achievement.classList.remove('unlocked');
                achievement.classList.add('locked');
            });
        }

        function toggleMemoryLanguageMenu() {
            const menu = document.getElementById('memory-language-menu');
            if (menu) {
                menu.classList.toggle('active');
            }
        }

        function changeMemoryLanguage(lang) {
            gameState.language = lang;
            document.getElementById('memory-current-lang').textContent = lang.toUpperCase();
            document.getElementById('memory-language-menu').classList.remove('active');
            
            // Mettre à jour tous les textes du jeu immédiatement
            updateMemoryLanguageDisplay(lang);
        }

        function updateMemoryLanguageDisplay(lang) {
            const translations = {
                fr: {
                    title: "🧠 Memory Quantique 2077",
                    level: "Niveau",
                    pairs: "Paires",
                    moves: "Coups",
                    time: "Temps",
                    score: "Score",
                    streak: "Série",
                    aiDifficulty: "Difficulté IA",
                    quantumEffects: "Effets Quantiques",
                    morphing: "Morphing Infini",
                    aiHint: "💡 Indice IA",
                    reset: "🔄 Reset",
                    nextLevel: "➡️ Niveau Suivant",
                    prevLevel: "⬅️ Niveau Précédent",
                    aiAnalysis: "🤖 Analyse IA",
                    quantumField: "⚛️ Champ Quantique",
                    neuralNetwork: "🧠 Réseau Neural",
                    performance: "📊 Performance",
                    achievements: "🏆 Succès Quantiques",
                    firstMatch: "🥉 Premier Match",
                    perfectLevel: "🥈 Niveau Parfait",
                    speedDemon: "⚡ Démon de Vitesse",
                    memoryMaster: "🧠 Maître Mémoire",
                    quantumGod: "🥇 Dieu Quantique",
                    progression: "Progression:",
                    accuracy: "Précision:",
                    speed: "Vitesse:",
                    efficiency: "Efficacité:",
                    confidence: "Confiance:",
                    aiThinking: "🧠 Initialisation...",
                    superposition: "🌀 Superposition",
                    teleportation: "⚡ Téléportation",
                    prediction: "🔮 Prédiction"
                },
                en: {
                    title: "🧠 Quantum Memory 2077",
                    level: "Level",
                    pairs: "Pairs",
                    moves: "Moves",
                    time: "Time",
                    score: "Score",
                    streak: "Streak",
                    aiDifficulty: "AI Difficulty",
                    quantumEffects: "Quantum Effects",
                    morphing: "Infinite Morphing",
                    aiHint: "💡 AI Hint",
                    reset: "🔄 Reset",
                    nextLevel: "➡️ Next Level",
                    prevLevel: "⬅️ Previous Level",
                    aiAnalysis: "🤖 AI Analysis",
                    quantumField: "⚛️ Quantum Field",
                    neuralNetwork: "🧠 Neural Network",
                    performance: "📊 Performance",
                    achievements: "🏆 Quantum Achievements",
                    firstMatch: "🥉 First Match",
                    perfectLevel: "🥈 Perfect Level",
                    speedDemon: "⚡ Speed Demon",
                    memoryMaster: "🧠 Memory Master",
                    quantumGod: "🥇 Quantum God",
                    progression: "Progress:",
                    accuracy: "Accuracy:",
                    speed: "Speed:",
                    efficiency: "Efficiency:",
                    confidence: "Confidence:",
                    aiThinking: "🧠 Initializing...",
                    superposition: "🌀 Superposition",
                    teleportation: "⚡ Teleportation",
                    prediction: "🔮 Prediction"
                },
                ar: {
                    title: "🧠 الذاكرة الكمية 2077",
                    level: "المستوى",
                    pairs: "الأزواج",
                    moves: "الحركات",
                    time: "الوقت",
                    score: "النقاط",
                    streak: "السلسلة",
                    aiDifficulty: "صعوبة الذكاء الاصطناعي",
                    quantumEffects: "التأثيرات الكمية",
                    morphing: "التحول اللانهائي",
                    aiHint: "💡 تلميح الذكاء الاصطناعي",
                    reset: "🔄 إعادة تعيين",
                    nextLevel: "➡️ المستوى التالي",
                    prevLevel: "⬅️ المستوى السابق",
                    aiAnalysis: "🤖 تحليل الذكاء الاصطناعي",
                    quantumField: "⚛️ المجال الكمي",
                    neuralNetwork: "🧠 الشبكة العصبية",
                    performance: "📊 الأداء",
                    achievements: "🏆 الإنجازات الكمية",
                    firstMatch: "🥉 أول مطابقة",
                    perfectLevel: "🥈 مستوى مثالي",
                    speedDemon: "⚡ شيطان السرعة",
                    memoryMaster: "🧠 سيد الذاكرة",
                    quantumGod: "🥇 إله الكم",
                    progression: "التقدم:",
                    accuracy: "الدقة:",
                    speed: "السرعة:",
                    efficiency: "الكفاءة:",
                    confidence: "الثقة:",
                    aiThinking: "🧠 جاري التهيئة...",
                    superposition: "🌀 التراكب",
                    teleportation: "⚡ النقل الآني",
                    prediction: "🔮 التنبؤ"
                },
                es: {
                    title: "🧠 Memoria Cuántica 2077",
                    level: "Nivel",
                    pairs: "Pares",
                    moves: "Movimientos",
                    time: "Tiempo",
                    score: "Puntuación",
                    streak: "Racha",
                    aiDifficulty: "Dificultad IA",
                    quantumEffects: "Efectos Cuánticos",
                    morphing: "Morfismo Infinito",
                    aiHint: "💡 Pista IA",
                    reset: "🔄 Reiniciar",
                    nextLevel: "➡️ Siguiente Nivel",
                    prevLevel: "⬅️ Nivel Anterior",
                    aiAnalysis: "🤖 Análisis IA",
                    quantumField: "⚛️ Campo Cuántico",
                    neuralNetwork: "🧠 Red Neural",
                    performance: "📊 Rendimiento",
                    achievements: "🏆 Logros Cuánticos",
                    firstMatch: "🥉 Primera Coincidencia",
                    perfectLevel: "🥈 Nivel Perfecto",
                    speedDemon: "⚡ Demonio de Velocidad",
                    memoryMaster: "🧠 Maestro de Memoria",
                    quantumGod: "🥇 Dios Cuántico",
                    progression: "Progreso:",
                    accuracy: "Precisión:",
                    speed: "Velocidad:",
                    efficiency: "Eficiencia:",
                    confidence: "Confianza:",
                    aiThinking: "🧠 Inicializando...",
                    superposition: "🌀 Superposición",
                    teleportation: "⚡ Teletransporte",
                    prediction: "🔮 Predicción"
                },
                zh: {
                    title: "🧠 量子记忆 2077",
                    level: "等级",
                    pairs: "配对",
                    moves: "移动",
                    time: "时间",
                    score: "分数",
                    streak: "连击",
                    aiDifficulty: "AI难度",
                    quantumEffects: "量子效应",
                    morphing: "无限变形",
                    aiHint: "💡 AI提示",
                    reset: "🔄 重置",
                    nextLevel: "➡️ 下一级",
                    prevLevel: "⬅️ 上一级",
                    aiAnalysis: "🤖 AI分析",
                    quantumField: "⚛️ 量子场",
                    neuralNetwork: "🧠 神经网络",
                    performance: "📊 性能",
                    achievements: "🏆 量子成就",
                    firstMatch: "🥉 首次匹配",
                    perfectLevel: "🥈 完美等级",
                    speedDemon: "⚡ 速度恶魔",
                    memoryMaster: "🧠 记忆大师",
                    quantumGod: "🥇 量子之神",
                    progression: "进度:",
                    accuracy: "准确度:",
                    speed: "速度:",
                    efficiency: "效率:",
                    confidence: "置信度:",
                    aiThinking: "🧠 初始化中...",
                    superposition: "🌀 叠加态",
                    teleportation: "⚡ 传送",
                    prediction: "🔮 预测"
                }
            };

            const t = translations[lang] || translations.fr;

            // Mettre à jour le titre principal
            const titleElement = document.getElementById('memory-title');
            if (titleElement) titleElement.textContent = t.title;

            // Mettre à jour les labels des statistiques
            const statLabels = document.querySelectorAll('.memory-stats .stat-item span:first-child');
            const statKeys = ['level', 'pairs', 'moves', 'time', 'score', 'streak'];
            statLabels.forEach((label, index) => {
                if (statKeys[index] && t[statKeys[index]]) {
                    label.textContent = t[statKeys[index]] + ':';
                }
            });

            // Mettre à jour les titres des panneaux
            const aiPanelTitle = document.querySelector('.memory-ai-panel h4');
            if (aiPanelTitle) aiPanelTitle.textContent = t.aiAnalysis;

            const quantumPanelTitle = document.querySelector('.memory-quantum-panel h4');
            if (quantumPanelTitle) quantumPanelTitle.textContent = t.quantumField;

            const neuralPanelTitle = document.querySelector('.memory-neural-panel h4');
            if (neuralPanelTitle) neuralPanelTitle.textContent = t.neuralNetwork;

            const performancePanelTitle = document.querySelector('.memory-performance-panel h4');
            if (performancePanelTitle) performancePanelTitle.textContent = t.performance;

            const achievementsTitle = document.querySelector('.memory-achievements h4');
            if (achievementsTitle) achievementsTitle.textContent = t.achievements;

            // Mettre à jour les boutons de contrôle
            const prevBtn = document.getElementById('prev-level-btn');
            if (prevBtn) prevBtn.textContent = t.prevLevel;

            const resetBtn = document.querySelector('.memory-control-btn:not(.primary):not(.secondary)');
            if (resetBtn) resetBtn.textContent = t.reset;

            const nextBtn = document.getElementById('next-level-btn');
            if (nextBtn) nextBtn.textContent = t.nextLevel;

            // Mettre à jour le bouton d'indice IA
            const aiHintBtn = document.querySelector('.ai-hint-btn');
            if (aiHintBtn) {
                const hintsLeft = aiHintBtn.textContent.match(/\((\d+)\)/);
                const hintsCount = hintsLeft ? hintsLeft[1] : '3';
                aiHintBtn.textContent = `${t.aiHint} (${hintsCount})`;
            }

            // Mettre à jour les labels des contrôles quantiques
            const quantumControls = document.querySelectorAll('.quantum-controls span');
            if (quantumControls.length >= 2) {
                quantumControls[0].textContent = t.quantumEffects;
                quantumControls[1].textContent = t.morphing;
            }

            // Mettre à jour les labels de difficulté et confiance
            const difficultyLabel = document.querySelector('.ai-difficulty span:first-child');
            if (difficultyLabel) difficultyLabel.textContent = t.aiDifficulty + ': ';

            // Mettre à jour les métriques de performance
            const performanceMetrics = document.querySelectorAll('.performance-metrics .metric span:first-child');
            const metricKeys = ['accuracy', 'speed', 'efficiency'];
            performanceMetrics.forEach((metric, index) => {
                if (metricKeys[index] && t[metricKeys[index]]) {
                    metric.textContent = t[metricKeys[index]];
                }
            });

            // Mettre à jour le texte de progression
            const progressText = document.querySelector('.progress-text span:first-child');
            if (progressText) progressText.textContent = t.progression + ' ';

            // Mettre à jour les succès
            const achievements = document.querySelectorAll('.memory-achievements .achievement');
            const achievementKeys = ['firstMatch', 'perfectLevel', 'speedDemon', 'memoryMaster', 'quantumGod'];
            achievements.forEach((achievement, index) => {
                if (achievementKeys[index] && t[achievementKeys[index]]) {
                    achievement.textContent = t[achievementKeys[index]];
                }
            });

            // Mettre à jour les effets quantiques
            const effectItems = document.querySelectorAll('.effects-list .effect-item');
            const effectKeys = ['superposition', 'teleportation', 'prediction'];
            effectItems.forEach((effect, index) => {
                if (effectKeys[index] && t[effectKeys[index]]) {
                    effect.textContent = t[effectKeys[index]];
                }
            });

            // Mettre à jour l'analyse IA si elle est visible
            const aiAnalysis = document.getElementById('memory-ai-analysis');
            if (aiAnalysis && aiAnalysis.textContent.includes('Initialisation')) {
                aiAnalysis.innerHTML = `<div style="color: #00ff88;">${t.aiThinking}</div>`;
            }
        }

        // Fonctions de jeu Puzzle
        function movePuzzleTile(index) {
            const emptyIndex = gameState.puzzle.indexOf(0);
            const size = gameState.size;
            
            // Vérifier si le mouvement est valide
            const validMoves = [];
            if (emptyIndex % size !== 0) validMoves.push(emptyIndex - 1);
            if (emptyIndex % size !== size - 1) validMoves.push(emptyIndex + 1);
            if (emptyIndex >= size) validMoves.push(emptyIndex - size);
            if (emptyIndex < size * (size - 1)) validMoves.push(emptyIndex + size);
            
            if (validMoves.includes(index)) {
                [gameState.puzzle[emptyIndex], gameState.puzzle[index]] = [gameState.puzzle[index], gameState.puzzle[emptyIndex]];
                gameState.moves++;
                document.getElementById('puzzle-moves').textContent = gameState.moves;
                updatePuzzleBoard();
                
                // Vérifier la victoire
                const isWon = gameState.puzzle.every((num, i) => {
                    if (i === gameState.puzzle.length - 1) return num === 0;
                    return num === i + 1;
                });
                
                if (isWon) {
                    setTimeout(() => alert('🎉 Puzzle résolu! Félicitations!'), 100);
                }
            }
        }
        
        function updatePuzzleBoard() {
            const board = document.getElementById('puzzle-board');
            board.innerHTML = gameState.puzzle.map((num, index) => `
                <div class="puzzle-tile ${num === 0 ? 'empty' : ''}" 
                     data-index="${index}" 
                     onclick="movePuzzleTile(${index})">
                    ${num === 0 ? '' : num}
                </div>
            `).join('');
        }
        
        function shufflePuzzle() {
            // Remélanger le puzzle
            for (let i = 0; i < 1000; i++) {
                const emptyIndex = gameState.puzzle.indexOf(0);
                const possibleMoves = [];
                const size = gameState.size;
                
                if (emptyIndex % size !== 0) possibleMoves.push(emptyIndex - 1);
                if (emptyIndex % size !== size - 1) possibleMoves.push(emptyIndex + 1);
                if (emptyIndex >= size) possibleMoves.push(emptyIndex - size);
                if (emptyIndex < size * (size - 1)) possibleMoves.push(emptyIndex + size);
                
                const randomMove = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                [gameState.puzzle[emptyIndex], gameState.puzzle[randomMove]] = [gameState.puzzle[randomMove], gameState.puzzle[emptyIndex]];
            }
            
            gameState.moves = 0;
            document.getElementById('puzzle-moves').textContent = gameState.moves;
            updatePuzzleBoard();
        }

        // Fonctions Simon Says
        function startSimonGame() {
            gameState.sequence = [];
            gameState.playerSequence = [];
            gameState.level = 1;
            gameState.isPlaying = true;
            gameState.isPlayerTurn = false;
            
            document.getElementById('simon-level').textContent = gameState.level;
            document.getElementById('simon-message').textContent = 'Regardez la séquence...';
            document.getElementById('simon-start').textContent = '🎮 En cours...';
            
            addToSimonSequence();
        }
        
        function addToSimonSequence() {
            const colors = ['red', 'blue', 'green', 'yellow'];
            const randomColor = colors[Math.floor(Math.random() * colors.length)];
            gameState.sequence.push(randomColor);
            playSimonSequence();
        }
        
        function playSimonSequence() {
            gameState.isPlayerTurn = false;
            let index = 0;
            
            const interval = setInterval(() => {
                if (index < gameState.sequence.length) {
                    flashSimonButton(gameState.sequence[index]);
                    index++;
                } else {
                    clearInterval(interval);
                    gameState.isPlayerTurn = true;
                    gameState.playerSequence = [];
                    document.getElementById('simon-message').textContent = 'À votre tour!';
                }
            }, 800);
        }
        
        function flashSimonButton(color) {
            const button = document.querySelector(`.simon-button.${color}`);
            button.classList.add('active');
            setTimeout(() => button.classList.remove('active'), 400);
        }
        
        function simonButtonClick(color) {
            if (!gameState.isPlayerTurn || !gameState.isPlaying) return;
            
            flashSimonButton(color);
            gameState.playerSequence.push(color);
            
            const currentIndex = gameState.playerSequence.length - 1;
            
            if (gameState.playerSequence[currentIndex] !== gameState.sequence[currentIndex]) {
                // Erreur
                document.getElementById('simon-message').textContent = '❌ Erreur! Recommencez...';
                gameState.isPlaying = false;
                document.getElementById('simon-start').textContent = '🎮 Commencer';
                return;
            }
            
            if (gameState.playerSequence.length === gameState.sequence.length) {
                // Niveau réussi
                gameState.level++;
                document.getElementById('simon-level').textContent = gameState.level;
                document.getElementById('simon-message').textContent = `Niveau ${gameState.level}! Préparez-vous...`;
                
                setTimeout(() => {
                    addToSimonSequence();
                }, 1500);
            }
        }
        
        function resetSimonGame() {
            gameState.sequence = [];
            gameState.playerSequence = [];
            gameState.level = 1;
            gameState.isPlaying = false;
            gameState.isPlayerTurn = false;
            
            document.getElementById('simon-level').textContent = '1';
            document.getElementById('simon-message').textContent = 'Cliquez sur Commencer!';
            document.getElementById('simon-start').textContent = '🎮 Commencer';
        }

        // Quantum Tetris 2077 - Fonctions Complètes
        const TETRIS_PIECES = {
            I: { shape: [[1,1,1,1]], color: '#00d4ff' },
            O: { shape: [[1,1],[1,1]], color: '#ffd700' },
            T: { shape: [[0,1,0],[1,1,1]], color: '#ff0096' },
            S: { shape: [[0,1,1],[1,1,0]], color: '#00ff88' },
            Z: { shape: [[1,1,0],[0,1,1]], color: '#ff4757' },
            J: { shape: [[1,0,0],[1,1,1]], color: '#3742fa' },
            L: { shape: [[0,0,1],[1,1,1]], color: '#2ed573' }
        };

        let tetrisGameLoop = null;
        let tetrisAIInterval = null;

        function initQuantumTetrisBoard() {
            const board = document.getElementById('tetris-board');
            board.innerHTML = '';
            
            for (let row = 0; row < 16; row++) {
                for (let col = 0; col < 10; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'tetris-cell';
                    cell.id = `tetris-cell-${row}-${col}`;
                    board.appendChild(cell);
                }
            }
            
            // Créer les effets quantiques
            createQuantumEffects();
        }

        function createQuantumEffects() {
            const effectsContainer = document.getElementById('tetris-quantum-effects');
            if (!effectsContainer) return;
            
            for (let i = 0; i < 20; i++) {
                const particle = document.createElement('div');
                particle.className = 'quantum-particle';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.animationDelay = Math.random() * 3 + 's';
                particle.style.animationDuration = (Math.random() * 2 + 2) + 's';
                effectsContainer.appendChild(particle);
            }
        }

        function generateTetrisPieces() {
            const pieceTypes = Object.keys(TETRIS_PIECES);
            
            if (!gameState.currentPiece) {
                gameState.currentPiece = createTetrisPiece(pieceTypes[Math.floor(Math.random() * pieceTypes.length)]);
            }
            
            if (!gameState.nextPiece) {
                gameState.nextPiece = createTetrisPiece(pieceTypes[Math.floor(Math.random() * pieceTypes.length)]);
            }
        }

        function createTetrisPiece(type) {
            const piece = TETRIS_PIECES[type];
            return {
                type: type,
                shape: piece.shape.map(row => [...row]),
                color: piece.color,
                x: Math.floor((10 - piece.shape[0].length) / 2),
                y: 0,
                rotation: 0
            };
        }

        function drawTetrisBoard() {
            // Effacer complètement le plateau
            for (let row = 0; row < 16; row++) {
                for (let col = 0; col < 10; col++) {
                    const cell = document.getElementById(`tetris-cell-${row}-${col}`);
                    if (cell) {
                        // Réinitialiser complètement la cellule
                        cell.className = 'tetris-cell';
                        cell.style.background = '';
                        cell.style.borderColor = '';
                        
                        // Dessiner les pièces verrouillées
                        if (gameState.board[row][col]) {
                            cell.classList.add('filled');
                            cell.style.background = gameState.board[row][col];
                            cell.style.borderColor = gameState.board[row][col];
                            if (gameState.quantumMode && Math.random() < 0.3) {
                                cell.classList.add('quantum');
                            }
                        }
                    }
                }
            }
            
            // Dessiner la pièce courante par-dessus
            if (gameState.currentPiece) {
                drawCurrentPiece();
            }
        }

        function drawCurrentPiece() {
            const piece = gameState.currentPiece;
            piece.shape.forEach((row, rowIndex) => {
                row.forEach((cell, colIndex) => {
                    if (cell) {
                        const x = piece.x + colIndex;
                        const y = piece.y + rowIndex;
                        if (y >= 0 && y < 16 && x >= 0 && x < 10) {
                            const cellElement = document.getElementById(`tetris-cell-${y}-${x}`);
                            if (cellElement && !gameState.board[y][x]) {
                                // Ne dessiner que si la cellule est vide
                                cellElement.style.background = piece.color;
                                cellElement.style.borderColor = piece.color;
                                cellElement.classList.add('current-piece');
                            }
                        }
                    }
                });
            });
        }

        function canMovePiece(piece, deltaX, deltaY) {
            const newX = piece.x + deltaX;
            const newY = piece.y + deltaY;
            
            return piece.shape.every((row, rowIndex) => {
                return row.every((cell, colIndex) => {
                    if (!cell) return true;
                    
                    const x = newX + colIndex;
                    const y = newY + rowIndex;
                    
                    return x >= 0 && x < 10 && y < 16 && 
                           (y < 0 || !gameState.board[y][x]);
                });
            });
        }

        function moveTetrisPiece(direction) {
            if (!gameState.currentPiece || !gameState.gameRunning) return;
            
            let deltaX = 0;
            let deltaY = 0;
            
            switch(direction) {
                case 'left': deltaX = -1; break;
                case 'right': deltaX = 1; break;
                case 'down': deltaY = 1; break;
            }
            
            if (canMovePiece(gameState.currentPiece, deltaX, deltaY)) {
                gameState.currentPiece.x += deltaX;
                gameState.currentPiece.y += deltaY;
                drawTetrisBoard();
                
                if (gameState.aiMode) {
                    updateAIPrediction();
                }
            }
        }

        function rotateTetrisPiece() {
            if (!gameState.currentPiece || !gameState.gameRunning) return;
            
            const rotatedShape = rotateMatrix(gameState.currentPiece.shape);
            const originalShape = gameState.currentPiece.shape;
            
            gameState.currentPiece.shape = rotatedShape;
            
            if (!canMovePiece(gameState.currentPiece, 0, 0)) {
                // Essayer le wall kick
                const kicks = [[-1, 0], [1, 0], [0, -1], [-2, 0], [2, 0]];
                let kicked = false;
                
                for (let kick of kicks) {
                    if (canMovePiece(gameState.currentPiece, kick[0], kick[1])) {
                        gameState.currentPiece.x += kick[0];
                        gameState.currentPiece.y += kick[1];
                        kicked = true;
                        break;
                    }
                }
                
                if (!kicked) {
                    gameState.currentPiece.shape = originalShape;
                }
            }
            
            drawTetrisBoard();
        }

        function rotateMatrix(matrix) {
            const rows = matrix.length;
            const cols = matrix[0].length;
            const rotated = Array(cols).fill().map(() => Array(rows).fill(0));
            
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    rotated[j][rows - 1 - i] = matrix[i][j];
                }
            }
            
            return rotated;
        }

        function softDropTetris() {
            moveTetrisPiece('down');
        }

        function hardDropTetris() {
            if (!gameState.currentPiece || !gameState.gameRunning) return;
            
            let dropDistance = 0;
            while (canMovePiece(gameState.currentPiece, 0, 1)) {
                gameState.currentPiece.y++;
                dropDistance++;
            }
            
            gameState.score += dropDistance * 2;
            lockPiece();
            drawTetrisBoard();
            updateTetrisDisplay();
        }

        function holdTetrisPiece() {
            if (!gameState.currentPiece || !gameState.gameRunning) return;
            
            if (!gameState.holdPiece) {
                gameState.holdPiece = gameState.currentPiece;
                spawnNextPiece();
            } else {
                const temp = gameState.holdPiece;
                gameState.holdPiece = gameState.currentPiece;
                gameState.currentPiece = temp;
                gameState.currentPiece.x = Math.floor((10 - gameState.currentPiece.shape[0].length) / 2);
                gameState.currentPiece.y = 0;
            }
            
            updatePiecePreview('tetris-hold-piece', gameState.holdPiece);
            drawTetrisBoard();
        }

        function lockPiece() {
            if (!gameState.currentPiece) return;
            
            // Placer la pièce sur le plateau
            gameState.currentPiece.shape.forEach((row, rowIndex) => {
                row.forEach((cell, colIndex) => {
                    if (cell) {
                        const x = gameState.currentPiece.x + colIndex;
                        const y = gameState.currentPiece.y + rowIndex;
                        if (y >= 0 && y < 16 && x >= 0 && x < 10) {
                            gameState.board[y][x] = gameState.currentPiece.color;
                        }
                    }
                });
            });
            
            // Vérifier les lignes complètes
            const linesCleared = clearLines();
            if (linesCleared > 0) {
                updateScore(linesCleared);
                triggerQuantumEffect();
            }
            
            // Générer la prochaine pièce
            spawnNextPiece();
            
            // Vérifier game over
            if (!canMovePiece(gameState.currentPiece, 0, 0)) {
                gameOver();
            }
        }

        function clearLines() {
            let linesCleared = 0;
            
            for (let row = 15; row >= 0; row--) {
                if (gameState.board[row].every(cell => cell !== 0)) {
                    gameState.board.splice(row, 1);
                    gameState.board.unshift(Array(10).fill(0));
                    linesCleared++;
                    row++; // Revérifier la même ligne
                }
            }
            
            return linesCleared;
        }

        function updateScore(linesCleared) {
            const baseScore = [0, 100, 300, 500, 800];
            const lineScore = baseScore[linesCleared] || 800;
            
            gameState.score += lineScore * gameState.level;
            gameState.lines += linesCleared;
            
            if (linesCleared > 1) {
                gameState.combo++;
                gameState.score += gameState.combo * 50;
            } else {
                gameState.combo = 0;
            }
            
            // Augmenter le niveau
            const newLevel = Math.floor(gameState.lines / 10) + 1;
            if (newLevel > gameState.level) {
                gameState.level = newLevel;
                gameState.dropTime = Math.max(50, 1000 - (gameState.level - 1) * 50);
                unlockAchievement('level-up');
            }
            
            if (linesCleared === 4) {
                unlockAchievement('tetris');
            }
        }

        function spawnNextPiece() {
            gameState.currentPiece = gameState.nextPiece;
            
            const pieceTypes = Object.keys(TETRIS_PIECES);
            gameState.nextPiece = createTetrisPiece(pieceTypes[Math.floor(Math.random() * pieceTypes.length)]);
            
            updatePiecePreview('tetris-next-piece', gameState.nextPiece);
        }

        function updatePiecePreview(elementId, piece) {
            const preview = document.getElementById(elementId);
            if (!preview || !piece) return;
            
            preview.innerHTML = '';
            preview.style.background = 'rgba(0, 0, 0, 0.8)';
            preview.style.border = `2px solid ${piece.color}`;
            preview.style.display = 'grid';
            preview.style.placeItems = 'center';
            
            // Créer une grille pour afficher la vraie forme de la pièce
            const pieceGrid = document.createElement('div');
            pieceGrid.style.display = 'grid';
            pieceGrid.style.gridTemplateColumns = `repeat(${piece.shape[0].length}, 12px)`;
            pieceGrid.style.gridTemplateRows = `repeat(${piece.shape.length}, 12px)`;
            pieceGrid.style.gap = '1px';
            
            piece.shape.forEach((row, rowIndex) => {
                row.forEach((cell, colIndex) => {
                    const cellDiv = document.createElement('div');
                    cellDiv.style.width = '12px';
                    cellDiv.style.height = '12px';
                    cellDiv.style.borderRadius = '2px';
                    
                    if (cell) {
                        cellDiv.style.background = piece.color;
                        cellDiv.style.border = `1px solid ${piece.color}`;
                        cellDiv.style.boxShadow = `0 0 4px ${piece.color}`;
                    } else {
                        cellDiv.style.background = 'transparent';
                    }
                    
                    pieceGrid.appendChild(cellDiv);
                });
            });
            
            preview.appendChild(pieceGrid);
        }

        function updateTetrisDisplay() {
            document.getElementById('tetris-score').textContent = gameState.score.toLocaleString();
            document.getElementById('tetris-level').textContent = gameState.level;
            document.getElementById('tetris-lines').textContent = gameState.lines;
            document.getElementById('tetris-combo').textContent = gameState.combo;
        }

        function toggleTetrisGame() {
            if (gameState.gameRunning) {
                pauseTetrisGame();
            } else {
                startTetrisGame();
            }
        }

        function startTetrisGame() {
            gameState.gameRunning = true;
            document.getElementById('tetris-play-btn').textContent = '⏸️ Pause';
            
            if (!gameState.currentPiece) {
                generateTetrisPieces();
                updatePiecePreview('tetris-next-piece', gameState.nextPiece);
            }
            
            tetrisGameLoop = setInterval(() => {
                if (gameState.gameRunning && gameState.currentPiece) {
                    if (canMovePiece(gameState.currentPiece, 0, 1)) {
                        gameState.currentPiece.y++;
                    } else {
                        lockPiece();
                    }
                    drawTetrisBoard();
                    updateTetrisDisplay();
                }
            }, gameState.dropTime);
        }

        function pauseTetrisGame() {
            gameState.gameRunning = false;
            document.getElementById('tetris-play-btn').textContent = '▶️ Reprendre';
            
            if (tetrisGameLoop) {
                clearInterval(tetrisGameLoop);
                tetrisGameLoop = null;
            }
        }

        function resetTetrisGame() {
            gameState.board = Array(16).fill().map(() => Array(10).fill(0));
            gameState.currentPiece = null;
            gameState.nextPiece = null;
            gameState.holdPiece = null;
            gameState.score = 0;
            gameState.level = 1;
            gameState.lines = 0;
            gameState.combo = 0;
            gameState.dropTime = 1000;
            gameState.gameRunning = false;
            
            if (tetrisGameLoop) {
                clearInterval(tetrisGameLoop);
                tetrisGameLoop = null;
            }
            
            document.getElementById('tetris-play-btn').textContent = '▶️ Démarrer';
            document.getElementById('tetris-hold-piece').innerHTML = '';
            document.getElementById('tetris-next-piece').innerHTML = '';
            
            generateTetrisPieces();
            updatePiecePreview('tetris-next-piece', gameState.nextPiece);
            drawTetrisBoard();
            updateTetrisDisplay();
        }

        function gameOver() {
            gameState.gameRunning = false;
            if (tetrisGameLoop) {
                clearInterval(tetrisGameLoop);
                tetrisGameLoop = null;
            }
            
            alert(`🎮 Game Over!\n\nScore Final: ${gameState.score.toLocaleString()}\nNiveau: ${gameState.level}\nLignes: ${gameState.lines}`);
            resetTetrisGame();
        }

        // IA et Effets Quantiques
        function startTetrisAI() {
            if (tetrisAIInterval) {
                clearInterval(tetrisAIInterval);
            }
            
            tetrisAIInterval = setInterval(() => {
                if (gameState.aiMode && gameState.currentPiece) {
                    updateAIPrediction();
                }
                
                if (gameState.quantumMode) {
                    triggerQuantumEffect();
                }
            }, 2000);
        }

        function updateAIPrediction() {
            const suggestions = [
                "🎯 Placer à gauche",
                "🔄 Rotation recommandée",
                "⚡ Drop rapide optimal",
                "🧠 Préparer Tetris",
                "🎪 Position parfaite"
            ];
            
            const confidence = Math.floor(Math.random() * 40) + 60;
            const suggestion = suggestions[Math.floor(Math.random() * suggestions.length)];
            
            document.getElementById('tetris-ai-suggestion').innerHTML = `<div style="color: #00ff88;">${suggestion}</div>`;
            document.getElementById('ai-confidence-fill').style.width = confidence + '%';
            document.getElementById('ai-confidence-text').textContent = confidence + '%';
        }

        function triggerQuantumEffect() {
            if (!gameState.quantumMode) return;
            
            const effects = ['superposition', 'teleportation', 'prediction'];
            const effect = effects[Math.floor(Math.random() * effects.length)];
            
            switch(effect) {
                case 'superposition':
                    // Effet de superposition quantique
                    setTimeout(() => {
                        const cells = document.querySelectorAll('.tetris-cell.filled');
                        cells.forEach(cell => {
                            if (Math.random() < 0.1) {
                                cell.classList.add('quantum');
                            }
                        });
                    }, 100);
                    break;
                    
                case 'teleportation':
                    // Téléportation de pièce
                    if (gameState.currentPiece && Math.random() < 0.3) {
                        const newX = Math.floor(Math.random() * 8);
                        if (canMovePiece({...gameState.currentPiece, x: newX}, 0, 0)) {
                            gameState.currentPiece.x = newX;
                            drawTetrisBoard();
                        }
                    }
                    break;
                    
                case 'prediction':
                    // Prédiction IA améliorée
                    if (gameState.aiMode) {
                        updateAIPrediction();
                    }
                    break;
            }
        }

        function toggleAIMode() {
            gameState.aiMode = !gameState.aiMode;
            
            if (gameState.aiMode) {
                updateAIPrediction();
            } else {
                document.getElementById('tetris-ai-suggestion').innerHTML = '<div class="ai-thinking">🧠 IA désactivée</div>';
                document.getElementById('ai-confidence-fill').style.width = '0%';
                document.getElementById('ai-confidence-text').textContent = '0%';
            }
        }

        function toggleQuantumMode() {
            gameState.quantumMode = !gameState.quantumMode;
            
            if (gameState.quantumMode) {
                createQuantumEffects();
            } else {
                const effects = document.getElementById('tetris-quantum-effects');
                if (effects) effects.innerHTML = '';
            }
        }

        function unlockAchievement(type) {
            const achievements = document.querySelectorAll('.achievement');
            achievements.forEach(achievement => {
                if (achievement.textContent.includes('Première ligne') && type === 'first-line') {
                    achievement.classList.remove('locked');
                    achievement.classList.add('unlocked');
                } else if (achievement.textContent.includes('Tetris Master') && type === 'tetris') {
                    achievement.classList.remove('locked');
                    achievement.classList.add('unlocked');
                } else if (achievement.textContent.includes('Quantum God') && type === 'level-up' && gameState.level >= 10) {
                    achievement.classList.remove('locked');
                    achievement.classList.add('unlocked');
                }
            });
        }

        function toggleTetrisLanguageMenu() {
            const menu = document.getElementById('tetris-language-menu');
            menu.classList.toggle('active');
        }

        function changeTetrisLanguage(lang) {
            gameState.language = lang;
            
            // Fermer le menu
            document.getElementById('tetris-language-menu').classList.remove('active');
            
            // Mettre à jour l'affichage de la langue courante
            document.getElementById('tetris-current-lang').textContent = lang.toUpperCase();
            
            // Traduire tous les éléments du jeu
            updateTetrisLanguage(lang);
        }

        function updateTetrisLanguage(lang) {
            const translations = {
                fr: {
                    title: "🎮 Quantum Tetris 2077",
                    score: "Score",
                    level: "Niveau",
                    lines: "Lignes",
                    combo: "Combo",
                    next: "Suivant",
                    hold: "Réserve",
                    aiMode: "Mode IA",
                    quantumMode: "Mode Quantique",
                    aiPrediction: "Prédiction IA",
                    start: "▶️ Démarrer",
                    pause: "⏸️ Pause",
                    resume: "▶️ Reprendre",
                    reset: "🔄 Reset",
                    quantumEffects: "⚛️ Effets Quantiques",
                    achievements: "🏆 Succès",
                    firstLine: "🥉 Première ligne",
                    tetrisMaster: "🥈 Tetris Master",
                    quantumGod: "🥇 Quantum God",
                    aiThinking: "🧠 Analyse en cours...",
                    aiDisabled: "🧠 IA désactivée",
                    confidence: "Confiance:"
                },
                en: {
                    title: "🎮 Quantum Tetris 2077",
                    score: "Score",
                    level: "Level",
                    lines: "Lines",
                    combo: "Combo",
                    next: "Next",
                    hold: "Hold",
                    aiMode: "AI Mode",
                    quantumMode: "Quantum Mode",
                    aiPrediction: "AI Prediction",
                    start: "▶️ Start",
                    pause: "⏸️ Pause",
                    resume: "▶️ Resume",
                    reset: "🔄 Reset",
                    quantumEffects: "⚛️ Quantum Effects",
                    achievements: "🏆 Achievements",
                    firstLine: "🥉 First Line",
                    tetrisMaster: "🥈 Tetris Master",
                    quantumGod: "🥇 Quantum God",
                    aiThinking: "🧠 Analyzing...",
                    aiDisabled: "🧠 AI disabled",
                    confidence: "Confidence:"
                },
                ar: {
                    title: "🎮 تيتريس الكمي 2077",
                    score: "النقاط",
                    level: "المستوى",
                    lines: "الخطوط",
                    combo: "التسلسل",
                    next: "التالي",
                    hold: "الاحتياط",
                    aiMode: "وضع الذكاء الاصطناعي",
                    quantumMode: "الوضع الكمي",
                    aiPrediction: "توقع الذكاء الاصطناعي",
                    start: "▶️ ابدأ",
                    pause: "⏸️ توقف",
                    resume: "▶️ استئناف",
                    reset: "🔄 إعادة تعيين",
                    quantumEffects: "⚛️ التأثيرات الكمية",
                    achievements: "🏆 الإنجازات",
                    firstLine: "🥉 الخط الأول",
                    tetrisMaster: "🥈 سيد التيتريس",
                    quantumGod: "🥇 إله الكم",
                    aiThinking: "🧠 جاري التحليل...",
                    aiDisabled: "🧠 الذكاء الاصطناعي معطل",
                    confidence: "الثقة:"
                },
                es: {
                    title: "🎮 Quantum Tetris 2077",
                    score: "Puntuación",
                    level: "Nivel",
                    lines: "Líneas",
                    combo: "Combo",
                    next: "Siguiente",
                    hold: "Reserva",
                    aiMode: "Modo IA",
                    quantumMode: "Modo Cuántico",
                    aiPrediction: "Predicción IA",
                    start: "▶️ Iniciar",
                    pause: "⏸️ Pausa",
                    resume: "▶️ Reanudar",
                    reset: "🔄 Reiniciar",
                    quantumEffects: "⚛️ Efectos Cuánticos",
                    achievements: "🏆 Logros",
                    firstLine: "🥉 Primera Línea",
                    tetrisMaster: "🥈 Maestro Tetris",
                    quantumGod: "🥇 Dios Cuántico",
                    aiThinking: "🧠 Analizando...",
                    aiDisabled: "🧠 IA desactivada",
                    confidence: "Confianza:"
                },
                zh: {
                    title: "🎮 量子俄罗斯方块 2077",
                    score: "分数",
                    level: "等级",
                    lines: "行数",
                    combo: "连击",
                    next: "下一个",
                    hold: "保留",
                    aiMode: "AI模式",
                    quantumMode: "量子模式",
                    aiPrediction: "AI预测",
                    start: "▶️ 开始",
                    pause: "⏸️ 暂停",
                    resume: "▶️ 继续",
                    reset: "🔄 重置",
                    quantumEffects: "⚛️ 量子效应",
                    achievements: "🏆 成就",
                    firstLine: "🥉 第一行",
                    tetrisMaster: "🥈 俄罗斯方块大师",
                    quantumGod: "🥇 量子之神",
                    aiThinking: "🧠 分析中...",
                    aiDisabled: "🧠 AI已禁用",
                    confidence: "置信度:"
                }
            };

            const t = translations[lang] || translations.fr;

            // Mettre à jour tous les textes
            const titleElement = document.getElementById('tetris-title');
            if (titleElement) titleElement.textContent = t.title;

            // Mettre à jour les labels des statistiques
            const statLabels = document.querySelectorAll('.stat-item span:first-child');
            if (statLabels.length >= 4) {
                statLabels[0].textContent = t.score + ':';
                statLabels[1].textContent = t.level + ':';
                statLabels[2].textContent = t.lines + ':';
                statLabels[3].textContent = t.combo + ':';
            }

            // Mettre à jour les titres des sections
            const holdTitle = document.querySelector('.tetris-hold-area h4');
            if (holdTitle) holdTitle.textContent = t.hold;

            const nextTitle = document.querySelector('.tetris-next-area h4');
            if (nextTitle) nextTitle.textContent = t.next;

            const aiTitle = document.querySelector('.tetris-ai-panel h4');
            if (aiTitle) aiTitle.textContent = '🤖 ' + t.aiPrediction;

            const effectsTitle = document.querySelector('.tetris-effects-panel h4');
            if (effectsTitle) effectsTitle.textContent = t.quantumEffects;

            const achievementsTitle = document.querySelector('.tetris-achievements h4');
            if (achievementsTitle) achievementsTitle.textContent = t.achievements;

            // Mettre à jour le bouton principal
            const playBtn = document.getElementById('tetris-play-btn');
            if (playBtn) {
                if (gameState.gameRunning) {
                    playBtn.textContent = t.pause;
                } else {
                    playBtn.textContent = t.start;
                }
            }

            // Mettre à jour le bouton reset
            const resetBtn = document.querySelector('.control-btn:not(.primary)');
            if (resetBtn && resetBtn.textContent.includes('Reset')) {
                resetBtn.textContent = t.reset;
            }

            // Mettre à jour les modes
            const modeToggles = document.querySelectorAll('.mode-toggle span');
            if (modeToggles.length >= 2) {
                modeToggles[0].textContent = t.aiMode;
                modeToggles[1].textContent = t.quantumMode;
            }

            // Mettre à jour les succès
            const achievements = document.querySelectorAll('.achievement');
            if (achievements.length >= 3) {
                achievements[0].textContent = t.firstLine;
                achievements[1].textContent = t.tetrisMaster;
                achievements[2].textContent = t.quantumGod;
            }

            // Mettre à jour l'IA
            const aiSuggestion = document.getElementById('tetris-ai-suggestion');
            if (aiSuggestion && !gameState.aiMode) {
                aiSuggestion.innerHTML = `<div class="ai-thinking">${t.aiDisabled}</div>`;
            }

            // Mettre à jour le label de confiance
            const confidenceLabel = document.querySelector('.ai-confidence span:first-child');
            if (confidenceLabel) confidenceLabel.textContent = t.confidence + ' ';
        }

        // Contrôles clavier pour Tetris
        document.addEventListener('keydown', function(event) {
            if (currentGame !== 'tetris' || !gameState.gameRunning) return;
            
            switch(event.key) {
                case 'ArrowLeft':
                    event.preventDefault();
                    moveTetrisPiece('left');
                    break;
                case 'ArrowRight':
                    event.preventDefault();
                    moveTetrisPiece('right');
                    break;
                case 'ArrowDown':
                    event.preventDefault();
                    softDropTetris();
                    break;
                case 'ArrowUp':
                    event.preventDefault();
                    rotateTetrisPiece();
                    break;
                case ' ':
                    event.preventDefault();
                    hardDropTetris();
                    break;
                case 'c':
                case 'C':
                    event.preventDefault();
                    holdTetrisPiece();
                    break;
                case 'p':
                case 'P':
                    event.preventDefault();
                    toggleTetrisGame();
                    break;
            }
        });

        // Fonctions Pac-Man (simplifiées)
        function initPacmanBoard() {
            const board = document.getElementById('pacman-board');
            const maze = [
                '####################',
                '#........##........#',
                '#.##.###.##.###.##.#',
                '#..................#',
                '#.##.#.######.#.##.#',
                '#....#...##...#....#',
                '####.###.##.###.####',
                '   #.#........#.#   ',
                '####.#.###.##.#.####',
                '#......#  #......#',
                '####.#.######.#.####',
                '   #.#........#.#   ',
                '####.##.####.##.####',
                '#........##........#',
                '#.##.###.##.###.##.#',
                '#..#.....P.....#..#',
                '##.#.#.######.#.#.##',
                '#....#...##...#....#',
                '#.######.##.######.#',
                '####################'
            ];
            
            board.innerHTML = '';
            board.style.display = 'grid';
            board.style.gridTemplateColumns = 'repeat(20, 15px)';
            board.style.gridTemplateRows = 'repeat(20, 15px)';
            board.style.gap = '1px';
            board.style.background = '#000';
            board.style.padding = '10px';
            board.style.border = '2px solid #00d4ff';
            board.style.margin = '0 auto';
            board.style.width = 'fit-content';
            
            maze.forEach((row, rowIndex) => {
                row.split('').forEach((cell, colIndex) => {
                    const cellDiv = document.createElement('div');
                    cellDiv.style.width = '15px';
                    cellDiv.style.height = '15px';
                    cellDiv.style.display = 'flex';
                    cellDiv.style.alignItems = 'center';
                    cellDiv.style.justifyContent = 'center';
                    cellDiv.style.fontSize = '12px';
                    
                    if (cell === '#') {
                        cellDiv.style.background = '#00d4ff';
                    } else if (cell === '.') {
                        cellDiv.textContent = '·';
                        cellDiv.style.color = '#ffd700';
                        cellDiv.style.background = '#000';
                    } else if (cell === 'P') {
                        cellDiv.textContent = '🟡';
                        cellDiv.style.background = '#000';
                        gameState.pacman = {x: colIndex, y: rowIndex};
                    } else {
                        cellDiv.style.background = '#000';
                    }
                    
                    cellDiv.id = `pacman-cell-${rowIndex}-${colIndex}`;
                    board.appendChild(cellDiv);
                });
            });
            
            // Placer les fantômes
            gameState.ghosts.forEach((ghost, index) => {
                const ghostCell = document.getElementById(`pacman-cell-${ghost.y}-${ghost.x}`);
                if (ghostCell) {
                    ghostCell.textContent = ghost.color;
                }
            });
        }
        
        function movePacman(direction) {
            const oldCell = document.getElementById(`pacman-cell-${gameState.pacman.y}-${gameState.pacman.x}`);
            oldCell.textContent = '';
            
            switch(direction) {
                case 'up':
                    if (gameState.pacman.y > 0) gameState.pacman.y--;
                    break;
                case 'down':
                    if (gameState.pacman.y < 19) gameState.pacman.y++;
                    break;
                case 'left':
                    if (gameState.pacman.x > 0) gameState.pacman.x--;
                    break;
                case 'right':
                    if (gameState.pacman.x < 19) gameState.pacman.x++;
                    break;
            }
            
            const newCell = document.getElementById(`pacman-cell-${gameState.pacman.y}-${gameState.pacman.x}`);
            if (newCell && newCell.style.background !== 'rgb(0, 212, 255)') {
                if (newCell.textContent === '·') {
                    gameState.score += 10;
                    gameState.dots++;
                    document.getElementById('pacman-score').textContent = gameState.score;
                    document.getElementById('pacman-dots').textContent = gameState.dots;
                }
                newCell.textContent = '🟡';
            }
        }
        
        function togglePacmanGame() {
            gameState.gameRunning = !gameState.gameRunning;
            if (gameState.gameRunning) {
                // Démarrer le mouvement automatique des fantômes
                console.log('Jeu Pac-Man démarré!');
            } else {
                console.log('Jeu Pac-Man en pause!');
            }
        }

        // Afficher "Bientôt disponible" pour les jeux non implémentés
        function showComingSoon(gameName) {
            alert(`🚀 ${gameName} sera bientôt disponible!\n\n🎮 Notre équipe d'IA travaille actuellement sur ce jeu révolutionnaire. Restez connecté pour découvrir cette expérience unique!`);
        }

        // Initialisation
        document.addEventListener('DOMContentLoaded', function() {
            createParticles();
        });
    
function launchGame13() {
  document.getElementById('game13Overlay').style.display = 'block';
}
function closeGame13() {
  document.getElementById('game13Overlay').style.display = 'none';
  var ifr = document.getElementById('game13Frame');
  if (ifr) {
    try { ifr.srcdoc = ifr.srcdoc; } catch(e) { ifr.src = 'about:blank'; }
  }
}
document.addEventListener('keydown', function(e) {
  if (e.key === "Escape") {
    closeGame13();
  }
});


function launchGame14() {
  document.getElementById('game14Overlay').style.display = 'block';
}
function closeGame14() {
  document.getElementById('game14Overlay').style.display = 'none';
}
document.addEventListener('keydown', function(e) {
  if (e.key === "Escape") {
    closeGame14();
  }
});

</script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'9839b122b0d4cedb',t:'MTc1ODYyNjgzNy4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script>
<template id="game3Template">



    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🧩 Neural Puzzle Master - IA Futuriste</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%);
            min-height: 100vh;
            overflow-x: hidden;
            overflow-y: auto;
            position: relative;
        }

        /* Particules d'arrière-plan futuristes */
        .neural-particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .neural-particle {
            position: absolute;
            width: 2px;
            height: 2px;
            background: #00ffff;
            border-radius: 50%;
            animation: neuralFloat 8s infinite linear;
            box-shadow: 0 0 6px #00ffff;
        }

        @keyframes neuralFloat {
            0% {
                transform: translateY(100vh) translateX(0) rotate(0deg);
                opacity: 0;
            }
            10% {
                opacity: 1;
            }
            90% {
                opacity: 1;
            }
            100% {
                transform: translateY(-10vh) translateX(100px) rotate(360deg);
                opacity: 0;
            }
        }

        /* Grille de fond cyberpunk */
        .cyber-grid {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(0, 255, 255, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 255, 0.1) 1px, transparent 1px);
            background-size: 50px 50px;
            animation: gridMove 20s linear infinite;
            z-index: 1;
        }

        @keyframes gridMove {
            0% { transform: translate(0, 0); }
            100% { transform: translate(50px, 50px); }
        }

        /* Container principal */
        .neural-puzzle-container {
            position: relative;
            z-index: 10;
            display: grid;
            grid-template-columns: 250px 1fr 250px;
            gap: 20px;
            min-height: 100vh;
            padding: 15px;
            padding-top: 20px;
            max-width: 1400px;
            margin: 0 auto;
        }

        .left-panel, .right-panel {
            background: linear-gradient(145deg, 
                rgba(26, 26, 46, 0.95) 0%,
                rgba(22, 33, 62, 0.95) 50%,
                rgba(15, 15, 35, 0.95) 100%);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 20px;
            height: fit-content;
            box-shadow: 
                0 20px 40px rgba(0, 0, 0, 0.5),
                0 0 80px rgba(0, 255, 255, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(0, 255, 255, 0.3);
            animation: panelGlow 3s ease-in-out infinite alternate;
        }

        .game-panel {
            background: linear-gradient(145deg, 
                rgba(26, 26, 46, 0.95) 0%,
                rgba(22, 33, 62, 0.95) 50%,
                rgba(15, 15, 35, 0.95) 100%);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 25px;
            width: 100%;
            height: fit-content;
            box-shadow: 
                0 20px 40px rgba(0, 0, 0, 0.5),
                0 0 80px rgba(0, 255, 255, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(0, 255, 255, 0.3);
            animation: panelGlow 3s ease-in-out infinite alternate;
        }

        @keyframes panelGlow {
            from { 
                box-shadow: 
                    0 25px 50px rgba(0, 0, 0, 0.5),
                    0 0 100px rgba(0, 255, 255, 0.1),
                    inset 0 1px 0 rgba(255, 255, 255, 0.1);
            }
            to { 
                box-shadow: 
                    0 25px 50px rgba(0, 0, 0, 0.5),
                    0 0 120px rgba(0, 255, 255, 0.2),
                    inset 0 1px 0 rgba(255, 255, 255, 0.2);
            }
        }

        /* En-tête du jeu */
        .neural-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid rgba(0, 255, 255, 0.3);
        }

        .neural-title {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .neural-title h1 {
            color: #00ffff;
            margin: 0;
            font-size: 24px;
            font-weight: 700;
            text-shadow: 0 0 20px rgba(0, 255, 255, 0.6);
            animation: titlePulse 2s infinite alternate;
        }

        @keyframes titlePulse {
            from { text-shadow: 0 0 20px rgba(0, 255, 255, 0.6); }
            to { text-shadow: 0 0 30px rgba(0, 255, 255, 0.9); }
        }

        .neural-icon {
            font-size: 32px;
            animation: iconSpin 4s linear infinite;
            filter: drop-shadow(0 0 10px #00ffff);
        }

        @keyframes iconSpin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .ai-badge {
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7aa);
            background-size: 200% 200%;
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: bold;
            animation: badgeShine 3s ease-in-out infinite;
            box-shadow: 0 0 15px rgba(78, 205, 196, 0.5);
        }

        @keyframes badgeShine {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .close-btn {
            background: rgba(255, 0, 0, 0.2);
            border: 2px solid rgba(255, 0, 0, 0.5);
            color: #ff6b6b;
            width: 45px;
            height: 45px;
            border-radius: 50%;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .close-btn:hover {
            background: rgba(255, 0, 0, 0.4);
            transform: scale(1.1) rotate(90deg);
            box-shadow: 0 0 20px rgba(255, 107, 107, 0.6);
        }

        /* En-tête des contrôles de jeu */
        .game-header-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            border: 2px solid rgba(0, 255, 255, 0.2);
        }

        /* Sélecteur de langue */
        .language-selector {
            position: relative;
        }

        .language-btn {
            background: linear-gradient(145deg, #6c5ce7, #5f3dc4);
            position: relative;
            z-index: 10;
        }

        .language-btn:hover {
            background: linear-gradient(145deg, #7c6ce7, #6f4dc4);
        }

        .language-menu {
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(145deg, 
                rgba(26, 26, 46, 0.98) 0%,
                rgba(22, 33, 62, 0.98) 50%,
                rgba(15, 15, 35, 0.98) 100%);
            backdrop-filter: blur(20px);
            border: 2px solid rgba(0, 255, 255, 0.3);
            border-radius: 15px;
            padding: 10px;
            display: none;
            flex-direction: column;
            gap: 5px;
            min-width: 180px;
            z-index: 20;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            animation: slideDown 0.3s ease-out;
        }

        .language-menu.active {
            display: flex;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        .language-option {
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid rgba(0, 255, 255, 0.3);
            color: #00ffff;
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 12px;
            text-align: left;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .language-option:hover {
            background: rgba(0, 255, 255, 0.2);
            transform: translateX(5px);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }

        .language-option.selected {
            background: rgba(0, 255, 255, 0.3);
            border-color: rgba(0, 255, 255, 0.6);
        }

        /* Bouton Pause */
        .pause-control {
            position: relative;
        }

        .pause-btn {
            background: linear-gradient(145deg, #e74c3c, #c0392b);
            position: relative;
            z-index: 10;
            min-width: 120px;
        }

        .pause-btn:hover {
            background: linear-gradient(145deg, #f74c3c, #d0392b);
        }

        .pause-btn.paused {
            background: linear-gradient(145deg, #27ae60, #229954);
        }

        .pause-btn.paused:hover {
            background: linear-gradient(145deg, #37be70, #339964);
        }

        /* Statistiques horizontales */
        .neural-stats-horizontal {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .neural-stats-horizontal .stat-item {
            background: rgba(0, 255, 255, 0.1);
            padding: 8px 15px;
            border-radius: 12px;
            text-align: center;
            border: 2px solid rgba(0, 255, 255, 0.3);
            position: relative;
            overflow: hidden;
            min-width: 80px;
        }

        .neural-stats-horizontal .stat-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 255, 0.2), transparent);
            animation: statScan 3s linear infinite;
        }

        @keyframes statScan {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .neural-stats-horizontal .stat-label {
            display: block;
            color: #888;
            font-size: 10px;
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .neural-stats-horizontal .stat-value {
            display: block;
            color: #00ffff;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.6);
            position: relative;
            z-index: 1;
        }

        /* Statut IA */
        .neural-ai-status {
            margin-bottom: 15px;
            text-align: center;
            min-height: 25px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .ai-thinking {
            display: inline-flex;
            align-items: center;
            gap: 12px;
            color: #4ecdc4;
            font-size: 16px;
            opacity: 0;
            transition: opacity 0.5s ease;
            background: rgba(78, 205, 196, 0.1);
            padding: 10px 20px;
            border-radius: 25px;
            border: 1px solid rgba(78, 205, 196, 0.3);
        }

        .ai-thinking.active {
            opacity: 1;
        }

        .ai-pulse {
            width: 12px;
            height: 12px;
            background: #4ecdc4;
            border-radius: 50%;
            animation: aiPulse 1.5s infinite;
            box-shadow: 0 0 10px #4ecdc4;
        }

        @keyframes aiPulse {
            0%, 100% { 
                transform: scale(1); 
                opacity: 1; 
            }
            50% { 
                transform: scale(1.5); 
                opacity: 0.5; 
            }
        }

        /* Plateaux de jeu côte à côte */
        .game-boards-container {
            display: flex;
            gap: 30px;
            justify-content: center;
            align-items: flex-start;
            margin-bottom: 20px;
        }

        .board-section {
            text-align: center;
            flex: 1;
        }

        .reference-board {
            width: 300px;
            height: 300px;
            border-radius: 15px;
            border: 3px solid rgba(0, 255, 255, 0.5);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
            animation: referenceGlow 3s ease-in-out infinite alternate;
        }

        .puzzle-board {
            width: 300px;
            height: 300px;
            display: grid;
            gap: 2px;
            border-radius: 15px;
            border: 3px solid rgba(255, 107, 107, 0.5);
            box-shadow: 0 0 20px rgba(255, 107, 107, 0.3);
            background: rgba(0, 0, 0, 0.3);
            padding: 5px;
            margin: 0 auto;
            transition: opacity 0.3s ease;
        }

        .puzzle-board.grid-4x4 {
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(4, 1fr);
        }

        .puzzle-board.grid-5x5 {
            grid-template-columns: repeat(5, 1fr);
            grid-template-rows: repeat(5, 1fr);
        }

        .puzzle-board.grid-6x6 {
            grid-template-columns: repeat(6, 1fr);
            grid-template-rows: repeat(6, 1fr);
        }

        .puzzle-piece {
            background-size: 300px 300px;
            background-repeat: no-repeat;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid rgba(255, 255, 255, 0.2);
            position: relative;
            overflow: hidden;
        }

        .puzzle-piece:hover {
            transform: scale(1.05);
            border-color: rgba(0, 255, 255, 0.8);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
            z-index: 10;
        }

        .puzzle-piece.selected {
            border-color: rgba(255, 215, 0, 1);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
            transform: scale(1.1);
            z-index: 20;
        }

        .puzzle-piece.correct {
            border-color: rgba(0, 255, 0, 0.8);
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.5);
        }

        @keyframes referenceGlow {
            from { box-shadow: 0 0 20px rgba(0, 255, 255, 0.3); }
            to { box-shadow: 0 0 30px rgba(0, 255, 255, 0.6); }
        }

        .board-label {
            color: #00ffff;
            font-size: 14px;
            margin-top: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.6);
            font-weight: bold;
        }

        .puzzle-label {
            color: #ff6b6b;
            text-shadow: 0 0 10px rgba(255, 107, 107, 0.6);
        }

        /* Contrôles du jeu */
        .neural-controls {
            display: grid;
            grid-template-columns: 1fr;
            gap: 10px;
            margin-bottom: 18px;
        }

        .panel-section {
            margin-bottom: 20px;
        }

        .panel-title {
            color: #00ffff;
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 15px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.6);
            border-bottom: 2px solid rgba(0, 255, 255, 0.3);
            padding-bottom: 8px;
        }

        .neural-btn {
            padding: 12px 18px;
            background: linear-gradient(145deg, #4ecdc4, #45b7aa);
            color: white;
            border: none;
            border-radius: 10px;
            font-weight: bold;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .neural-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transition: left 0.5s ease;
        }

        .neural-btn:hover::before {
            left: 100%;
        }

        .neural-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(78, 205, 196, 0.4);
            background: linear-gradient(145deg, #5fd4d4, #4ecdc4);
        }

        .neural-btn:active {
            transform: translateY(-1px);
        }

        .neural-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        /* Fonctionnalités avancées */
        .advanced-features {
            margin-bottom: 20px;
        }

        .feature-row {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-bottom: 8px;
        }

        .stats-horizontal {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: space-between;
        }

        .stats-horizontal .neural-btn {
            flex: 1;
            min-width: 120px;
            font-size: 10px;
            padding: 8px 10px;
        }

        .feature-btn {
            font-size: 11px;
            padding: 10px 12px;
            background: linear-gradient(145deg, #6c5ce7, #5f3dc4);
        }

        .feature-btn:hover {
            background: linear-gradient(145deg, #7c6ce7, #6f4dc4);
        }

        .feature-btn.active {
            background: linear-gradient(145deg, #00b894, #00a085);
        }

        /* Panneau d'analyse */
        .analysis-panel {
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid rgba(0, 255, 255, 0.3);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 15px;
            display: none;
        }

        .analysis-panel.active {
            display: block;
            animation: slideDownPanel 0.3s ease-out;
        }

        @keyframes slideDownPanel {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .analysis-text {
            color: #00ffff;
            font-size: 14px;
            line-height: 1.4;
            margin-bottom: 10px;
        }

        .difficulty-indicator {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 8px;
            font-size: 10px;
            font-weight: bold;
            margin-left: 5px;
        }

        .difficulty-easy { background: #00b894; }
        .difficulty-normal { background: #fdcb6e; color: #2d3436; }
        .difficulty-hard { background: #e17055; }
        .difficulty-expert { background: #d63031; }

        /* Barre de progression */
        .neural-progress {
            text-align: center;
        }

        .progress-container {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 15px;
            padding: 5px;
            margin-bottom: 15px;
            border: 2px solid rgba(0, 255, 255, 0.3);
        }

        .progress-bar {
            width: 100%;
            height: 12px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4ecdc4, #00ffff, #4ecdc4);
            background-size: 200% 100%;
            width: 0%;
            transition: width 0.8s ease;
            border-radius: 10px;
            animation: progressShine 2s linear infinite;
            position: relative;
        }

        @keyframes progressShine {
            0% { background-position: -200% 0; }
            100% { background-position: 200% 0; }
        }

        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: progressGlow 1.5s ease-in-out infinite alternate;
        }

        @keyframes progressGlow {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .progress-text {
            color: #00ffff;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.6);
        }

        /* Effets de victoire */
        .victory-effect {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
        }

        .victory-particle {
            position: absolute;
            width: 6px;
            height: 6px;
            background: #00ffff;
            border-radius: 50%;
            animation: victoryBurst 2s ease-out forwards;
        }

        @keyframes victoryBurst {
            0% {
                transform: scale(0) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: scale(1) rotate(720deg);
                opacity: 0;
            }
        }

        /* Responsive */
        @media (max-width: 1200px) {
            .neural-puzzle-container {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .left-panel, .right-panel {
                display: none;
            }
            
            .game-boards-container {
                flex-direction: column;
                align-items: center;
                gap: 20px;
            }
            
            .reference-board, .puzzle-board {
                width: 280px;
                height: 280px;
            }
            
            .puzzle-piece {
                background-size: 280px 280px;
            }
        }

        @media (max-width: 768px) {
            .game-panel {
                padding: 20px;
                margin: 10px;
            }
            
            .game-header-controls {
                flex-direction: column;
                gap: 15px;
                align-items: stretch;
            }
            
            .neural-stats-horizontal {
                justify-content: space-between;
                gap: 10px;
            }
            
            .neural-stats-horizontal .stat-item {
                min-width: 60px;
                padding: 6px 10px;
            }
            
            .neural-controls {
                grid-template-columns: 1fr;
                gap: 12px;
            }
            
            .neural-title h1 {
                font-size: 22px;
            }
            
            .game-boards-container {
                gap: 15px;
            }
            
            .reference-board, .puzzle-board {
                width: 250px;
                height: 250px;
            }
            
            .puzzle-piece {
                background-size: 250px 250px;
            }
        }

        @media (max-width: 480px) {
            .neural-stats-horizontal {
                flex-wrap: wrap;
                gap: 8px;
            }
            
            .neural-stats-horizontal .stat-item {
                flex: 1;
                min-width: 70px;
            }
            
            .neural-stats-horizontal .stat-value {
                font-size: 14px;
            }
            
            .reference-board, .puzzle-board {
                width: 220px;
                height: 220px;
            }
            
            .puzzle-piece {
                background-size: 220px 220px;
            }
        }
    </style>


    <!-- Particules d'arrière-plan -->
    <div class="neural-particles" id="neuralParticles"></div>
    
    <!-- Grille cyberpunk -->
    <div class="cyber-grid"></div>
    
    <!-- Container principal -->
    <div class="neural-puzzle-container">
        <!-- Panneau gauche -->
        <div class="left-panel">
            <div class="panel-section">
                <div class="panel-title">🎮 Contrôles</div>
                <div class="neural-controls">
                    <button class="neural-btn" onclick="getAIHint()" id="hintBtn">
                        💡 Indice IA
                    </button>
                    <button class="neural-btn" onclick="changeImage()">
                        🖼️ Nouvelle Image
                    </button>
                    <button class="neural-btn" onclick="aiSolvePuzzle()" id="solveBtn">
                        🤖 IA Résout
                    </button>
                </div>
            </div>

            <div class="panel-section">
                <div class="panel-title">⚙️ Options</div>
                <div class="neural-controls">
                    <button class="neural-btn feature-btn" onclick="changeGridSize()" id="gridSizeBtn">
                        🎯 Niveau: 4x4 (16)
                    </button>
                    <button class="neural-btn feature-btn" onclick="toggleAutoSolve()" id="autoSolveBtn">
                        ⚡ Auto-Résolution
                    </button>
                    <button class="neural-btn feature-btn" onclick="changeDifficulty()" id="difficultyBtn">
                        ⚙️ Difficulté: Normal
                    </button>
                    <button class="neural-btn feature-btn" onclick="saveGame()" id="saveBtn">
                        💾 Sauvegarder
                    </button>
                </div>
            </div>
        </div>

        <!-- Panneau central -->
        <div class="game-panel">
            <!-- En-tête -->
            <div class="neural-header">
                <div class="neural-title">
                    <span class="neural-icon">🧩</span>
                    <h1>Neural Puzzle Master</h1>
                    <span class="ai-badge">🤖 IA AVANCÉE</span>
                </div>
                <button class="close-btn" onclick="window.close()" title="Fermer">✕</button>
            </div>

            <!-- En-tête avec sélecteur de langue et pause -->
            <div class="game-header-controls">
                <!-- Sélecteur de langue -->
                <div class="language-selector">
                    <button class="neural-btn language-btn" onclick="toggleLanguageMenu()" id="languageBtn">
                        🌐 Français
                    </button>
                    <div class="language-menu" id="languageMenu">
                        <button class="language-option" onclick="changeLanguage('fr')">🇫🇷 Français</button>
                        <button class="language-option" onclick="changeLanguage('en')">🇺🇸 English</button>
                        <button class="language-option" onclick="changeLanguage('ar')">🇸🇦 العربية</button>
                        <button class="language-option" onclick="changeLanguage('es')">🇪🇸 Español</button>
                        <button class="language-option" onclick="changeLanguage('de')">🇩🇪 Deutsch</button>
                        <button class="language-option" onclick="changeLanguage('zh')">🇨🇳 中文</button>
                    </div>
                </div>

                <!-- Bouton Pause/Reprise -->
                <div class="pause-control">
                    <button class="neural-btn pause-btn" onclick="togglePause()" id="pauseBtn">
                        ⏸️ Pause
                    </button>
                </div>
                
                <!-- Statistiques horizontales -->
                <div class="neural-stats-horizontal">
                    <div class="stat-item">
                        <span class="stat-label">Niveau IA</span>
                        <span class="stat-value" id="aiLevel">1</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Score</span>
                        <span class="stat-value" id="neuralScore">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Mouvements</span>
                        <span class="stat-value" id="moveCount">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Temps</span>
                        <span class="stat-value" id="neuralTime">00:00</span>
                    </div>
                </div>
            </div>

            <!-- Plateaux de jeu côte à côte -->
            <div class="game-boards-container">
                <div class="board-section">
                    <canvas id="referenceImage" class="reference-board" width="300" height="300"></canvas>
                    <div class="board-label">🖼️ Image Originale</div>
                </div>
                <div class="board-section">
                    <div id="puzzleBoard" class="puzzle-board">
                        <!-- Les cases du puzzle seront générées ici -->
                    </div>
                    <div class="board-label puzzle-label">🧩 Puzzle à Reconstituer</div>
                </div>
            </div>

            <!-- Statut IA -->
            <div class="neural-ai-status">
                <div class="ai-thinking" id="aiThinking">
                    <span class="ai-pulse"></span>
                    <span id="aiMessage">IA en analyse...</span>
                </div>
            </div>

            <!-- Barre de progression -->
            <div class="neural-progress">
                <div class="progress-container">
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill"></div>
                    </div>
                </div>
                <span class="progress-text" id="progressText">0% complété</span>
            </div>
        </div>

        <!-- Panneau droit -->
        <div class="right-panel">
            <div class="panel-section">
                <div class="panel-title">🔍 Analyse IA</div>
                <div class="stats-horizontal">
                    <button class="neural-btn feature-btn" onclick="showOptimalPath()" id="pathBtn">
                        🎯 Chemin Optimal
                    </button>
                    <button class="neural-btn feature-btn" onclick="analyzePosition()" id="analyzeBtn">
                        🔍 Analyser Position
                    </button>
                    <button class="neural-btn feature-btn" onclick="showStatistics()" id="statsBtn">
                        📊 Statistiques
                    </button>
                </div>
            </div>

            <!-- Panneau d'analyse -->
            <div class="panel-section">
                <div class="analysis-panel active" id="analysisPanel">
                    <div class="analysis-text" id="analysisText">
                        🤖 <span id="aiReadyText">L'IA est prête à analyser votre puzzle !</span><br><br>
                        <span id="analysisInstructions">Utilisez les boutons ci-dessus pour obtenir des analyses détaillées de votre position actuelle.</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // État du jeu
    var gameState = {
            board: [],
            correctBoard: [],
            selectedPiece: null,
            moves: 0,
            startTime: null,
            timer: null,
            aiLevel: 1,
            score: 0,
            isPlaying: false,
            isSolving: false,
            hintUsed: false,
            autoSolve: false,
            difficulty: 'normal',
            optimalPath: [],
            gameHistory: [],
            currentImageIndex: 0,
            imageChangeTimer: null,
            currentImageData: null,
            gridSize: 4,
            currentLanguage: 'fr',
            isPaused: false,
            pausedTime: 0,
            statistics: {
                gamesPlayed: 0,
                gamesWon: 0,
                totalMoves: 0,
                totalTime: 0,
                bestScore: 0,
                averageTime: 0
            }
        };

        // Collection d'images variées
        const puzzleImages = [
            {
                name: "Forêt enchantée",
                type: "nature",
                colors: ["#228B22", "#32CD32", "#006400", "#ADFF2F", "#9ACD32", "#8FBC8F", "#90EE90", "#98FB98"],
                pattern: "enchanted_forest"
            },
            {
                name: "Cascade cristalline",
                type: "nature",
                colors: ["#87CEEB", "#4682B4", "#B0E0E6", "#FFFFFF", "#708090", "#20B2AA", "#48D1CC", "#40E0D0"],
                pattern: "crystal_waterfall"
            },
            {
                name: "Champ de lavande",
                type: "nature",
                colors: ["#9370DB", "#8A2BE2", "#DDA0DD", "#E6E6FA", "#32CD32", "#9ACD32", "#ADFF2F", "#98FB98"],
                pattern: "lavender_field"
            },
            {
                name: "Nébuleuse colorée",
                type: "space",
                colors: ["#000000", "#4B0082", "#8A2BE2", "#FF1493", "#00CED1", "#FFD700", "#FF4500", "#FFFFFF"],
                pattern: "nebula"
            },
            {
                name: "Coucher de soleil",
                type: "landscape",
                colors: ["#FF4500", "#FF6347", "#FFD700", "#FFA500", "#FF8C00", "#DC143C", "#B22222", "#8B0000"],
                pattern: "sunset"
            }
        ];

        // Système de traduction complet
        const translations = {
            fr: {
                title: "Maître des Puzzles Neuraux",
                aiAdvanced: "IA AVANCÉE",
                controls: "Contrôles",
                hintAI: "Indice IA",
                newImage: "Nouvelle Image",
                aiSolve: "IA Résout",
                options: "Options",
                level: "Niveau",
                autoSolve: "Auto-Résolution",
                difficulty: "Difficulté",
                save: "Sauvegarder",
                stats: "Statistiques",
                aiLevel: "Niveau IA",
                score: "Score",
                moves: "Mouvements",
                time: "Temps",
                originalImage: "Image Originale",
                puzzleToSolve: "Puzzle à Reconstituer",
                aiAnalysis: "Analyse IA",
                optimalPath: "Chemin Optimal",
                analyzePosition: "Analyser Position",
                statistics: "Statistiques",
                completed: "complété",
                aiThinking: "IA en analyse...",
                close: "Fermer",
                language: "Langue",
                solving: "Résolution...",
                pause: "Pause",
                resume: "Reprendre",
                messages: {
                    hintUsed: "Indice déjà utilisé pour ce puzzle !",
                    wrongPiece: "La pièce en position {0} n'est pas à sa place !",
                    allCorrect: "Toutes les pièces sont correctement placées !",
                    newImageMsg: "Nouvelle image : {0}",
                    puzzleSolved: "Puzzle résolu ! Score : {0}",
                    aiSolved: "Puzzle résolu par l'IA !",
                    gridChanged: "Grille changée : {0}x{0}",
                    autoSolveOn: "Auto-résolution activée !",
                    autoSolveOff: "Auto-résolution désactivée !",
                    gameSaved: "Jeu sauvegardé !",
                    gameLoaded: "Jeu chargé !",
                    aiReady: "L'IA est prête à analyser votre puzzle !",
                    gamePaused: "Jeu mis en pause",
                    gameResumed: "Jeu repris"
                }
            },
            en: {
                title: "Neural Puzzle Master",
                aiAdvanced: "ADVANCED AI",
                controls: "Controls",
                hintAI: "AI Hint",
                newImage: "New Image",
                aiSolve: "AI Solve",
                options: "Options",
                level: "Level",
                autoSolve: "Auto-Solve",
                difficulty: "Difficulty",
                save: "Save",
                stats: "Statistics",
                aiLevel: "AI Level",
                score: "Score",
                moves: "Moves",
                time: "Time",
                originalImage: "Original Image",
                puzzleToSolve: "Puzzle to Solve",
                aiAnalysis: "AI Analysis",
                optimalPath: "Optimal Path",
                analyzePosition: "Analyze Position",
                statistics: "Statistics",
                completed: "completed",
                aiThinking: "AI analyzing...",
                close: "Close",
                language: "Language",
                solving: "Solving...",
                pause: "Pause",
                resume: "Resume",
                messages: {
                    hintUsed: "Hint already used for this puzzle!",
                    wrongPiece: "Piece at position {0} is not in the right place!",
                    allCorrect: "All pieces are correctly placed!",
                    newImageMsg: "New image: {0}",
                    puzzleSolved: "Puzzle solved! Score: {0}",
                    aiSolved: "Puzzle solved by AI!",
                    gridChanged: "Grid changed: {0}x{0}",
                    autoSolveOn: "Auto-solve activated!",
                    autoSolveOff: "Auto-solve deactivated!",
                    gameSaved: "Game saved!",
                    gameLoaded: "Game loaded!",
                    aiReady: "AI is ready to analyze your puzzle!",
                    gamePaused: "Game paused",
                    gameResumed: "Game resumed"
                }
            },
            ar: {
                title: "سيد الألغاز العصبية",
                aiAdvanced: "ذكاء اصطناعي متقدم",
                controls: "التحكم",
                hintAI: "تلميح الذكاء الاصطناعي",
                newImage: "صورة جديدة",
                aiSolve: "حل بالذكاء الاصطناعي",
                options: "الخيارات",
                level: "المستوى",
                autoSolve: "الحل التلقائي",
                difficulty: "الصعوبة",
                save: "حفظ",
                stats: "الإحصائيات",
                aiLevel: "مستوى الذكاء الاصطناعي",
                score: "النقاط",
                moves: "الحركات",
                time: "الوقت",
                originalImage: "الصورة الأصلية",
                puzzleToSolve: "اللغز المراد حله",
                aiAnalysis: "تحليل الذكاء الاصطناعي",
                optimalPath: "المسار الأمثل",
                analyzePosition: "تحليل الموضع",
                statistics: "الإحصائيات",
                completed: "مكتمل",
                aiThinking: "الذكاء الاصطناعي يحلل...",
                close: "إغلاق",
                language: "اللغة",
                solving: "جاري الحل...",
                pause: "إيقاف مؤقت",
                resume: "استئناف",
                messages: {
                    gamePaused: "تم إيقاف اللعبة مؤقتاً",
                    gameResumed: "تم استئناف اللعبة"
                }
            },
            es: {
                title: "Maestro de Rompecabezas Neurales",
                aiAdvanced: "IA AVANZADA",
                controls: "Controles",
                hintAI: "Pista IA",
                newImage: "Nueva Imagen",
                aiSolve: "IA Resuelve",
                options: "Opciones",
                level: "Nivel",
                autoSolve: "Auto-Resolución",
                difficulty: "Dificultad",
                save: "Guardar",
                stats: "Estadísticas",
                aiLevel: "Nivel IA",
                score: "Puntuación",
                moves: "Movimientos",
                time: "Tiempo",
                originalImage: "Imagen Original",
                puzzleToSolve: "Rompecabezas a Resolver",
                aiAnalysis: "Análisis IA",
                optimalPath: "Camino Óptimo",
                analyzePosition: "Analizar Posición",
                statistics: "Estadísticas",
                completed: "completado",
                aiThinking: "IA analizando...",
                close: "Cerrar",
                language: "Idioma",
                solving: "Resolviendo...",
                pause: "Pausa",
                resume: "Reanudar",
                messages: {
                    gamePaused: "Juego pausado",
                    gameResumed: "Juego reanudado"
                }
            },
            de: {
                title: "Neuraler Puzzle-Meister",
                aiAdvanced: "ERWEITERTE KI",
                controls: "Steuerung",
                hintAI: "KI-Hinweis",
                newImage: "Neues Bild",
                aiSolve: "KI Löst",
                options: "Optionen",
                level: "Level",
                autoSolve: "Auto-Lösung",
                difficulty: "Schwierigkeit",
                save: "Speichern",
                stats: "Statistiken",
                aiLevel: "KI-Level",
                score: "Punkte",
                moves: "Züge",
                time: "Zeit",
                originalImage: "Originalbild",
                puzzleToSolve: "Zu lösendes Puzzle",
                aiAnalysis: "KI-Analyse",
                optimalPath: "Optimaler Pfad",
                analyzePosition: "Position Analysieren",
                statistics: "Statistiken",
                completed: "abgeschlossen",
                aiThinking: "KI analysiert...",
                close: "Schließen",
                language: "Sprache",
                solving: "Löse...",
                pause: "Pause",
                resume: "Fortsetzen",
                messages: {
                    gamePaused: "Spiel pausiert",
                    gameResumed: "Spiel fortgesetzt"
                }
            },
            zh: {
                title: "神经拼图大师",
                aiAdvanced: "高级人工智能",
                controls: "控制",
                hintAI: "AI提示",
                newImage: "新图片",
                aiSolve: "AI解决",
                options: "选项",
                level: "级别",
                autoSolve: "自动解决",
                difficulty: "难度",
                save: "保存",
                stats: "统计",
                aiLevel: "AI级别",
                score: "分数",
                moves: "移动",
                time: "时间",
                originalImage: "原始图片",
                puzzleToSolve: "待解拼图",
                aiAnalysis: "AI分析",
                optimalPath: "最优路径",
                analyzePosition: "分析位置",
                statistics: "统计数据",
                completed: "已完成",
                aiThinking: "AI分析中...",
                close: "关闭",
                language: "语言",
                solving: "解决中...",
                pause: "暂停",
                resume: "继续",
                messages: {
                    gamePaused: "游戏已暂停",
                    gameResumed: "游戏已恢复"
                }
            }
        };

        // Fonctions de traduction
        function t(key, ...args) {
            const lang = gameState.currentLanguage;
            let text = translations[lang] && translations[lang][key] ? translations[lang][key] : key;
            
            if (args.length > 0) {
                args.forEach((arg, index) => {
                    text = text.replace(`{${index}}`, arg);
                });
            }
            
            return text;
        }

        function tm(key, ...args) {
            const lang = gameState.currentLanguage;
            let text = translations[lang] && translations[lang].messages && translations[lang].messages[key] 
                ? translations[lang].messages[key] 
                : key;
            
            if (args.length > 0) {
                args.forEach((arg, index) => {
                    text = text.replace(`{${index}}`, arg);
                });
            }
            
            return text;
        }

        // Fonctions de gestion des langues
        function toggleLanguageMenu() {
            const menu = document.getElementById('languageMenu');
            menu.classList.toggle('active');
            
            document.addEventListener('click', function closeMenu(e) {
                if (!e.target.closest('.language-selector')) {
                    menu.classList.remove('active');
                    document.removeEventListener('click', closeMenu);
                }
            });
        }

        function changeLanguage(lang) {
            gameState.currentLanguage = lang;
            
            const languageBtn = document.getElementById('languageBtn');
            const flags = {
                fr: '🇫🇷 Français',
                en: '🇺🇸 English',
                ar: '🇸🇦 العربية',
                es: '🇪🇸 Español',
                de: '🇩🇪 Deutsch',
                zh: '🇨🇳 中文'
            };
            languageBtn.textContent = `🌐 ${flags[lang]}`;
            
            document.getElementById('languageMenu').classList.remove('active');
            updateLanguage();
            localStorage.setItem('neuralPuzzleLanguage', lang);
        }

        function updateLanguage() {
            document.querySelector('.neural-title h1').textContent = t('title');
            document.querySelector('.ai-badge').textContent = `🤖 ${t('aiAdvanced')}`;
            document.querySelector('.close-btn').title = t('close');
            
            const panelTitles = document.querySelectorAll('.panel-title');
            panelTitles[0].textContent = `🎮 ${t('controls')}`;
            panelTitles[1].textContent = `⚙️ ${t('options')}`;
            panelTitles[2].textContent = `🔍 ${t('aiAnalysis')}`;
            
            document.querySelector('button[onclick="getAIHint()"]').innerHTML = `💡 ${t('hintAI')}`;
            document.querySelector('button[onclick="changeImage()"]').innerHTML = `🖼️ ${t('newImage')}`;
            document.querySelector('button[onclick="aiSolvePuzzle()"]').innerHTML = `🤖 ${t('aiSolve')}`;
            document.querySelector('button[onclick="toggleAutoSolve()"]').innerHTML = `⚡ ${t('autoSolve')}`;
            document.querySelector('button[onclick="saveGame()"]').innerHTML = `💾 ${t('save')}`;
            
            document.querySelector('button[onclick="showOptimalPath()"]').innerHTML = `🎯 ${t('optimalPath')}`;
            document.querySelector('button[onclick="analyzePosition()"]').innerHTML = `🔍 ${t('analyzePosition')}`;
            document.querySelector('button[onclick="showStatistics()"]').innerHTML = `📊 ${t('statistics')}`;
            
            const statLabels = document.querySelectorAll('.stat-label');
            statLabels[0].textContent = t('aiLevel');
            statLabels[1].textContent = t('score');
            statLabels[2].textContent = t('moves');
            statLabels[3].textContent = t('time');
            
            const boardLabels = document.querySelectorAll('.board-label');
            boardLabels[0].textContent = `🖼️ ${t('originalImage')}`;
            boardLabels[1].textContent = `🧩 ${t('puzzleToSolve')}`;
            
            const pauseBtn = document.getElementById('pauseBtn');
            if(pauseBtn) {
                if(gameState.isPaused) {
                    pauseBtn.innerHTML = `▶️ ${t('resume')}`;
                } else {
                    pauseBtn.innerHTML = `⏸️ ${t('pause')}`;
                }
            }
            
            const aiReadyText = document.getElementById('aiReadyText');
            const analysisInstructions = document.getElementById('analysisInstructions');
            if(aiReadyText) aiReadyText.textContent = tm('aiReady');
            if(analysisInstructions) {
                const lang = gameState.currentLanguage;
                const instructions = {
                    fr: "Utilisez les boutons ci-dessus pour obtenir des analyses détaillées de votre position actuelle.",
                    en: "Use the buttons above to get detailed analysis of your current position.",
                    ar: "استخدم الأزرار أعلاه للحصول على تحليل مفصل لموضعك الحالي.",
                    es: "Usa los botones de arriba para obtener análisis detallados de tu posición actual.",
                    de: "Verwenden Sie die Schaltflächen oben, um detaillierte Analysen Ihrer aktuellen Position zu erhalten.",
                    zh: "使用上面的按钮获取当前位置的详细分析。"
                };
                analysisInstructions.textContent = instructions[lang] || instructions.en;
            }
            
            updateUI();
            updateProgress();
        }

        // Fonction pause/reprise
        function togglePause() {
            if(!gameState.isPlaying) return;
            
            const pauseBtn = document.getElementById('pauseBtn');
            
            if(gameState.isPaused) {
                gameState.isPaused = false;
                gameState.startTime = Date.now() - gameState.pausedTime;
                startTimer();
                
                pauseBtn.innerHTML = `⏸️ ${t('pause')}`;
                pauseBtn.classList.remove('paused');
                
                const puzzleBoard = document.getElementById('puzzleBoard');
                puzzleBoard.style.pointerEvents = 'auto';
                puzzleBoard.style.opacity = '1';
                
                showAIMessage(tm('gameResumed'), 1500);
            } else {
                gameState.isPaused = true;
                gameState.pausedTime = Date.now() - gameState.startTime;
                clearInterval(gameState.timer);
                
                pauseBtn.innerHTML = `▶️ ${t('resume')}`;
                pauseBtn.classList.add('paused');
                
                const puzzleBoard = document.getElementById('puzzleBoard');
                puzzleBoard.style.pointerEvents = 'none';
                puzzleBoard.style.opacity = '0.5';
                
                showAIMessage(tm('gamePaused'), 1500);
            }
        }

        // Générer une image procédurale
        function generateProceduralImage(imageData, size = 400) {
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            
            const centerX = size / 2;
            const centerY = size / 2;
            
            let gradient;
            switch(imageData.type) {
                case 'nature':
                case 'landscape':
                    gradient = ctx.createLinearGradient(0, 0, size, size);
                    break;
                case 'space':
                    gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, size * 0.8);
                    break;
                default:
                    gradient = ctx.createLinearGradient(0, 0, size, size);
            }
            
            for(let i = 0; i < imageData.colors.length; i++) {
                gradient.addColorStop(i / (imageData.colors.length - 1), imageData.colors[i]);
            }
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, size, size);
            
            // Ajouter des effets selon le pattern
            addPatternEffects(ctx, imageData);
            
            return canvas.toDataURL();
        }

        function addPatternEffects(ctx, imageData) {
            const size = ctx.canvas.width;
            const scale = size / 400;
            
            switch(imageData.pattern) {
                case 'enchanted_forest':
                    drawEnchantedForest(ctx, imageData.colors, scale);
                    break;
                case 'crystal_waterfall':
                    drawCrystalWaterfall(ctx, imageData.colors, scale);
                    break;
                case 'lavender_field':
                    drawLavenderField(ctx, imageData.colors, scale);
                    break;
                case 'nebula':
                    drawNebula(ctx, imageData.colors, scale);
                    break;
                case 'sunset':
                    drawSunset(ctx, imageData.colors, scale);
                    break;
                default:
                    drawGenericPattern(ctx, imageData.colors, scale);
                    break;
            }
        }

        function drawEnchantedForest(ctx, colors, scale = 1) {
            const size = ctx.canvas.width;
            
            for(let i = 0; i < 12; i++) {
                const x = (i * size / 12) + Math.random() * 30 * scale;
                const treeHeight = (100 + Math.random() * 100) * scale;
                const y = size - treeHeight;
                
                ctx.fillStyle = colors[3];
                ctx.fillRect(x - 8 * scale, y, 16 * scale, treeHeight);
                
                for(let layer = 0; layer < 3; layer++) {
                    ctx.fillStyle = colors[4 + layer % 4];
                    ctx.beginPath();
                    ctx.arc(x, y - layer * 20 * scale, (40 - layer * 5) * scale, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                if(Math.random() > 0.5) {
                    ctx.fillStyle = colors[7];
                    ctx.shadowBlur = 10 * scale;
                    ctx.shadowColor = colors[7];
                    ctx.beginPath();
                    ctx.arc(x + Math.random() * 40 * scale - 20 * scale, y - Math.random() * 60 * scale, 2 * scale, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            }
        }

        function drawCrystalWaterfall(ctx, colors, scale = 1) {
            const size = ctx.canvas.width;
            
            const waterfallGradient = ctx.createLinearGradient(size * 0.4, 0, size * 0.6, size);
            waterfallGradient.addColorStop(0, colors[0]);
            waterfallGradient.addColorStop(0.3, colors[1]);
            waterfallGradient.addColorStop(0.7, colors[2]);
            waterfallGradient.addColorStop(1, colors[3]);
            
            ctx.fillStyle = waterfallGradient;
            ctx.beginPath();
            ctx.moveTo(size * 0.45, 0);
            ctx.quadraticCurveTo(size * 0.5, size * 0.3, size * 0.48, size * 0.6);
            ctx.quadraticCurveTo(size * 0.52, size * 0.8, size * 0.55, size);
            ctx.lineTo(size * 0.45, size);
            ctx.quadraticCurveTo(size * 0.48, size * 0.7, size * 0.45, 0);
            ctx.fill();
            
            for(let i = 0; i < 20; i++) {
                ctx.fillStyle = colors[3];
                const x = size * 0.4 + Math.random() * size * 0.3;
                const y = size * 0.8 + Math.random() * size * 0.2;
                const radius = Math.random() * 4 * scale + 1;
                
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawLavenderField(ctx, colors, scale = 1) {
            const size = ctx.canvas.width;
            
            for(let row = 0; row < 8; row++) {
                const y = size * 0.65 + row * (size * 0.04);
                const perspective = 1 - (row * 0.1);
                
                for(let i = 0; i < 15; i++) {
                    const x = (i * size / 15) + Math.sin(row + i) * 10 * scale;
                    
                    ctx.fillStyle = colors[5];
                    ctx.fillRect(x - 1 * scale * perspective, y, 2 * scale * perspective, 25 * scale * perspective);
                    
                    ctx.fillStyle = colors[0 + (i % 2)];
                    for(let flower = 0; flower < 5; flower++) {
                        ctx.beginPath();
                        ctx.arc(
                            x + Math.random() * 4 * scale - 2 * scale,
                            y - flower * 4 * scale * perspective,
                            1.5 * scale * perspective,
                            0, Math.PI * 2
                        );
                        ctx.fill();
                    }
                }
            }
        }

        function drawNebula(ctx, colors, scale = 1) {
            const centerX = ctx.canvas.width / 2;
            const centerY = ctx.canvas.height / 2;
            
            for(let i = 0; i < 8; i++) {
                const gradient = ctx.createRadialGradient(
                    centerX + (Math.random() - 0.5) * 200 * scale,
                    centerY + (Math.random() - 0.5) * 200 * scale,
                    0,
                    centerX + (Math.random() - 0.5) * 200 * scale,
                    centerY + (Math.random() - 0.5) * 200 * scale,
                    80 * scale
                );
                
                gradient.addColorStop(0, colors[1 + i % 6]);
                gradient.addColorStop(0.5, colors[2 + i % 5] + '80');
                gradient.addColorStop(1, 'transparent');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(
                    centerX + (Math.random() - 0.5) * 150 * scale,
                    centerY + (Math.random() - 0.5) * 150 * scale,
                    60 * scale + Math.random() * 40 * scale,
                    0, Math.PI * 2
                );
                ctx.fill();
            }
        }

        function drawSunset(ctx, colors, scale = 1) {
            const size = ctx.canvas.width;
            
            ctx.fillStyle = colors[2];
            ctx.beginPath();
            ctx.arc(size * 0.5, size * 0.375, 60 * scale, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.strokeStyle = colors[3];
            ctx.lineWidth = 4 * scale;
            for(let i = 0; i < 12; i++) {
                const angle = (i * Math.PI * 2) / 12;
                ctx.beginPath();
                ctx.moveTo(size * 0.5 + Math.cos(angle) * 70 * scale, size * 0.375 + Math.sin(angle) * 70 * scale);
                ctx.lineTo(size * 0.5 + Math.cos(angle) * 100 * scale, size * 0.375 + Math.sin(angle) * 100 * scale);
                ctx.stroke();
            }
        }

        function drawGenericPattern(ctx, colors, scale = 1) {
            const size = ctx.canvas.width;
            
            for(let i = 0; i < 20; i++) {
                const x = Math.random() * size;
                const y = Math.random() * size;
                const radius = Math.random() * 30 * scale + 10 * scale;
                
                ctx.fillStyle = colors[i % colors.length];
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Créer les particules neurales
        function createNeuralParticles() {
            const container = document.getElementById('neuralParticles');
            
            for(let i = 0; i < 30; i++) {
                const particle = document.createElement('div');
                particle.className = 'neural-particle';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.animationDelay = Math.random() * 8 + 's';
                particle.style.animationDuration = (8 + Math.random() * 4) + 's';
                container.appendChild(particle);
            }
        }

        // Initialiser le jeu
        function initGame() {
            gameState.currentImageIndex = 0;
            gameState.currentImageData = puzzleImages[gameState.currentImageIndex];
            
            generateNewPuzzle();
            updateUI();
            startTimer();
        }

        // Générer un nouveau puzzle
        function generateNewPuzzle() {
            const totalPieces = gameState.gridSize * gameState.gridSize;
            
            const imageData = generateProceduralImage(gameState.currentImageData, 300);
            const canvas = document.getElementById('referenceImage');
            const ctx = canvas.getContext('2d');
            
            const img = new Image();
            img.onload = function() {
                ctx.drawImage(img, 0, 0, 300, 300);
                gameState.currentImageData.imageData = imageData;
            };
            img.src = imageData;
            
            gameState.board = [];
            gameState.correctBoard = [];
            
            for(let i = 0; i < totalPieces; i++) {
                gameState.board.push(i);
                gameState.correctBoard.push(i);
            }
            
            shuffleBoard();
            createPuzzleBoard();
            
            gameState.moves = 0;
            gameState.hintUsed = false;
            gameState.isPlaying = true;
            gameState.isPaused = false;
            gameState.pausedTime = 0;
            gameState.startTime = Date.now();
            
            updateUI();
            updateProgress();
        }

        // Mélanger le plateau
        function shuffleBoard() {
            const totalPieces = gameState.gridSize * gameState.gridSize;
            
            for(let i = totalPieces - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [gameState.board[i], gameState.board[j]] = [gameState.board[j], gameState.board[i]];
            }
            
            let isSolved = true;
            for(let i = 0; i < totalPieces; i++) {
                if(gameState.board[i] !== i) {
                    isSolved = false;
                    break;
                }
            }
            
            if(isSolved) {
                [gameState.board[0], gameState.board[1]] = [gameState.board[1], gameState.board[0]];
            }
        }

        // Créer l'interface du puzzle
        function createPuzzleBoard() {
            const puzzleBoard = document.getElementById('puzzleBoard');
            puzzleBoard.innerHTML = '';
            puzzleBoard.className = `puzzle-board grid-${gameState.gridSize}x${gameState.gridSize}`;
            
            const totalPieces = gameState.gridSize * gameState.gridSize;
            
            for(let i = 0; i < totalPieces; i++) {
                const piece = document.createElement('div');
                piece.className = 'puzzle-piece';
                piece.dataset.position = i;
                piece.onclick = () => selectPiece(i);
                
                updatePieceImage(piece, i);
                puzzleBoard.appendChild(piece);
            }
        }

        // Mettre à jour l'image d'une pièce
        function updatePieceImage(piece, position) {
            const pieceIndex = gameState.board[position];
            const pieceSize = 300 / gameState.gridSize;
            
            const row = Math.floor(pieceIndex / gameState.gridSize);
            const col = pieceIndex % gameState.gridSize;
            
            const offsetX = -col * pieceSize;
            const offsetY = -row * pieceSize;
            
            if(gameState.currentImageData && gameState.currentImageData.imageData) {
                piece.style.backgroundImage = `url(${gameState.currentImageData.imageData})`;
                piece.style.backgroundPosition = `${offsetX}px ${offsetY}px`;
            }
            
            // Vérifier si la pièce est à la bonne place
            if(pieceIndex === position) {
                piece.classList.add('correct');
            } else {
                piece.classList.remove('correct');
            }
        }

        // Sélectionner une pièce
        function selectPiece(position) {
            if(gameState.isPaused || !gameState.isPlaying) return;
            
            const pieces = document.querySelectorAll('.puzzle-piece');
            
            if(gameState.selectedPiece === null) {
                gameState.selectedPiece = position;
                pieces[position].classList.add('selected');
            } else if(gameState.selectedPiece === position) {
                gameState.selectedPiece = null;
                pieces[position].classList.remove('selected');
            } else {
                // Échanger les pièces
                const piece1 = gameState.selectedPiece;
                const piece2 = position;
                
                [gameState.board[piece1], gameState.board[piece2]] = [gameState.board[piece2], gameState.board[piece1]];
                
                updatePieceImage(pieces[piece1], piece1);
                updatePieceImage(pieces[piece2], piece2);
                
                pieces[piece1].classList.remove('selected');
                gameState.selectedPiece = null;
                
                gameState.moves++;
                updateUI();
                updateProgress();
                
                // Vérifier si le puzzle est résolu
                if(isPuzzleSolved()) {
                    solvePuzzle();
                }
            }
        }

        // Vérifier si le puzzle est résolu
        function isPuzzleSolved() {
            const totalPieces = gameState.gridSize * gameState.gridSize;
            for(let i = 0; i < totalPieces; i++) {
                if(gameState.board[i] !== i) {
                    return false;
                }
            }
            return true;
        }

        // Résoudre le puzzle
        function solvePuzzle() {
            gameState.isPlaying = false;
            clearInterval(gameState.timer);
            
            const elapsedTime = Date.now() - gameState.startTime;
            gameState.score = Math.max(1000 - gameState.moves * 10 - Math.floor(elapsedTime / 1000), 100);
            
            showVictoryEffect();
            showAIMessage(tm('puzzleSolved', gameState.score), 3000);
            
            // Mettre à jour les statistiques
            gameState.statistics.gamesPlayed++;
            gameState.statistics.gamesWon++;
            gameState.statistics.totalMoves += gameState.moves;
            gameState.statistics.totalTime += elapsedTime;
            
            if(gameState.score > gameState.statistics.bestScore) {
                gameState.statistics.bestScore = gameState.score;
            }
            
            updateUI();
        }

        // Afficher l'effet de victoire
        function showVictoryEffect() {
            const effect = document.createElement('div');
            effect.className = 'victory-effect';
            document.body.appendChild(effect);
            
            for(let i = 0; i < 50; i++) {
                const particle = document.createElement('div');
                particle.className = 'victory-particle';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.top = Math.random() * 100 + '%';
                particle.style.animationDelay = Math.random() * 2 + 's';
                effect.appendChild(particle);
            }
            
            setTimeout(() => {
                document.body.removeChild(effect);
            }, 3000);
        }

        // Afficher un message IA
        function showAIMessage(message, duration = 2000) {
            const aiThinking = document.getElementById('aiThinking');
            const aiMessage = document.getElementById('aiMessage');
            
            aiMessage.textContent = message;
            aiThinking.classList.add('active');
            
            setTimeout(() => {
                aiThinking.classList.remove('active');
            }, duration);
        }

        // Démarrer le timer
        function startTimer() {
            if(gameState.timer) {
                clearInterval(gameState.timer);
            }
            
            gameState.timer = setInterval(() => {
                if(!gameState.isPaused && gameState.isPlaying) {
                    updateUI();
                }
            }, 1000);
        }

        // Mettre à jour l'interface utilisateur
        function updateUI() {
            document.getElementById('aiLevel').textContent = gameState.aiLevel;
            document.getElementById('neuralScore').textContent = gameState.score;
            document.getElementById('moveCount').textContent = gameState.moves;
            
            if(gameState.isPlaying && !gameState.isPaused) {
                const elapsedTime = Date.now() - gameState.startTime;
                const minutes = Math.floor(elapsedTime / 60000);
                const seconds = Math.floor((elapsedTime % 60000) / 1000);
                document.getElementById('neuralTime').textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
        }

        // Mettre à jour la progression
        function updateProgress() {
            const totalPieces = gameState.gridSize * gameState.gridSize;
            let correctPieces = 0;
            
            for(let i = 0; i < totalPieces; i++) {
                if(gameState.board[i] === i) {
                    correctPieces++;
                }
            }
            
            const progress = (correctPieces / totalPieces) * 100;
            document.getElementById('progressFill').style.width = progress + '%';
            document.getElementById('progressText').textContent = Math.round(progress) + '% ' + t('completed');
        }

        // Fonctions des boutons
        function getAIHint() {
            if(gameState.hintUsed) {
                showAIMessage(tm('hintUsed'), 2000);
                return;
            }
            
            showAIMessage(t('aiThinking'), 2000);
            
            setTimeout(() => {
                const totalPieces = gameState.gridSize * gameState.gridSize;
                let wrongPieces = [];
                
                for(let i = 0; i < totalPieces; i++) {
                    if(gameState.board[i] !== i) {
                        wrongPieces.push(i);
                    }
                }
                
                if(wrongPieces.length === 0) {
                    showAIMessage(tm('allCorrect'), 2000);
                } else {
                    const hintPosition = wrongPieces[Math.floor(Math.random() * wrongPieces.length)];
                    showAIMessage(tm('wrongPiece', hintPosition + 1), 3000);
                    
                    // Mettre en évidence la pièce
                    const pieces = document.querySelectorAll('.puzzle-piece');
                    pieces[hintPosition].style.border = '3px solid #FFD700';
                    pieces[hintPosition].style.boxShadow = '0 0 20px #FFD700';
                    
                    setTimeout(() => {
                        pieces[hintPosition].style.border = '';
                        pieces[hintPosition].style.boxShadow = '';
                    }, 3000);
                }
                
                gameState.hintUsed = true;
            }, 2000);
        }

        function changeImage() {
            gameState.currentImageIndex = (gameState.currentImageIndex + 1) % puzzleImages.length;
            gameState.currentImageData = puzzleImages[gameState.currentImageIndex];
            
            showAIMessage(tm('newImageMsg', gameState.currentImageData.name), 2000);
            generateNewPuzzle();
        }

        function aiSolvePuzzle() {
            if(gameState.isSolving) return;
            
            gameState.isSolving = true;
            showAIMessage(t('solving'), 1000);
            
            setTimeout(() => {
                const totalPieces = gameState.gridSize * gameState.gridSize;
                for(let i = 0; i < totalPieces; i++) {
                    gameState.board[i] = i;
                }
                
                const pieces = document.querySelectorAll('.puzzle-piece');
                pieces.forEach((piece, index) => {
                    updatePieceImage(piece, index);
                });
                
                gameState.moves += 10; // Pénalité pour l'aide IA
                gameState.isSolving = false;
                
                showAIMessage(tm('aiSolved'), 2000);
                solvePuzzle();
            }, 2000);
        }

        function changeGridSize() {
            const sizes = [4, 5, 6];
            const currentIndex = sizes.indexOf(gameState.gridSize);
            const nextIndex = (currentIndex + 1) % sizes.length;
            gameState.gridSize = sizes[nextIndex];
            
            const totalPieces = gameState.gridSize * gameState.gridSize;
            document.getElementById('gridSizeBtn').innerHTML = 
                `🎯 ${t('level')}: ${gameState.gridSize}x${gameState.gridSize} (${totalPieces})`;
            
            showAIMessage(tm('gridChanged', gameState.gridSize), 2000);
            generateNewPuzzle();
        }

        function toggleAutoSolve() {
            gameState.autoSolve = !gameState.autoSolve;
            const btn = document.getElementById('autoSolveBtn');
            
            if(gameState.autoSolve) {
                btn.classList.add('active');
                showAIMessage(tm('autoSolveOn'), 2000);
            } else {
                btn.classList.remove('active');
                showAIMessage(tm('autoSolveOff'), 2000);
            }
        }

        function changeDifficulty() {
            const difficulties = ['easy', 'normal', 'hard', 'expert'];
            const currentIndex = difficulties.indexOf(gameState.difficulty);
            const nextIndex = (currentIndex + 1) % difficulties.length;
            gameState.difficulty = difficulties[nextIndex];
            
            document.getElementById('difficultyBtn').innerHTML = 
                `⚙️ ${t('difficulty')}: ${gameState.difficulty}`;
        }

        function saveGame() {
            const saveData = {
                board: gameState.board,
                moves: gameState.moves,
                score: gameState.score,
                gridSize: gameState.gridSize,
                difficulty: gameState.difficulty,
                currentImageIndex: gameState.currentImageIndex,
                statistics: gameState.statistics
            };
            
            localStorage.setItem('neuralPuzzleSave', JSON.stringify(saveData));
            showAIMessage(tm('gameSaved'), 2000);
        }

        function loadGame() {
            const saveData = localStorage.getItem('neuralPuzzleSave');
            if(saveData) {
                const data = JSON.parse(saveData);
                gameState.board = data.board;
                gameState.moves = data.moves;
                gameState.score = data.score;
                gameState.gridSize = data.gridSize;
                gameState.difficulty = data.difficulty;
                gameState.currentImageIndex = data.currentImageIndex;
                gameState.statistics = data.statistics;
                
                gameState.currentImageData = puzzleImages[gameState.currentImageIndex];
                createPuzzleBoard();
                updateUI();
                updateProgress();
                
                showAIMessage(tm('gameLoaded'), 2000);
            }
        }

        function showOptimalPath() {
            showAIMessage(t('aiThinking'), 2000);
            
            setTimeout(() => {
                const analysisText = document.getElementById('analysisText');
                analysisText.innerHTML = `
                    🎯 <strong>${t('optimalPath')}</strong><br><br>
                    ${t('recommendedMoves')}: ${Math.max(5, 20 - gameState.moves)}<br>
                    ${t('currentEfficiency')}: ${Math.max(20, 100 - gameState.moves * 2)}%<br><br>
                    <strong>${t('strategy')}:</strong> Commencer par les coins<br>
                    <strong>${t('advice')}:</strong> Observez les motifs de couleur
                `;
            }, 2000);
        }

        function analyzePosition() {
            showAIMessage(t('aiThinking'), 2000);
            
            setTimeout(() => {
                const totalPieces = gameState.gridSize * gameState.gridSize;
                let correctPieces = 0;
                
                for(let i = 0; i < totalPieces; i++) {
                    if(gameState.board[i] === i) {
                        correctPieces++;
                    }
                }
                
                const progress = Math.round((correctPieces / totalPieces) * 100);
                const complexity = gameState.moves < 10 ? 'Faible' : gameState.moves < 30 ? 'Moyenne' : 'Élevée';
                
                const analysisText = document.getElementById('analysisText');
                analysisText.innerHTML = `
                    🔍 <strong>Analyse de Position</strong><br><br>
                    Pièces correctes: ${correctPieces}/${totalPieces}<br>
                    Progression: ${progress}%<br>
                    Complexité: ${complexity}<br>
                    Temps estimé: ${Math.max(1, Math.round((totalPieces - correctPieces) / 2))} min<br>
                    Score potentiel: ${Math.max(100, 1000 - gameState.moves * 15)}
                `;
            }, 2000);
        }

        function showStatistics() {
            const analysisText = document.getElementById('analysisText');
            const winRate = gameState.statistics.gamesPlayed > 0 ? 
                Math.round((gameState.statistics.gamesWon / gameState.statistics.gamesPlayed) * 100) : 0;
            const avgMoves = gameState.statistics.gamesPlayed > 0 ? 
                Math.round(gameState.statistics.totalMoves / gameState.statistics.gamesPlayed) : 0;
            
            analysisText.innerHTML = `
                📊 <strong>Statistiques Globales</strong><br><br>
                Parties jouées: ${gameState.statistics.gamesPlayed}<br>
                Parties gagnées: ${gameState.statistics.gamesWon}<br>
                Taux de réussite: ${winRate}%<br>
                Meilleur score: ${gameState.statistics.bestScore}<br>
                Mouvements moyens: ${avgMoves}<br><br>
                Niveau IA actuel: ${gameState.aiLevel}<br>
                Rang: ${gameState.aiLevel < 3 ? 'Débutant' : gameState.aiLevel < 6 ? 'Intermédiaire' : 'Expert'}
            `;
        }

        // Initialisation
        document.addEventListener('DOMContentLoaded', function() {
            const savedLanguage = localStorage.getItem('neuralPuzzleLanguage');
            if(savedLanguage && translations[savedLanguage]) {
                gameState.currentLanguage = savedLanguage;
                const flags = {
                    fr: '🇫🇷 Français',
                    en: '🇺🇸 English',
                    ar: '🇸🇦 العربية',
                    es: '🇪🇸 Español',
                    de: '🇩🇪 Deutsch',
                    zh: '🇨🇳 中文'
                };
                document.getElementById('languageBtn').textContent = `🌐 ${flags[savedLanguage]}`;
            }
            
            createNeuralParticles();
            initGame();
            updateLanguage();
            
            // Charger une sauvegarde si elle existe
            if(localStorage.getItem('neuralPuzzleSave')) {
                setTimeout(() => loadGame(), 1000);
            }
        });
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'98420401738b11a5',t:'MTc1ODcxNDExNy4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script>


</template>

<script>
function launchGame3() {
  const card = document.getElementById('card3');
  const tpl = document.getElementById('game3Template');
  if (card && tpl) {
    // Créer un iframe isolé
    const iframe = document.createElement('iframe');
    iframe.style.width = "100%";
    iframe.style.height = "600px";
    iframe.style.border = "none";
    iframe.style.borderRadius = "12px";
    iframe.title = "Neural Puzzle Master";
    card.innerHTML = "";
    card.appendChild(iframe);
    card.onclick = null;

    // Injecter le contenu du template dans l'iframe
    const doc = iframe.contentWindow.document;
    doc.open();
    doc.write(tpl.innerHTML);
    doc.close();
  }
}
</script>


<div id="gameOverlay3" style="display:none;">
  <button onclick="closeGame3()" style="position:absolute;top:10px;right:10px;z-index:10000;font-size:24px;background:red;color:white;border:none;border-radius:50%;width:40px;height:40px;cursor:pointer;">✖</button>
  <iframe id="iframeGame3" src="data:text/html;base64,PCFET0NUWVBFIGh0bWw+CjxodG1sIGxhbmc9ImZyIj4KPGhlYWQ+CiAgICA8bWV0YSBjaGFyc2V0PSJVVEYtOCI+CiAgICA8bWV0YSBuYW1lPSJ2aWV3cG9ydCIgY29udGVudD0id2lkdGg9ZGV2aWNlLXdpZHRoLCBpbml0aWFsLXNjYWxlPTEuMCI+CiAgICA8dGl0bGU+8J+nqSBOZXVyYWwgUHV6emxlIE1hc3RlciAtIElBIEZ1dHVyaXN0ZTwvdGl0bGU+CiAgICA8c2NyaXB0IHNyYz0iaHR0cHM6Ly9jZG4udGFpbHdpbmRjc3MuY29tIj48L3NjcmlwdD4KICAgIDxzdHlsZT4KICAgICAgICAqIHsKICAgICAgICAgICAgbWFyZ2luOiAwOwogICAgICAgICAgICBwYWRkaW5nOiAwOwogICAgICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94OwogICAgICAgIH0KCiAgICAgICAgYm9keSB7CiAgICAgICAgICAgIGZvbnQtZmFtaWx5OiAnU2Vnb2UgVUknLCBUYWhvbWEsIEdlbmV2YSwgVmVyZGFuYSwgc2Fucy1zZXJpZjsKICAgICAgICAgICAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KDEzNWRlZywgIzBmMGYyMyAwJSwgIzFhMWEyZSA1MCUsICMxNjIxM2UgMTAwJSk7CiAgICAgICAgICAgIG1pbi1oZWlnaHQ6IDEwMHZoOwogICAgICAgICAgICBvdmVyZmxvdy14OiBoaWRkZW47CiAgICAgICAgICAgIG92ZXJmbG93LXk6IGF1dG87CiAgICAgICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTsKICAgICAgICB9CgogICAgICAgIC8qIFBhcnRpY3VsZXMgZCdhcnJpw6hyZS1wbGFuIGZ1dHVyaXN0ZXMgKi8KICAgICAgICAubmV1cmFsLXBhcnRpY2xlcyB7CiAgICAgICAgICAgIHBvc2l0aW9uOiBmaXhlZDsKICAgICAgICAgICAgdG9wOiAwOwogICAgICAgICAgICBsZWZ0OiAwOwogICAgICAgICAgICB3aWR0aDogMTAwJTsKICAgICAgICAgICAgaGVpZ2h0OiAxMDAlOwogICAgICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTsKICAgICAgICAgICAgei1pbmRleDogMTsKICAgICAgICB9CgogICAgICAgIC5uZXVyYWwtcGFydGljbGUgewogICAgICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7CiAgICAgICAgICAgIHdpZHRoOiAycHg7CiAgICAgICAgICAgIGhlaWdodDogMnB4OwogICAgICAgICAgICBiYWNrZ3JvdW5kOiAjMDBmZmZmOwogICAgICAgICAgICBib3JkZXItcmFkaXVzOiA1MCU7CiAgICAgICAgICAgIGFuaW1hdGlvbjogbmV1cmFsRmxvYXQgOHMgaW5maW5pdGUgbGluZWFyOwogICAgICAgICAgICBib3gtc2hhZG93OiAwIDAgNnB4ICMwMGZmZmY7CiAgICAgICAgfQoKICAgICAgICBAa2V5ZnJhbWVzIG5ldXJhbEZsb2F0IHsKICAgICAgICAgICAgMCUgewogICAgICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDEwMHZoKSB0cmFuc2xhdGVYKDApIHJvdGF0ZSgwZGVnKTsKICAgICAgICAgICAgICAgIG9wYWNpdHk6IDA7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgMTAlIHsKICAgICAgICAgICAgICAgIG9wYWNpdHk6IDE7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgOTAlIHsKICAgICAgICAgICAgICAgIG9wYWNpdHk6IDE7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgMTAwJSB7CiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTEwdmgpIHRyYW5zbGF0ZVgoMTAwcHgpIHJvdGF0ZSgzNjBkZWcpOwogICAgICAgICAgICAgICAgb3BhY2l0eTogMDsKICAgICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgLyogR3JpbGxlIGRlIGZvbmQgY3liZXJwdW5rICovCiAgICAgICAgLmN5YmVyLWdyaWQgewogICAgICAgICAgICBwb3NpdGlvbjogZml4ZWQ7CiAgICAgICAgICAgIHRvcDogMDsKICAgICAgICAgICAgbGVmdDogMDsKICAgICAgICAgICAgd2lkdGg6IDEwMCU7CiAgICAgICAgICAgIGhlaWdodDogMTAwJTsKICAgICAgICAgICAgYmFja2dyb3VuZC1pbWFnZTogCiAgICAgICAgICAgICAgICBsaW5lYXItZ3JhZGllbnQocmdiYSgwLCAyNTUsIDI1NSwgMC4xKSAxcHgsIHRyYW5zcGFyZW50IDFweCksCiAgICAgICAgICAgICAgICBsaW5lYXItZ3JhZGllbnQoOTBkZWcsIHJnYmEoMCwgMjU1LCAyNTUsIDAuMSkgMXB4LCB0cmFuc3BhcmVudCAxcHgpOwogICAgICAgICAgICBiYWNrZ3JvdW5kLXNpemU6IDUwcHggNTBweDsKICAgICAgICAgICAgYW5pbWF0aW9uOiBncmlkTW92ZSAyMHMgbGluZWFyIGluZmluaXRlOwogICAgICAgICAgICB6LWluZGV4OiAxOwogICAgICAgIH0KCiAgICAgICAgQGtleWZyYW1lcyBncmlkTW92ZSB7CiAgICAgICAgICAgIDAlIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUoMCwgMCk7IH0KICAgICAgICAgICAgMTAwJSB7IHRyYW5zZm9ybTogdHJhbnNsYXRlKDUwcHgsIDUwcHgpOyB9CiAgICAgICAgfQoKICAgICAgICAvKiBDb250YWluZXIgcHJpbmNpcGFsICovCiAgICAgICAgLm5ldXJhbC1wdXp6bGUtY29udGFpbmVyIHsKICAgICAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlOwogICAgICAgICAgICB6LWluZGV4OiAxMDsKICAgICAgICAgICAgZGlzcGxheTogZ3JpZDsKICAgICAgICAgICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiAyNTBweCAxZnIgMjUwcHg7CiAgICAgICAgICAgIGdhcDogMjBweDsKICAgICAgICAgICAgbWluLWhlaWdodDogMTAwdmg7CiAgICAgICAgICAgIHBhZGRpbmc6IDE1cHg7CiAgICAgICAgICAgIHBhZGRpbmctdG9wOiAyMHB4OwogICAgICAgICAgICBtYXgtd2lkdGg6IDE0MDBweDsKICAgICAgICAgICAgbWFyZ2luOiAwIGF1dG87CiAgICAgICAgfQoKICAgICAgICAubGVmdC1wYW5lbCwgLnJpZ2h0LXBhbmVsIHsKICAgICAgICAgICAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KDE0NWRlZywgCiAgICAgICAgICAgICAgICByZ2JhKDI2LCAyNiwgNDYsIDAuOTUpIDAlLAogICAgICAgICAgICAgICAgcmdiYSgyMiwgMzMsIDYyLCAwLjk1KSA1MCUsCiAgICAgICAgICAgICAgICByZ2JhKDE1LCAxNSwgMzUsIDAuOTUpIDEwMCUpOwogICAgICAgICAgICBiYWNrZHJvcC1maWx0ZXI6IGJsdXIoMjBweCk7CiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDIwcHg7CiAgICAgICAgICAgIHBhZGRpbmc6IDIwcHg7CiAgICAgICAgICAgIGhlaWdodDogZml0LWNvbnRlbnQ7CiAgICAgICAgICAgIGJveC1zaGFkb3c6IAogICAgICAgICAgICAgICAgMCAyMHB4IDQwcHggcmdiYSgwLCAwLCAwLCAwLjUpLAogICAgICAgICAgICAgICAgMCAwIDgwcHggcmdiYSgwLCAyNTUsIDI1NSwgMC4xKSwKICAgICAgICAgICAgICAgIGluc2V0IDAgMXB4IDAgcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjEpOwogICAgICAgICAgICBib3JkZXI6IDJweCBzb2xpZCByZ2JhKDAsIDI1NSwgMjU1LCAwLjMpOwogICAgICAgICAgICBhbmltYXRpb246IHBhbmVsR2xvdyAzcyBlYXNlLWluLW91dCBpbmZpbml0ZSBhbHRlcm5hdGU7CiAgICAgICAgfQoKICAgICAgICAuZ2FtZS1wYW5lbCB7CiAgICAgICAgICAgIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCgxNDVkZWcsIAogICAgICAgICAgICAgICAgcmdiYSgyNiwgMjYsIDQ2LCAwLjk1KSAwJSwKICAgICAgICAgICAgICAgIHJnYmEoMjIsIDMzLCA2MiwgMC45NSkgNTAlLAogICAgICAgICAgICAgICAgcmdiYSgxNSwgMTUsIDM1LCAwLjk1KSAxMDAlKTsKICAgICAgICAgICAgYmFja2Ryb3AtZmlsdGVyOiBibHVyKDIwcHgpOwogICAgICAgICAgICBib3JkZXItcmFkaXVzOiAyMHB4OwogICAgICAgICAgICBwYWRkaW5nOiAyNXB4OwogICAgICAgICAgICB3aWR0aDogMTAwJTsKICAgICAgICAgICAgaGVpZ2h0OiBmaXQtY29udGVudDsKICAgICAgICAgICAgYm94LXNoYWRvdzogCiAgICAgICAgICAgICAgICAwIDIwcHggNDBweCByZ2JhKDAsIDAsIDAsIDAuNSksCiAgICAgICAgICAgICAgICAwIDAgODBweCByZ2JhKDAsIDI1NSwgMjU1LCAwLjEpLAogICAgICAgICAgICAgICAgaW5zZXQgMCAxcHggMCByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMSk7CiAgICAgICAgICAgIGJvcmRlcjogMnB4IHNvbGlkIHJnYmEoMCwgMjU1LCAyNTUsIDAuMyk7CiAgICAgICAgICAgIGFuaW1hdGlvbjogcGFuZWxHbG93IDNzIGVhc2UtaW4tb3V0IGluZmluaXRlIGFsdGVybmF0ZTsKICAgICAgICB9CgogICAgICAgIEBrZXlmcmFtZXMgcGFuZWxHbG93IHsKICAgICAgICAgICAgZnJvbSB7IAogICAgICAgICAgICAgICAgYm94LXNoYWRvdzogCiAgICAgICAgICAgICAgICAgICAgMCAyNXB4IDUwcHggcmdiYSgwLCAwLCAwLCAwLjUpLAogICAgICAgICAgICAgICAgICAgIDAgMCAxMDBweCByZ2JhKDAsIDI1NSwgMjU1LCAwLjEpLAogICAgICAgICAgICAgICAgICAgIGluc2V0IDAgMXB4IDAgcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjEpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHRvIHsgCiAgICAgICAgICAgICAgICBib3gtc2hhZG93OiAKICAgICAgICAgICAgICAgICAgICAwIDI1cHggNTBweCByZ2JhKDAsIDAsIDAsIDAuNSksCiAgICAgICAgICAgICAgICAgICAgMCAwIDEyMHB4IHJnYmEoMCwgMjU1LCAyNTUsIDAuMiksCiAgICAgICAgICAgICAgICAgICAgaW5zZXQgMCAxcHggMCByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMik7CiAgICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIC8qIEVuLXTDqnRlIGR1IGpldSAqLwogICAgICAgIC5uZXVyYWwtaGVhZGVyIHsKICAgICAgICAgICAgZGlzcGxheTogZmxleDsKICAgICAgICAgICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuOwogICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyOwogICAgICAgICAgICBtYXJnaW4tYm90dG9tOiAyMHB4OwogICAgICAgICAgICBwYWRkaW5nLWJvdHRvbTogMTVweDsKICAgICAgICAgICAgYm9yZGVyLWJvdHRvbTogMnB4IHNvbGlkIHJnYmEoMCwgMjU1LCAyNTUsIDAuMyk7CiAgICAgICAgfQoKICAgICAgICAubmV1cmFsLXRpdGxlIHsKICAgICAgICAgICAgZGlzcGxheTogZmxleDsKICAgICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjsKICAgICAgICAgICAgZ2FwOiAxNXB4OwogICAgICAgIH0KCiAgICAgICAgLm5ldXJhbC10aXRsZSBoMSB7CiAgICAgICAgICAgIGNvbG9yOiAjMDBmZmZmOwogICAgICAgICAgICBtYXJnaW46IDA7CiAgICAgICAgICAgIGZvbnQtc2l6ZTogMjRweDsKICAgICAgICAgICAgZm9udC13ZWlnaHQ6IDcwMDsKICAgICAgICAgICAgdGV4dC1zaGFkb3c6IDAgMCAyMHB4IHJnYmEoMCwgMjU1LCAyNTUsIDAuNik7CiAgICAgICAgICAgIGFuaW1hdGlvbjogdGl0bGVQdWxzZSAycyBpbmZpbml0ZSBhbHRlcm5hdGU7CiAgICAgICAgfQoKICAgICAgICBAa2V5ZnJhbWVzIHRpdGxlUHVsc2UgewogICAgICAgICAgICBmcm9tIHsgdGV4dC1zaGFkb3c6IDAgMCAyMHB4IHJnYmEoMCwgMjU1LCAyNTUsIDAuNik7IH0KICAgICAgICAgICAgdG8geyB0ZXh0LXNoYWRvdzogMCAwIDMwcHggcmdiYSgwLCAyNTUsIDI1NSwgMC45KTsgfQogICAgICAgIH0KCiAgICAgICAgLm5ldXJhbC1pY29uIHsKICAgICAgICAgICAgZm9udC1zaXplOiAzMnB4OwogICAgICAgICAgICBhbmltYXRpb246IGljb25TcGluIDRzIGxpbmVhciBpbmZpbml0ZTsKICAgICAgICAgICAgZmlsdGVyOiBkcm9wLXNoYWRvdygwIDAgMTBweCAjMDBmZmZmKTsKICAgICAgICB9CgogICAgICAgIEBrZXlmcmFtZXMgaWNvblNwaW4gewogICAgICAgICAgICBmcm9tIHsgdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7IH0KICAgICAgICAgICAgdG8geyB0cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpOyB9CiAgICAgICAgfQoKICAgICAgICAuYWktYmFkZ2UgewogICAgICAgICAgICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoNDVkZWcsICNmZjZiNmIsICM0ZWNkYzQsICM0NWI3YWEpOwogICAgICAgICAgICBiYWNrZ3JvdW5kLXNpemU6IDIwMCUgMjAwJTsKICAgICAgICAgICAgY29sb3I6IHdoaXRlOwogICAgICAgICAgICBwYWRkaW5nOiA4cHggMTZweDsKICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogMjBweDsKICAgICAgICAgICAgZm9udC1zaXplOiAxNHB4OwogICAgICAgICAgICBmb250LXdlaWdodDogYm9sZDsKICAgICAgICAgICAgYW5pbWF0aW9uOiBiYWRnZVNoaW5lIDNzIGVhc2UtaW4tb3V0IGluZmluaXRlOwogICAgICAgICAgICBib3gtc2hhZG93OiAwIDAgMTVweCByZ2JhKDc4LCAyMDUsIDE5NiwgMC41KTsKICAgICAgICB9CgogICAgICAgIEBrZXlmcmFtZXMgYmFkZ2VTaGluZSB7CiAgICAgICAgICAgIDAlLCAxMDAlIHsgYmFja2dyb3VuZC1wb3NpdGlvbjogMCUgNTAlOyB9CiAgICAgICAgICAgIDUwJSB7IGJhY2tncm91bmQtcG9zaXRpb246IDEwMCUgNTAlOyB9CiAgICAgICAgfQoKICAgICAgICAuY2xvc2UtYnRuIHsKICAgICAgICAgICAgYmFja2dyb3VuZDogcmdiYSgyNTUsIDAsIDAsIDAuMik7CiAgICAgICAgICAgIGJvcmRlcjogMnB4IHNvbGlkIHJnYmEoMjU1LCAwLCAwLCAwLjUpOwogICAgICAgICAgICBjb2xvcjogI2ZmNmI2YjsKICAgICAgICAgICAgd2lkdGg6IDQ1cHg7CiAgICAgICAgICAgIGhlaWdodDogNDVweDsKICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogNTAlOwogICAgICAgICAgICBmb250LXNpemU6IDIwcHg7CiAgICAgICAgICAgIGN1cnNvcjogcG9pbnRlcjsKICAgICAgICAgICAgdHJhbnNpdGlvbjogYWxsIDAuM3MgZWFzZTsKICAgICAgICAgICAgZGlzcGxheTogZmxleDsKICAgICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjsKICAgICAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7CiAgICAgICAgfQoKICAgICAgICAuY2xvc2UtYnRuOmhvdmVyIHsKICAgICAgICAgICAgYmFja2dyb3VuZDogcmdiYSgyNTUsIDAsIDAsIDAuNCk7CiAgICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMS4xKSByb3RhdGUoOTBkZWcpOwogICAgICAgICAgICBib3gtc2hhZG93OiAwIDAgMjBweCByZ2JhKDI1NSwgMTA3LCAxMDcsIDAuNik7CiAgICAgICAgfQoKICAgICAgICAvKiBFbi10w6p0ZSBkZXMgY29udHLDtGxlcyBkZSBqZXUgKi8KICAgICAgICAuZ2FtZS1oZWFkZXItY29udHJvbHMgewogICAgICAgICAgICBkaXNwbGF5OiBmbGV4OwogICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47CiAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7CiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDIwcHg7CiAgICAgICAgICAgIHBhZGRpbmc6IDE1cHg7CiAgICAgICAgICAgIGJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMCwgMC4zKTsKICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogMTVweDsKICAgICAgICAgICAgYm9yZGVyOiAycHggc29saWQgcmdiYSgwLCAyNTUsIDI1NSwgMC4yKTsKICAgICAgICB9CgogICAgICAgIC8qIFPDqWxlY3RldXIgZGUgbGFuZ3VlICovCiAgICAgICAgLmxhbmd1YWdlLXNlbGVjdG9yIHsKICAgICAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlOwogICAgICAgIH0KCiAgICAgICAgLmxhbmd1YWdlLWJ0biB7CiAgICAgICAgICAgIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCgxNDVkZWcsICM2YzVjZTcsICM1ZjNkYzQpOwogICAgICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7CiAgICAgICAgICAgIHotaW5kZXg6IDEwOwogICAgICAgIH0KCiAgICAgICAgLmxhbmd1YWdlLWJ0bjpob3ZlciB7CiAgICAgICAgICAgIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCgxNDVkZWcsICM3YzZjZTcsICM2ZjRkYzQpOwogICAgICAgIH0KCiAgICAgICAgLmxhbmd1YWdlLW1lbnUgewogICAgICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7CiAgICAgICAgICAgIHRvcDogMTAwJTsKICAgICAgICAgICAgbGVmdDogNTAlOwogICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwJSk7CiAgICAgICAgICAgIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCgxNDVkZWcsIAogICAgICAgICAgICAgICAgcmdiYSgyNiwgMjYsIDQ2LCAwLjk4KSAwJSwKICAgICAgICAgICAgICAgIHJnYmEoMjIsIDMzLCA2MiwgMC45OCkgNTAlLAogICAgICAgICAgICAgICAgcmdiYSgxNSwgMTUsIDM1LCAwLjk4KSAxMDAlKTsKICAgICAgICAgICAgYmFja2Ryb3AtZmlsdGVyOiBibHVyKDIwcHgpOwogICAgICAgICAgICBib3JkZXI6IDJweCBzb2xpZCByZ2JhKDAsIDI1NSwgMjU1LCAwLjMpOwogICAgICAgICAgICBib3JkZXItcmFkaXVzOiAxNXB4OwogICAgICAgICAgICBwYWRkaW5nOiAxMHB4OwogICAgICAgICAgICBkaXNwbGF5OiBub25lOwogICAgICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uOwogICAgICAgICAgICBnYXA6IDVweDsKICAgICAgICAgICAgbWluLXdpZHRoOiAxODBweDsKICAgICAgICAgICAgei1pbmRleDogMjA7CiAgICAgICAgICAgIGJveC1zaGFkb3c6IDAgMTBweCAzMHB4IHJnYmEoMCwgMCwgMCwgMC41KTsKICAgICAgICAgICAgYW5pbWF0aW9uOiBzbGlkZURvd24gMC4zcyBlYXNlLW91dDsKICAgICAgICB9CgogICAgICAgIC5sYW5ndWFnZS1tZW51LmFjdGl2ZSB7CiAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7CiAgICAgICAgfQoKICAgICAgICBAa2V5ZnJhbWVzIHNsaWRlRG93biB7CiAgICAgICAgICAgIGZyb20gewogICAgICAgICAgICAgICAgb3BhY2l0eTogMDsKICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtNTAlKSB0cmFuc2xhdGVZKC0xMHB4KTsKICAgICAgICAgICAgfQogICAgICAgICAgICB0byB7CiAgICAgICAgICAgICAgICBvcGFjaXR5OiAxOwogICAgICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MCUpIHRyYW5zbGF0ZVkoMCk7CiAgICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIC5sYW5ndWFnZS1vcHRpb24gewogICAgICAgICAgICBiYWNrZ3JvdW5kOiByZ2JhKDAsIDI1NSwgMjU1LCAwLjEpOwogICAgICAgICAgICBib3JkZXI6IDFweCBzb2xpZCByZ2JhKDAsIDI1NSwgMjU1LCAwLjMpOwogICAgICAgICAgICBjb2xvcjogIzAwZmZmZjsKICAgICAgICAgICAgcGFkZGluZzogOHB4IDEycHg7CiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDhweDsKICAgICAgICAgICAgY3Vyc29yOiBwb2ludGVyOwogICAgICAgICAgICB0cmFuc2l0aW9uOiBhbGwgMC4zcyBlYXNlOwogICAgICAgICAgICBmb250LXNpemU6IDEycHg7CiAgICAgICAgICAgIHRleHQtYWxpZ246IGxlZnQ7CiAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7CiAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7CiAgICAgICAgICAgIGdhcDogOHB4OwogICAgICAgIH0KCiAgICAgICAgLmxhbmd1YWdlLW9wdGlvbjpob3ZlciB7CiAgICAgICAgICAgIGJhY2tncm91bmQ6IHJnYmEoMCwgMjU1LCAyNTUsIDAuMik7CiAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCg1cHgpOwogICAgICAgICAgICBib3gtc2hhZG93OiAwIDAgMTVweCByZ2JhKDAsIDI1NSwgMjU1LCAwLjMpOwogICAgICAgIH0KCiAgICAgICAgLmxhbmd1YWdlLW9wdGlvbi5zZWxlY3RlZCB7CiAgICAgICAgICAgIGJhY2tncm91bmQ6IHJnYmEoMCwgMjU1LCAyNTUsIDAuMyk7CiAgICAgICAgICAgIGJvcmRlci1jb2xvcjogcmdiYSgwLCAyNTUsIDI1NSwgMC42KTsKICAgICAgICB9CgogICAgICAgIC8qIEJvdXRvbiBQYXVzZSAqLwogICAgICAgIC5wYXVzZS1jb250cm9sIHsKICAgICAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlOwogICAgICAgIH0KCiAgICAgICAgLnBhdXNlLWJ0biB7CiAgICAgICAgICAgIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCgxNDVkZWcsICNlNzRjM2MsICNjMDM5MmIpOwogICAgICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7CiAgICAgICAgICAgIHotaW5kZXg6IDEwOwogICAgICAgICAgICBtaW4td2lkdGg6IDEyMHB4OwogICAgICAgIH0KCiAgICAgICAgLnBhdXNlLWJ0bjpob3ZlciB7CiAgICAgICAgICAgIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCgxNDVkZWcsICNmNzRjM2MsICNkMDM5MmIpOwogICAgICAgIH0KCiAgICAgICAgLnBhdXNlLWJ0bi5wYXVzZWQgewogICAgICAgICAgICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoMTQ1ZGVnLCAjMjdhZTYwLCAjMjI5OTU0KTsKICAgICAgICB9CgogICAgICAgIC5wYXVzZS1idG4ucGF1c2VkOmhvdmVyIHsKICAgICAgICAgICAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KDE0NWRlZywgIzM3YmU3MCwgIzMzOTk2NCk7CiAgICAgICAgfQoKICAgICAgICAvKiBTdGF0aXN0aXF1ZXMgaG9yaXpvbnRhbGVzICovCiAgICAgICAgLm5ldXJhbC1zdGF0cy1ob3Jpem9udGFsIHsKICAgICAgICAgICAgZGlzcGxheTogZmxleDsKICAgICAgICAgICAgZ2FwOiAyMHB4OwogICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyOwogICAgICAgIH0KCiAgICAgICAgLm5ldXJhbC1zdGF0cy1ob3Jpem9udGFsIC5zdGF0LWl0ZW0gewogICAgICAgICAgICBiYWNrZ3JvdW5kOiByZ2JhKDAsIDI1NSwgMjU1LCAwLjEpOwogICAgICAgICAgICBwYWRkaW5nOiA4cHggMTVweDsKICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogMTJweDsKICAgICAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyOwogICAgICAgICAgICBib3JkZXI6IDJweCBzb2xpZCByZ2JhKDAsIDI1NSwgMjU1LCAwLjMpOwogICAgICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7CiAgICAgICAgICAgIG92ZXJmbG93OiBoaWRkZW47CiAgICAgICAgICAgIG1pbi13aWR0aDogODBweDsKICAgICAgICB9CgogICAgICAgIC5uZXVyYWwtc3RhdHMtaG9yaXpvbnRhbCAuc3RhdC1pdGVtOjpiZWZvcmUgewogICAgICAgICAgICBjb250ZW50OiAnJzsKICAgICAgICAgICAgcG9zaXRpb246IGFic29sdXRlOwogICAgICAgICAgICB0b3A6IDA7CiAgICAgICAgICAgIGxlZnQ6IC0xMDAlOwogICAgICAgICAgICB3aWR0aDogMTAwJTsKICAgICAgICAgICAgaGVpZ2h0OiAxMDAlOwogICAgICAgICAgICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoOTBkZWcsIHRyYW5zcGFyZW50LCByZ2JhKDAsIDI1NSwgMjU1LCAwLjIpLCB0cmFuc3BhcmVudCk7CiAgICAgICAgICAgIGFuaW1hdGlvbjogc3RhdFNjYW4gM3MgbGluZWFyIGluZmluaXRlOwogICAgICAgIH0KCiAgICAgICAgQGtleWZyYW1lcyBzdGF0U2NhbiB7CiAgICAgICAgICAgIDAlIHsgbGVmdDogLTEwMCU7IH0KICAgICAgICAgICAgMTAwJSB7IGxlZnQ6IDEwMCU7IH0KICAgICAgICB9CgogICAgICAgIC5uZXVyYWwtc3RhdHMtaG9yaXpvbnRhbCAuc3RhdC1sYWJlbCB7CiAgICAgICAgICAgIGRpc3BsYXk6IGJsb2NrOwogICAgICAgICAgICBjb2xvcjogIzg4ODsKICAgICAgICAgICAgZm9udC1zaXplOiAxMHB4OwogICAgICAgICAgICBtYXJnaW4tYm90dG9tOiA0cHg7CiAgICAgICAgICAgIHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7CiAgICAgICAgICAgIGxldHRlci1zcGFjaW5nOiAxcHg7CiAgICAgICAgfQoKICAgICAgICAubmV1cmFsLXN0YXRzLWhvcml6b250YWwgLnN0YXQtdmFsdWUgewogICAgICAgICAgICBkaXNwbGF5OiBibG9jazsKICAgICAgICAgICAgY29sb3I6ICMwMGZmZmY7CiAgICAgICAgICAgIGZvbnQtc2l6ZTogMTZweDsKICAgICAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7CiAgICAgICAgICAgIHRleHQtc2hhZG93OiAwIDAgMTBweCByZ2JhKDAsIDI1NSwgMjU1LCAwLjYpOwogICAgICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7CiAgICAgICAgICAgIHotaW5kZXg6IDE7CiAgICAgICAgfQoKICAgICAgICAvKiBTdGF0dXQgSUEgKi8KICAgICAgICAubmV1cmFsLWFpLXN0YXR1cyB7CiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDE1cHg7CiAgICAgICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjsKICAgICAgICAgICAgbWluLWhlaWdodDogMjVweDsKICAgICAgICAgICAgZGlzcGxheTogZmxleDsKICAgICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjsKICAgICAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7CiAgICAgICAgfQoKICAgICAgICAuYWktdGhpbmtpbmcgewogICAgICAgICAgICBkaXNwbGF5OiBpbmxpbmUtZmxleDsKICAgICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjsKICAgICAgICAgICAgZ2FwOiAxMnB4OwogICAgICAgICAgICBjb2xvcjogIzRlY2RjNDsKICAgICAgICAgICAgZm9udC1zaXplOiAxNnB4OwogICAgICAgICAgICBvcGFjaXR5OiAwOwogICAgICAgICAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuNXMgZWFzZTsKICAgICAgICAgICAgYmFja2dyb3VuZDogcmdiYSg3OCwgMjA1LCAxOTYsIDAuMSk7CiAgICAgICAgICAgIHBhZGRpbmc6IDEwcHggMjBweDsKICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogMjVweDsKICAgICAgICAgICAgYm9yZGVyOiAxcHggc29saWQgcmdiYSg3OCwgMjA1LCAxOTYsIDAuMyk7CiAgICAgICAgfQoKICAgICAgICAuYWktdGhpbmtpbmcuYWN0aXZlIHsKICAgICAgICAgICAgb3BhY2l0eTogMTsKICAgICAgICB9CgogICAgICAgIC5haS1wdWxzZSB7CiAgICAgICAgICAgIHdpZHRoOiAxMnB4OwogICAgICAgICAgICBoZWlnaHQ6IDEycHg7CiAgICAgICAgICAgIGJhY2tncm91bmQ6ICM0ZWNkYzQ7CiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDUwJTsKICAgICAgICAgICAgYW5pbWF0aW9uOiBhaVB1bHNlIDEuNXMgaW5maW5pdGU7CiAgICAgICAgICAgIGJveC1zaGFkb3c6IDAgMCAxMHB4ICM0ZWNkYzQ7CiAgICAgICAgfQoKICAgICAgICBAa2V5ZnJhbWVzIGFpUHVsc2UgewogICAgICAgICAgICAwJSwgMTAwJSB7IAogICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgxKTsgCiAgICAgICAgICAgICAgICBvcGFjaXR5OiAxOyAKICAgICAgICAgICAgfQogICAgICAgICAgICA1MCUgeyAKICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMS41KTsgCiAgICAgICAgICAgICAgICBvcGFjaXR5OiAwLjU7IAogICAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICAvKiBQbGF0ZWF1eCBkZSBqZXUgY8O0dGUgw6AgY8O0dGUgKi8KICAgICAgICAuZ2FtZS1ib2FyZHMtY29udGFpbmVyIHsKICAgICAgICAgICAgZGlzcGxheTogZmxleDsKICAgICAgICAgICAgZ2FwOiAzMHB4OwogICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjsKICAgICAgICAgICAgYWxpZ24taXRlbXM6IGZsZXgtc3RhcnQ7CiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDIwcHg7CiAgICAgICAgfQoKICAgICAgICAuYm9hcmQtc2VjdGlvbiB7CiAgICAgICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjsKICAgICAgICAgICAgZmxleDogMTsKICAgICAgICB9CgogICAgICAgIC5yZWZlcmVuY2UtYm9hcmQgewogICAgICAgICAgICB3aWR0aDogMzAwcHg7CiAgICAgICAgICAgIGhlaWdodDogMzAwcHg7CiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDE1cHg7CiAgICAgICAgICAgIGJvcmRlcjogM3B4IHNvbGlkIHJnYmEoMCwgMjU1LCAyNTUsIDAuNSk7CiAgICAgICAgICAgIGJveC1zaGFkb3c6IDAgMCAyMHB4IHJnYmEoMCwgMjU1LCAyNTUsIDAuMyk7CiAgICAgICAgICAgIGFuaW1hdGlvbjogcmVmZXJlbmNlR2xvdyAzcyBlYXNlLWluLW91dCBpbmZpbml0ZSBhbHRlcm5hdGU7CiAgICAgICAgfQoKICAgICAgICAucHV6emxlLWJvYXJkIHsKICAgICAgICAgICAgd2lkdGg6IDMwMHB4OwogICAgICAgICAgICBoZWlnaHQ6IDMwMHB4OwogICAgICAgICAgICBkaXNwbGF5OiBncmlkOwogICAgICAgICAgICBnYXA6IDJweDsKICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogMTVweDsKICAgICAgICAgICAgYm9yZGVyOiAzcHggc29saWQgcmdiYSgyNTUsIDEwNywgMTA3LCAwLjUpOwogICAgICAgICAgICBib3gtc2hhZG93OiAwIDAgMjBweCByZ2JhKDI1NSwgMTA3LCAxMDcsIDAuMyk7CiAgICAgICAgICAgIGJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMCwgMC4zKTsKICAgICAgICAgICAgcGFkZGluZzogNXB4OwogICAgICAgICAgICBtYXJnaW46IDAgYXV0bzsKICAgICAgICAgICAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjNzIGVhc2U7CiAgICAgICAgfQoKICAgICAgICAucHV6emxlLWJvYXJkLmdyaWQtNHg0IHsKICAgICAgICAgICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiByZXBlYXQoNCwgMWZyKTsKICAgICAgICAgICAgZ3JpZC10ZW1wbGF0ZS1yb3dzOiByZXBlYXQoNCwgMWZyKTsKICAgICAgICB9CgogICAgICAgIC5wdXp6bGUtYm9hcmQuZ3JpZC01eDUgewogICAgICAgICAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IHJlcGVhdCg1LCAxZnIpOwogICAgICAgICAgICBncmlkLXRlbXBsYXRlLXJvd3M6IHJlcGVhdCg1LCAxZnIpOwogICAgICAgIH0KCiAgICAgICAgLnB1enpsZS1ib2FyZC5ncmlkLTZ4NiB7CiAgICAgICAgICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogcmVwZWF0KDYsIDFmcik7CiAgICAgICAgICAgIGdyaWQtdGVtcGxhdGUtcm93czogcmVwZWF0KDYsIDFmcik7CiAgICAgICAgfQoKICAgICAgICAucHV6emxlLXBpZWNlIHsKICAgICAgICAgICAgYmFja2dyb3VuZC1zaXplOiAzMDBweCAzMDBweDsKICAgICAgICAgICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDsKICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogOHB4OwogICAgICAgICAgICBjdXJzb3I6IHBvaW50ZXI7CiAgICAgICAgICAgIHRyYW5zaXRpb246IGFsbCAwLjNzIGVhc2U7CiAgICAgICAgICAgIGJvcmRlcjogMnB4IHNvbGlkIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKTsKICAgICAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlOwogICAgICAgICAgICBvdmVyZmxvdzogaGlkZGVuOwogICAgICAgIH0KCiAgICAgICAgLnB1enpsZS1waWVjZTpob3ZlciB7CiAgICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMS4wNSk7CiAgICAgICAgICAgIGJvcmRlci1jb2xvcjogcmdiYSgwLCAyNTUsIDI1NSwgMC44KTsKICAgICAgICAgICAgYm94LXNoYWRvdzogMCAwIDE1cHggcmdiYSgwLCAyNTUsIDI1NSwgMC41KTsKICAgICAgICAgICAgei1pbmRleDogMTA7CiAgICAgICAgfQoKICAgICAgICAucHV6emxlLXBpZWNlLnNlbGVjdGVkIHsKICAgICAgICAgICAgYm9yZGVyLWNvbG9yOiByZ2JhKDI1NSwgMjE1LCAwLCAxKTsKICAgICAgICAgICAgYm94LXNoYWRvdzogMCAwIDIwcHggcmdiYSgyNTUsIDIxNSwgMCwgMC44KTsKICAgICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgxLjEpOwogICAgICAgICAgICB6LWluZGV4OiAyMDsKICAgICAgICB9CgogICAgICAgIC5wdXp6bGUtcGllY2UuY29ycmVjdCB7CiAgICAgICAgICAgIGJvcmRlci1jb2xvcjogcmdiYSgwLCAyNTUsIDAsIDAuOCk7CiAgICAgICAgICAgIGJveC1zaGFkb3c6IDAgMCAxNXB4IHJnYmEoMCwgMjU1LCAwLCAwLjUpOwogICAgICAgIH0KCiAgICAgICAgQGtleWZyYW1lcyByZWZlcmVuY2VHbG93IHsKICAgICAgICAgICAgZnJvbSB7IGJveC1zaGFkb3c6IDAgMCAyMHB4IHJnYmEoMCwgMjU1LCAyNTUsIDAuMyk7IH0KICAgICAgICAgICAgdG8geyBib3gtc2hhZG93OiAwIDAgMzBweCByZ2JhKDAsIDI1NSwgMjU1LCAwLjYpOyB9CiAgICAgICAgfQoKICAgICAgICAuYm9hcmQtbGFiZWwgewogICAgICAgICAgICBjb2xvcjogIzAwZmZmZjsKICAgICAgICAgICAgZm9udC1zaXplOiAxNHB4OwogICAgICAgICAgICBtYXJnaW4tdG9wOiAxNXB4OwogICAgICAgICAgICB0ZXh0LXRyYW5zZm9ybTogdXBwZXJjYXNlOwogICAgICAgICAgICBsZXR0ZXItc3BhY2luZzogMXB4OwogICAgICAgICAgICB0ZXh0LXNoYWRvdzogMCAwIDEwcHggcmdiYSgwLCAyNTUsIDI1NSwgMC42KTsKICAgICAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7CiAgICAgICAgfQoKICAgICAgICAucHV6emxlLWxhYmVsIHsKICAgICAgICAgICAgY29sb3I6ICNmZjZiNmI7CiAgICAgICAgICAgIHRleHQtc2hhZG93OiAwIDAgMTBweCByZ2JhKDI1NSwgMTA3LCAxMDcsIDAuNik7CiAgICAgICAgfQoKICAgICAgICAvKiBDb250csO0bGVzIGR1IGpldSAqLwogICAgICAgIC5uZXVyYWwtY29udHJvbHMgewogICAgICAgICAgICBkaXNwbGF5OiBncmlkOwogICAgICAgICAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IDFmcjsKICAgICAgICAgICAgZ2FwOiAxMHB4OwogICAgICAgICAgICBtYXJnaW4tYm90dG9tOiAxOHB4OwogICAgICAgIH0KCiAgICAgICAgLnBhbmVsLXNlY3Rpb24gewogICAgICAgICAgICBtYXJnaW4tYm90dG9tOiAyMHB4OwogICAgICAgIH0KCiAgICAgICAgLnBhbmVsLXRpdGxlIHsKICAgICAgICAgICAgY29sb3I6ICMwMGZmZmY7CiAgICAgICAgICAgIGZvbnQtc2l6ZTogMTRweDsKICAgICAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7CiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDE1cHg7CiAgICAgICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjsKICAgICAgICAgICAgdGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTsKICAgICAgICAgICAgbGV0dGVyLXNwYWNpbmc6IDFweDsKICAgICAgICAgICAgdGV4dC1zaGFkb3c6IDAgMCAxMHB4IHJnYmEoMCwgMjU1LCAyNTUsIDAuNik7CiAgICAgICAgICAgIGJvcmRlci1ib3R0b206IDJweCBzb2xpZCByZ2JhKDAsIDI1NSwgMjU1LCAwLjMpOwogICAgICAgICAgICBwYWRkaW5nLWJvdHRvbTogOHB4OwogICAgICAgIH0KCiAgICAgICAgLm5ldXJhbC1idG4gewogICAgICAgICAgICBwYWRkaW5nOiAxMnB4IDE4cHg7CiAgICAgICAgICAgIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCgxNDVkZWcsICM0ZWNkYzQsICM0NWI3YWEpOwogICAgICAgICAgICBjb2xvcjogd2hpdGU7CiAgICAgICAgICAgIGJvcmRlcjogbm9uZTsKICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogMTBweDsKICAgICAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7CiAgICAgICAgICAgIGZvbnQtc2l6ZTogMTJweDsKICAgICAgICAgICAgY3Vyc29yOiBwb2ludGVyOwogICAgICAgICAgICB0cmFuc2l0aW9uOiBhbGwgMC4zcyBlYXNlOwogICAgICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7CiAgICAgICAgICAgIG92ZXJmbG93OiBoaWRkZW47CiAgICAgICAgICAgIHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7CiAgICAgICAgICAgIGxldHRlci1zcGFjaW5nOiAwLjVweDsKICAgICAgICB9CgogICAgICAgIC5uZXVyYWwtYnRuOjpiZWZvcmUgewogICAgICAgICAgICBjb250ZW50OiAnJzsKICAgICAgICAgICAgcG9zaXRpb246IGFic29sdXRlOwogICAgICAgICAgICB0b3A6IDA7CiAgICAgICAgICAgIGxlZnQ6IC0xMDAlOwogICAgICAgICAgICB3aWR0aDogMTAwJTsKICAgICAgICAgICAgaGVpZ2h0OiAxMDAlOwogICAgICAgICAgICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoOTBkZWcsIHRyYW5zcGFyZW50LCByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMyksIHRyYW5zcGFyZW50KTsKICAgICAgICAgICAgdHJhbnNpdGlvbjogbGVmdCAwLjVzIGVhc2U7CiAgICAgICAgfQoKICAgICAgICAubmV1cmFsLWJ0bjpob3Zlcjo6YmVmb3JlIHsKICAgICAgICAgICAgbGVmdDogMTAwJTsKICAgICAgICB9CgogICAgICAgIC5uZXVyYWwtYnRuOmhvdmVyIHsKICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC0zcHgpOwogICAgICAgICAgICBib3gtc2hhZG93OiAwIDhweCAyNXB4IHJnYmEoNzgsIDIwNSwgMTk2LCAwLjQpOwogICAgICAgICAgICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoMTQ1ZGVnLCAjNWZkNGQ0LCAjNGVjZGM0KTsKICAgICAgICB9CgogICAgICAgIC5uZXVyYWwtYnRuOmFjdGl2ZSB7CiAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtMXB4KTsKICAgICAgICB9CgogICAgICAgIC5uZXVyYWwtYnRuOmRpc2FibGVkIHsKICAgICAgICAgICAgb3BhY2l0eTogMC41OwogICAgICAgICAgICBjdXJzb3I6IG5vdC1hbGxvd2VkOwogICAgICAgICAgICB0cmFuc2Zvcm06IG5vbmU7CiAgICAgICAgfQoKICAgICAgICAvKiBGb25jdGlvbm5hbGl0w6lzIGF2YW5jw6llcyAqLwogICAgICAgIC5hZHZhbmNlZC1mZWF0dXJlcyB7CiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDIwcHg7CiAgICAgICAgfQoKICAgICAgICAuZmVhdHVyZS1yb3cgewogICAgICAgICAgICBkaXNwbGF5OiBncmlkOwogICAgICAgICAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IHJlcGVhdCgzLCAxZnIpOwogICAgICAgICAgICBnYXA6IDhweDsKICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogOHB4OwogICAgICAgIH0KCiAgICAgICAgLnN0YXRzLWhvcml6b250YWwgewogICAgICAgICAgICBkaXNwbGF5OiBmbGV4OwogICAgICAgICAgICBmbGV4LXdyYXA6IHdyYXA7CiAgICAgICAgICAgIGdhcDogOHB4OwogICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47CiAgICAgICAgfQoKICAgICAgICAuc3RhdHMtaG9yaXpvbnRhbCAubmV1cmFsLWJ0biB7CiAgICAgICAgICAgIGZsZXg6IDE7CiAgICAgICAgICAgIG1pbi13aWR0aDogMTIwcHg7CiAgICAgICAgICAgIGZvbnQtc2l6ZTogMTBweDsKICAgICAgICAgICAgcGFkZGluZzogOHB4IDEwcHg7CiAgICAgICAgfQoKICAgICAgICAuZmVhdHVyZS1idG4gewogICAgICAgICAgICBmb250LXNpemU6IDExcHg7CiAgICAgICAgICAgIHBhZGRpbmc6IDEwcHggMTJweDsKICAgICAgICAgICAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KDE0NWRlZywgIzZjNWNlNywgIzVmM2RjNCk7CiAgICAgICAgfQoKICAgICAgICAuZmVhdHVyZS1idG46aG92ZXIgewogICAgICAgICAgICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoMTQ1ZGVnLCAjN2M2Y2U3LCAjNmY0ZGM0KTsKICAgICAgICB9CgogICAgICAgIC5mZWF0dXJlLWJ0bi5hY3RpdmUgewogICAgICAgICAgICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoMTQ1ZGVnLCAjMDBiODk0LCAjMDBhMDg1KTsKICAgICAgICB9CgogICAgICAgIC8qIFBhbm5lYXUgZCdhbmFseXNlICovCiAgICAgICAgLmFuYWx5c2lzLXBhbmVsIHsKICAgICAgICAgICAgYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAwLjYpOwogICAgICAgICAgICBib3JkZXI6IDJweCBzb2xpZCByZ2JhKDAsIDI1NSwgMjU1LCAwLjMpOwogICAgICAgICAgICBib3JkZXItcmFkaXVzOiAxMnB4OwogICAgICAgICAgICBwYWRkaW5nOiAxNXB4OwogICAgICAgICAgICBtYXJnaW4tYm90dG9tOiAxNXB4OwogICAgICAgICAgICBkaXNwbGF5OiBub25lOwogICAgICAgIH0KCiAgICAgICAgLmFuYWx5c2lzLXBhbmVsLmFjdGl2ZSB7CiAgICAgICAgICAgIGRpc3BsYXk6IGJsb2NrOwogICAgICAgICAgICBhbmltYXRpb246IHNsaWRlRG93blBhbmVsIDAuM3MgZWFzZS1vdXQ7CiAgICAgICAgfQoKICAgICAgICBAa2V5ZnJhbWVzIHNsaWRlRG93blBhbmVsIHsKICAgICAgICAgICAgZnJvbSB7IG9wYWNpdHk6IDA7IHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtMTBweCk7IH0KICAgICAgICAgICAgdG8geyBvcGFjaXR5OiAxOyB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMCk7IH0KICAgICAgICB9CgogICAgICAgIC5hbmFseXNpcy10ZXh0IHsKICAgICAgICAgICAgY29sb3I6ICMwMGZmZmY7CiAgICAgICAgICAgIGZvbnQtc2l6ZTogMTRweDsKICAgICAgICAgICAgbGluZS1oZWlnaHQ6IDEuNDsKICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMTBweDsKICAgICAgICB9CgogICAgICAgIC5kaWZmaWN1bHR5LWluZGljYXRvciB7CiAgICAgICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jazsKICAgICAgICAgICAgcGFkZGluZzogNHB4IDhweDsKICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogOHB4OwogICAgICAgICAgICBmb250LXNpemU6IDEwcHg7CiAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkOwogICAgICAgICAgICBtYXJnaW4tbGVmdDogNXB4OwogICAgICAgIH0KCiAgICAgICAgLmRpZmZpY3VsdHktZWFzeSB7IGJhY2tncm91bmQ6ICMwMGI4OTQ7IH0KICAgICAgICAuZGlmZmljdWx0eS1ub3JtYWwgeyBiYWNrZ3JvdW5kOiAjZmRjYjZlOyBjb2xvcjogIzJkMzQzNjsgfQogICAgICAgIC5kaWZmaWN1bHR5LWhhcmQgeyBiYWNrZ3JvdW5kOiAjZTE3MDU1OyB9CiAgICAgICAgLmRpZmZpY3VsdHktZXhwZXJ0IHsgYmFja2dyb3VuZDogI2Q2MzAzMTsgfQoKICAgICAgICAvKiBCYXJyZSBkZSBwcm9ncmVzc2lvbiAqLwogICAgICAgIC5uZXVyYWwtcHJvZ3Jlc3MgewogICAgICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7CiAgICAgICAgfQoKICAgICAgICAucHJvZ3Jlc3MtY29udGFpbmVyIHsKICAgICAgICAgICAgYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAwLjQpOwogICAgICAgICAgICBib3JkZXItcmFkaXVzOiAxNXB4OwogICAgICAgICAgICBwYWRkaW5nOiA1cHg7CiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDE1cHg7CiAgICAgICAgICAgIGJvcmRlcjogMnB4IHNvbGlkIHJnYmEoMCwgMjU1LCAyNTUsIDAuMyk7CiAgICAgICAgfQoKICAgICAgICAucHJvZ3Jlc3MtYmFyIHsKICAgICAgICAgICAgd2lkdGg6IDEwMCU7CiAgICAgICAgICAgIGhlaWdodDogMTJweDsKICAgICAgICAgICAgYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAwLjYpOwogICAgICAgICAgICBib3JkZXItcmFkaXVzOiAxMHB4OwogICAgICAgICAgICBvdmVyZmxvdzogaGlkZGVuOwogICAgICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7CiAgICAgICAgfQoKICAgICAgICAucHJvZ3Jlc3MtZmlsbCB7CiAgICAgICAgICAgIGhlaWdodDogMTAwJTsKICAgICAgICAgICAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KDkwZGVnLCAjNGVjZGM0LCAjMDBmZmZmLCAjNGVjZGM0KTsKICAgICAgICAgICAgYmFja2dyb3VuZC1zaXplOiAyMDAlIDEwMCU7CiAgICAgICAgICAgIHdpZHRoOiAwJTsKICAgICAgICAgICAgdHJhbnNpdGlvbjogd2lkdGggMC44cyBlYXNlOwogICAgICAgICAgICBib3JkZXItcmFkaXVzOiAxMHB4OwogICAgICAgICAgICBhbmltYXRpb246IHByb2dyZXNzU2hpbmUgMnMgbGluZWFyIGluZmluaXRlOwogICAgICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7CiAgICAgICAgfQoKICAgICAgICBAa2V5ZnJhbWVzIHByb2dyZXNzU2hpbmUgewogICAgICAgICAgICAwJSB7IGJhY2tncm91bmQtcG9zaXRpb246IC0yMDAlIDA7IH0KICAgICAgICAgICAgMTAwJSB7IGJhY2tncm91bmQtcG9zaXRpb246IDIwMCUgMDsgfQogICAgICAgIH0KCiAgICAgICAgLnByb2dyZXNzLWZpbGw6OmFmdGVyIHsKICAgICAgICAgICAgY29udGVudDogJyc7CiAgICAgICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTsKICAgICAgICAgICAgdG9wOiAwOwogICAgICAgICAgICBsZWZ0OiAwOwogICAgICAgICAgICByaWdodDogMDsKICAgICAgICAgICAgYm90dG9tOiAwOwogICAgICAgICAgICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoOTBkZWcsIHRyYW5zcGFyZW50LCByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMyksIHRyYW5zcGFyZW50KTsKICAgICAgICAgICAgYW5pbWF0aW9uOiBwcm9ncmVzc0dsb3cgMS41cyBlYXNlLWluLW91dCBpbmZpbml0ZSBhbHRlcm5hdGU7CiAgICAgICAgfQoKICAgICAgICBAa2V5ZnJhbWVzIHByb2dyZXNzR2xvdyB7CiAgICAgICAgICAgIGZyb20geyBvcGFjaXR5OiAwOyB9CiAgICAgICAgICAgIHRvIHsgb3BhY2l0eTogMTsgfQogICAgICAgIH0KCiAgICAgICAgLnByb2dyZXNzLXRleHQgewogICAgICAgICAgICBjb2xvcjogIzAwZmZmZjsKICAgICAgICAgICAgZm9udC1zaXplOiAxNnB4OwogICAgICAgICAgICBmb250LXdlaWdodDogYm9sZDsKICAgICAgICAgICAgdGV4dC1zaGFkb3c6IDAgMCAxMHB4IHJnYmEoMCwgMjU1LCAyNTUsIDAuNik7CiAgICAgICAgfQoKICAgICAgICAvKiBFZmZldHMgZGUgdmljdG9pcmUgKi8KICAgICAgICAudmljdG9yeS1lZmZlY3QgewogICAgICAgICAgICBwb3NpdGlvbjogZml4ZWQ7CiAgICAgICAgICAgIHRvcDogMDsKICAgICAgICAgICAgbGVmdDogMDsKICAgICAgICAgICAgd2lkdGg6IDEwMCU7CiAgICAgICAgICAgIGhlaWdodDogMTAwJTsKICAgICAgICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7CiAgICAgICAgICAgIHotaW5kZXg6IDEwMDA7CiAgICAgICAgfQoKICAgICAgICAudmljdG9yeS1wYXJ0aWNsZSB7CiAgICAgICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTsKICAgICAgICAgICAgd2lkdGg6IDZweDsKICAgICAgICAgICAgaGVpZ2h0OiA2cHg7CiAgICAgICAgICAgIGJhY2tncm91bmQ6ICMwMGZmZmY7CiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDUwJTsKICAgICAgICAgICAgYW5pbWF0aW9uOiB2aWN0b3J5QnVyc3QgMnMgZWFzZS1vdXQgZm9yd2FyZHM7CiAgICAgICAgfQoKICAgICAgICBAa2V5ZnJhbWVzIHZpY3RvcnlCdXJzdCB7CiAgICAgICAgICAgIDAlIHsKICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMCkgcm90YXRlKDBkZWcpOwogICAgICAgICAgICAgICAgb3BhY2l0eTogMTsKICAgICAgICAgICAgfQogICAgICAgICAgICAxMDAlIHsKICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMSkgcm90YXRlKDcyMGRlZyk7CiAgICAgICAgICAgICAgICBvcGFjaXR5OiAwOwogICAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICAvKiBSZXNwb25zaXZlICovCiAgICAgICAgQG1lZGlhIChtYXgtd2lkdGg6IDEyMDBweCkgewogICAgICAgICAgICAubmV1cmFsLXB1enpsZS1jb250YWluZXIgewogICAgICAgICAgICAgICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiAxZnI7CiAgICAgICAgICAgICAgICBnYXA6IDE1cHg7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgCiAgICAgICAgICAgIC5sZWZ0LXBhbmVsLCAucmlnaHQtcGFuZWwgewogICAgICAgICAgICAgICAgZGlzcGxheTogbm9uZTsKICAgICAgICAgICAgfQogICAgICAgICAgICAKICAgICAgICAgICAgLmdhbWUtYm9hcmRzLWNvbnRhaW5lciB7CiAgICAgICAgICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uOwogICAgICAgICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjsKICAgICAgICAgICAgICAgIGdhcDogMjBweDsKICAgICAgICAgICAgfQogICAgICAgICAgICAKICAgICAgICAgICAgLnJlZmVyZW5jZS1ib2FyZCwgLnB1enpsZS1ib2FyZCB7CiAgICAgICAgICAgICAgICB3aWR0aDogMjgwcHg7CiAgICAgICAgICAgICAgICBoZWlnaHQ6IDI4MHB4OwogICAgICAgICAgICB9CiAgICAgICAgICAgIAogICAgICAgICAgICAucHV6emxlLXBpZWNlIHsKICAgICAgICAgICAgICAgIGJhY2tncm91bmQtc2l6ZTogMjgwcHggMjgwcHg7CiAgICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIEBtZWRpYSAobWF4LXdpZHRoOiA3NjhweCkgewogICAgICAgICAgICAuZ2FtZS1wYW5lbCB7CiAgICAgICAgICAgICAgICBwYWRkaW5nOiAyMHB4OwogICAgICAgICAgICAgICAgbWFyZ2luOiAxMHB4OwogICAgICAgICAgICB9CiAgICAgICAgICAgIAogICAgICAgICAgICAuZ2FtZS1oZWFkZXItY29udHJvbHMgewogICAgICAgICAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjsKICAgICAgICAgICAgICAgIGdhcDogMTVweDsKICAgICAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBzdHJldGNoOwogICAgICAgICAgICB9CiAgICAgICAgICAgIAogICAgICAgICAgICAubmV1cmFsLXN0YXRzLWhvcml6b250YWwgewogICAgICAgICAgICAgICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuOwogICAgICAgICAgICAgICAgZ2FwOiAxMHB4OwogICAgICAgICAgICB9CiAgICAgICAgICAgIAogICAgICAgICAgICAubmV1cmFsLXN0YXRzLWhvcml6b250YWwgLnN0YXQtaXRlbSB7CiAgICAgICAgICAgICAgICBtaW4td2lkdGg6IDYwcHg7CiAgICAgICAgICAgICAgICBwYWRkaW5nOiA2cHggMTBweDsKICAgICAgICAgICAgfQogICAgICAgICAgICAKICAgICAgICAgICAgLm5ldXJhbC1jb250cm9scyB7CiAgICAgICAgICAgICAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IDFmcjsKICAgICAgICAgICAgICAgIGdhcDogMTJweDsKICAgICAgICAgICAgfQogICAgICAgICAgICAKICAgICAgICAgICAgLm5ldXJhbC10aXRsZSBoMSB7CiAgICAgICAgICAgICAgICBmb250LXNpemU6IDIycHg7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgCiAgICAgICAgICAgIC5nYW1lLWJvYXJkcy1jb250YWluZXIgewogICAgICAgICAgICAgICAgZ2FwOiAxNXB4OwogICAgICAgICAgICB9CiAgICAgICAgICAgIAogICAgICAgICAgICAucmVmZXJlbmNlLWJvYXJkLCAucHV6emxlLWJvYXJkIHsKICAgICAgICAgICAgICAgIHdpZHRoOiAyNTBweDsKICAgICAgICAgICAgICAgIGhlaWdodDogMjUwcHg7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgCiAgICAgICAgICAgIC5wdXp6bGUtcGllY2UgewogICAgICAgICAgICAgICAgYmFja2dyb3VuZC1zaXplOiAyNTBweCAyNTBweDsKICAgICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgQG1lZGlhIChtYXgtd2lkdGg6IDQ4MHB4KSB7CiAgICAgICAgICAgIC5uZXVyYWwtc3RhdHMtaG9yaXpvbnRhbCB7CiAgICAgICAgICAgICAgICBmbGV4LXdyYXA6IHdyYXA7CiAgICAgICAgICAgICAgICBnYXA6IDhweDsKICAgICAgICAgICAgfQogICAgICAgICAgICAKICAgICAgICAgICAgLm5ldXJhbC1zdGF0cy1ob3Jpem9udGFsIC5zdGF0LWl0ZW0gewogICAgICAgICAgICAgICAgZmxleDogMTsKICAgICAgICAgICAgICAgIG1pbi13aWR0aDogNzBweDsKICAgICAgICAgICAgfQogICAgICAgICAgICAKICAgICAgICAgICAgLm5ldXJhbC1zdGF0cy1ob3Jpem9udGFsIC5zdGF0LXZhbHVlIHsKICAgICAgICAgICAgICAgIGZvbnQtc2l6ZTogMTRweDsKICAgICAgICAgICAgfQogICAgICAgICAgICAKICAgICAgICAgICAgLnJlZmVyZW5jZS1ib2FyZCwgLnB1enpsZS1ib2FyZCB7CiAgICAgICAgICAgICAgICB3aWR0aDogMjIwcHg7CiAgICAgICAgICAgICAgICBoZWlnaHQ6IDIyMHB4OwogICAgICAgICAgICB9CiAgICAgICAgICAgIAogICAgICAgICAgICAucHV6emxlLXBpZWNlIHsKICAgICAgICAgICAgICAgIGJhY2tncm91bmQtc2l6ZTogMjIwcHggMjIwcHg7CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICA8L3N0eWxlPgo8L2hlYWQ+Cjxib2R5PgogICAgPCEtLSBQYXJ0aWN1bGVzIGQnYXJyacOocmUtcGxhbiAtLT4KICAgIDxkaXYgY2xhc3M9Im5ldXJhbC1wYXJ0aWNsZXMiIGlkPSJuZXVyYWxQYXJ0aWNsZXMiPjwvZGl2PgogICAgCiAgICA8IS0tIEdyaWxsZSBjeWJlcnB1bmsgLS0+CiAgICA8ZGl2IGNsYXNzPSJjeWJlci1ncmlkIj48L2Rpdj4KICAgIAogICAgPCEtLSBDb250YWluZXIgcHJpbmNpcGFsIC0tPgogICAgPGRpdiBjbGFzcz0ibmV1cmFsLXB1enpsZS1jb250YWluZXIiPgogICAgICAgIDwhLS0gUGFubmVhdSBnYXVjaGUgLS0+CiAgICAgICAgPGRpdiBjbGFzcz0ibGVmdC1wYW5lbCI+CiAgICAgICAgICAgIDxkaXYgY2xhc3M9InBhbmVsLXNlY3Rpb24iPgogICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0icGFuZWwtdGl0bGUiPvCfjq4gQ29udHLDtGxlczwvZGl2PgogICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0ibmV1cmFsLWNvbnRyb2xzIj4KICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPSJuZXVyYWwtYnRuIiBvbmNsaWNrPSJnZXRBSUhpbnQoKSIgaWQ9ImhpbnRCdG4iPgogICAgICAgICAgICAgICAgICAgICAgICDwn5KhIEluZGljZSBJQQogICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPgogICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9Im5ldXJhbC1idG4iIG9uY2xpY2s9ImNoYW5nZUltYWdlKCkiPgogICAgICAgICAgICAgICAgICAgICAgICDwn5a877iPIE5vdXZlbGxlIEltYWdlCiAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+CiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz0ibmV1cmFsLWJ0biIgb25jbGljaz0iYWlTb2x2ZVB1enpsZSgpIiBpZD0ic29sdmVCdG4iPgogICAgICAgICAgICAgICAgICAgICAgICDwn6SWIElBIFLDqXNvdXQKICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj4KICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICA8L2Rpdj4KCiAgICAgICAgICAgIDxkaXYgY2xhc3M9InBhbmVsLXNlY3Rpb24iPgogICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0icGFuZWwtdGl0bGUiPuKame+4jyBPcHRpb25zPC9kaXY+CiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJuZXVyYWwtY29udHJvbHMiPgogICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9Im5ldXJhbC1idG4gZmVhdHVyZS1idG4iIG9uY2xpY2s9ImNoYW5nZUdyaWRTaXplKCkiIGlkPSJncmlkU2l6ZUJ0biI+CiAgICAgICAgICAgICAgICAgICAgICAgIPCfjq8gTml2ZWF1OiA0eDQgKDE2KQogICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPgogICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9Im5ldXJhbC1idG4gZmVhdHVyZS1idG4iIG9uY2xpY2s9InRvZ2dsZUF1dG9Tb2x2ZSgpIiBpZD0iYXV0b1NvbHZlQnRuIj4KICAgICAgICAgICAgICAgICAgICAgICAg4pqhIEF1dG8tUsOpc29sdXRpb24KICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj4KICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPSJuZXVyYWwtYnRuIGZlYXR1cmUtYnRuIiBvbmNsaWNrPSJjaGFuZ2VEaWZmaWN1bHR5KCkiIGlkPSJkaWZmaWN1bHR5QnRuIj4KICAgICAgICAgICAgICAgICAgICAgICAg4pqZ77iPIERpZmZpY3VsdMOpOiBOb3JtYWwKICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj4KICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPSJuZXVyYWwtYnRuIGZlYXR1cmUtYnRuIiBvbmNsaWNrPSJzYXZlR2FtZSgpIiBpZD0ic2F2ZUJ0biI+CiAgICAgICAgICAgICAgICAgICAgICAgIPCfkr4gU2F1dmVnYXJkZXIKICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj4KICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICA8L2Rpdj4KICAgICAgICA8L2Rpdj4KCiAgICAgICAgPCEtLSBQYW5uZWF1IGNlbnRyYWwgLS0+CiAgICAgICAgPGRpdiBjbGFzcz0iZ2FtZS1wYW5lbCI+CiAgICAgICAgICAgIDwhLS0gRW4tdMOqdGUgLS0+CiAgICAgICAgICAgIDxkaXYgY2xhc3M9Im5ldXJhbC1oZWFkZXIiPgogICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0ibmV1cmFsLXRpdGxlIj4KICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0ibmV1cmFsLWljb24iPvCfp6k8L3NwYW4+CiAgICAgICAgICAgICAgICAgICAgPGgxPk5ldXJhbCBQdXp6bGUgTWFzdGVyPC9oMT4KICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0iYWktYmFkZ2UiPvCfpJYgSUEgQVZBTkPDiUU8L3NwYW4+CiAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9ImNsb3NlLWJ0biIgb25jbGljaz0id2luZG93LmNsb3NlKCkiIHRpdGxlPSJGZXJtZXIiPuKclTwvYnV0dG9uPgogICAgICAgICAgICA8L2Rpdj4KCiAgICAgICAgICAgIDwhLS0gRW4tdMOqdGUgYXZlYyBzw6lsZWN0ZXVyIGRlIGxhbmd1ZSBldCBwYXVzZSAtLT4KICAgICAgICAgICAgPGRpdiBjbGFzcz0iZ2FtZS1oZWFkZXItY29udHJvbHMiPgogICAgICAgICAgICAgICAgPCEtLSBTw6lsZWN0ZXVyIGRlIGxhbmd1ZSAtLT4KICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9Imxhbmd1YWdlLXNlbGVjdG9yIj4KICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPSJuZXVyYWwtYnRuIGxhbmd1YWdlLWJ0biIgb25jbGljaz0idG9nZ2xlTGFuZ3VhZ2VNZW51KCkiIGlkPSJsYW5ndWFnZUJ0biI+CiAgICAgICAgICAgICAgICAgICAgICAgIPCfjJAgRnJhbsOnYWlzCiAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+CiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0ibGFuZ3VhZ2UtbWVudSIgaWQ9Imxhbmd1YWdlTWVudSI+CiAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9Imxhbmd1YWdlLW9wdGlvbiIgb25jbGljaz0iY2hhbmdlTGFuZ3VhZ2UoJ2ZyJykiPvCfh6vwn4e3IEZyYW7Dp2FpczwvYnV0dG9uPgogICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPSJsYW5ndWFnZS1vcHRpb24iIG9uY2xpY2s9ImNoYW5nZUxhbmd1YWdlKCdlbicpIj7wn4e68J+HuCBFbmdsaXNoPC9idXR0b24+CiAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9Imxhbmd1YWdlLW9wdGlvbiIgb25jbGljaz0iY2hhbmdlTGFuZ3VhZ2UoJ2FyJykiPvCfh7jwn4emINin2YTYudix2KjZitipPC9idXR0b24+CiAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9Imxhbmd1YWdlLW9wdGlvbiIgb25jbGljaz0iY2hhbmdlTGFuZ3VhZ2UoJ2VzJykiPvCfh6rwn4e4IEVzcGHDsW9sPC9idXR0b24+CiAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9Imxhbmd1YWdlLW9wdGlvbiIgb25jbGljaz0iY2hhbmdlTGFuZ3VhZ2UoJ2RlJykiPvCfh6nwn4eqIERldXRzY2g8L2J1dHRvbj4KICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz0ibGFuZ3VhZ2Utb3B0aW9uIiBvbmNsaWNrPSJjaGFuZ2VMYW5ndWFnZSgnemgnKSI+8J+HqPCfh7Mg5Lit5paHPC9idXR0b24+CiAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICA8L2Rpdj4KCiAgICAgICAgICAgICAgICA8IS0tIEJvdXRvbiBQYXVzZS9SZXByaXNlIC0tPgogICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0icGF1c2UtY29udHJvbCI+CiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz0ibmV1cmFsLWJ0biBwYXVzZS1idG4iIG9uY2xpY2s9InRvZ2dsZVBhdXNlKCkiIGlkPSJwYXVzZUJ0biI+CiAgICAgICAgICAgICAgICAgICAgICAgIOKPuO+4jyBQYXVzZQogICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPgogICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgIDwhLS0gU3RhdGlzdGlxdWVzIGhvcml6b250YWxlcyAtLT4KICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9Im5ldXJhbC1zdGF0cy1ob3Jpem9udGFsIj4KICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJzdGF0LWl0ZW0iPgogICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0ic3RhdC1sYWJlbCI+Tml2ZWF1IElBPC9zcGFuPgogICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0ic3RhdC12YWx1ZSIgaWQ9ImFpTGV2ZWwiPjE8L3NwYW4+CiAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0ic3RhdC1pdGVtIj4KICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9InN0YXQtbGFiZWwiPlNjb3JlPC9zcGFuPgogICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0ic3RhdC12YWx1ZSIgaWQ9Im5ldXJhbFNjb3JlIj4wPC9zcGFuPgogICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InN0YXQtaXRlbSI+CiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSJzdGF0LWxhYmVsIj5Nb3V2ZW1lbnRzPC9zcGFuPgogICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0ic3RhdC12YWx1ZSIgaWQ9Im1vdmVDb3VudCI+MDwvc3Bhbj4KICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJzdGF0LWl0ZW0iPgogICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0ic3RhdC1sYWJlbCI+VGVtcHM8L3NwYW4+CiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSJzdGF0LXZhbHVlIiBpZD0ibmV1cmFsVGltZSI+MDA6MDA8L3NwYW4+CiAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgPC9kaXY+CgogICAgICAgICAgICA8IS0tIFBsYXRlYXV4IGRlIGpldSBjw7R0ZSDDoCBjw7R0ZSAtLT4KICAgICAgICAgICAgPGRpdiBjbGFzcz0iZ2FtZS1ib2FyZHMtY29udGFpbmVyIj4KICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImJvYXJkLXNlY3Rpb24iPgogICAgICAgICAgICAgICAgICAgIDxjYW52YXMgaWQ9InJlZmVyZW5jZUltYWdlIiBjbGFzcz0icmVmZXJlbmNlLWJvYXJkIiB3aWR0aD0iMzAwIiBoZWlnaHQ9IjMwMCI+PC9jYW52YXM+CiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iYm9hcmQtbGFiZWwiPvCflrzvuI8gSW1hZ2UgT3JpZ2luYWxlPC9kaXY+CiAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImJvYXJkLXNlY3Rpb24iPgogICAgICAgICAgICAgICAgICAgIDxkaXYgaWQ9InB1enpsZUJvYXJkIiBjbGFzcz0icHV6emxlLWJvYXJkIj4KICAgICAgICAgICAgICAgICAgICAgICAgPCEtLSBMZXMgY2FzZXMgZHUgcHV6emxlIHNlcm9udCBnw6luw6lyw6llcyBpY2kgLS0+CiAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iYm9hcmQtbGFiZWwgcHV6emxlLWxhYmVsIj7wn6epIFB1enpsZSDDoCBSZWNvbnN0aXR1ZXI8L2Rpdj4KICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICA8L2Rpdj4KCiAgICAgICAgICAgIDwhLS0gU3RhdHV0IElBIC0tPgogICAgICAgICAgICA8ZGl2IGNsYXNzPSJuZXVyYWwtYWktc3RhdHVzIj4KICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImFpLXRoaW5raW5nIiBpZD0iYWlUaGlua2luZyI+CiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9ImFpLXB1bHNlIj48L3NwYW4+CiAgICAgICAgICAgICAgICAgICAgPHNwYW4gaWQ9ImFpTWVzc2FnZSI+SUEgZW4gYW5hbHlzZS4uLjwvc3Bhbj4KICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICA8L2Rpdj4KCiAgICAgICAgICAgIDwhLS0gQmFycmUgZGUgcHJvZ3Jlc3Npb24gLS0+CiAgICAgICAgICAgIDxkaXYgY2xhc3M9Im5ldXJhbC1wcm9ncmVzcyI+CiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJwcm9ncmVzcy1jb250YWluZXIiPgogICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InByb2dyZXNzLWJhciI+CiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InByb2dyZXNzLWZpbGwiIGlkPSJwcm9ncmVzc0ZpbGwiPjwvZGl2PgogICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0icHJvZ3Jlc3MtdGV4dCIgaWQ9InByb2dyZXNzVGV4dCI+MCUgY29tcGzDqXTDqTwvc3Bhbj4KICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgPC9kaXY+CgogICAgICAgIDwhLS0gUGFubmVhdSBkcm9pdCAtLT4KICAgICAgICA8ZGl2IGNsYXNzPSJyaWdodC1wYW5lbCI+CiAgICAgICAgICAgIDxkaXYgY2xhc3M9InBhbmVsLXNlY3Rpb24iPgogICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0icGFuZWwtdGl0bGUiPvCflI0gQW5hbHlzZSBJQTwvZGl2PgogICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0ic3RhdHMtaG9yaXpvbnRhbCI+CiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz0ibmV1cmFsLWJ0biBmZWF0dXJlLWJ0biIgb25jbGljaz0ic2hvd09wdGltYWxQYXRoKCkiIGlkPSJwYXRoQnRuIj4KICAgICAgICAgICAgICAgICAgICAgICAg8J+OryBDaGVtaW4gT3B0aW1hbAogICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPgogICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9Im5ldXJhbC1idG4gZmVhdHVyZS1idG4iIG9uY2xpY2s9ImFuYWx5emVQb3NpdGlvbigpIiBpZD0iYW5hbHl6ZUJ0biI+CiAgICAgICAgICAgICAgICAgICAgICAgIPCflI0gQW5hbHlzZXIgUG9zaXRpb24KICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj4KICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPSJuZXVyYWwtYnRuIGZlYXR1cmUtYnRuIiBvbmNsaWNrPSJzaG93U3RhdGlzdGljcygpIiBpZD0ic3RhdHNCdG4iPgogICAgICAgICAgICAgICAgICAgICAgICDwn5OKIFN0YXRpc3RpcXVlcwogICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPgogICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgIDwvZGl2PgoKICAgICAgICAgICAgPCEtLSBQYW5uZWF1IGQnYW5hbHlzZSAtLT4KICAgICAgICAgICAgPGRpdiBjbGFzcz0icGFuZWwtc2VjdGlvbiI+CiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJhbmFseXNpcy1wYW5lbCBhY3RpdmUiIGlkPSJhbmFseXNpc1BhbmVsIj4KICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJhbmFseXNpcy10ZXh0IiBpZD0iYW5hbHlzaXNUZXh0Ij4KICAgICAgICAgICAgICAgICAgICAgICAg8J+kliA8c3BhbiBpZD0iYWlSZWFkeVRleHQiPkwnSUEgZXN0IHByw6p0ZSDDoCBhbmFseXNlciB2b3RyZSBwdXp6bGUgITwvc3Bhbj48YnI+PGJyPgogICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBpZD0iYW5hbHlzaXNJbnN0cnVjdGlvbnMiPlV0aWxpc2V6IGxlcyBib3V0b25zIGNpLWRlc3N1cyBwb3VyIG9idGVuaXIgZGVzIGFuYWx5c2VzIGTDqXRhaWxsw6llcyBkZSB2b3RyZSBwb3NpdGlvbiBhY3R1ZWxsZS48L3NwYW4+CiAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgPC9kaXY+CiAgICA8L2Rpdj4KCiAgICA8c2NyaXB0PgogICAgICAgIC8vIMOJdGF0IGR1IGpldQogICAgICAgIGxldCBnYW1lU3RhdGUgPSB7CiAgICAgICAgICAgIGJvYXJkOiBbXSwKICAgICAgICAgICAgY29ycmVjdEJvYXJkOiBbXSwKICAgICAgICAgICAgc2VsZWN0ZWRQaWVjZTogbnVsbCwKICAgICAgICAgICAgbW92ZXM6IDAsCiAgICAgICAgICAgIHN0YXJ0VGltZTogbnVsbCwKICAgICAgICAgICAgdGltZXI6IG51bGwsCiAgICAgICAgICAgIGFpTGV2ZWw6IDEsCiAgICAgICAgICAgIHNjb3JlOiAwLAogICAgICAgICAgICBpc1BsYXlpbmc6IGZhbHNlLAogICAgICAgICAgICBpc1NvbHZpbmc6IGZhbHNlLAogICAgICAgICAgICBoaW50VXNlZDogZmFsc2UsCiAgICAgICAgICAgIGF1dG9Tb2x2ZTogZmFsc2UsCiAgICAgICAgICAgIGRpZmZpY3VsdHk6ICdub3JtYWwnLAogICAgICAgICAgICBvcHRpbWFsUGF0aDogW10sCiAgICAgICAgICAgIGdhbWVIaXN0b3J5OiBbXSwKICAgICAgICAgICAgY3VycmVudEltYWdlSW5kZXg6IDAsCiAgICAgICAgICAgIGltYWdlQ2hhbmdlVGltZXI6IG51bGwsCiAgICAgICAgICAgIGN1cnJlbnRJbWFnZURhdGE6IG51bGwsCiAgICAgICAgICAgIGdyaWRTaXplOiA0LAogICAgICAgICAgICBjdXJyZW50TGFuZ3VhZ2U6ICdmcicsCiAgICAgICAgICAgIGlzUGF1c2VkOiBmYWxzZSwKICAgICAgICAgICAgcGF1c2VkVGltZTogMCwKICAgICAgICAgICAgc3RhdGlzdGljczogewogICAgICAgICAgICAgICAgZ2FtZXNQbGF5ZWQ6IDAsCiAgICAgICAgICAgICAgICBnYW1lc1dvbjogMCwKICAgICAgICAgICAgICAgIHRvdGFsTW92ZXM6IDAsCiAgICAgICAgICAgICAgICB0b3RhbFRpbWU6IDAsCiAgICAgICAgICAgICAgICBiZXN0U2NvcmU6IDAsCiAgICAgICAgICAgICAgICBhdmVyYWdlVGltZTogMAogICAgICAgICAgICB9CiAgICAgICAgfTsKCiAgICAgICAgLy8gQ29sbGVjdGlvbiBkJ2ltYWdlcyB2YXJpw6llcwogICAgICAgIGNvbnN0IHB1enpsZUltYWdlcyA9IFsKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgbmFtZTogIkZvcsOqdCBlbmNoYW50w6llIiwKICAgICAgICAgICAgICAgIHR5cGU6ICJuYXR1cmUiLAogICAgICAgICAgICAgICAgY29sb3JzOiBbIiMyMjhCMjIiLCAiIzMyQ0QzMiIsICIjMDA2NDAwIiwgIiNBREZGMkYiLCAiIzlBQ0QzMiIsICIjOEZCQzhGIiwgIiM5MEVFOTAiLCAiIzk4RkI5OCJdLAogICAgICAgICAgICAgICAgcGF0dGVybjogImVuY2hhbnRlZF9mb3Jlc3QiCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIG5hbWU6ICJDYXNjYWRlIGNyaXN0YWxsaW5lIiwKICAgICAgICAgICAgICAgIHR5cGU6ICJuYXR1cmUiLAogICAgICAgICAgICAgICAgY29sb3JzOiBbIiM4N0NFRUIiLCAiIzQ2ODJCNCIsICIjQjBFMEU2IiwgIiNGRkZGRkYiLCAiIzcwODA5MCIsICIjMjBCMkFBIiwgIiM0OEQxQ0MiLCAiIzQwRTBEMCJdLAogICAgICAgICAgICAgICAgcGF0dGVybjogImNyeXN0YWxfd2F0ZXJmYWxsIgogICAgICAgICAgICB9LAogICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBuYW1lOiAiQ2hhbXAgZGUgbGF2YW5kZSIsCiAgICAgICAgICAgICAgICB0eXBlOiAibmF0dXJlIiwKICAgICAgICAgICAgICAgIGNvbG9yczogWyIjOTM3MERCIiwgIiM4QTJCRTIiLCAiI0REQTBERCIsICIjRTZFNkZBIiwgIiMzMkNEMzIiLCAiIzlBQ0QzMiIsICIjQURGRjJGIiwgIiM5OEZCOTgiXSwKICAgICAgICAgICAgICAgIHBhdHRlcm46ICJsYXZlbmRlcl9maWVsZCIKICAgICAgICAgICAgfSwKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgbmFtZTogIk7DqWJ1bGV1c2UgY29sb3LDqWUiLAogICAgICAgICAgICAgICAgdHlwZTogInNwYWNlIiwKICAgICAgICAgICAgICAgIGNvbG9yczogWyIjMDAwMDAwIiwgIiM0QjAwODIiLCAiIzhBMkJFMiIsICIjRkYxNDkzIiwgIiMwMENFRDEiLCAiI0ZGRDcwMCIsICIjRkY0NTAwIiwgIiNGRkZGRkYiXSwKICAgICAgICAgICAgICAgIHBhdHRlcm46ICJuZWJ1bGEiCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIG5hbWU6ICJDb3VjaGVyIGRlIHNvbGVpbCIsCiAgICAgICAgICAgICAgICB0eXBlOiAibGFuZHNjYXBlIiwKICAgICAgICAgICAgICAgIGNvbG9yczogWyIjRkY0NTAwIiwgIiNGRjYzNDciLCAiI0ZGRDcwMCIsICIjRkZBNTAwIiwgIiNGRjhDMDAiLCAiI0RDMTQzQyIsICIjQjIyMjIyIiwgIiM4QjAwMDAiXSwKICAgICAgICAgICAgICAgIHBhdHRlcm46ICJzdW5zZXQiCiAgICAgICAgICAgIH0KICAgICAgICBdOwoKICAgICAgICAvLyBTeXN0w6htZSBkZSB0cmFkdWN0aW9uIGNvbXBsZXQKICAgICAgICBjb25zdCB0cmFuc2xhdGlvbnMgPSB7CiAgICAgICAgICAgIGZyOiB7CiAgICAgICAgICAgICAgICB0aXRsZTogIk1hw650cmUgZGVzIFB1enpsZXMgTmV1cmF1eCIsCiAgICAgICAgICAgICAgICBhaUFkdmFuY2VkOiAiSUEgQVZBTkPDiUUiLAogICAgICAgICAgICAgICAgY29udHJvbHM6ICJDb250csO0bGVzIiwKICAgICAgICAgICAgICAgIGhpbnRBSTogIkluZGljZSBJQSIsCiAgICAgICAgICAgICAgICBuZXdJbWFnZTogIk5vdXZlbGxlIEltYWdlIiwKICAgICAgICAgICAgICAgIGFpU29sdmU6ICJJQSBSw6lzb3V0IiwKICAgICAgICAgICAgICAgIG9wdGlvbnM6ICJPcHRpb25zIiwKICAgICAgICAgICAgICAgIGxldmVsOiAiTml2ZWF1IiwKICAgICAgICAgICAgICAgIGF1dG9Tb2x2ZTogIkF1dG8tUsOpc29sdXRpb24iLAogICAgICAgICAgICAgICAgZGlmZmljdWx0eTogIkRpZmZpY3VsdMOpIiwKICAgICAgICAgICAgICAgIHNhdmU6ICJTYXV2ZWdhcmRlciIsCiAgICAgICAgICAgICAgICBzdGF0czogIlN0YXRpc3RpcXVlcyIsCiAgICAgICAgICAgICAgICBhaUxldmVsOiAiTml2ZWF1IElBIiwKICAgICAgICAgICAgICAgIHNjb3JlOiAiU2NvcmUiLAogICAgICAgICAgICAgICAgbW92ZXM6ICJNb3V2ZW1lbnRzIiwKICAgICAgICAgICAgICAgIHRpbWU6ICJUZW1wcyIsCiAgICAgICAgICAgICAgICBvcmlnaW5hbEltYWdlOiAiSW1hZ2UgT3JpZ2luYWxlIiwKICAgICAgICAgICAgICAgIHB1enpsZVRvU29sdmU6ICJQdXp6bGUgw6AgUmVjb25zdGl0dWVyIiwKICAgICAgICAgICAgICAgIGFpQW5hbHlzaXM6ICJBbmFseXNlIElBIiwKICAgICAgICAgICAgICAgIG9wdGltYWxQYXRoOiAiQ2hlbWluIE9wdGltYWwiLAogICAgICAgICAgICAgICAgYW5hbHl6ZVBvc2l0aW9uOiAiQW5hbHlzZXIgUG9zaXRpb24iLAogICAgICAgICAgICAgICAgc3RhdGlzdGljczogIlN0YXRpc3RpcXVlcyIsCiAgICAgICAgICAgICAgICBjb21wbGV0ZWQ6ICJjb21wbMOpdMOpIiwKICAgICAgICAgICAgICAgIGFpVGhpbmtpbmc6ICJJQSBlbiBhbmFseXNlLi4uIiwKICAgICAgICAgICAgICAgIGNsb3NlOiAiRmVybWVyIiwKICAgICAgICAgICAgICAgIGxhbmd1YWdlOiAiTGFuZ3VlIiwKICAgICAgICAgICAgICAgIHNvbHZpbmc6ICJSw6lzb2x1dGlvbi4uLiIsCiAgICAgICAgICAgICAgICBwYXVzZTogIlBhdXNlIiwKICAgICAgICAgICAgICAgIHJlc3VtZTogIlJlcHJlbmRyZSIsCiAgICAgICAgICAgICAgICBtZXNzYWdlczogewogICAgICAgICAgICAgICAgICAgIGhpbnRVc2VkOiAiSW5kaWNlIGTDqWrDoCB1dGlsaXPDqSBwb3VyIGNlIHB1enpsZSAhIiwKICAgICAgICAgICAgICAgICAgICB3cm9uZ1BpZWNlOiAiTGEgcGnDqGNlIGVuIHBvc2l0aW9uIHswfSBuJ2VzdCBwYXMgw6Agc2EgcGxhY2UgISIsCiAgICAgICAgICAgICAgICAgICAgYWxsQ29ycmVjdDogIlRvdXRlcyBsZXMgcGnDqGNlcyBzb250IGNvcnJlY3RlbWVudCBwbGFjw6llcyAhIiwKICAgICAgICAgICAgICAgICAgICBuZXdJbWFnZU1zZzogIk5vdXZlbGxlIGltYWdlIDogezB9IiwKICAgICAgICAgICAgICAgICAgICBwdXp6bGVTb2x2ZWQ6ICJQdXp6bGUgcsOpc29sdSAhIFNjb3JlIDogezB9IiwKICAgICAgICAgICAgICAgICAgICBhaVNvbHZlZDogIlB1enpsZSByw6lzb2x1IHBhciBsJ0lBICEiLAogICAgICAgICAgICAgICAgICAgIGdyaWRDaGFuZ2VkOiAiR3JpbGxlIGNoYW5nw6llIDogezB9eHswfSIsCiAgICAgICAgICAgICAgICAgICAgYXV0b1NvbHZlT246ICJBdXRvLXLDqXNvbHV0aW9uIGFjdGl2w6llICEiLAogICAgICAgICAgICAgICAgICAgIGF1dG9Tb2x2ZU9mZjogIkF1dG8tcsOpc29sdXRpb24gZMOpc2FjdGl2w6llICEiLAogICAgICAgICAgICAgICAgICAgIGdhbWVTYXZlZDogIkpldSBzYXV2ZWdhcmTDqSAhIiwKICAgICAgICAgICAgICAgICAgICBnYW1lTG9hZGVkOiAiSmV1IGNoYXJnw6kgISIsCiAgICAgICAgICAgICAgICAgICAgYWlSZWFkeTogIkwnSUEgZXN0IHByw6p0ZSDDoCBhbmFseXNlciB2b3RyZSBwdXp6bGUgISIsCiAgICAgICAgICAgICAgICAgICAgZ2FtZVBhdXNlZDogIkpldSBtaXMgZW4gcGF1c2UiLAogICAgICAgICAgICAgICAgICAgIGdhbWVSZXN1bWVkOiAiSmV1IHJlcHJpcyIKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSwKICAgICAgICAgICAgZW46IHsKICAgICAgICAgICAgICAgIHRpdGxlOiAiTmV1cmFsIFB1enpsZSBNYXN0ZXIiLAogICAgICAgICAgICAgICAgYWlBZHZhbmNlZDogIkFEVkFOQ0VEIEFJIiwKICAgICAgICAgICAgICAgIGNvbnRyb2xzOiAiQ29udHJvbHMiLAogICAgICAgICAgICAgICAgaGludEFJOiAiQUkgSGludCIsCiAgICAgICAgICAgICAgICBuZXdJbWFnZTogIk5ldyBJbWFnZSIsCiAgICAgICAgICAgICAgICBhaVNvbHZlOiAiQUkgU29sdmUiLAogICAgICAgICAgICAgICAgb3B0aW9uczogIk9wdGlvbnMiLAogICAgICAgICAgICAgICAgbGV2ZWw6ICJMZXZlbCIsCiAgICAgICAgICAgICAgICBhdXRvU29sdmU6ICJBdXRvLVNvbHZlIiwKICAgICAgICAgICAgICAgIGRpZmZpY3VsdHk6ICJEaWZmaWN1bHR5IiwKICAgICAgICAgICAgICAgIHNhdmU6ICJTYXZlIiwKICAgICAgICAgICAgICAgIHN0YXRzOiAiU3RhdGlzdGljcyIsCiAgICAgICAgICAgICAgICBhaUxldmVsOiAiQUkgTGV2ZWwiLAogICAgICAgICAgICAgICAgc2NvcmU6ICJTY29yZSIsCiAgICAgICAgICAgICAgICBtb3ZlczogIk1vdmVzIiwKICAgICAgICAgICAgICAgIHRpbWU6ICJUaW1lIiwKICAgICAgICAgICAgICAgIG9yaWdpbmFsSW1hZ2U6ICJPcmlnaW5hbCBJbWFnZSIsCiAgICAgICAgICAgICAgICBwdXp6bGVUb1NvbHZlOiAiUHV6emxlIHRvIFNvbHZlIiwKICAgICAgICAgICAgICAgIGFpQW5hbHlzaXM6ICJBSSBBbmFseXNpcyIsCiAgICAgICAgICAgICAgICBvcHRpbWFsUGF0aDogIk9wdGltYWwgUGF0aCIsCiAgICAgICAgICAgICAgICBhbmFseXplUG9zaXRpb246ICJBbmFseXplIFBvc2l0aW9uIiwKICAgICAgICAgICAgICAgIHN0YXRpc3RpY3M6ICJTdGF0aXN0aWNzIiwKICAgICAgICAgICAgICAgIGNvbXBsZXRlZDogImNvbXBsZXRlZCIsCiAgICAgICAgICAgICAgICBhaVRoaW5raW5nOiAiQUkgYW5hbHl6aW5nLi4uIiwKICAgICAgICAgICAgICAgIGNsb3NlOiAiQ2xvc2UiLAogICAgICAgICAgICAgICAgbGFuZ3VhZ2U6ICJMYW5ndWFnZSIsCiAgICAgICAgICAgICAgICBzb2x2aW5nOiAiU29sdmluZy4uLiIsCiAgICAgICAgICAgICAgICBwYXVzZTogIlBhdXNlIiwKICAgICAgICAgICAgICAgIHJlc3VtZTogIlJlc3VtZSIsCiAgICAgICAgICAgICAgICBtZXNzYWdlczogewogICAgICAgICAgICAgICAgICAgIGhpbnRVc2VkOiAiSGludCBhbHJlYWR5IHVzZWQgZm9yIHRoaXMgcHV6emxlISIsCiAgICAgICAgICAgICAgICAgICAgd3JvbmdQaWVjZTogIlBpZWNlIGF0IHBvc2l0aW9uIHswfSBpcyBub3QgaW4gdGhlIHJpZ2h0IHBsYWNlISIsCiAgICAgICAgICAgICAgICAgICAgYWxsQ29ycmVjdDogIkFsbCBwaWVjZXMgYXJlIGNvcnJlY3RseSBwbGFjZWQhIiwKICAgICAgICAgICAgICAgICAgICBuZXdJbWFnZU1zZzogIk5ldyBpbWFnZTogezB9IiwKICAgICAgICAgICAgICAgICAgICBwdXp6bGVTb2x2ZWQ6ICJQdXp6bGUgc29sdmVkISBTY29yZTogezB9IiwKICAgICAgICAgICAgICAgICAgICBhaVNvbHZlZDogIlB1enpsZSBzb2x2ZWQgYnkgQUkhIiwKICAgICAgICAgICAgICAgICAgICBncmlkQ2hhbmdlZDogIkdyaWQgY2hhbmdlZDogezB9eHswfSIsCiAgICAgICAgICAgICAgICAgICAgYXV0b1NvbHZlT246ICJBdXRvLXNvbHZlIGFjdGl2YXRlZCEiLAogICAgICAgICAgICAgICAgICAgIGF1dG9Tb2x2ZU9mZjogIkF1dG8tc29sdmUgZGVhY3RpdmF0ZWQhIiwKICAgICAgICAgICAgICAgICAgICBnYW1lU2F2ZWQ6ICJHYW1lIHNhdmVkISIsCiAgICAgICAgICAgICAgICAgICAgZ2FtZUxvYWRlZDogIkdhbWUgbG9hZGVkISIsCiAgICAgICAgICAgICAgICAgICAgYWlSZWFkeTogIkFJIGlzIHJlYWR5IHRvIGFuYWx5emUgeW91ciBwdXp6bGUhIiwKICAgICAgICAgICAgICAgICAgICBnYW1lUGF1c2VkOiAiR2FtZSBwYXVzZWQiLAogICAgICAgICAgICAgICAgICAgIGdhbWVSZXN1bWVkOiAiR2FtZSByZXN1bWVkIgogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9LAogICAgICAgICAgICBhcjogewogICAgICAgICAgICAgICAgdGl0bGU6ICLYs9mK2K8g2KfZhNij2YTYutin2LIg2KfZhNi52LXYqNmK2KkiLAogICAgICAgICAgICAgICAgYWlBZHZhbmNlZDogItiw2YPYp9ihINin2LXYt9mG2KfYudmKINmF2KrZgtiv2YUiLAogICAgICAgICAgICAgICAgY29udHJvbHM6ICLYp9mE2KrYrdmD2YUiLAogICAgICAgICAgICAgICAgaGludEFJOiAi2KrZhNmF2YrYrSDYp9mE2LDZg9in2KEg2KfZhNin2LXYt9mG2KfYudmKIiwKICAgICAgICAgICAgICAgIG5ld0ltYWdlOiAi2LXZiNix2Kkg2KzYr9mK2K/YqSIsCiAgICAgICAgICAgICAgICBhaVNvbHZlOiAi2K3ZhCDYqNin2YTYsNmD2KfYoSDYp9mE2KfYtdi32YbYp9i52YoiLAogICAgICAgICAgICAgICAgb3B0aW9uczogItin2YTYrtmK2KfYsdin2KoiLAogICAgICAgICAgICAgICAgbGV2ZWw6ICLYp9mE2YXYs9iq2YjZiSIsCiAgICAgICAgICAgICAgICBhdXRvU29sdmU6ICLYp9mE2K3ZhCDYp9mE2KrZhNmC2KfYptmKIiwKICAgICAgICAgICAgICAgIGRpZmZpY3VsdHk6ICLYp9mE2LXYudmI2KjYqSIsCiAgICAgICAgICAgICAgICBzYXZlOiAi2K3Zgdi4IiwKICAgICAgICAgICAgICAgIHN0YXRzOiAi2KfZhNil2K3Ytdin2KbZitin2KoiLAogICAgICAgICAgICAgICAgYWlMZXZlbDogItmF2LPYqtmI2Ykg2KfZhNiw2YPYp9ihINin2YTYp9i12LfZhtin2LnZiiIsCiAgICAgICAgICAgICAgICBzY29yZTogItin2YTZhtmC2KfYtyIsCiAgICAgICAgICAgICAgICBtb3ZlczogItin2YTYrdix2YPYp9iqIiwKICAgICAgICAgICAgICAgIHRpbWU6ICLYp9mE2YjZgtiqIiwKICAgICAgICAgICAgICAgIG9yaWdpbmFsSW1hZ2U6ICLYp9mE2LXZiNix2Kkg2KfZhNij2LXZhNmK2KkiLAogICAgICAgICAgICAgICAgcHV6emxlVG9Tb2x2ZTogItin2YTZhNi62LIg2KfZhNmF2LHYp9ivINit2YTZhyIsCiAgICAgICAgICAgICAgICBhaUFuYWx5c2lzOiAi2KrYrdmE2YrZhCDYp9mE2LDZg9in2KEg2KfZhNin2LXYt9mG2KfYudmKIiwKICAgICAgICAgICAgICAgIG9wdGltYWxQYXRoOiAi2KfZhNmF2LPYp9ixINin2YTYo9mF2KvZhCIsCiAgICAgICAgICAgICAgICBhbmFseXplUG9zaXRpb246ICLYqtit2YTZitmEINin2YTZhdmI2LbYuSIsCiAgICAgICAgICAgICAgICBzdGF0aXN0aWNzOiAi2KfZhNil2K3Ytdin2KbZitin2KoiLAogICAgICAgICAgICAgICAgY29tcGxldGVkOiAi2YXZg9iq2YXZhCIsCiAgICAgICAgICAgICAgICBhaVRoaW5raW5nOiAi2KfZhNiw2YPYp9ihINin2YTYp9i12LfZhtin2LnZiiDZitit2YTZhC4uLiIsCiAgICAgICAgICAgICAgICBjbG9zZTogItil2LrZhNin2YIiLAogICAgICAgICAgICAgICAgbGFuZ3VhZ2U6ICLYp9mE2YTYutipIiwKICAgICAgICAgICAgICAgIHNvbHZpbmc6ICLYrNin2LHZiiDYp9mE2K3ZhC4uLiIsCiAgICAgICAgICAgICAgICBwYXVzZTogItil2YrZgtin2YEg2YXYpNmC2KoiLAogICAgICAgICAgICAgICAgcmVzdW1lOiAi2KfYs9iq2KbZhtin2YEiLAogICAgICAgICAgICAgICAgbWVzc2FnZXM6IHsKICAgICAgICAgICAgICAgICAgICBnYW1lUGF1c2VkOiAi2KrZhSDYpdmK2YLYp9mBINin2YTZhNi52KjYqSDZhdik2YLYqtin2YsiLAogICAgICAgICAgICAgICAgICAgIGdhbWVSZXN1bWVkOiAi2KrZhSDYp9iz2KrYptmG2KfZgSDYp9mE2YTYudio2KkiCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIGVzOiB7CiAgICAgICAgICAgICAgICB0aXRsZTogIk1hZXN0cm8gZGUgUm9tcGVjYWJlemFzIE5ldXJhbGVzIiwKICAgICAgICAgICAgICAgIGFpQWR2YW5jZWQ6ICJJQSBBVkFOWkFEQSIsCiAgICAgICAgICAgICAgICBjb250cm9sczogIkNvbnRyb2xlcyIsCiAgICAgICAgICAgICAgICBoaW50QUk6ICJQaXN0YSBJQSIsCiAgICAgICAgICAgICAgICBuZXdJbWFnZTogIk51ZXZhIEltYWdlbiIsCiAgICAgICAgICAgICAgICBhaVNvbHZlOiAiSUEgUmVzdWVsdmUiLAogICAgICAgICAgICAgICAgb3B0aW9uczogIk9wY2lvbmVzIiwKICAgICAgICAgICAgICAgIGxldmVsOiAiTml2ZWwiLAogICAgICAgICAgICAgICAgYXV0b1NvbHZlOiAiQXV0by1SZXNvbHVjacOzbiIsCiAgICAgICAgICAgICAgICBkaWZmaWN1bHR5OiAiRGlmaWN1bHRhZCIsCiAgICAgICAgICAgICAgICBzYXZlOiAiR3VhcmRhciIsCiAgICAgICAgICAgICAgICBzdGF0czogIkVzdGFkw61zdGljYXMiLAogICAgICAgICAgICAgICAgYWlMZXZlbDogIk5pdmVsIElBIiwKICAgICAgICAgICAgICAgIHNjb3JlOiAiUHVudHVhY2nDs24iLAogICAgICAgICAgICAgICAgbW92ZXM6ICJNb3ZpbWllbnRvcyIsCiAgICAgICAgICAgICAgICB0aW1lOiAiVGllbXBvIiwKICAgICAgICAgICAgICAgIG9yaWdpbmFsSW1hZ2U6ICJJbWFnZW4gT3JpZ2luYWwiLAogICAgICAgICAgICAgICAgcHV6emxlVG9Tb2x2ZTogIlJvbXBlY2FiZXphcyBhIFJlc29sdmVyIiwKICAgICAgICAgICAgICAgIGFpQW5hbHlzaXM6ICJBbsOhbGlzaXMgSUEiLAogICAgICAgICAgICAgICAgb3B0aW1hbFBhdGg6ICJDYW1pbm8gw5NwdGltbyIsCiAgICAgICAgICAgICAgICBhbmFseXplUG9zaXRpb246ICJBbmFsaXphciBQb3NpY2nDs24iLAogICAgICAgICAgICAgICAgc3RhdGlzdGljczogIkVzdGFkw61zdGljYXMiLAogICAgICAgICAgICAgICAgY29tcGxldGVkOiAiY29tcGxldGFkbyIsCiAgICAgICAgICAgICAgICBhaVRoaW5raW5nOiAiSUEgYW5hbGl6YW5kby4uLiIsCiAgICAgICAgICAgICAgICBjbG9zZTogIkNlcnJhciIsCiAgICAgICAgICAgICAgICBsYW5ndWFnZTogIklkaW9tYSIsCiAgICAgICAgICAgICAgICBzb2x2aW5nOiAiUmVzb2x2aWVuZG8uLi4iLAogICAgICAgICAgICAgICAgcGF1c2U6ICJQYXVzYSIsCiAgICAgICAgICAgICAgICByZXN1bWU6ICJSZWFudWRhciIsCiAgICAgICAgICAgICAgICBtZXNzYWdlczogewogICAgICAgICAgICAgICAgICAgIGdhbWVQYXVzZWQ6ICJKdWVnbyBwYXVzYWRvIiwKICAgICAgICAgICAgICAgICAgICBnYW1lUmVzdW1lZDogIkp1ZWdvIHJlYW51ZGFkbyIKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSwKICAgICAgICAgICAgZGU6IHsKICAgICAgICAgICAgICAgIHRpdGxlOiAiTmV1cmFsZXIgUHV6emxlLU1laXN0ZXIiLAogICAgICAgICAgICAgICAgYWlBZHZhbmNlZDogIkVSV0VJVEVSVEUgS0kiLAogICAgICAgICAgICAgICAgY29udHJvbHM6ICJTdGV1ZXJ1bmciLAogICAgICAgICAgICAgICAgaGludEFJOiAiS0ktSGlud2VpcyIsCiAgICAgICAgICAgICAgICBuZXdJbWFnZTogIk5ldWVzIEJpbGQiLAogICAgICAgICAgICAgICAgYWlTb2x2ZTogIktJIEzDtnN0IiwKICAgICAgICAgICAgICAgIG9wdGlvbnM6ICJPcHRpb25lbiIsCiAgICAgICAgICAgICAgICBsZXZlbDogIkxldmVsIiwKICAgICAgICAgICAgICAgIGF1dG9Tb2x2ZTogIkF1dG8tTMO2c3VuZyIsCiAgICAgICAgICAgICAgICBkaWZmaWN1bHR5OiAiU2Nod2llcmlna2VpdCIsCiAgICAgICAgICAgICAgICBzYXZlOiAiU3BlaWNoZXJuIiwKICAgICAgICAgICAgICAgIHN0YXRzOiAiU3RhdGlzdGlrZW4iLAogICAgICAgICAgICAgICAgYWlMZXZlbDogIktJLUxldmVsIiwKICAgICAgICAgICAgICAgIHNjb3JlOiAiUHVua3RlIiwKICAgICAgICAgICAgICAgIG1vdmVzOiAiWsO8Z2UiLAogICAgICAgICAgICAgICAgdGltZTogIlplaXQiLAogICAgICAgICAgICAgICAgb3JpZ2luYWxJbWFnZTogIk9yaWdpbmFsYmlsZCIsCiAgICAgICAgICAgICAgICBwdXp6bGVUb1NvbHZlOiAiWnUgbMO2c2VuZGVzIFB1enpsZSIsCiAgICAgICAgICAgICAgICBhaUFuYWx5c2lzOiAiS0ktQW5hbHlzZSIsCiAgICAgICAgICAgICAgICBvcHRpbWFsUGF0aDogIk9wdGltYWxlciBQZmFkIiwKICAgICAgICAgICAgICAgIGFuYWx5emVQb3NpdGlvbjogIlBvc2l0aW9uIEFuYWx5c2llcmVuIiwKICAgICAgICAgICAgICAgIHN0YXRpc3RpY3M6ICJTdGF0aXN0aWtlbiIsCiAgICAgICAgICAgICAgICBjb21wbGV0ZWQ6ICJhYmdlc2NobG9zc2VuIiwKICAgICAgICAgICAgICAgIGFpVGhpbmtpbmc6ICJLSSBhbmFseXNpZXJ0Li4uIiwKICAgICAgICAgICAgICAgIGNsb3NlOiAiU2NobGllw59lbiIsCiAgICAgICAgICAgICAgICBsYW5ndWFnZTogIlNwcmFjaGUiLAogICAgICAgICAgICAgICAgc29sdmluZzogIkzDtnNlLi4uIiwKICAgICAgICAgICAgICAgIHBhdXNlOiAiUGF1c2UiLAogICAgICAgICAgICAgICAgcmVzdW1lOiAiRm9ydHNldHplbiIsCiAgICAgICAgICAgICAgICBtZXNzYWdlczogewogICAgICAgICAgICAgICAgICAgIGdhbWVQYXVzZWQ6ICJTcGllbCBwYXVzaWVydCIsCiAgICAgICAgICAgICAgICAgICAgZ2FtZVJlc3VtZWQ6ICJTcGllbCBmb3J0Z2VzZXR6dCIKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSwKICAgICAgICAgICAgemg6IHsKICAgICAgICAgICAgICAgIHRpdGxlOiAi56We57uP5ou85Zu+5aSn5biIIiwKICAgICAgICAgICAgICAgIGFpQWR2YW5jZWQ6ICLpq5jnuqfkurrlt6Xmmbrog70iLAogICAgICAgICAgICAgICAgY29udHJvbHM6ICLmjqfliLYiLAogICAgICAgICAgICAgICAgaGludEFJOiAiQUnmj5DnpLoiLAogICAgICAgICAgICAgICAgbmV3SW1hZ2U6ICLmlrDlm77niYciLAogICAgICAgICAgICAgICAgYWlTb2x2ZTogIkFJ6Kej5YazIiwKICAgICAgICAgICAgICAgIG9wdGlvbnM6ICLpgInpobkiLAogICAgICAgICAgICAgICAgbGV2ZWw6ICLnuqfliKsiLAogICAgICAgICAgICAgICAgYXV0b1NvbHZlOiAi6Ieq5Yqo6Kej5YazIiwKICAgICAgICAgICAgICAgIGRpZmZpY3VsdHk6ICLpmr7luqYiLAogICAgICAgICAgICAgICAgc2F2ZTogIuS/neWtmCIsCiAgICAgICAgICAgICAgICBzdGF0czogIue7n+iuoSIsCiAgICAgICAgICAgICAgICBhaUxldmVsOiAiQUnnuqfliKsiLAogICAgICAgICAgICAgICAgc2NvcmU6ICLliIbmlbAiLAogICAgICAgICAgICAgICAgbW92ZXM6ICLnp7vliqgiLAogICAgICAgICAgICAgICAgdGltZTogIuaXtumXtCIsCiAgICAgICAgICAgICAgICBvcmlnaW5hbEltYWdlOiAi5Y6f5aeL5Zu+54mHIiwKICAgICAgICAgICAgICAgIHB1enpsZVRvU29sdmU6ICLlvoXop6Pmi7zlm74iLAogICAgICAgICAgICAgICAgYWlBbmFseXNpczogIkFJ5YiG5p6QIiwKICAgICAgICAgICAgICAgIG9wdGltYWxQYXRoOiAi5pyA5LyY6Lev5b6EIiwKICAgICAgICAgICAgICAgIGFuYWx5emVQb3NpdGlvbjogIuWIhuaekOS9jee9riIsCiAgICAgICAgICAgICAgICBzdGF0aXN0aWNzOiAi57uf6K6h5pWw5o2uIiwKICAgICAgICAgICAgICAgIGNvbXBsZXRlZDogIuW3suWujOaIkCIsCiAgICAgICAgICAgICAgICBhaVRoaW5raW5nOiAiQUnliIbmnpDkuK0uLi4iLAogICAgICAgICAgICAgICAgY2xvc2U6ICLlhbPpl60iLAogICAgICAgICAgICAgICAgbGFuZ3VhZ2U6ICLor63oqIAiLAogICAgICAgICAgICAgICAgc29sdmluZzogIuino+WGs+S4rS4uLiIsCiAgICAgICAgICAgICAgICBwYXVzZTogIuaaguWBnCIsCiAgICAgICAgICAgICAgICByZXN1bWU6ICLnu6fnu60iLAogICAgICAgICAgICAgICAgbWVzc2FnZXM6IHsKICAgICAgICAgICAgICAgICAgICBnYW1lUGF1c2VkOiAi5ri45oiP5bey5pqC5YGcIiwKICAgICAgICAgICAgICAgICAgICBnYW1lUmVzdW1lZDogIua4uOaIj+W3suaBouWkjSIKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgIH07CgogICAgICAgIC8vIEZvbmN0aW9ucyBkZSB0cmFkdWN0aW9uCiAgICAgICAgZnVuY3Rpb24gdChrZXksIC4uLmFyZ3MpIHsKICAgICAgICAgICAgY29uc3QgbGFuZyA9IGdhbWVTdGF0ZS5jdXJyZW50TGFuZ3VhZ2U7CiAgICAgICAgICAgIGxldCB0ZXh0ID0gdHJhbnNsYXRpb25zW2xhbmddICYmIHRyYW5zbGF0aW9uc1tsYW5nXVtrZXldID8gdHJhbnNsYXRpb25zW2xhbmddW2tleV0gOiBrZXk7CiAgICAgICAgICAgIAogICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPiAwKSB7CiAgICAgICAgICAgICAgICBhcmdzLmZvckVhY2goKGFyZywgaW5kZXgpID0+IHsKICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKGB7JHtpbmRleH19YCwgYXJnKTsKICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICB9CiAgICAgICAgICAgIAogICAgICAgICAgICByZXR1cm4gdGV4dDsKICAgICAgICB9CgogICAgICAgIGZ1bmN0aW9uIHRtKGtleSwgLi4uYXJncykgewogICAgICAgICAgICBjb25zdCBsYW5nID0gZ2FtZVN0YXRlLmN1cnJlbnRMYW5ndWFnZTsKICAgICAgICAgICAgbGV0IHRleHQgPSB0cmFuc2xhdGlvbnNbbGFuZ10gJiYgdHJhbnNsYXRpb25zW2xhbmddLm1lc3NhZ2VzICYmIHRyYW5zbGF0aW9uc1tsYW5nXS5tZXNzYWdlc1trZXldIAogICAgICAgICAgICAgICAgPyB0cmFuc2xhdGlvbnNbbGFuZ10ubWVzc2FnZXNba2V5XSAKICAgICAgICAgICAgICAgIDoga2V5OwogICAgICAgICAgICAKICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMCkgewogICAgICAgICAgICAgICAgYXJncy5mb3JFYWNoKChhcmcsIGluZGV4KSA9PiB7CiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZShgeyR7aW5kZXh9fWAsIGFyZyk7CiAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgfQogICAgICAgICAgICAKICAgICAgICAgICAgcmV0dXJuIHRleHQ7CiAgICAgICAgfQoKICAgICAgICAvLyBGb25jdGlvbnMgZGUgZ2VzdGlvbiBkZXMgbGFuZ3VlcwogICAgICAgIGZ1bmN0aW9uIHRvZ2dsZUxhbmd1YWdlTWVudSgpIHsKICAgICAgICAgICAgY29uc3QgbWVudSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsYW5ndWFnZU1lbnUnKTsKICAgICAgICAgICAgbWVudS5jbGFzc0xpc3QudG9nZ2xlKCdhY3RpdmUnKTsKICAgICAgICAgICAgCiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gY2xvc2VNZW51KGUpIHsKICAgICAgICAgICAgICAgIGlmICghZS50YXJnZXQuY2xvc2VzdCgnLmxhbmd1YWdlLXNlbGVjdG9yJykpIHsKICAgICAgICAgICAgICAgICAgICBtZW51LmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpOwogICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgY2xvc2VNZW51KTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSk7CiAgICAgICAgfQoKICAgICAgICBmdW5jdGlvbiBjaGFuZ2VMYW5ndWFnZShsYW5nKSB7CiAgICAgICAgICAgIGdhbWVTdGF0ZS5jdXJyZW50TGFuZ3VhZ2UgPSBsYW5nOwogICAgICAgICAgICAKICAgICAgICAgICAgY29uc3QgbGFuZ3VhZ2VCdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbGFuZ3VhZ2VCdG4nKTsKICAgICAgICAgICAgY29uc3QgZmxhZ3MgPSB7CiAgICAgICAgICAgICAgICBmcjogJ/Cfh6vwn4e3IEZyYW7Dp2FpcycsCiAgICAgICAgICAgICAgICBlbjogJ/Cfh7rwn4e4IEVuZ2xpc2gnLAogICAgICAgICAgICAgICAgYXI6ICfwn4e48J+HpiDYp9mE2LnYsdio2YrYqScsCiAgICAgICAgICAgICAgICBlczogJ/Cfh6rwn4e4IEVzcGHDsW9sJywKICAgICAgICAgICAgICAgIGRlOiAn8J+HqfCfh6ogRGV1dHNjaCcsCiAgICAgICAgICAgICAgICB6aDogJ/Cfh6jwn4ezIOS4reaWhycKICAgICAgICAgICAgfTsKICAgICAgICAgICAgbGFuZ3VhZ2VCdG4udGV4dENvbnRlbnQgPSBg8J+MkCAke2ZsYWdzW2xhbmddfWA7CiAgICAgICAgICAgIAogICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbGFuZ3VhZ2VNZW51JykuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7CiAgICAgICAgICAgIHVwZGF0ZUxhbmd1YWdlKCk7CiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCduZXVyYWxQdXp6bGVMYW5ndWFnZScsIGxhbmcpOwogICAgICAgIH0KCiAgICAgICAgZnVuY3Rpb24gdXBkYXRlTGFuZ3VhZ2UoKSB7CiAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5uZXVyYWwtdGl0bGUgaDEnKS50ZXh0Q29udGVudCA9IHQoJ3RpdGxlJyk7CiAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5haS1iYWRnZScpLnRleHRDb250ZW50ID0gYPCfpJYgJHt0KCdhaUFkdmFuY2VkJyl9YDsKICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNsb3NlLWJ0bicpLnRpdGxlID0gdCgnY2xvc2UnKTsKICAgICAgICAgICAgCiAgICAgICAgICAgIGNvbnN0IHBhbmVsVGl0bGVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnBhbmVsLXRpdGxlJyk7CiAgICAgICAgICAgIHBhbmVsVGl0bGVzWzBdLnRleHRDb250ZW50ID0gYPCfjq4gJHt0KCdjb250cm9scycpfWA7CiAgICAgICAgICAgIHBhbmVsVGl0bGVzWzFdLnRleHRDb250ZW50ID0gYOKame+4jyAke3QoJ29wdGlvbnMnKX1gOwogICAgICAgICAgICBwYW5lbFRpdGxlc1syXS50ZXh0Q29udGVudCA9IGDwn5SNICR7dCgnYWlBbmFseXNpcycpfWA7CiAgICAgICAgICAgIAogICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdidXR0b25bb25jbGljaz0iZ2V0QUlIaW50KCkiXScpLmlubmVySFRNTCA9IGDwn5KhICR7dCgnaGludEFJJyl9YDsKICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYnV0dG9uW29uY2xpY2s9ImNoYW5nZUltYWdlKCkiXScpLmlubmVySFRNTCA9IGDwn5a877iPICR7dCgnbmV3SW1hZ2UnKX1gOwogICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdidXR0b25bb25jbGljaz0iYWlTb2x2ZVB1enpsZSgpIl0nKS5pbm5lckhUTUwgPSBg8J+kliAke3QoJ2FpU29sdmUnKX1gOwogICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdidXR0b25bb25jbGljaz0idG9nZ2xlQXV0b1NvbHZlKCkiXScpLmlubmVySFRNTCA9IGDimqEgJHt0KCdhdXRvU29sdmUnKX1gOwogICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdidXR0b25bb25jbGljaz0ic2F2ZUdhbWUoKSJdJykuaW5uZXJIVE1MID0gYPCfkr4gJHt0KCdzYXZlJyl9YDsKICAgICAgICAgICAgCiAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2J1dHRvbltvbmNsaWNrPSJzaG93T3B0aW1hbFBhdGgoKSJdJykuaW5uZXJIVE1MID0gYPCfjq8gJHt0KCdvcHRpbWFsUGF0aCcpfWA7CiAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2J1dHRvbltvbmNsaWNrPSJhbmFseXplUG9zaXRpb24oKSJdJykuaW5uZXJIVE1MID0gYPCflI0gJHt0KCdhbmFseXplUG9zaXRpb24nKX1gOwogICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdidXR0b25bb25jbGljaz0ic2hvd1N0YXRpc3RpY3MoKSJdJykuaW5uZXJIVE1MID0gYPCfk4ogJHt0KCdzdGF0aXN0aWNzJyl9YDsKICAgICAgICAgICAgCiAgICAgICAgICAgIGNvbnN0IHN0YXRMYWJlbHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuc3RhdC1sYWJlbCcpOwogICAgICAgICAgICBzdGF0TGFiZWxzWzBdLnRleHRDb250ZW50ID0gdCgnYWlMZXZlbCcpOwogICAgICAgICAgICBzdGF0TGFiZWxzWzFdLnRleHRDb250ZW50ID0gdCgnc2NvcmUnKTsKICAgICAgICAgICAgc3RhdExhYmVsc1syXS50ZXh0Q29udGVudCA9IHQoJ21vdmVzJyk7CiAgICAgICAgICAgIHN0YXRMYWJlbHNbM10udGV4dENvbnRlbnQgPSB0KCd0aW1lJyk7CiAgICAgICAgICAgIAogICAgICAgICAgICBjb25zdCBib2FyZExhYmVscyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5ib2FyZC1sYWJlbCcpOwogICAgICAgICAgICBib2FyZExhYmVsc1swXS50ZXh0Q29udGVudCA9IGDwn5a877iPICR7dCgnb3JpZ2luYWxJbWFnZScpfWA7CiAgICAgICAgICAgIGJvYXJkTGFiZWxzWzFdLnRleHRDb250ZW50ID0gYPCfp6kgJHt0KCdwdXp6bGVUb1NvbHZlJyl9YDsKICAgICAgICAgICAgCiAgICAgICAgICAgIGNvbnN0IHBhdXNlQnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3BhdXNlQnRuJyk7CiAgICAgICAgICAgIGlmKHBhdXNlQnRuKSB7CiAgICAgICAgICAgICAgICBpZihnYW1lU3RhdGUuaXNQYXVzZWQpIHsKICAgICAgICAgICAgICAgICAgICBwYXVzZUJ0bi5pbm5lckhUTUwgPSBg4pa277iPICR7dCgncmVzdW1lJyl9YDsKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgcGF1c2VCdG4uaW5uZXJIVE1MID0gYOKPuO+4jyAke3QoJ3BhdXNlJyl9YDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICAKICAgICAgICAgICAgY29uc3QgYWlSZWFkeVRleHQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYWlSZWFkeVRleHQnKTsKICAgICAgICAgICAgY29uc3QgYW5hbHlzaXNJbnN0cnVjdGlvbnMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYW5hbHlzaXNJbnN0cnVjdGlvbnMnKTsKICAgICAgICAgICAgaWYoYWlSZWFkeVRleHQpIGFpUmVhZHlUZXh0LnRleHRDb250ZW50ID0gdG0oJ2FpUmVhZHknKTsKICAgICAgICAgICAgaWYoYW5hbHlzaXNJbnN0cnVjdGlvbnMpIHsKICAgICAgICAgICAgICAgIGNvbnN0IGxhbmcgPSBnYW1lU3RhdGUuY3VycmVudExhbmd1YWdlOwogICAgICAgICAgICAgICAgY29uc3QgaW5zdHJ1Y3Rpb25zID0gewogICAgICAgICAgICAgICAgICAgIGZyOiAiVXRpbGlzZXogbGVzIGJvdXRvbnMgY2ktZGVzc3VzIHBvdXIgb2J0ZW5pciBkZXMgYW5hbHlzZXMgZMOpdGFpbGzDqWVzIGRlIHZvdHJlIHBvc2l0aW9uIGFjdHVlbGxlLiIsCiAgICAgICAgICAgICAgICAgICAgZW46ICJVc2UgdGhlIGJ1dHRvbnMgYWJvdmUgdG8gZ2V0IGRldGFpbGVkIGFuYWx5c2lzIG9mIHlvdXIgY3VycmVudCBwb3NpdGlvbi4iLAogICAgICAgICAgICAgICAgICAgIGFyOiAi2KfYs9iq2K7Yr9mFINin2YTYo9iy2LHYp9ixINij2LnZhNin2Ycg2YTZhNit2LXZiNmEINi52YTZiSDYqtit2YTZitmEINmF2YHYtdmEINmE2YXZiNi22LnZgyDYp9mE2K3Yp9mE2YouIiwKICAgICAgICAgICAgICAgICAgICBlczogIlVzYSBsb3MgYm90b25lcyBkZSBhcnJpYmEgcGFyYSBvYnRlbmVyIGFuw6FsaXNpcyBkZXRhbGxhZG9zIGRlIHR1IHBvc2ljacOzbiBhY3R1YWwuIiwKICAgICAgICAgICAgICAgICAgICBkZTogIlZlcndlbmRlbiBTaWUgZGllIFNjaGFsdGZsw6RjaGVuIG9iZW4sIHVtIGRldGFpbGxpZXJ0ZSBBbmFseXNlbiBJaHJlciBha3R1ZWxsZW4gUG9zaXRpb24genUgZXJoYWx0ZW4uIiwKICAgICAgICAgICAgICAgICAgICB6aDogIuS9v+eUqOS4iumdoueahOaMiemSruiOt+WPluW9k+WJjeS9jee9rueahOivpue7huWIhuaekOOAgiIKICAgICAgICAgICAgICAgIH07CiAgICAgICAgICAgICAgICBhbmFseXNpc0luc3RydWN0aW9ucy50ZXh0Q29udGVudCA9IGluc3RydWN0aW9uc1tsYW5nXSB8fCBpbnN0cnVjdGlvbnMuZW47CiAgICAgICAgICAgIH0KICAgICAgICAgICAgCiAgICAgICAgICAgIHVwZGF0ZVVJKCk7CiAgICAgICAgICAgIHVwZGF0ZVByb2dyZXNzKCk7CiAgICAgICAgfQoKICAgICAgICAvLyBGb25jdGlvbiBwYXVzZS9yZXByaXNlCiAgICAgICAgZnVuY3Rpb24gdG9nZ2xlUGF1c2UoKSB7CiAgICAgICAgICAgIGlmKCFnYW1lU3RhdGUuaXNQbGF5aW5nKSByZXR1cm47CiAgICAgICAgICAgIAogICAgICAgICAgICBjb25zdCBwYXVzZUJ0biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwYXVzZUJ0bicpOwogICAgICAgICAgICAKICAgICAgICAgICAgaWYoZ2FtZVN0YXRlLmlzUGF1c2VkKSB7CiAgICAgICAgICAgICAgICBnYW1lU3RhdGUuaXNQYXVzZWQgPSBmYWxzZTsKICAgICAgICAgICAgICAgIGdhbWVTdGF0ZS5zdGFydFRpbWUgPSBEYXRlLm5vdygpIC0gZ2FtZVN0YXRlLnBhdXNlZFRpbWU7CiAgICAgICAgICAgICAgICBzdGFydFRpbWVyKCk7CiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgIHBhdXNlQnRuLmlubmVySFRNTCA9IGDij7jvuI8gJHt0KCdwYXVzZScpfWA7CiAgICAgICAgICAgICAgICBwYXVzZUJ0bi5jbGFzc0xpc3QucmVtb3ZlKCdwYXVzZWQnKTsKICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgY29uc3QgcHV6emxlQm9hcmQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncHV6emxlQm9hcmQnKTsKICAgICAgICAgICAgICAgIHB1enpsZUJvYXJkLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnYXV0byc7CiAgICAgICAgICAgICAgICBwdXp6bGVCb2FyZC5zdHlsZS5vcGFjaXR5ID0gJzEnOwogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICBzaG93QUlNZXNzYWdlKHRtKCdnYW1lUmVzdW1lZCcpLCAxNTAwKTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIGdhbWVTdGF0ZS5pc1BhdXNlZCA9IHRydWU7CiAgICAgICAgICAgICAgICBnYW1lU3RhdGUucGF1c2VkVGltZSA9IERhdGUubm93KCkgLSBnYW1lU3RhdGUuc3RhcnRUaW1lOwogICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChnYW1lU3RhdGUudGltZXIpOwogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICBwYXVzZUJ0bi5pbm5lckhUTUwgPSBg4pa277iPICR7dCgncmVzdW1lJyl9YDsKICAgICAgICAgICAgICAgIHBhdXNlQnRuLmNsYXNzTGlzdC5hZGQoJ3BhdXNlZCcpOwogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICBjb25zdCBwdXp6bGVCb2FyZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwdXp6bGVCb2FyZCcpOwogICAgICAgICAgICAgICAgcHV6emxlQm9hcmQuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJzsKICAgICAgICAgICAgICAgIHB1enpsZUJvYXJkLnN0eWxlLm9wYWNpdHkgPSAnMC41JzsKICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgc2hvd0FJTWVzc2FnZSh0bSgnZ2FtZVBhdXNlZCcpLCAxNTAwKTsKICAgICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgLy8gR8OpbsOpcmVyIHVuZSBpbWFnZSBwcm9jw6lkdXJhbGUKICAgICAgICBmdW5jdGlvbiBnZW5lcmF0ZVByb2NlZHVyYWxJbWFnZShpbWFnZURhdGEsIHNpemUgPSA0MDApIHsKICAgICAgICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7CiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHNpemU7CiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBzaXplOwogICAgICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTsKICAgICAgICAgICAgCiAgICAgICAgICAgIGNvbnN0IGNlbnRlclggPSBzaXplIC8gMjsKICAgICAgICAgICAgY29uc3QgY2VudGVyWSA9IHNpemUgLyAyOwogICAgICAgICAgICAKICAgICAgICAgICAgbGV0IGdyYWRpZW50OwogICAgICAgICAgICBzd2l0Y2goaW1hZ2VEYXRhLnR5cGUpIHsKICAgICAgICAgICAgICAgIGNhc2UgJ25hdHVyZSc6CiAgICAgICAgICAgICAgICBjYXNlICdsYW5kc2NhcGUnOgogICAgICAgICAgICAgICAgICAgIGdyYWRpZW50ID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KDAsIDAsIHNpemUsIHNpemUpOwogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgY2FzZSAnc3BhY2UnOgogICAgICAgICAgICAgICAgICAgIGdyYWRpZW50ID0gY3R4LmNyZWF0ZVJhZGlhbEdyYWRpZW50KGNlbnRlclgsIGNlbnRlclksIDAsIGNlbnRlclgsIGNlbnRlclksIHNpemUgKiAwLjgpOwogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgZGVmYXVsdDoKICAgICAgICAgICAgICAgICAgICBncmFkaWVudCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCAwLCBzaXplLCBzaXplKTsKICAgICAgICAgICAgfQogICAgICAgICAgICAKICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGltYWdlRGF0YS5jb2xvcnMubGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcChpIC8gKGltYWdlRGF0YS5jb2xvcnMubGVuZ3RoIC0gMSksIGltYWdlRGF0YS5jb2xvcnNbaV0pOwogICAgICAgICAgICB9CiAgICAgICAgICAgIAogICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZ3JhZGllbnQ7CiAgICAgICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBzaXplLCBzaXplKTsKICAgICAgICAgICAgCiAgICAgICAgICAgIC8vIEFqb3V0ZXIgZGVzIGVmZmV0cyBzZWxvbiBsZSBwYXR0ZXJuCiAgICAgICAgICAgIGFkZFBhdHRlcm5FZmZlY3RzKGN0eCwgaW1hZ2VEYXRhKTsKICAgICAgICAgICAgCiAgICAgICAgICAgIHJldHVybiBjYW52YXMudG9EYXRhVVJMKCk7CiAgICAgICAgfQoKICAgICAgICBmdW5jdGlvbiBhZGRQYXR0ZXJuRWZmZWN0cyhjdHgsIGltYWdlRGF0YSkgewogICAgICAgICAgICBjb25zdCBzaXplID0gY3R4LmNhbnZhcy53aWR0aDsKICAgICAgICAgICAgY29uc3Qgc2NhbGUgPSBzaXplIC8gNDAwOwogICAgICAgICAgICAKICAgICAgICAgICAgc3dpdGNoKGltYWdlRGF0YS5wYXR0ZXJuKSB7CiAgICAgICAgICAgICAgICBjYXNlICdlbmNoYW50ZWRfZm9yZXN0JzoKICAgICAgICAgICAgICAgICAgICBkcmF3RW5jaGFudGVkRm9yZXN0KGN0eCwgaW1hZ2VEYXRhLmNvbG9ycywgc2NhbGUpOwogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgY2FzZSAnY3J5c3RhbF93YXRlcmZhbGwnOgogICAgICAgICAgICAgICAgICAgIGRyYXdDcnlzdGFsV2F0ZXJmYWxsKGN0eCwgaW1hZ2VEYXRhLmNvbG9ycywgc2NhbGUpOwogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgY2FzZSAnbGF2ZW5kZXJfZmllbGQnOgogICAgICAgICAgICAgICAgICAgIGRyYXdMYXZlbmRlckZpZWxkKGN0eCwgaW1hZ2VEYXRhLmNvbG9ycywgc2NhbGUpOwogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgY2FzZSAnbmVidWxhJzoKICAgICAgICAgICAgICAgICAgICBkcmF3TmVidWxhKGN0eCwgaW1hZ2VEYXRhLmNvbG9ycywgc2NhbGUpOwogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgY2FzZSAnc3Vuc2V0JzoKICAgICAgICAgICAgICAgICAgICBkcmF3U3Vuc2V0KGN0eCwgaW1hZ2VEYXRhLmNvbG9ycywgc2NhbGUpOwogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgZGVmYXVsdDoKICAgICAgICAgICAgICAgICAgICBkcmF3R2VuZXJpY1BhdHRlcm4oY3R4LCBpbWFnZURhdGEuY29sb3JzLCBzY2FsZSk7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIGZ1bmN0aW9uIGRyYXdFbmNoYW50ZWRGb3Jlc3QoY3R4LCBjb2xvcnMsIHNjYWxlID0gMSkgewogICAgICAgICAgICBjb25zdCBzaXplID0gY3R4LmNhbnZhcy53aWR0aDsKICAgICAgICAgICAgCiAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCAxMjsgaSsrKSB7CiAgICAgICAgICAgICAgICBjb25zdCB4ID0gKGkgKiBzaXplIC8gMTIpICsgTWF0aC5yYW5kb20oKSAqIDMwICogc2NhbGU7CiAgICAgICAgICAgICAgICBjb25zdCB0cmVlSGVpZ2h0ID0gKDEwMCArIE1hdGgucmFuZG9tKCkgKiAxMDApICogc2NhbGU7CiAgICAgICAgICAgICAgICBjb25zdCB5ID0gc2l6ZSAtIHRyZWVIZWlnaHQ7CiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBjb2xvcnNbM107CiAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoeCAtIDggKiBzY2FsZSwgeSwgMTYgKiBzY2FsZSwgdHJlZUhlaWdodCk7CiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgIGZvcihsZXQgbGF5ZXIgPSAwOyBsYXllciA8IDM7IGxheWVyKyspIHsKICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gY29sb3JzWzQgKyBsYXllciAlIDRdOwogICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTsKICAgICAgICAgICAgICAgICAgICBjdHguYXJjKHgsIHkgLSBsYXllciAqIDIwICogc2NhbGUsICg0MCAtIGxheWVyICogNSkgKiBzY2FsZSwgMCwgTWF0aC5QSSAqIDIpOwogICAgICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgIGlmKE1hdGgucmFuZG9tKCkgPiAwLjUpIHsKICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gY29sb3JzWzddOwogICAgICAgICAgICAgICAgICAgIGN0eC5zaGFkb3dCbHVyID0gMTAgKiBzY2FsZTsKICAgICAgICAgICAgICAgICAgICBjdHguc2hhZG93Q29sb3IgPSBjb2xvcnNbN107CiAgICAgICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpOwogICAgICAgICAgICAgICAgICAgIGN0eC5hcmMoeCArIE1hdGgucmFuZG9tKCkgKiA0MCAqIHNjYWxlIC0gMjAgKiBzY2FsZSwgeSAtIE1hdGgucmFuZG9tKCkgKiA2MCAqIHNjYWxlLCAyICogc2NhbGUsIDAsIE1hdGguUEkgKiAyKTsKICAgICAgICAgICAgICAgICAgICBjdHguZmlsbCgpOwogICAgICAgICAgICAgICAgICAgIGN0eC5zaGFkb3dCbHVyID0gMDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgZnVuY3Rpb24gZHJhd0NyeXN0YWxXYXRlcmZhbGwoY3R4LCBjb2xvcnMsIHNjYWxlID0gMSkgewogICAgICAgICAgICBjb25zdCBzaXplID0gY3R4LmNhbnZhcy53aWR0aDsKICAgICAgICAgICAgCiAgICAgICAgICAgIGNvbnN0IHdhdGVyZmFsbEdyYWRpZW50ID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KHNpemUgKiAwLjQsIDAsIHNpemUgKiAwLjYsIHNpemUpOwogICAgICAgICAgICB3YXRlcmZhbGxHcmFkaWVudC5hZGRDb2xvclN0b3AoMCwgY29sb3JzWzBdKTsKICAgICAgICAgICAgd2F0ZXJmYWxsR3JhZGllbnQuYWRkQ29sb3JTdG9wKDAuMywgY29sb3JzWzFdKTsKICAgICAgICAgICAgd2F0ZXJmYWxsR3JhZGllbnQuYWRkQ29sb3JTdG9wKDAuNywgY29sb3JzWzJdKTsKICAgICAgICAgICAgd2F0ZXJmYWxsR3JhZGllbnQuYWRkQ29sb3JTdG9wKDEsIGNvbG9yc1szXSk7CiAgICAgICAgICAgIAogICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gd2F0ZXJmYWxsR3JhZGllbnQ7CiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTsKICAgICAgICAgICAgY3R4Lm1vdmVUbyhzaXplICogMC40NSwgMCk7CiAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHNpemUgKiAwLjUsIHNpemUgKiAwLjMsIHNpemUgKiAwLjQ4LCBzaXplICogMC42KTsKICAgICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oc2l6ZSAqIDAuNTIsIHNpemUgKiAwLjgsIHNpemUgKiAwLjU1LCBzaXplKTsKICAgICAgICAgICAgY3R4LmxpbmVUbyhzaXplICogMC40NSwgc2l6ZSk7CiAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHNpemUgKiAwLjQ4LCBzaXplICogMC43LCBzaXplICogMC40NSwgMCk7CiAgICAgICAgICAgIGN0eC5maWxsKCk7CiAgICAgICAgICAgIAogICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgMjA7IGkrKykgewogICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yc1szXTsKICAgICAgICAgICAgICAgIGNvbnN0IHggPSBzaXplICogMC40ICsgTWF0aC5yYW5kb20oKSAqIHNpemUgKiAwLjM7CiAgICAgICAgICAgICAgICBjb25zdCB5ID0gc2l6ZSAqIDAuOCArIE1hdGgucmFuZG9tKCkgKiBzaXplICogMC4yOwogICAgICAgICAgICAgICAgY29uc3QgcmFkaXVzID0gTWF0aC5yYW5kb20oKSAqIDQgKiBzY2FsZSArIDE7CiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTsKICAgICAgICAgICAgICAgIGN0eC5hcmMoeCwgeSwgcmFkaXVzLCAwLCBNYXRoLlBJICogMik7CiAgICAgICAgICAgICAgICBjdHguZmlsbCgpOwogICAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICBmdW5jdGlvbiBkcmF3TGF2ZW5kZXJGaWVsZChjdHgsIGNvbG9ycywgc2NhbGUgPSAxKSB7CiAgICAgICAgICAgIGNvbnN0IHNpemUgPSBjdHguY2FudmFzLndpZHRoOwogICAgICAgICAgICAKICAgICAgICAgICAgZm9yKGxldCByb3cgPSAwOyByb3cgPCA4OyByb3crKykgewogICAgICAgICAgICAgICAgY29uc3QgeSA9IHNpemUgKiAwLjY1ICsgcm93ICogKHNpemUgKiAwLjA0KTsKICAgICAgICAgICAgICAgIGNvbnN0IHBlcnNwZWN0aXZlID0gMSAtIChyb3cgKiAwLjEpOwogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgMTU7IGkrKykgewogICAgICAgICAgICAgICAgICAgIGNvbnN0IHggPSAoaSAqIHNpemUgLyAxNSkgKyBNYXRoLnNpbihyb3cgKyBpKSAqIDEwICogc2NhbGU7CiAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yc1s1XTsKICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoeCAtIDEgKiBzY2FsZSAqIHBlcnNwZWN0aXZlLCB5LCAyICogc2NhbGUgKiBwZXJzcGVjdGl2ZSwgMjUgKiBzY2FsZSAqIHBlcnNwZWN0aXZlKTsKICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gY29sb3JzWzAgKyAoaSAlIDIpXTsKICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGZsb3dlciA9IDA7IGZsb3dlciA8IDU7IGZsb3dlcisrKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTsKICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmFyYygKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggKyBNYXRoLnJhbmRvbSgpICogNCAqIHNjYWxlIC0gMiAqIHNjYWxlLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgeSAtIGZsb3dlciAqIDQgKiBzY2FsZSAqIHBlcnNwZWN0aXZlLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgMS41ICogc2NhbGUgKiBwZXJzcGVjdGl2ZSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsIE1hdGguUEkgKiAyCiAgICAgICAgICAgICAgICAgICAgICAgICk7CiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICBmdW5jdGlvbiBkcmF3TmVidWxhKGN0eCwgY29sb3JzLCBzY2FsZSA9IDEpIHsKICAgICAgICAgICAgY29uc3QgY2VudGVyWCA9IGN0eC5jYW52YXMud2lkdGggLyAyOwogICAgICAgICAgICBjb25zdCBjZW50ZXJZID0gY3R4LmNhbnZhcy5oZWlnaHQgLyAyOwogICAgICAgICAgICAKICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IDg7IGkrKykgewogICAgICAgICAgICAgICAgY29uc3QgZ3JhZGllbnQgPSBjdHguY3JlYXRlUmFkaWFsR3JhZGllbnQoCiAgICAgICAgICAgICAgICAgICAgY2VudGVyWCArIChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDIwMCAqIHNjYWxlLAogICAgICAgICAgICAgICAgICAgIGNlbnRlclkgKyAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAyMDAgKiBzY2FsZSwKICAgICAgICAgICAgICAgICAgICAwLAogICAgICAgICAgICAgICAgICAgIGNlbnRlclggKyAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAyMDAgKiBzY2FsZSwKICAgICAgICAgICAgICAgICAgICBjZW50ZXJZICsgKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMjAwICogc2NhbGUsCiAgICAgICAgICAgICAgICAgICAgODAgKiBzY2FsZQogICAgICAgICAgICAgICAgKTsKICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDAsIGNvbG9yc1sxICsgaSAlIDZdKTsKICAgICAgICAgICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgwLjUsIGNvbG9yc1syICsgaSAlIDVdICsgJzgwJyk7CiAgICAgICAgICAgICAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMSwgJ3RyYW5zcGFyZW50Jyk7CiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBncmFkaWVudDsKICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTsKICAgICAgICAgICAgICAgIGN0eC5hcmMoCiAgICAgICAgICAgICAgICAgICAgY2VudGVyWCArIChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDE1MCAqIHNjYWxlLAogICAgICAgICAgICAgICAgICAgIGNlbnRlclkgKyAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAxNTAgKiBzY2FsZSwKICAgICAgICAgICAgICAgICAgICA2MCAqIHNjYWxlICsgTWF0aC5yYW5kb20oKSAqIDQwICogc2NhbGUsCiAgICAgICAgICAgICAgICAgICAgMCwgTWF0aC5QSSAqIDIKICAgICAgICAgICAgICAgICk7CiAgICAgICAgICAgICAgICBjdHguZmlsbCgpOwogICAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICBmdW5jdGlvbiBkcmF3U3Vuc2V0KGN0eCwgY29sb3JzLCBzY2FsZSA9IDEpIHsKICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IGN0eC5jYW52YXMud2lkdGg7CiAgICAgICAgICAgIAogICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gY29sb3JzWzJdOwogICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7CiAgICAgICAgICAgIGN0eC5hcmMoc2l6ZSAqIDAuNSwgc2l6ZSAqIDAuMzc1LCA2MCAqIHNjYWxlLCAwLCBNYXRoLlBJICogMik7CiAgICAgICAgICAgIGN0eC5maWxsKCk7CiAgICAgICAgICAgIAogICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcnNbM107CiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSA0ICogc2NhbGU7CiAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCAxMjsgaSsrKSB7CiAgICAgICAgICAgICAgICBjb25zdCBhbmdsZSA9IChpICogTWF0aC5QSSAqIDIpIC8gMTI7CiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7CiAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHNpemUgKiAwLjUgKyBNYXRoLmNvcyhhbmdsZSkgKiA3MCAqIHNjYWxlLCBzaXplICogMC4zNzUgKyBNYXRoLnNpbihhbmdsZSkgKiA3MCAqIHNjYWxlKTsKICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oc2l6ZSAqIDAuNSArIE1hdGguY29zKGFuZ2xlKSAqIDEwMCAqIHNjYWxlLCBzaXplICogMC4zNzUgKyBNYXRoLnNpbihhbmdsZSkgKiAxMDAgKiBzY2FsZSk7CiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7CiAgICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIGZ1bmN0aW9uIGRyYXdHZW5lcmljUGF0dGVybihjdHgsIGNvbG9ycywgc2NhbGUgPSAxKSB7CiAgICAgICAgICAgIGNvbnN0IHNpemUgPSBjdHguY2FudmFzLndpZHRoOwogICAgICAgICAgICAKICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IDIwOyBpKyspIHsKICAgICAgICAgICAgICAgIGNvbnN0IHggPSBNYXRoLnJhbmRvbSgpICogc2l6ZTsKICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBNYXRoLnJhbmRvbSgpICogc2l6ZTsKICAgICAgICAgICAgICAgIGNvbnN0IHJhZGl1cyA9IE1hdGgucmFuZG9tKCkgKiAzMCAqIHNjYWxlICsgMTAgKiBzY2FsZTsKICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yc1tpICUgY29sb3JzLmxlbmd0aF07CiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7CiAgICAgICAgICAgICAgICBjdHguYXJjKHgsIHksIHJhZGl1cywgMCwgTWF0aC5QSSAqIDIpOwogICAgICAgICAgICAgICAgY3R4LmZpbGwoKTsKICAgICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgLy8gQ3LDqWVyIGxlcyBwYXJ0aWN1bGVzIG5ldXJhbGVzCiAgICAgICAgZnVuY3Rpb24gY3JlYXRlTmV1cmFsUGFydGljbGVzKCkgewogICAgICAgICAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbmV1cmFsUGFydGljbGVzJyk7CiAgICAgICAgICAgIAogICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgMzA7IGkrKykgewogICAgICAgICAgICAgICAgY29uc3QgcGFydGljbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTsKICAgICAgICAgICAgICAgIHBhcnRpY2xlLmNsYXNzTmFtZSA9ICduZXVyYWwtcGFydGljbGUnOwogICAgICAgICAgICAgICAgcGFydGljbGUuc3R5bGUubGVmdCA9IE1hdGgucmFuZG9tKCkgKiAxMDAgKyAnJSc7CiAgICAgICAgICAgICAgICBwYXJ0aWNsZS5zdHlsZS5hbmltYXRpb25EZWxheSA9IE1hdGgucmFuZG9tKCkgKiA4ICsgJ3MnOwogICAgICAgICAgICAgICAgcGFydGljbGUuc3R5bGUuYW5pbWF0aW9uRHVyYXRpb24gPSAoOCArIE1hdGgucmFuZG9tKCkgKiA0KSArICdzJzsKICAgICAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChwYXJ0aWNsZSk7CiAgICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIC8vIEluaXRpYWxpc2VyIGxlIGpldQogICAgICAgIGZ1bmN0aW9uIGluaXRHYW1lKCkgewogICAgICAgICAgICBnYW1lU3RhdGUuY3VycmVudEltYWdlSW5kZXggPSAwOwogICAgICAgICAgICBnYW1lU3RhdGUuY3VycmVudEltYWdlRGF0YSA9IHB1enpsZUltYWdlc1tnYW1lU3RhdGUuY3VycmVudEltYWdlSW5kZXhdOwogICAgICAgICAgICAKICAgICAgICAgICAgZ2VuZXJhdGVOZXdQdXp6bGUoKTsKICAgICAgICAgICAgdXBkYXRlVUkoKTsKICAgICAgICAgICAgc3RhcnRUaW1lcigpOwogICAgICAgIH0KCiAgICAgICAgLy8gR8OpbsOpcmVyIHVuIG5vdXZlYXUgcHV6emxlCiAgICAgICAgZnVuY3Rpb24gZ2VuZXJhdGVOZXdQdXp6bGUoKSB7CiAgICAgICAgICAgIGNvbnN0IHRvdGFsUGllY2VzID0gZ2FtZVN0YXRlLmdyaWRTaXplICogZ2FtZVN0YXRlLmdyaWRTaXplOwogICAgICAgICAgICAKICAgICAgICAgICAgY29uc3QgaW1hZ2VEYXRhID0gZ2VuZXJhdGVQcm9jZWR1cmFsSW1hZ2UoZ2FtZVN0YXRlLmN1cnJlbnRJbWFnZURhdGEsIDMwMCk7CiAgICAgICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyZWZlcmVuY2VJbWFnZScpOwogICAgICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTsKICAgICAgICAgICAgCiAgICAgICAgICAgIGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpOwogICAgICAgICAgICBpbWcub25sb2FkID0gZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKGltZywgMCwgMCwgMzAwLCAzMDApOwogICAgICAgICAgICAgICAgZ2FtZVN0YXRlLmN1cnJlbnRJbWFnZURhdGEuaW1hZ2VEYXRhID0gaW1hZ2VEYXRhOwogICAgICAgICAgICB9OwogICAgICAgICAgICBpbWcuc3JjID0gaW1hZ2VEYXRhOwogICAgICAgICAgICAKICAgICAgICAgICAgZ2FtZVN0YXRlLmJvYXJkID0gW107CiAgICAgICAgICAgIGdhbWVTdGF0ZS5jb3JyZWN0Qm9hcmQgPSBbXTsKICAgICAgICAgICAgCiAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0b3RhbFBpZWNlczsgaSsrKSB7CiAgICAgICAgICAgICAgICBnYW1lU3RhdGUuYm9hcmQucHVzaChpKTsKICAgICAgICAgICAgICAgIGdhbWVTdGF0ZS5jb3JyZWN0Qm9hcmQucHVzaChpKTsKICAgICAgICAgICAgfQogICAgICAgICAgICAKICAgICAgICAgICAgc2h1ZmZsZUJvYXJkKCk7CiAgICAgICAgICAgIGNyZWF0ZVB1enpsZUJvYXJkKCk7CiAgICAgICAgICAgIAogICAgICAgICAgICBnYW1lU3RhdGUubW92ZXMgPSAwOwogICAgICAgICAgICBnYW1lU3RhdGUuaGludFVzZWQgPSBmYWxzZTsKICAgICAgICAgICAgZ2FtZVN0YXRlLmlzUGxheWluZyA9IHRydWU7CiAgICAgICAgICAgIGdhbWVTdGF0ZS5pc1BhdXNlZCA9IGZhbHNlOwogICAgICAgICAgICBnYW1lU3RhdGUucGF1c2VkVGltZSA9IDA7CiAgICAgICAgICAgIGdhbWVTdGF0ZS5zdGFydFRpbWUgPSBEYXRlLm5vdygpOwogICAgICAgICAgICAKICAgICAgICAgICAgdXBkYXRlVUkoKTsKICAgICAgICAgICAgdXBkYXRlUHJvZ3Jlc3MoKTsKICAgICAgICB9CgogICAgICAgIC8vIE3DqWxhbmdlciBsZSBwbGF0ZWF1CiAgICAgICAgZnVuY3Rpb24gc2h1ZmZsZUJvYXJkKCkgewogICAgICAgICAgICBjb25zdCB0b3RhbFBpZWNlcyA9IGdhbWVTdGF0ZS5ncmlkU2l6ZSAqIGdhbWVTdGF0ZS5ncmlkU2l6ZTsKICAgICAgICAgICAgCiAgICAgICAgICAgIGZvcihsZXQgaSA9IHRvdGFsUGllY2VzIC0gMTsgaSA+IDA7IGktLSkgewogICAgICAgICAgICAgICAgY29uc3QgaiA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChpICsgMSkpOwogICAgICAgICAgICAgICAgW2dhbWVTdGF0ZS5ib2FyZFtpXSwgZ2FtZVN0YXRlLmJvYXJkW2pdXSA9IFtnYW1lU3RhdGUuYm9hcmRbal0sIGdhbWVTdGF0ZS5ib2FyZFtpXV07CiAgICAgICAgICAgIH0KICAgICAgICAgICAgCiAgICAgICAgICAgIGxldCBpc1NvbHZlZCA9IHRydWU7CiAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0b3RhbFBpZWNlczsgaSsrKSB7CiAgICAgICAgICAgICAgICBpZihnYW1lU3RhdGUuYm9hcmRbaV0gIT09IGkpIHsKICAgICAgICAgICAgICAgICAgICBpc1NvbHZlZCA9IGZhbHNlOwogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIAogICAgICAgICAgICBpZihpc1NvbHZlZCkgewogICAgICAgICAgICAgICAgW2dhbWVTdGF0ZS5ib2FyZFswXSwgZ2FtZVN0YXRlLmJvYXJkWzFdXSA9IFtnYW1lU3RhdGUuYm9hcmRbMV0sIGdhbWVTdGF0ZS5ib2FyZFswXV07CiAgICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIC8vIENyw6llciBsJ2ludGVyZmFjZSBkdSBwdXp6bGUKICAgICAgICBmdW5jdGlvbiBjcmVhdGVQdXp6bGVCb2FyZCgpIHsKICAgICAgICAgICAgY29uc3QgcHV6emxlQm9hcmQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncHV6emxlQm9hcmQnKTsKICAgICAgICAgICAgcHV6emxlQm9hcmQuaW5uZXJIVE1MID0gJyc7CiAgICAgICAgICAgIHB1enpsZUJvYXJkLmNsYXNzTmFtZSA9IGBwdXp6bGUtYm9hcmQgZ3JpZC0ke2dhbWVTdGF0ZS5ncmlkU2l6ZX14JHtnYW1lU3RhdGUuZ3JpZFNpemV9YDsKICAgICAgICAgICAgCiAgICAgICAgICAgIGNvbnN0IHRvdGFsUGllY2VzID0gZ2FtZVN0YXRlLmdyaWRTaXplICogZ2FtZVN0YXRlLmdyaWRTaXplOwogICAgICAgICAgICAKICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRvdGFsUGllY2VzOyBpKyspIHsKICAgICAgICAgICAgICAgIGNvbnN0IHBpZWNlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7CiAgICAgICAgICAgICAgICBwaWVjZS5jbGFzc05hbWUgPSAncHV6emxlLXBpZWNlJzsKICAgICAgICAgICAgICAgIHBpZWNlLmRhdGFzZXQucG9zaXRpb24gPSBpOwogICAgICAgICAgICAgICAgcGllY2Uub25jbGljayA9ICgpID0+IHNlbGVjdFBpZWNlKGkpOwogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICB1cGRhdGVQaWVjZUltYWdlKHBpZWNlLCBpKTsKICAgICAgICAgICAgICAgIHB1enpsZUJvYXJkLmFwcGVuZENoaWxkKHBpZWNlKTsKICAgICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgLy8gTWV0dHJlIMOgIGpvdXIgbCdpbWFnZSBkJ3VuZSBwacOoY2UKICAgICAgICBmdW5jdGlvbiB1cGRhdGVQaWVjZUltYWdlKHBpZWNlLCBwb3NpdGlvbikgewogICAgICAgICAgICBjb25zdCBwaWVjZUluZGV4ID0gZ2FtZVN0YXRlLmJvYXJkW3Bvc2l0aW9uXTsKICAgICAgICAgICAgY29uc3QgcGllY2VTaXplID0gMzAwIC8gZ2FtZVN0YXRlLmdyaWRTaXplOwogICAgICAgICAgICAKICAgICAgICAgICAgY29uc3Qgcm93ID0gTWF0aC5mbG9vcihwaWVjZUluZGV4IC8gZ2FtZVN0YXRlLmdyaWRTaXplKTsKICAgICAgICAgICAgY29uc3QgY29sID0gcGllY2VJbmRleCAlIGdhbWVTdGF0ZS5ncmlkU2l6ZTsKICAgICAgICAgICAgCiAgICAgICAgICAgIGNvbnN0IG9mZnNldFggPSAtY29sICogcGllY2VTaXplOwogICAgICAgICAgICBjb25zdCBvZmZzZXRZID0gLXJvdyAqIHBpZWNlU2l6ZTsKICAgICAgICAgICAgCiAgICAgICAgICAgIGlmKGdhbWVTdGF0ZS5jdXJyZW50SW1hZ2VEYXRhICYmIGdhbWVTdGF0ZS5jdXJyZW50SW1hZ2VEYXRhLmltYWdlRGF0YSkgewogICAgICAgICAgICAgICAgcGllY2Uuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gYHVybCgke2dhbWVTdGF0ZS5jdXJyZW50SW1hZ2VEYXRhLmltYWdlRGF0YX0pYDsKICAgICAgICAgICAgICAgIHBpZWNlLnN0eWxlLmJhY2tncm91bmRQb3NpdGlvbiA9IGAke29mZnNldFh9cHggJHtvZmZzZXRZfXB4YDsKICAgICAgICAgICAgfQogICAgICAgICAgICAKICAgICAgICAgICAgLy8gVsOpcmlmaWVyIHNpIGxhIHBpw6hjZSBlc3Qgw6AgbGEgYm9ubmUgcGxhY2UKICAgICAgICAgICAgaWYocGllY2VJbmRleCA9PT0gcG9zaXRpb24pIHsKICAgICAgICAgICAgICAgIHBpZWNlLmNsYXNzTGlzdC5hZGQoJ2NvcnJlY3QnKTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHBpZWNlLmNsYXNzTGlzdC5yZW1vdmUoJ2NvcnJlY3QnKTsKICAgICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgLy8gU8OpbGVjdGlvbm5lciB1bmUgcGnDqGNlCiAgICAgICAgZnVuY3Rpb24gc2VsZWN0UGllY2UocG9zaXRpb24pIHsKICAgICAgICAgICAgaWYoZ2FtZVN0YXRlLmlzUGF1c2VkIHx8ICFnYW1lU3RhdGUuaXNQbGF5aW5nKSByZXR1cm47CiAgICAgICAgICAgIAogICAgICAgICAgICBjb25zdCBwaWVjZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcucHV6emxlLXBpZWNlJyk7CiAgICAgICAgICAgIAogICAgICAgICAgICBpZihnYW1lU3RhdGUuc2VsZWN0ZWRQaWVjZSA9PT0gbnVsbCkgewogICAgICAgICAgICAgICAgZ2FtZVN0YXRlLnNlbGVjdGVkUGllY2UgPSBwb3NpdGlvbjsKICAgICAgICAgICAgICAgIHBpZWNlc1twb3NpdGlvbl0uY2xhc3NMaXN0LmFkZCgnc2VsZWN0ZWQnKTsKICAgICAgICAgICAgfSBlbHNlIGlmKGdhbWVTdGF0ZS5zZWxlY3RlZFBpZWNlID09PSBwb3NpdGlvbikgewogICAgICAgICAgICAgICAgZ2FtZVN0YXRlLnNlbGVjdGVkUGllY2UgPSBudWxsOwogICAgICAgICAgICAgICAgcGllY2VzW3Bvc2l0aW9uXS5jbGFzc0xpc3QucmVtb3ZlKCdzZWxlY3RlZCcpOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgLy8gw4ljaGFuZ2VyIGxlcyBwacOoY2VzCiAgICAgICAgICAgICAgICBjb25zdCBwaWVjZTEgPSBnYW1lU3RhdGUuc2VsZWN0ZWRQaWVjZTsKICAgICAgICAgICAgICAgIGNvbnN0IHBpZWNlMiA9IHBvc2l0aW9uOwogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICBbZ2FtZVN0YXRlLmJvYXJkW3BpZWNlMV0sIGdhbWVTdGF0ZS5ib2FyZFtwaWVjZTJdXSA9IFtnYW1lU3RhdGUuYm9hcmRbcGllY2UyXSwgZ2FtZVN0YXRlLmJvYXJkW3BpZWNlMV1dOwogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICB1cGRhdGVQaWVjZUltYWdlKHBpZWNlc1twaWVjZTFdLCBwaWVjZTEpOwogICAgICAgICAgICAgICAgdXBkYXRlUGllY2VJbWFnZShwaWVjZXNbcGllY2UyXSwgcGllY2UyKTsKICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgcGllY2VzW3BpZWNlMV0uY2xhc3NMaXN0LnJlbW92ZSgnc2VsZWN0ZWQnKTsKICAgICAgICAgICAgICAgIGdhbWVTdGF0ZS5zZWxlY3RlZFBpZWNlID0gbnVsbDsKICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgZ2FtZVN0YXRlLm1vdmVzKys7CiAgICAgICAgICAgICAgICB1cGRhdGVVSSgpOwogICAgICAgICAgICAgICAgdXBkYXRlUHJvZ3Jlc3MoKTsKICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgLy8gVsOpcmlmaWVyIHNpIGxlIHB1enpsZSBlc3QgcsOpc29sdQogICAgICAgICAgICAgICAgaWYoaXNQdXp6bGVTb2x2ZWQoKSkgewogICAgICAgICAgICAgICAgICAgIHNvbHZlUHV6emxlKCk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIC8vIFbDqXJpZmllciBzaSBsZSBwdXp6bGUgZXN0IHLDqXNvbHUKICAgICAgICBmdW5jdGlvbiBpc1B1enpsZVNvbHZlZCgpIHsKICAgICAgICAgICAgY29uc3QgdG90YWxQaWVjZXMgPSBnYW1lU3RhdGUuZ3JpZFNpemUgKiBnYW1lU3RhdGUuZ3JpZFNpemU7CiAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0b3RhbFBpZWNlczsgaSsrKSB7CiAgICAgICAgICAgICAgICBpZihnYW1lU3RhdGUuYm9hcmRbaV0gIT09IGkpIHsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgfQoKICAgICAgICAvLyBSw6lzb3VkcmUgbGUgcHV6emxlCiAgICAgICAgZnVuY3Rpb24gc29sdmVQdXp6bGUoKSB7CiAgICAgICAgICAgIGdhbWVTdGF0ZS5pc1BsYXlpbmcgPSBmYWxzZTsKICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChnYW1lU3RhdGUudGltZXIpOwogICAgICAgICAgICAKICAgICAgICAgICAgY29uc3QgZWxhcHNlZFRpbWUgPSBEYXRlLm5vdygpIC0gZ2FtZVN0YXRlLnN0YXJ0VGltZTsKICAgICAgICAgICAgZ2FtZVN0YXRlLnNjb3JlID0gTWF0aC5tYXgoMTAwMCAtIGdhbWVTdGF0ZS5tb3ZlcyAqIDEwIC0gTWF0aC5mbG9vcihlbGFwc2VkVGltZSAvIDEwMDApLCAxMDApOwogICAgICAgICAgICAKICAgICAgICAgICAgc2hvd1ZpY3RvcnlFZmZlY3QoKTsKICAgICAgICAgICAgc2hvd0FJTWVzc2FnZSh0bSgncHV6emxlU29sdmVkJywgZ2FtZVN0YXRlLnNjb3JlKSwgMzAwMCk7CiAgICAgICAgICAgIAogICAgICAgICAgICAvLyBNZXR0cmUgw6Agam91ciBsZXMgc3RhdGlzdGlxdWVzCiAgICAgICAgICAgIGdhbWVTdGF0ZS5zdGF0aXN0aWNzLmdhbWVzUGxheWVkKys7CiAgICAgICAgICAgIGdhbWVTdGF0ZS5zdGF0aXN0aWNzLmdhbWVzV29uKys7CiAgICAgICAgICAgIGdhbWVTdGF0ZS5zdGF0aXN0aWNzLnRvdGFsTW92ZXMgKz0gZ2FtZVN0YXRlLm1vdmVzOwogICAgICAgICAgICBnYW1lU3RhdGUuc3RhdGlzdGljcy50b3RhbFRpbWUgKz0gZWxhcHNlZFRpbWU7CiAgICAgICAgICAgIAogICAgICAgICAgICBpZihnYW1lU3RhdGUuc2NvcmUgPiBnYW1lU3RhdGUuc3RhdGlzdGljcy5iZXN0U2NvcmUpIHsKICAgICAgICAgICAgICAgIGdhbWVTdGF0ZS5zdGF0aXN0aWNzLmJlc3RTY29yZSA9IGdhbWVTdGF0ZS5zY29yZTsKICAgICAgICAgICAgfQogICAgICAgICAgICAKICAgICAgICAgICAgdXBkYXRlVUkoKTsKICAgICAgICB9CgogICAgICAgIC8vIEFmZmljaGVyIGwnZWZmZXQgZGUgdmljdG9pcmUKICAgICAgICBmdW5jdGlvbiBzaG93VmljdG9yeUVmZmVjdCgpIHsKICAgICAgICAgICAgY29uc3QgZWZmZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7CiAgICAgICAgICAgIGVmZmVjdC5jbGFzc05hbWUgPSAndmljdG9yeS1lZmZlY3QnOwogICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGVmZmVjdCk7CiAgICAgICAgICAgIAogICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgNTA7IGkrKykgewogICAgICAgICAgICAgICAgY29uc3QgcGFydGljbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTsKICAgICAgICAgICAgICAgIHBhcnRpY2xlLmNsYXNzTmFtZSA9ICd2aWN0b3J5LXBhcnRpY2xlJzsKICAgICAgICAgICAgICAgIHBhcnRpY2xlLnN0eWxlLmxlZnQgPSBNYXRoLnJhbmRvbSgpICogMTAwICsgJyUnOwogICAgICAgICAgICAgICAgcGFydGljbGUuc3R5bGUudG9wID0gTWF0aC5yYW5kb20oKSAqIDEwMCArICclJzsKICAgICAgICAgICAgICAgIHBhcnRpY2xlLnN0eWxlLmFuaW1hdGlvbkRlbGF5ID0gTWF0aC5yYW5kb20oKSAqIDIgKyAncyc7CiAgICAgICAgICAgICAgICBlZmZlY3QuYXBwZW5kQ2hpbGQocGFydGljbGUpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIAogICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsKICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZWZmZWN0KTsKICAgICAgICAgICAgfSwgMzAwMCk7CiAgICAgICAgfQoKICAgICAgICAvLyBBZmZpY2hlciB1biBtZXNzYWdlIElBCiAgICAgICAgZnVuY3Rpb24gc2hvd0FJTWVzc2FnZShtZXNzYWdlLCBkdXJhdGlvbiA9IDIwMDApIHsKICAgICAgICAgICAgY29uc3QgYWlUaGlua2luZyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhaVRoaW5raW5nJyk7CiAgICAgICAgICAgIGNvbnN0IGFpTWVzc2FnZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhaU1lc3NhZ2UnKTsKICAgICAgICAgICAgCiAgICAgICAgICAgIGFpTWVzc2FnZS50ZXh0Q29udGVudCA9IG1lc3NhZ2U7CiAgICAgICAgICAgIGFpVGhpbmtpbmcuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7CiAgICAgICAgICAgIAogICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsKICAgICAgICAgICAgICAgIGFpVGhpbmtpbmcuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7CiAgICAgICAgICAgIH0sIGR1cmF0aW9uKTsKICAgICAgICB9CgogICAgICAgIC8vIETDqW1hcnJlciBsZSB0aW1lcgogICAgICAgIGZ1bmN0aW9uIHN0YXJ0VGltZXIoKSB7CiAgICAgICAgICAgIGlmKGdhbWVTdGF0ZS50aW1lcikgewogICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChnYW1lU3RhdGUudGltZXIpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIAogICAgICAgICAgICBnYW1lU3RhdGUudGltZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB7CiAgICAgICAgICAgICAgICBpZighZ2FtZVN0YXRlLmlzUGF1c2VkICYmIGdhbWVTdGF0ZS5pc1BsYXlpbmcpIHsKICAgICAgICAgICAgICAgICAgICB1cGRhdGVVSSgpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9LCAxMDAwKTsKICAgICAgICB9CgogICAgICAgIC8vIE1ldHRyZSDDoCBqb3VyIGwnaW50ZXJmYWNlIHV0aWxpc2F0ZXVyCiAgICAgICAgZnVuY3Rpb24gdXBkYXRlVUkoKSB7CiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhaUxldmVsJykudGV4dENvbnRlbnQgPSBnYW1lU3RhdGUuYWlMZXZlbDsKICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ25ldXJhbFNjb3JlJykudGV4dENvbnRlbnQgPSBnYW1lU3RhdGUuc2NvcmU7CiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtb3ZlQ291bnQnKS50ZXh0Q29udGVudCA9IGdhbWVTdGF0ZS5tb3ZlczsKICAgICAgICAgICAgCiAgICAgICAgICAgIGlmKGdhbWVTdGF0ZS5pc1BsYXlpbmcgJiYgIWdhbWVTdGF0ZS5pc1BhdXNlZCkgewogICAgICAgICAgICAgICAgY29uc3QgZWxhcHNlZFRpbWUgPSBEYXRlLm5vdygpIC0gZ2FtZVN0YXRlLnN0YXJ0VGltZTsKICAgICAgICAgICAgICAgIGNvbnN0IG1pbnV0ZXMgPSBNYXRoLmZsb29yKGVsYXBzZWRUaW1lIC8gNjAwMDApOwogICAgICAgICAgICAgICAgY29uc3Qgc2Vjb25kcyA9IE1hdGguZmxvb3IoKGVsYXBzZWRUaW1lICUgNjAwMDApIC8gMTAwMCk7CiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbmV1cmFsVGltZScpLnRleHRDb250ZW50ID0gCiAgICAgICAgICAgICAgICAgICAgYCR7bWludXRlcy50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyl9OiR7c2Vjb25kcy50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyl9YDsKICAgICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgLy8gTWV0dHJlIMOgIGpvdXIgbGEgcHJvZ3Jlc3Npb24KICAgICAgICBmdW5jdGlvbiB1cGRhdGVQcm9ncmVzcygpIHsKICAgICAgICAgICAgY29uc3QgdG90YWxQaWVjZXMgPSBnYW1lU3RhdGUuZ3JpZFNpemUgKiBnYW1lU3RhdGUuZ3JpZFNpemU7CiAgICAgICAgICAgIGxldCBjb3JyZWN0UGllY2VzID0gMDsKICAgICAgICAgICAgCiAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0b3RhbFBpZWNlczsgaSsrKSB7CiAgICAgICAgICAgICAgICBpZihnYW1lU3RhdGUuYm9hcmRbaV0gPT09IGkpIHsKICAgICAgICAgICAgICAgICAgICBjb3JyZWN0UGllY2VzKys7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgCiAgICAgICAgICAgIGNvbnN0IHByb2dyZXNzID0gKGNvcnJlY3RQaWVjZXMgLyB0b3RhbFBpZWNlcykgKiAxMDA7CiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwcm9ncmVzc0ZpbGwnKS5zdHlsZS53aWR0aCA9IHByb2dyZXNzICsgJyUnOwogICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncHJvZ3Jlc3NUZXh0JykudGV4dENvbnRlbnQgPSBNYXRoLnJvdW5kKHByb2dyZXNzKSArICclICcgKyB0KCdjb21wbGV0ZWQnKTsKICAgICAgICB9CgogICAgICAgIC8vIEZvbmN0aW9ucyBkZXMgYm91dG9ucwogICAgICAgIGZ1bmN0aW9uIGdldEFJSGludCgpIHsKICAgICAgICAgICAgaWYoZ2FtZVN0YXRlLmhpbnRVc2VkKSB7CiAgICAgICAgICAgICAgICBzaG93QUlNZXNzYWdlKHRtKCdoaW50VXNlZCcpLCAyMDAwKTsKICAgICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgfQogICAgICAgICAgICAKICAgICAgICAgICAgc2hvd0FJTWVzc2FnZSh0KCdhaVRoaW5raW5nJyksIDIwMDApOwogICAgICAgICAgICAKICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7CiAgICAgICAgICAgICAgICBjb25zdCB0b3RhbFBpZWNlcyA9IGdhbWVTdGF0ZS5ncmlkU2l6ZSAqIGdhbWVTdGF0ZS5ncmlkU2l6ZTsKICAgICAgICAgICAgICAgIGxldCB3cm9uZ1BpZWNlcyA9IFtdOwogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdG90YWxQaWVjZXM7IGkrKykgewogICAgICAgICAgICAgICAgICAgIGlmKGdhbWVTdGF0ZS5ib2FyZFtpXSAhPT0gaSkgewogICAgICAgICAgICAgICAgICAgICAgICB3cm9uZ1BpZWNlcy5wdXNoKGkpOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgaWYod3JvbmdQaWVjZXMubGVuZ3RoID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgc2hvd0FJTWVzc2FnZSh0bSgnYWxsQ29ycmVjdCcpLCAyMDAwKTsKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGludFBvc2l0aW9uID0gd3JvbmdQaWVjZXNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogd3JvbmdQaWVjZXMubGVuZ3RoKV07CiAgICAgICAgICAgICAgICAgICAgc2hvd0FJTWVzc2FnZSh0bSgnd3JvbmdQaWVjZScsIGhpbnRQb3NpdGlvbiArIDEpLCAzMDAwKTsKICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAvLyBNZXR0cmUgZW4gw6l2aWRlbmNlIGxhIHBpw6hjZQogICAgICAgICAgICAgICAgICAgIGNvbnN0IHBpZWNlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5wdXp6bGUtcGllY2UnKTsKICAgICAgICAgICAgICAgICAgICBwaWVjZXNbaGludFBvc2l0aW9uXS5zdHlsZS5ib3JkZXIgPSAnM3B4IHNvbGlkICNGRkQ3MDAnOwogICAgICAgICAgICAgICAgICAgIHBpZWNlc1toaW50UG9zaXRpb25dLnN0eWxlLmJveFNoYWRvdyA9ICcwIDAgMjBweCAjRkZENzAwJzsKICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsKICAgICAgICAgICAgICAgICAgICAgICAgcGllY2VzW2hpbnRQb3NpdGlvbl0uc3R5bGUuYm9yZGVyID0gJyc7CiAgICAgICAgICAgICAgICAgICAgICAgIHBpZWNlc1toaW50UG9zaXRpb25dLnN0eWxlLmJveFNoYWRvdyA9ICcnOwogICAgICAgICAgICAgICAgICAgIH0sIDMwMDApOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICBnYW1lU3RhdGUuaGludFVzZWQgPSB0cnVlOwogICAgICAgICAgICB9LCAyMDAwKTsKICAgICAgICB9CgogICAgICAgIGZ1bmN0aW9uIGNoYW5nZUltYWdlKCkgewogICAgICAgICAgICBnYW1lU3RhdGUuY3VycmVudEltYWdlSW5kZXggPSAoZ2FtZVN0YXRlLmN1cnJlbnRJbWFnZUluZGV4ICsgMSkgJSBwdXp6bGVJbWFnZXMubGVuZ3RoOwogICAgICAgICAgICBnYW1lU3RhdGUuY3VycmVudEltYWdlRGF0YSA9IHB1enpsZUltYWdlc1tnYW1lU3RhdGUuY3VycmVudEltYWdlSW5kZXhdOwogICAgICAgICAgICAKICAgICAgICAgICAgc2hvd0FJTWVzc2FnZSh0bSgnbmV3SW1hZ2VNc2cnLCBnYW1lU3RhdGUuY3VycmVudEltYWdlRGF0YS5uYW1lKSwgMjAwMCk7CiAgICAgICAgICAgIGdlbmVyYXRlTmV3UHV6emxlKCk7CiAgICAgICAgfQoKICAgICAgICBmdW5jdGlvbiBhaVNvbHZlUHV6emxlKCkgewogICAgICAgICAgICBpZihnYW1lU3RhdGUuaXNTb2x2aW5nKSByZXR1cm47CiAgICAgICAgICAgIAogICAgICAgICAgICBnYW1lU3RhdGUuaXNTb2x2aW5nID0gdHJ1ZTsKICAgICAgICAgICAgc2hvd0FJTWVzc2FnZSh0KCdzb2x2aW5nJyksIDEwMDApOwogICAgICAgICAgICAKICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7CiAgICAgICAgICAgICAgICBjb25zdCB0b3RhbFBpZWNlcyA9IGdhbWVTdGF0ZS5ncmlkU2l6ZSAqIGdhbWVTdGF0ZS5ncmlkU2l6ZTsKICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0b3RhbFBpZWNlczsgaSsrKSB7CiAgICAgICAgICAgICAgICAgICAgZ2FtZVN0YXRlLmJvYXJkW2ldID0gaTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgY29uc3QgcGllY2VzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnB1enpsZS1waWVjZScpOwogICAgICAgICAgICAgICAgcGllY2VzLmZvckVhY2goKHBpZWNlLCBpbmRleCkgPT4gewogICAgICAgICAgICAgICAgICAgIHVwZGF0ZVBpZWNlSW1hZ2UocGllY2UsIGluZGV4KTsKICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICBnYW1lU3RhdGUubW92ZXMgKz0gMTA7IC8vIFDDqW5hbGl0w6kgcG91ciBsJ2FpZGUgSUEKICAgICAgICAgICAgICAgIGdhbWVTdGF0ZS5pc1NvbHZpbmcgPSBmYWxzZTsKICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgc2hvd0FJTWVzc2FnZSh0bSgnYWlTb2x2ZWQnKSwgMjAwMCk7CiAgICAgICAgICAgICAgICBzb2x2ZVB1enpsZSgpOwogICAgICAgICAgICB9LCAyMDAwKTsKICAgICAgICB9CgogICAgICAgIGZ1bmN0aW9uIGNoYW5nZUdyaWRTaXplKCkgewogICAgICAgICAgICBjb25zdCBzaXplcyA9IFs0LCA1LCA2XTsKICAgICAgICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gc2l6ZXMuaW5kZXhPZihnYW1lU3RhdGUuZ3JpZFNpemUpOwogICAgICAgICAgICBjb25zdCBuZXh0SW5kZXggPSAoY3VycmVudEluZGV4ICsgMSkgJSBzaXplcy5sZW5ndGg7CiAgICAgICAgICAgIGdhbWVTdGF0ZS5ncmlkU2l6ZSA9IHNpemVzW25leHRJbmRleF07CiAgICAgICAgICAgIAogICAgICAgICAgICBjb25zdCB0b3RhbFBpZWNlcyA9IGdhbWVTdGF0ZS5ncmlkU2l6ZSAqIGdhbWVTdGF0ZS5ncmlkU2l6ZTsKICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2dyaWRTaXplQnRuJykuaW5uZXJIVE1MID0gCiAgICAgICAgICAgICAgICBg8J+OryAke3QoJ2xldmVsJyl9OiAke2dhbWVTdGF0ZS5ncmlkU2l6ZX14JHtnYW1lU3RhdGUuZ3JpZFNpemV9ICgke3RvdGFsUGllY2VzfSlgOwogICAgICAgICAgICAKICAgICAgICAgICAgc2hvd0FJTWVzc2FnZSh0bSgnZ3JpZENoYW5nZWQnLCBnYW1lU3RhdGUuZ3JpZFNpemUpLCAyMDAwKTsKICAgICAgICAgICAgZ2VuZXJhdGVOZXdQdXp6bGUoKTsKICAgICAgICB9CgogICAgICAgIGZ1bmN0aW9uIHRvZ2dsZUF1dG9Tb2x2ZSgpIHsKICAgICAgICAgICAgZ2FtZVN0YXRlLmF1dG9Tb2x2ZSA9ICFnYW1lU3RhdGUuYXV0b1NvbHZlOwogICAgICAgICAgICBjb25zdCBidG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYXV0b1NvbHZlQnRuJyk7CiAgICAgICAgICAgIAogICAgICAgICAgICBpZihnYW1lU3RhdGUuYXV0b1NvbHZlKSB7CiAgICAgICAgICAgICAgICBidG4uY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7CiAgICAgICAgICAgICAgICBzaG93QUlNZXNzYWdlKHRtKCdhdXRvU29sdmVPbicpLCAyMDAwKTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIGJ0bi5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTsKICAgICAgICAgICAgICAgIHNob3dBSU1lc3NhZ2UodG0oJ2F1dG9Tb2x2ZU9mZicpLCAyMDAwKTsKICAgICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgZnVuY3Rpb24gY2hhbmdlRGlmZmljdWx0eSgpIHsKICAgICAgICAgICAgY29uc3QgZGlmZmljdWx0aWVzID0gWydlYXN5JywgJ25vcm1hbCcsICdoYXJkJywgJ2V4cGVydCddOwogICAgICAgICAgICBjb25zdCBjdXJyZW50SW5kZXggPSBkaWZmaWN1bHRpZXMuaW5kZXhPZihnYW1lU3RhdGUuZGlmZmljdWx0eSk7CiAgICAgICAgICAgIGNvbnN0IG5leHRJbmRleCA9IChjdXJyZW50SW5kZXggKyAxKSAlIGRpZmZpY3VsdGllcy5sZW5ndGg7CiAgICAgICAgICAgIGdhbWVTdGF0ZS5kaWZmaWN1bHR5ID0gZGlmZmljdWx0aWVzW25leHRJbmRleF07CiAgICAgICAgICAgIAogICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGlmZmljdWx0eUJ0bicpLmlubmVySFRNTCA9IAogICAgICAgICAgICAgICAgYOKame+4jyAke3QoJ2RpZmZpY3VsdHknKX06ICR7Z2FtZVN0YXRlLmRpZmZpY3VsdHl9YDsKICAgICAgICB9CgogICAgICAgIGZ1bmN0aW9uIHNhdmVHYW1lKCkgewogICAgICAgICAgICBjb25zdCBzYXZlRGF0YSA9IHsKICAgICAgICAgICAgICAgIGJvYXJkOiBnYW1lU3RhdGUuYm9hcmQsCiAgICAgICAgICAgICAgICBtb3ZlczogZ2FtZVN0YXRlLm1vdmVzLAogICAgICAgICAgICAgICAgc2NvcmU6IGdhbWVTdGF0ZS5zY29yZSwKICAgICAgICAgICAgICAgIGdyaWRTaXplOiBnYW1lU3RhdGUuZ3JpZFNpemUsCiAgICAgICAgICAgICAgICBkaWZmaWN1bHR5OiBnYW1lU3RhdGUuZGlmZmljdWx0eSwKICAgICAgICAgICAgICAgIGN1cnJlbnRJbWFnZUluZGV4OiBnYW1lU3RhdGUuY3VycmVudEltYWdlSW5kZXgsCiAgICAgICAgICAgICAgICBzdGF0aXN0aWNzOiBnYW1lU3RhdGUuc3RhdGlzdGljcwogICAgICAgICAgICB9OwogICAgICAgICAgICAKICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ25ldXJhbFB1enpsZVNhdmUnLCBKU09OLnN0cmluZ2lmeShzYXZlRGF0YSkpOwogICAgICAgICAgICBzaG93QUlNZXNzYWdlKHRtKCdnYW1lU2F2ZWQnKSwgMjAwMCk7CiAgICAgICAgfQoKICAgICAgICBmdW5jdGlvbiBsb2FkR2FtZSgpIHsKICAgICAgICAgICAgY29uc3Qgc2F2ZURhdGEgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnbmV1cmFsUHV6emxlU2F2ZScpOwogICAgICAgICAgICBpZihzYXZlRGF0YSkgewogICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2Uoc2F2ZURhdGEpOwogICAgICAgICAgICAgICAgZ2FtZVN0YXRlLmJvYXJkID0gZGF0YS5ib2FyZDsKICAgICAgICAgICAgICAgIGdhbWVTdGF0ZS5tb3ZlcyA9IGRhdGEubW92ZXM7CiAgICAgICAgICAgICAgICBnYW1lU3RhdGUuc2NvcmUgPSBkYXRhLnNjb3JlOwogICAgICAgICAgICAgICAgZ2FtZVN0YXRlLmdyaWRTaXplID0gZGF0YS5ncmlkU2l6ZTsKICAgICAgICAgICAgICAgIGdhbWVTdGF0ZS5kaWZmaWN1bHR5ID0gZGF0YS5kaWZmaWN1bHR5OwogICAgICAgICAgICAgICAgZ2FtZVN0YXRlLmN1cnJlbnRJbWFnZUluZGV4ID0gZGF0YS5jdXJyZW50SW1hZ2VJbmRleDsKICAgICAgICAgICAgICAgIGdhbWVTdGF0ZS5zdGF0aXN0aWNzID0gZGF0YS5zdGF0aXN0aWNzOwogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICBnYW1lU3RhdGUuY3VycmVudEltYWdlRGF0YSA9IHB1enpsZUltYWdlc1tnYW1lU3RhdGUuY3VycmVudEltYWdlSW5kZXhdOwogICAgICAgICAgICAgICAgY3JlYXRlUHV6emxlQm9hcmQoKTsKICAgICAgICAgICAgICAgIHVwZGF0ZVVJKCk7CiAgICAgICAgICAgICAgICB1cGRhdGVQcm9ncmVzcygpOwogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICBzaG93QUlNZXNzYWdlKHRtKCdnYW1lTG9hZGVkJyksIDIwMDApOwogICAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICBmdW5jdGlvbiBzaG93T3B0aW1hbFBhdGgoKSB7CiAgICAgICAgICAgIHNob3dBSU1lc3NhZ2UodCgnYWlUaGlua2luZycpLCAyMDAwKTsKICAgICAgICAgICAgCiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gewogICAgICAgICAgICAgICAgY29uc3QgYW5hbHlzaXNUZXh0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FuYWx5c2lzVGV4dCcpOwogICAgICAgICAgICAgICAgYW5hbHlzaXNUZXh0LmlubmVySFRNTCA9IGAKICAgICAgICAgICAgICAgICAgICDwn46vIDxzdHJvbmc+JHt0KCdvcHRpbWFsUGF0aCcpfTwvc3Ryb25nPjxicj48YnI+CiAgICAgICAgICAgICAgICAgICAgJHt0KCdyZWNvbW1lbmRlZE1vdmVzJyl9OiAke01hdGgubWF4KDUsIDIwIC0gZ2FtZVN0YXRlLm1vdmVzKX08YnI+CiAgICAgICAgICAgICAgICAgICAgJHt0KCdjdXJyZW50RWZmaWNpZW5jeScpfTogJHtNYXRoLm1heCgyMCwgMTAwIC0gZ2FtZVN0YXRlLm1vdmVzICogMil9JTxicj48YnI+CiAgICAgICAgICAgICAgICAgICAgPHN0cm9uZz4ke3QoJ3N0cmF0ZWd5Jyl9Ojwvc3Ryb25nPiBDb21tZW5jZXIgcGFyIGxlcyBjb2luczxicj4KICAgICAgICAgICAgICAgICAgICA8c3Ryb25nPiR7dCgnYWR2aWNlJyl9Ojwvc3Ryb25nPiBPYnNlcnZleiBsZXMgbW90aWZzIGRlIGNvdWxldXIKICAgICAgICAgICAgICAgIGA7CiAgICAgICAgICAgIH0sIDIwMDApOwogICAgICAgIH0KCiAgICAgICAgZnVuY3Rpb24gYW5hbHl6ZVBvc2l0aW9uKCkgewogICAgICAgICAgICBzaG93QUlNZXNzYWdlKHQoJ2FpVGhpbmtpbmcnKSwgMjAwMCk7CiAgICAgICAgICAgIAogICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsKICAgICAgICAgICAgICAgIGNvbnN0IHRvdGFsUGllY2VzID0gZ2FtZVN0YXRlLmdyaWRTaXplICogZ2FtZVN0YXRlLmdyaWRTaXplOwogICAgICAgICAgICAgICAgbGV0IGNvcnJlY3RQaWVjZXMgPSAwOwogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdG90YWxQaWVjZXM7IGkrKykgewogICAgICAgICAgICAgICAgICAgIGlmKGdhbWVTdGF0ZS5ib2FyZFtpXSA9PT0gaSkgewogICAgICAgICAgICAgICAgICAgICAgICBjb3JyZWN0UGllY2VzKys7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICBjb25zdCBwcm9ncmVzcyA9IE1hdGgucm91bmQoKGNvcnJlY3RQaWVjZXMgLyB0b3RhbFBpZWNlcykgKiAxMDApOwogICAgICAgICAgICAgICAgY29uc3QgY29tcGxleGl0eSA9IGdhbWVTdGF0ZS5tb3ZlcyA8IDEwID8gJ0ZhaWJsZScgOiBnYW1lU3RhdGUubW92ZXMgPCAzMCA/ICdNb3llbm5lJyA6ICfDiWxldsOpZSc7CiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgIGNvbnN0IGFuYWx5c2lzVGV4dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhbmFseXNpc1RleHQnKTsKICAgICAgICAgICAgICAgIGFuYWx5c2lzVGV4dC5pbm5lckhUTUwgPSBgCiAgICAgICAgICAgICAgICAgICAg8J+UjSA8c3Ryb25nPkFuYWx5c2UgZGUgUG9zaXRpb248L3N0cm9uZz48YnI+PGJyPgogICAgICAgICAgICAgICAgICAgIFBpw6hjZXMgY29ycmVjdGVzOiAke2NvcnJlY3RQaWVjZXN9LyR7dG90YWxQaWVjZXN9PGJyPgogICAgICAgICAgICAgICAgICAgIFByb2dyZXNzaW9uOiAke3Byb2dyZXNzfSU8YnI+CiAgICAgICAgICAgICAgICAgICAgQ29tcGxleGl0w6k6ICR7Y29tcGxleGl0eX08YnI+CiAgICAgICAgICAgICAgICAgICAgVGVtcHMgZXN0aW3DqTogJHtNYXRoLm1heCgxLCBNYXRoLnJvdW5kKCh0b3RhbFBpZWNlcyAtIGNvcnJlY3RQaWVjZXMpIC8gMikpfSBtaW48YnI+CiAgICAgICAgICAgICAgICAgICAgU2NvcmUgcG90ZW50aWVsOiAke01hdGgubWF4KDEwMCwgMTAwMCAtIGdhbWVTdGF0ZS5tb3ZlcyAqIDE1KX0KICAgICAgICAgICAgICAgIGA7CiAgICAgICAgICAgIH0sIDIwMDApOwogICAgICAgIH0KCiAgICAgICAgZnVuY3Rpb24gc2hvd1N0YXRpc3RpY3MoKSB7CiAgICAgICAgICAgIGNvbnN0IGFuYWx5c2lzVGV4dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhbmFseXNpc1RleHQnKTsKICAgICAgICAgICAgY29uc3Qgd2luUmF0ZSA9IGdhbWVTdGF0ZS5zdGF0aXN0aWNzLmdhbWVzUGxheWVkID4gMCA/IAogICAgICAgICAgICAgICAgTWF0aC5yb3VuZCgoZ2FtZVN0YXRlLnN0YXRpc3RpY3MuZ2FtZXNXb24gLyBnYW1lU3RhdGUuc3RhdGlzdGljcy5nYW1lc1BsYXllZCkgKiAxMDApIDogMDsKICAgICAgICAgICAgY29uc3QgYXZnTW92ZXMgPSBnYW1lU3RhdGUuc3RhdGlzdGljcy5nYW1lc1BsYXllZCA+IDAgPyAKICAgICAgICAgICAgICAgIE1hdGgucm91bmQoZ2FtZVN0YXRlLnN0YXRpc3RpY3MudG90YWxNb3ZlcyAvIGdhbWVTdGF0ZS5zdGF0aXN0aWNzLmdhbWVzUGxheWVkKSA6IDA7CiAgICAgICAgICAgIAogICAgICAgICAgICBhbmFseXNpc1RleHQuaW5uZXJIVE1MID0gYAogICAgICAgICAgICAgICAg8J+TiiA8c3Ryb25nPlN0YXRpc3RpcXVlcyBHbG9iYWxlczwvc3Ryb25nPjxicj48YnI+CiAgICAgICAgICAgICAgICBQYXJ0aWVzIGpvdcOpZXM6ICR7Z2FtZVN0YXRlLnN0YXRpc3RpY3MuZ2FtZXNQbGF5ZWR9PGJyPgogICAgICAgICAgICAgICAgUGFydGllcyBnYWduw6llczogJHtnYW1lU3RhdGUuc3RhdGlzdGljcy5nYW1lc1dvbn08YnI+CiAgICAgICAgICAgICAgICBUYXV4IGRlIHLDqXVzc2l0ZTogJHt3aW5SYXRlfSU8YnI+CiAgICAgICAgICAgICAgICBNZWlsbGV1ciBzY29yZTogJHtnYW1lU3RhdGUuc3RhdGlzdGljcy5iZXN0U2NvcmV9PGJyPgogICAgICAgICAgICAgICAgTW91dmVtZW50cyBtb3llbnM6ICR7YXZnTW92ZXN9PGJyPjxicj4KICAgICAgICAgICAgICAgIE5pdmVhdSBJQSBhY3R1ZWw6ICR7Z2FtZVN0YXRlLmFpTGV2ZWx9PGJyPgogICAgICAgICAgICAgICAgUmFuZzogJHtnYW1lU3RhdGUuYWlMZXZlbCA8IDMgPyAnRMOpYnV0YW50JyA6IGdhbWVTdGF0ZS5haUxldmVsIDwgNiA/ICdJbnRlcm3DqWRpYWlyZScgOiAnRXhwZXJ0J30KICAgICAgICAgICAgYDsKICAgICAgICB9CgogICAgICAgIC8vIEluaXRpYWxpc2F0aW9uCiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGZ1bmN0aW9uKCkgewogICAgICAgICAgICBjb25zdCBzYXZlZExhbmd1YWdlID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ25ldXJhbFB1enpsZUxhbmd1YWdlJyk7CiAgICAgICAgICAgIGlmKHNhdmVkTGFuZ3VhZ2UgJiYgdHJhbnNsYXRpb25zW3NhdmVkTGFuZ3VhZ2VdKSB7CiAgICAgICAgICAgICAgICBnYW1lU3RhdGUuY3VycmVudExhbmd1YWdlID0gc2F2ZWRMYW5ndWFnZTsKICAgICAgICAgICAgICAgIGNvbnN0IGZsYWdzID0gewogICAgICAgICAgICAgICAgICAgIGZyOiAn8J+Hq/Cfh7cgRnJhbsOnYWlzJywKICAgICAgICAgICAgICAgICAgICBlbjogJ/Cfh7rwn4e4IEVuZ2xpc2gnLAogICAgICAgICAgICAgICAgICAgIGFyOiAn8J+HuPCfh6Yg2KfZhNi52LHYqNmK2KknLAogICAgICAgICAgICAgICAgICAgIGVzOiAn8J+HqvCfh7ggRXNwYcOxb2wnLAogICAgICAgICAgICAgICAgICAgIGRlOiAn8J+HqfCfh6ogRGV1dHNjaCcsCiAgICAgICAgICAgICAgICAgICAgemg6ICfwn4eo8J+HsyDkuK3mlocnCiAgICAgICAgICAgICAgICB9OwogICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xhbmd1YWdlQnRuJykudGV4dENvbnRlbnQgPSBg8J+MkCAke2ZsYWdzW3NhdmVkTGFuZ3VhZ2VdfWA7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgCiAgICAgICAgICAgIGNyZWF0ZU5ldXJhbFBhcnRpY2xlcygpOwogICAgICAgICAgICBpbml0R2FtZSgpOwogICAgICAgICAgICB1cGRhdGVMYW5ndWFnZSgpOwogICAgICAgICAgICAKICAgICAgICAgICAgLy8gQ2hhcmdlciB1bmUgc2F1dmVnYXJkZSBzaSBlbGxlIGV4aXN0ZQogICAgICAgICAgICBpZihsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnbmV1cmFsUHV6emxlU2F2ZScpKSB7CiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IGxvYWRHYW1lKCksIDEwMDApOwogICAgICAgICAgICB9CiAgICAgICAgfSk7CiAgICA8L3NjcmlwdD4KPHNjcmlwdD4oZnVuY3Rpb24oKXtmdW5jdGlvbiBjKCl7dmFyIGI9YS5jb250ZW50RG9jdW1lbnR8fGEuY29udGVudFdpbmRvdy5kb2N1bWVudDtpZihiKXt2YXIgZD1iLmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO2QuaW5uZXJIVE1MPSJ3aW5kb3cuX19DRiRjdiRwYXJhbXM9e3I6Jzk4NDIwNDAxNzM4YjExYTUnLHQ6J01UYzFPRGN4TkRFeE55NHdNREF3TURBPSd9O3ZhciBhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO2Eubm9uY2U9Jyc7YS5zcmM9Jy9jZG4tY2dpL2NoYWxsZW5nZS1wbGF0Zm9ybS9zY3JpcHRzL2pzZC9tYWluLmpzJztkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLmFwcGVuZENoaWxkKGEpOyI7Yi5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLmFwcGVuZENoaWxkKGQpfX1pZihkb2N1bWVudC5ib2R5KXt2YXIgYT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTthLmhlaWdodD0xO2Eud2lkdGg9MTthLnN0eWxlLnBvc2l0aW9uPSdhYnNvbHV0ZSc7YS5zdHlsZS50b3A9MDthLnN0eWxlLmxlZnQ9MDthLnN0eWxlLmJvcmRlcj0nbm9uZSc7YS5zdHlsZS52aXNpYmlsaXR5PSdoaWRkZW4nO2RvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYSk7aWYoJ2xvYWRpbmcnIT09ZG9jdW1lbnQucmVhZHlTdGF0ZSljKCk7ZWxzZSBpZih3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcilkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJyxjKTtlbHNle3ZhciBlPWRvY3VtZW50Lm9ucmVhZHlzdGF0ZWNoYW5nZXx8ZnVuY3Rpb24oKXt9O2RvY3VtZW50Lm9ucmVhZHlzdGF0ZWNoYW5nZT1mdW5jdGlvbihiKXtlKGIpOydsb2FkaW5nJyE9PWRvY3VtZW50LnJlYWR5U3RhdGUmJihkb2N1bWVudC5vbnJlYWR5c3RhdGVjaGFuZ2U9ZSxjKCkpfX19fSkoKTs8L3NjcmlwdD48L2JvZHk+CjwvaHRtbD4K" style="width:100%;height:100%;border:none;"></iframe>
</div>

<style>
#gameOverlay3 {
  position: fixed;
  inset: 0;
  background: #000;
  z-index: 9999;
  display: none;
}
#gameOverlay3 iframe {
  width: 100%;
  height: 100%;
}
</style>

<script>
function launchGame3() {
  document.getElementById("gameOverlay3").style.display = "block";
}

function closeGame3() {
  const overlay = document.getElementById("gameOverlay3");
  const iframe = document.getElementById("iframeGame3");
  overlay.style.display = "none";
  // Reset iframe pour relancer le jeu au prochain lancement
  iframe.src = iframe.src;
}

// Intercepter Échap globalement
document.addEventListener("keydown", function(e) {
  if (e.key === "Escape") {
    e.preventDefault();
    e.stopPropagation();
    closeGame3();
  }
}, true);
</script>


<div id="game4Overlay" style="display:none;position:fixed;inset:0;background:#000;z-index:9999;">
  <button onclick="closeGame4()" style="position:absolute;top:10px;right:10px;z-index:10000;font-size:24px;background:red;color:white;border:none;border-radius:50%;width:40px;height:40px;cursor:pointer;">✖</button>
  <iframe id="iframeGame4" srcdoc="&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;fr&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;♛ Brainova Quantum Chess - IA Quantique&lt;/title&gt;
    &lt;script src=&quot;https://cdn.tailwindcss.com&quot;&gt;&lt;/script&gt;
    &lt;style&gt;
        body {
            box-sizing: border-box;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: &#x27;Segoe UI&#x27;, Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 30%, #16213e 70%, #0f3460 100%);
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }

        /* Particules quantiques d&#x27;arrière-plan */
        .quantum-particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .quantum-particle {
            position: absolute;
            width: 3px;
            height: 3px;
            background: #00d4ff;
            border-radius: 50%;
            animation: quantumFloat 12s infinite linear;
            box-shadow: 0 0 8px #00d4ff, 0 0 16px #00d4ff;
        }

        @keyframes quantumFloat {
            0% {
                transform: translateY(100vh) translateX(0) rotate(0deg) scale(0);
                opacity: 0;
            }
            10% {
                opacity: 1;
                transform: translateY(90vh) translateX(20px) rotate(45deg) scale(1);
            }
            50% {
                transform: translateY(50vh) translateX(-30px) rotate(180deg) scale(1.5);
            }
            90% {
                opacity: 1;
                transform: translateY(10vh) translateX(50px) rotate(315deg) scale(1);
            }
            100% {
                transform: translateY(-10vh) translateX(100px) rotate(360deg) scale(0);
                opacity: 0;
            }
        }

        /* Lignes d&#x27;énergie futuristes */
        .energy-lines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
            overflow: hidden;
        }

        .energy-line {
            position: absolute;
            height: 2px;
            background: linear-gradient(90deg, transparent, #00d4ff, transparent);
            animation: energyFlow 8s infinite linear;
            box-shadow: 0 0 10px #00d4ff;
        }

        @keyframes energyFlow {
            0% {
                transform: translateX(-100%);
                opacity: 0;
            }
            10% {
                opacity: 1;
            }
            90% {
                opacity: 1;
            }
            100% {
                transform: translateX(100vw);
                opacity: 0;
            }
        }

        /* Cercles d&#x27;énergie pulsants */
        .energy-circles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .energy-circle {
            position: absolute;
            border: 2px solid rgba(0, 212, 255, 0.3);
            border-radius: 50%;
            animation: energyPulse 6s infinite ease-in-out;
        }

        @keyframes energyPulse {
            0% {
                transform: scale(0) rotate(0deg);
                opacity: 1;
                border-color: rgba(0, 212, 255, 0.8);
            }
            50% {
                transform: scale(1) rotate(180deg);
                opacity: 0.5;
                border-color: rgba(0, 212, 255, 0.4);
            }
            100% {
                transform: scale(2) rotate(360deg);
                opacity: 0;
                border-color: rgba(0, 212, 255, 0.1);
            }
        }

        /* Vagues d&#x27;énergie */
        .energy-waves {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
            overflow: hidden;
        }

        .energy-wave {
            position: absolute;
            bottom: 0;
            left: -100%;
            width: 200%;
            height: 200px;
            background: linear-gradient(45deg, 
                transparent 0%, 
                rgba(0, 212, 255, 0.1) 25%, 
                rgba(0, 212, 255, 0.2) 50%, 
                rgba(0, 212, 255, 0.1) 75%, 
                transparent 100%);
            animation: waveFlow 15s infinite linear;
            transform-origin: center bottom;
        }

        @keyframes waveFlow {
            0% {
                transform: translateX(-50%) rotate(0deg);
            }
            100% {
                transform: translateX(50%) rotate(360deg);
            }
        }

        /* Hexagones futuristes */
        .hex-pattern {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
            opacity: 0.1;
        }

        .hex-grid {
            position: absolute;
            width: 100%;
            height: 100%;
            background-image: 
                radial-gradient(circle at 25% 25%, rgba(0, 212, 255, 0.3) 2px, transparent 2px),
                radial-gradient(circle at 75% 75%, rgba(0, 212, 255, 0.2) 1px, transparent 1px);
            background-size: 60px 60px;
            animation: hexMove 20s infinite linear;
        }

        @keyframes hexMove {
            0% { transform: translate(0, 0) rotate(0deg); }
            25% { transform: translate(30px, -30px) rotate(90deg); }
            50% { transform: translate(0, -60px) rotate(180deg); }
            75% { transform: translate(-30px, -30px) rotate(270deg); }
            100% { transform: translate(0, 0) rotate(360deg); }
        }

        /* Rayons laser */
        .laser-beams {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .laser-beam {
            position: absolute;
            width: 2px;
            height: 100vh;
            background: linear-gradient(to bottom, 
                transparent 0%, 
                rgba(0, 212, 255, 0.8) 20%, 
                rgba(0, 212, 255, 0.4) 50%, 
                rgba(0, 212, 255, 0.8) 80%, 
                transparent 100%);
            animation: laserScan 12s infinite linear;
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.6);
        }

        @keyframes laserScan {
            0% {
                transform: translateX(-10px);
                opacity: 0;
            }
            10% {
                opacity: 1;
            }
            90% {
                opacity: 1;
            }
            100% {
                transform: translateX(100vw);
                opacity: 0;
            }
        }

        /* Orbes d&#x27;énergie flottants */
        .energy-orbs {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .energy-orb {
            position: absolute;
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, rgba(0, 212, 255, 0.8) 0%, rgba(0, 212, 255, 0.2) 70%, transparent 100%);
            border-radius: 50%;
            animation: orbFloat 18s infinite ease-in-out;
            box-shadow: 0 0 30px rgba(0, 212, 255, 0.6);
        }

        @keyframes orbFloat {
            0% {
                transform: translate(0, 100vh) scale(0.5);
                opacity: 0;
            }
            10% {
                opacity: 1;
            }
            25% {
                transform: translate(200px, 75vh) scale(1);
            }
            50% {
                transform: translate(-100px, 50vh) scale(1.2);
            }
            75% {
                transform: translate(150px, 25vh) scale(0.8);
            }
            90% {
                opacity: 1;
            }
            100% {
                transform: translate(-50px, -10vh) scale(0.3);
                opacity: 0;
            }
        }

        /* Grille quantique de fond */
        .quantum-grid {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(0, 212, 255, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 212, 255, 0.1) 1px, transparent 1px);
            background-size: 60px 60px;
            animation: quantumGridMove 25s linear infinite;
            z-index: 1;
        }

        @keyframes quantumGridMove {
            0% { transform: translate(0, 0) rotate(0deg); }
            50% { transform: translate(30px, 30px) rotate(1deg); }
            100% { transform: translate(60px, 60px) rotate(0deg); }
        }

        /* Container principal */
        .quantum-chess-container {
            position: relative;
            z-index: 10;
            display: grid;
            grid-template-columns: 200px 1fr 200px;
            gap: 10px;
            min-height: 100vh;
            padding: 10px;
            max-width: 1400px;
            margin: 0 auto;
            padding-top: 20px;
        }

        .left-panel, .right-panel {
            background: linear-gradient(145deg, 
                rgba(26, 26, 46, 0.95) 0%,
                rgba(22, 33, 62, 0.95) 50%,
                rgba(15, 15, 35, 0.95) 100%);
            backdrop-filter: blur(25px);
            border-radius: 15px;
            padding: 10px;
            height: fit-content;
            box-shadow: 
                0 15px 30px rgba(0, 0, 0, 0.6),
                0 0 60px rgba(0, 212, 255, 0.15),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(0, 212, 255, 0.4);
            animation: quantumPanelGlow 4s ease-in-out infinite alternate;
        }

        .game-panel {
            background: linear-gradient(145deg, 
                rgba(26, 26, 46, 0.95) 0%,
                rgba(22, 33, 62, 0.95) 50%,
                rgba(15, 15, 35, 0.95) 100%);
            backdrop-filter: blur(25px);
            border-radius: 18px;
            padding: 15px;
            width: 100%;
            height: fit-content;
            box-shadow: 
                0 20px 40px rgba(0, 0, 0, 0.6),
                0 0 80px rgba(0, 212, 255, 0.15),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(0, 212, 255, 0.4);
            animation: quantumPanelGlow 4s ease-in-out infinite alternate;
        }

        @keyframes quantumPanelGlow {
            from { 
                box-shadow: 
                    0 25px 50px rgba(0, 0, 0, 0.6),
                    0 0 100px rgba(0, 212, 255, 0.15),
                    inset 0 1px 0 rgba(255, 255, 255, 0.1);
            }
            to { 
                box-shadow: 
                    0 30px 60px rgba(0, 0, 0, 0.6),
                    0 0 120px rgba(0, 212, 255, 0.25),
                    inset 0 1px 0 rgba(255, 255, 255, 0.2);
            }
        }

        /* En-tête du jeu */
        .quantum-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            padding-bottom: 6px;
            border-bottom: 2px solid rgba(0, 212, 255, 0.4);
        }

        .quantum-title {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .quantum-title h1 {
            color: #00d4ff;
            margin: 0;
            font-size: 16px;
            font-weight: 700;
            text-shadow: 0 0 25px rgba(0, 212, 255, 0.8);
            animation: quantumTitlePulse 3s infinite alternate;
        }

        @keyframes quantumTitlePulse {
            from { 
                text-shadow: 0 0 25px rgba(0, 212, 255, 0.8);
                transform: scale(1);
            }
            to { 
                text-shadow: 0 0 35px rgba(0, 212, 255, 1);
                transform: scale(1.02);
            }
        }

        .quantum-icon {
            font-size: 22px;
            animation: quantumIconSpin 6s linear infinite;
            filter: drop-shadow(0 0 15px #00d4ff);
            color: #e0e0e0;
            text-shadow: 
                0 0 10px rgba(224, 224, 224, 0.8),
                0 0 20px rgba(224, 224, 224, 0.6),
                0 0 30px rgba(224, 224, 224, 0.4);
        }

        @keyframes quantumIconSpin {
            0% { transform: rotate(0deg) scale(1); }
            25% { transform: rotate(90deg) scale(1.1); }
            50% { transform: rotate(180deg) scale(1); }
            75% { transform: rotate(270deg) scale(1.1); }
            100% { transform: rotate(360deg) scale(1); }
        }

        .quantum-badge {
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7aa, #6c5ce7);
            background-size: 300% 300%;
            color: white;
            padding: 4px 8px;
            border-radius: 15px;
            font-size: 9px;
            font-weight: bold;
            animation: quantumBadgeShine 4s ease-in-out infinite;
            box-shadow: 0 0 20px rgba(78, 205, 196, 0.6);
        }

        @keyframes quantumBadgeShine {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .close-btn {
            background: rgba(255, 0, 0, 0.2);
            border: 2px solid rgba(255, 0, 0, 0.5);
            color: #ff6b6b;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .close-btn:hover {
            background: rgba(255, 0, 0, 0.4);
            transform: scale(1.1) rotate(90deg);
            box-shadow: 0 0 25px rgba(255, 107, 107, 0.8);
        }

        /* Sélecteur de langue */
        .language-selector {
            background: linear-gradient(145deg, #74b9ff, #0984e3);
            color: white;
            border: 2px solid rgba(116, 185, 255, 0.4);
            border-radius: 12px;
            padding: 10px 16px;
            font-weight: bold;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
            box-shadow: 0 0 20px rgba(116, 185, 255, 0.4);
            backdrop-filter: blur(10px);
            min-width: 140px;
            max-height: 200px;
            overflow-y: auto;
        }

        .language-selector:hover {
            background: linear-gradient(145deg, #81c7ff, #2d96ff);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(116, 185, 255, 0.6);
            border-color: rgba(116, 185, 255, 0.6);
        }

        .language-selector:focus {
            outline: none;
            box-shadow: 0 0 30px rgba(116, 185, 255, 0.8);
            border-color: rgba(116, 185, 255, 0.8);
        }

        .language-selector option {
            background: #1a1a2e;
            color: white;
            padding: 8px 12px;
            border: none;
            font-size: 12px;
        }

        .language-selector option:hover {
            background: #74b9ff;
        }

        /* Contrôles de mode de jeu */
        .game-mode-controls {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-bottom: 8px;
            padding: 6px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 8px;
            border: 2px solid rgba(0, 212, 255, 0.3);
        }

        .mode-btn {
            padding: 8px 16px;
            background: linear-gradient(145deg, #4ecdc4, #45b7aa);
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 1px;
            min-width: 110px;
        }

        .mode-btn::before {
            content: &#x27;&#x27;;
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            transition: left 0.5s ease;
        }

        .mode-btn:hover::before {
            left: 100%;
        }

        .mode-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(78, 205, 196, 0.5);
            background: linear-gradient(145deg, #5fd4d4, #4ecdc4);
        }

        .mode-btn.active {
            background: linear-gradient(145deg, #6c5ce7, #5f3dc4);
            box-shadow: 0 0 25px rgba(108, 92, 231, 0.6);
        }

        .mode-btn.active:hover {
            background: linear-gradient(145deg, #7c6ce7, #6f4dc4);
        }

        /* Plateau d&#x27;échecs quantique */
        .quantum-chessboard-container {
            display: flex;
            justify-content: center;
            margin-bottom: 8px;
            position: relative;
            margin-top: 10px;
        }

        .quantum-chessboard {
            width: 520px;
            height: 520px;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            border: 4px solid rgba(0, 212, 255, 0.8);
            border-radius: 16px;
            box-shadow: 
                0 0 35px rgba(0, 212, 255, 0.6),
                0 0 70px rgba(0, 212, 255, 0.3),
                inset 0 0 25px rgba(0, 212, 255, 0.2);
            animation: quantumBoardGlow 5s ease-in-out infinite alternate;
            position: relative;
            overflow: hidden;
        }

        @keyframes quantumBoardGlow {
            from { 
                box-shadow: 
                    0 0 25px rgba(0, 212, 255, 0.4),
                    0 0 50px rgba(0, 212, 255, 0.2),
                    inset 0 0 15px rgba(0, 212, 255, 0.1);
            }
            to { 
                box-shadow: 
                    0 0 35px rgba(0, 212, 255, 0.6),
                    0 0 70px rgba(0, 212, 255, 0.3),
                    inset 0 0 25px rgba(0, 212, 255, 0.2);
            }
        }

        .chess-square {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid rgba(0, 212, 255, 0.3);
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.1);
        }

        .chess-square.light {
            background: linear-gradient(145deg, #D6D8DB, #ADB5BD);
            box-shadow: 
                inset 0 0 15px rgba(255, 255, 255, 0.4),
                inset 0 0 8px rgba(0, 212, 255, 0.15);
        }

        .chess-square.dark {
            background: linear-gradient(145deg, #2C3E50, #1A252F);
            box-shadow: 
                inset 0 0 15px rgba(0, 0, 0, 0.6),
                inset 0 0 8px rgba(0, 212, 255, 0.25);
        }

        .chess-square:hover {
            transform: scale(1.05);
            z-index: 10;
            box-shadow: 
                0 0 25px rgba(0, 212, 255, 0.8),
                inset 0 0 20px rgba(0, 212, 255, 0.2);
            border: 2px solid rgba(0, 212, 255, 0.6);
        }

        .chess-square.selected {
            background: linear-gradient(145deg, #FFD700, #FFA500) !important;
            box-shadow: 
                0 0 30px rgba(255, 215, 0, 1),
                inset 0 0 20px rgba(255, 215, 0, 0.3),
                0 0 50px rgba(255, 215, 0, 0.5);
            transform: scale(1.1);
            z-index: 20;
            border: 3px solid #FFD700;
            animation: selectedPulse 1.5s ease-in-out infinite alternate;
        }

        @keyframes selectedPulse {
            from { 
                box-shadow: 
                    0 0 30px rgba(255, 215, 0, 1),
                    inset 0 0 20px rgba(255, 215, 0, 0.3),
                    0 0 50px rgba(255, 215, 0, 0.5);
            }
            to { 
                box-shadow: 
                    0 0 40px rgba(255, 215, 0, 1),
                    inset 0 0 30px rgba(255, 215, 0, 0.4),
                    0 0 70px rgba(255, 215, 0, 0.7);
            }
        }

        .chess-square.possible-move {
            background: linear-gradient(145deg, #00FF7F, #32CD32) !important;
            box-shadow: 
                0 0 20px rgba(0, 255, 127, 0.8),
                inset 0 0 15px rgba(0, 255, 127, 0.2);
            border: 2px solid #00FF7F;
            animation: possibleMovePulse 2s ease-in-out infinite alternate;
        }

        @keyframes possibleMovePulse {
            from { 
                box-shadow: 
                    0 0 20px rgba(0, 255, 127, 0.8),
                    inset 0 0 15px rgba(0, 255, 127, 0.2);
            }
            to { 
                box-shadow: 
                    0 0 30px rgba(0, 255, 127, 1),
                    inset 0 0 25px rgba(0, 255, 127, 0.3);
            }
        }

        .chess-square.quantum-state {
            background: linear-gradient(145deg, #FF1493, #DC143C) !important;
            box-shadow: 
                0 0 25px rgba(255, 20, 147, 1),
                inset 0 0 20px rgba(255, 20, 147, 0.3);
            animation: quantumPulse 1s infinite alternate;
            border: 2px solid #FF1493;
        }

        @keyframes quantumPulse {
            from { transform: scale(1); }
            to { transform: scale(1.05); }
        }

        /* Pièces d&#x27;échecs */
        .chess-piece {
            font-size: 38px;
            text-shadow: 
                4px 4px 8px rgba(0, 0, 0, 0.9),
                2px 2px 4px rgba(0, 0, 0, 0.7),
                0 0 2px rgba(0, 0, 0, 0.5);
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            z-index: 5;
            font-weight: 900;
            filter: contrast(1.2) brightness(1.1);
        }

        .chess-piece:hover {
            transform: scale(1.3);
            filter: contrast(1.3) brightness(1.2) drop-shadow(0 0 20px currentColor);
            animation: pieceGlow 0.5s ease-in-out;
        }

        @keyframes pieceGlow {
            0% { transform: scale(1.3); }
            50% { transform: scale(1.35); }
            100% { transform: scale(1.3); }
        }

        .chess-piece.white {
            color: #FFD700;
            text-shadow: 
                4px 4px 8px rgba(0, 0, 0, 0.95),
                2px 2px 4px rgba(0, 0, 0, 0.8),
                0 0 15px rgba(255, 215, 0, 0.8),
                0 0 30px rgba(255, 215, 0, 0.4),
                0 0 2px rgba(0, 0, 0, 0.6);
            -webkit-text-stroke: 1px rgba(0, 0, 0, 0.3);
        }

        .chess-piece.white:hover {
            color: #FFF700;
            text-shadow: 
                4px 4px 8px rgba(0, 0, 0, 0.95),
                2px 2px 4px rgba(0, 0, 0, 0.8),
                0 0 20px rgba(255, 247, 0, 1),
                0 0 40px rgba(255, 247, 0, 0.6),
                0 0 2px rgba(0, 0, 0, 0.6);
        }

        .chess-piece.black {
            color: #FF4757;
            text-shadow: 
                4px 4px 8px rgba(0, 0, 0, 0.95),
                2px 2px 4px rgba(0, 0, 0, 0.8),
                0 0 15px rgba(255, 71, 87, 0.8),
                0 0 30px rgba(255, 71, 87, 0.4),
                0 0 2px rgba(0, 0, 0, 0.6);
            -webkit-text-stroke: 1px rgba(0, 0, 0, 0.3);
        }

        .chess-piece.black:hover {
            color: #FF3742;
            text-shadow: 
                4px 4px 8px rgba(0, 0, 0, 0.95),
                2px 2px 4px rgba(0, 0, 0, 0.8),
                0 0 20px rgba(255, 55, 66, 1),
                0 0 40px rgba(255, 55, 66, 0.6),
                0 0 2px rgba(0, 0, 0, 0.6);
        }

        /* Panneau de titre des sections */
        .panel-title {
            color: #00d4ff;
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 15px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            text-shadow: 0 0 15px rgba(0, 212, 255, 0.8);
            border-bottom: 2px solid rgba(0, 212, 255, 0.4);
            padding-bottom: 8px;
        }

        /* Contrôles quantiques */
        .quantum-controls {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px;
            margin-bottom: 15px;
        }

        .quantum-btn {
            padding: 10px 15px;
            background: linear-gradient(145deg, #4ecdc4, #45b7aa);
            color: white;
            border: none;
            border-radius: 10px;
            font-weight: bold;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .quantum-btn::before {
            content: &#x27;&#x27;;
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transition: left 0.5s ease;
        }

        .quantum-btn:hover::before {
            left: 100%;
        }

        .quantum-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(78, 205, 196, 0.4);
            background: linear-gradient(145deg, #5fd4d4, #4ecdc4);
        }

        .quantum-btn:active {
            transform: translateY(-1px);
        }

        .quantum-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        /* Boutons spécialisés */
        .ai-btn {
            background: linear-gradient(145deg, #6c5ce7, #5f3dc4);
        }

        .ai-btn:hover {
            background: linear-gradient(145deg, #7c6ce7, #6f4dc4);
        }

        .reset-btn {
            background: linear-gradient(145deg, #e74c3c, #c0392b);
        }

        .reset-btn:hover {
            background: linear-gradient(145deg, #f74c3c, #d0392b);
        }

        .quantum-special-btn {
            background: linear-gradient(145deg, #ff6b6b, #ee5a52);
        }

        .quantum-special-btn:hover {
            background: linear-gradient(145deg, #ff7b7b, #fe6a62);
        }

        /* Bouton statut du joueur */
        .player-status-btn {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: linear-gradient(145deg, #4ecdc4, #45b7aa);
            color: white;
            border: none;
            border-radius: 12px;
            font-weight: bold;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 3px 10px rgba(78, 205, 196, 0.4);
            border: 2px solid rgba(0, 212, 255, 0.3);
        }

        .player-status-btn::before {
            content: &#x27;&#x27;;
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transition: left 0.5s ease;
        }

        .player-status-btn:hover::before {
            left: 100%;
        }

        .player-status-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(78, 205, 196, 0.6);
            background: linear-gradient(145deg, #5fd4d4, #4ecdc4);
            border-color: rgba(0, 212, 255, 0.5);
        }

        .player-status-btn:active {
            transform: translateY(0px);
        }

        .player-status-btn.yellow-player {
            background: linear-gradient(145deg, #f1c40f, #f39c12);
            border-color: rgba(241, 196, 15, 0.5);
            color: #2c3e50;
        }

        .player-status-btn.yellow-player:hover {
            background: linear-gradient(145deg, #f4d03f, #f5b041);
            border-color: rgba(241, 196, 15, 0.7);
            box-shadow: 0 8px 25px rgba(241, 196, 15, 0.6);
        }

        .player-status-btn.red-player {
            background: linear-gradient(145deg, #e74c3c, #c0392b);
            border-color: rgba(231, 76, 60, 0.5);
            color: white;
        }

        .player-status-btn.red-player:hover {
            background: linear-gradient(145deg, #ec7063, #cb4335);
            border-color: rgba(231, 76, 60, 0.7);
            box-shadow: 0 8px 25px rgba(231, 76, 60, 0.6);
        }

        .player-status-btn #currentPlayer {
            font-size: 16px;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
        }

        /* IA Quantique Status */
        .quantum-ai-status {
            margin-bottom: 15px;
            text-align: center;
            min-height: 25px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .ai-thinking {
            display: inline-flex;
            align-items: center;
            gap: 12px;
            color: #4ecdc4;
            font-size: 14px;
            opacity: 0;
            transition: opacity 0.5s ease;
            background: rgba(78, 205, 196, 0.15);
            padding: 10px 20px;
            border-radius: 25px;
            border: 1px solid rgba(78, 205, 196, 0.4);
        }

        .ai-thinking.active {
            opacity: 1;
        }

        .quantum-pulse {
            width: 12px;
            height: 12px;
            background: #4ecdc4;
            border-radius: 50%;
            animation: quantumAIPulse 2s infinite;
            box-shadow: 0 0 15px #4ecdc4;
        }

        @keyframes quantumAIPulse {
            0%, 100% { 
                transform: scale(1); 
                opacity: 1; 
            }
            50% { 
                transform: scale(1.8); 
                opacity: 0.3; 
            }
        }

        /* Statistiques du jeu */
        .game-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 15px;
        }

        .stat-item {
            background: rgba(0, 212, 255, 0.1);
            padding: 8px;
            border-radius: 12px;
            text-align: center;
            border: 2px solid rgba(0, 212, 255, 0.3);
            position: relative;
            overflow: hidden;
        }

        .stat-item::before {
            content: &#x27;&#x27;;
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 212, 255, 0.2), transparent);
            animation: statQuantumScan 4s linear infinite;
        }

        @keyframes statQuantumScan {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .stat-label {
            display: block;
            color: #888;
            font-size: 9px;
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-value {
            display: block;
            color: #00d4ff;
            font-size: 14px;
            font-weight: bold;
            text-shadow: 0 0 12px rgba(0, 212, 255, 0.8);
            position: relative;
            z-index: 1;
        }

        /* Historique des coups */
        .move-history {
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid rgba(0, 212, 255, 0.3);
            border-radius: 12px;
            padding: 10px;
            max-height: 150px;
            overflow-y: auto;
        }

        .move-item {
            color: #00d4ff;
            font-size: 11px;
            padding: 4px 8px;
            margin-bottom: 4px;
            background: rgba(0, 212, 255, 0.1);
            border-radius: 6px;
            border-left: 3px solid #00d4ff;
        }

        /* Responsive */
        @media (max-width: 1200px) {
            .quantum-chess-container {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .left-panel, .right-panel {
                display: none;
            }
            
            .quantum-chessboard {
                width: 480px;
                height: 480px;
            }
            
            .chess-piece {
                font-size: 36px;
            }
        }

        @media (max-width: 768px) {
            .game-panel {
                padding: 12px;
                margin: 6px;
            }
            
            .game-mode-controls {
                flex-direction: column;
                gap: 10px;
            }
            
            .quantum-title h1 {
                font-size: 16px;
            }
            
            .quantum-chessboard {
                width: 420px;
                height: 420px;
            }
            
            .chess-piece {
                font-size: 32px;
            }
        }

        @media (max-width: 480px) {
            .quantum-chessboard {
                width: 360px;
                height: 360px;
            }
            
            .chess-piece {
                font-size: 28px;
            }
            
            .game-stats {
                grid-template-columns: 1fr;
            }
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!-- Particules quantiques d&#x27;arrière-plan --&gt;
    &lt;div class=&quot;quantum-particles&quot; id=&quot;quantumParticles&quot;&gt;&lt;/div&gt;
    
    &lt;!-- Grille quantique --&gt;
    &lt;div class=&quot;quantum-grid&quot;&gt;&lt;/div&gt;
    
    &lt;!-- Lignes d&#x27;énergie futuristes --&gt;
    &lt;div class=&quot;energy-lines&quot; id=&quot;energyLines&quot;&gt;&lt;/div&gt;
    
    &lt;!-- Cercles d&#x27;énergie pulsants --&gt;
    &lt;div class=&quot;energy-circles&quot; id=&quot;energyCircles&quot;&gt;&lt;/div&gt;
    
    &lt;!-- Vagues d&#x27;énergie --&gt;
    &lt;div class=&quot;energy-waves&quot; id=&quot;energyWaves&quot;&gt;&lt;/div&gt;
    
    &lt;!-- Hexagones futuristes --&gt;
    &lt;div class=&quot;hex-pattern&quot;&gt;
        &lt;div class=&quot;hex-grid&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
    
    &lt;!-- Rayons laser --&gt;
    &lt;div class=&quot;laser-beams&quot; id=&quot;laserBeams&quot;&gt;&lt;/div&gt;
    
    &lt;!-- Orbes d&#x27;énergie flottants --&gt;
    &lt;div class=&quot;energy-orbs&quot; id=&quot;energyOrbs&quot;&gt;&lt;/div&gt;
    
    &lt;!-- Container principal --&gt;
    &lt;div class=&quot;quantum-chess-container&quot;&gt;
        &lt;!-- Panneau gauche --&gt;
        &lt;div class=&quot;left-panel&quot;&gt;
            &lt;div class=&quot;panel-section&quot;&gt;
                &lt;div class=&quot;panel-title&quot; id=&quot;controlsTitle&quot;&gt;🎮 Contrôles Quantiques&lt;/div&gt;
                &lt;div class=&quot;quantum-controls&quot;&gt;
                    &lt;button class=&quot;quantum-btn ai-btn&quot; onclick=&quot;makeAIMove()&quot; id=&quot;aiMoveBtn&quot;&gt;
                        🤖 &lt;span id=&quot;aiMoveText&quot;&gt;Coup IA Quantique&lt;/span&gt;
                    &lt;/button&gt;
                    &lt;button class=&quot;quantum-btn&quot; onclick=&quot;undoMove()&quot; id=&quot;undoBtn&quot;&gt;
                        ↶ &lt;span id=&quot;undoText&quot;&gt;Annuler Coup&lt;/span&gt;
                    &lt;/button&gt;
                    &lt;button class=&quot;quantum-btn quantum-special-btn&quot; onclick=&quot;activateQuantumMode()&quot; id=&quot;quantumBtn&quot;&gt;
                        ⚛️ &lt;span id=&quot;quantumModeText&quot;&gt;Mode Quantique&lt;/span&gt;
                    &lt;/button&gt;
                    &lt;button class=&quot;quantum-btn reset-btn&quot; onclick=&quot;resetGame()&quot;&gt;
                        🔄 &lt;span id=&quot;newGameText&quot;&gt;Nouvelle Partie&lt;/span&gt;
                    &lt;/button&gt;
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;div class=&quot;panel-section&quot;&gt;
                &lt;div class=&quot;panel-title&quot; id=&quot;statsTitle&quot;&gt;📊 Statistiques&lt;/div&gt;
                &lt;div class=&quot;game-stats&quot;&gt;
                    &lt;div class=&quot;stat-item&quot;&gt;
                        &lt;span class=&quot;stat-label&quot; id=&quot;movesLabel&quot;&gt;Coups Joués&lt;/span&gt;
                        &lt;span class=&quot;stat-value&quot; id=&quot;moveCount&quot;&gt;0&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;stat-item&quot;&gt;
                        &lt;span class=&quot;stat-label&quot; id=&quot;aiLevelLabel&quot;&gt;Niveau IA&lt;/span&gt;
                        &lt;span class=&quot;stat-value&quot; id=&quot;aiLevel&quot;&gt;5&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;stat-item&quot;&gt;
                        &lt;span class=&quot;stat-label&quot; id=&quot;timeLabel&quot;&gt;Temps&lt;/span&gt;
                        &lt;span class=&quot;stat-value&quot; id=&quot;gameTime&quot;&gt;00:00&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;stat-item&quot;&gt;
                        &lt;span class=&quot;stat-label&quot; id=&quot;scoreLabel&quot;&gt;Score&lt;/span&gt;
                        &lt;span class=&quot;stat-value&quot; id=&quot;gameScore&quot;&gt;0&lt;/span&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;

        &lt;!-- Panneau central --&gt;
        &lt;div class=&quot;game-panel&quot;&gt;
            &lt;!-- En-tête --&gt;
            &lt;div class=&quot;quantum-header&quot;&gt;
                &lt;div class=&quot;quantum-title&quot;&gt;
                    &lt;span class=&quot;quantum-icon&quot;&gt;♛&lt;/span&gt;
                    &lt;h1 id=&quot;gameTitle&quot;&gt;Brainova Quantum Chess&lt;/h1&gt;
                    &lt;span class=&quot;quantum-badge&quot; id=&quot;quantumBadge&quot;&gt;🚀 IA QUANTIQUE&lt;/span&gt;
                &lt;/div&gt;
                &lt;div style=&quot;display: flex; align-items: center; gap: 15px;&quot;&gt;
                    &lt;select id=&quot;languageSelector&quot; onchange=&quot;changeLanguage()&quot; class=&quot;language-selector&quot;&gt;
                        &lt;option value=&quot;fr&quot;&gt;🇫🇷 Français&lt;/option&gt;
                        &lt;option value=&quot;en&quot;&gt;🇺🇸 English&lt;/option&gt;
                        &lt;option value=&quot;ar&quot;&gt;🇸🇦 العربية&lt;/option&gt;
                        &lt;option value=&quot;es&quot;&gt;🇪🇸 Español&lt;/option&gt;
                        &lt;option value=&quot;de&quot;&gt;🇩🇪 Deutsch&lt;/option&gt;
                        &lt;option value=&quot;zh&quot;&gt;🇨🇳 中文&lt;/option&gt;
                    &lt;/select&gt;
                    &lt;button class=&quot;close-btn&quot; onclick=&quot;window.close()&quot; id=&quot;closeBtn&quot; title=&quot;Fermer&quot;&gt;✕&lt;/button&gt;
                &lt;/div&gt;
            &lt;/div&gt;



            &lt;!-- Boutons de contrôle en haut --&gt;
            &lt;div style=&quot;display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;&quot;&gt;
                &lt;!-- Bouton pause à gauche --&gt;
                &lt;button class=&quot;quantum-btn&quot; id=&quot;pauseBtn&quot; onclick=&quot;togglePause()&quot; style=&quot;min-width: 120px;&quot;&gt;
                    &lt;span id=&quot;pauseText&quot;&gt;⏸️ Pause&lt;/span&gt;
                &lt;/button&gt;
                
                &lt;!-- Bouton statut du joueur à droite --&gt;
                &lt;button class=&quot;player-status-btn&quot; id=&quot;playerStatusBtn&quot; onclick=&quot;switchPlayer()&quot;&gt;
                    &lt;span id=&quot;currentPlayer&quot;&gt;♔&lt;/span&gt;
                    &lt;span id=&quot;playerName&quot;&gt;Joueur Blanc&lt;/span&gt;
                &lt;/button&gt;
            &lt;/div&gt;

            &lt;!-- Plateau d&#x27;échecs quantique --&gt;
            &lt;div class=&quot;quantum-chessboard-container&quot;&gt;
                &lt;div class=&quot;quantum-chessboard&quot; id=&quot;chessboard&quot;&gt;
                    &lt;!-- Les cases seront générées dynamiquement --&gt;
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;!-- Statut IA Quantique --&gt;
            &lt;div class=&quot;quantum-ai-status&quot;&gt;
                &lt;div class=&quot;ai-thinking&quot; id=&quot;aiThinking&quot;&gt;
                    &lt;span class=&quot;quantum-pulse&quot;&gt;&lt;/span&gt;
                    &lt;span id=&quot;aiMessage&quot;&gt;IA Quantique en analyse...&lt;/span&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;

        &lt;!-- Panneau droit --&gt;
        &lt;div class=&quot;right-panel&quot;&gt;
            &lt;div class=&quot;panel-section&quot;&gt;
                &lt;div class=&quot;panel-title&quot; id=&quot;historyTitle&quot;&gt;📜 Historique&lt;/div&gt;
                &lt;div class=&quot;move-history&quot; id=&quot;moveHistory&quot;&gt;
                    &lt;div class=&quot;move-item&quot; id=&quot;gameStarted&quot;&gt;&lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;div class=&quot;panel-section&quot;&gt;
                &lt;div class=&quot;panel-title&quot; id=&quot;gameModeTitle&quot;&gt;🎮 Mode de Jeu&lt;/div&gt;
                &lt;div class=&quot;quantum-controls&quot;&gt;
                    &lt;button class=&quot;mode-btn active&quot; onclick=&quot;setGameMode(&#x27;ai&#x27;)&quot; id=&quot;aiModeBtn&quot;&gt;
                        🤖 &lt;span id=&quot;aiModeText&quot;&gt;Jouer vs IA&lt;/span&gt;
                    &lt;/button&gt;
                    &lt;button class=&quot;mode-btn&quot; onclick=&quot;setGameMode(&#x27;human&#x27;)&quot; id=&quot;humanModeBtn&quot;&gt;
                        👥 &lt;span id=&quot;humanModeText&quot;&gt;2 Joueurs&lt;/span&gt;
                    &lt;/button&gt;
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;div class=&quot;panel-section&quot;&gt;
                &lt;div class=&quot;panel-title&quot; id=&quot;optionsTitle&quot;&gt;⚙️ Options IA&lt;/div&gt;
                &lt;div class=&quot;quantum-controls&quot;&gt;
                    &lt;button class=&quot;quantum-btn&quot; onclick=&quot;changeDifficulty()&quot; id=&quot;difficultyBtn&quot;&gt;
                        🎯 &lt;span id=&quot;difficultyText&quot;&gt;Difficulté: Expert&lt;/span&gt;
                    &lt;/button&gt;
                    &lt;button class=&quot;quantum-btn ai-btn&quot; onclick=&quot;toggleAIAnalysis()&quot; id=&quot;analysisBtn&quot;&gt;
                        🔍 &lt;span id=&quot;analysisText&quot;&gt;Analyse IA&lt;/span&gt;
                    &lt;/button&gt;
                    &lt;button class=&quot;quantum-btn quantum-special-btn&quot; onclick=&quot;showBestMoves()&quot; id=&quot;hintBtn&quot;&gt;
                        💡 &lt;span id=&quot;hintText&quot;&gt;Meilleurs Coups&lt;/span&gt;
                    &lt;/button&gt;
                    &lt;button class=&quot;quantum-btn&quot; onclick=&quot;saveGame()&quot; id=&quot;saveBtn&quot;&gt;
                        💾 &lt;span id=&quot;saveText&quot;&gt;Sauvegarder&lt;/span&gt;
                    &lt;/button&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;script&gt;
        // Traductions multilingues
        const translations = {
            fr: {
                gameTitle: &quot;Brainova Échecs Quantiques&quot;,
                quantumBadge: &quot;🚀 IA QUANTIQUE&quot;,
                controlsTitle: &quot;🎮 Contrôles Quantiques&quot;,
                gameModeTitle: &quot;🎮 Mode de Jeu&quot;,
                aiMoveText: &quot;Coup IA Quantique&quot;,
                undoText: &quot;Annuler Coup&quot;,
                quantumModeText: &quot;Mode Quantique&quot;,
                newGameText: &quot;Nouvelle Partie&quot;,
                statsTitle: &quot;📊 Statistiques&quot;,
                movesLabel: &quot;Coups Joués&quot;,
                aiLevelLabel: &quot;Niveau IA&quot;,
                timeLabel: &quot;Temps&quot;,
                scoreLabel: &quot;Score&quot;,
                aiModeText: &quot;Jouer vs IA&quot;,
                humanModeText: &quot;2 Joueurs&quot;,
                gameStatus: &quot;Nouvelle partie - Blancs commencent&quot;,
                playerWhite: &quot;Joueur Jaune&quot;,
                playerBlack: &quot;Joueur Rouge&quot;,
                aiPlayer: &quot;IA Quantique&quot;,
                historyTitle: &quot;📜 Historique&quot;,
                gameStarted: &quot;Partie commencée&quot;,
                optionsTitle: &quot;⚙️ Options IA&quot;,
                difficultyText: &quot;Difficulté: Expert&quot;,
                analysisText: &quot;Analyse IA&quot;,
                hintText: &quot;Meilleurs Coups&quot;,
                saveText: &quot;Sauvegarder&quot;,
                aiThinking: &quot;IA Quantique en analyse...&quot;,
                closeBtn: &quot;Fermer&quot;,
                turnOf: &quot;Tour du&quot;,
                gameEnded: &quot;Partie terminée&quot;,
                newGameStarted: &quot;Nouvelle partie commencée&quot;,
                quantumActivated: &quot;Mode Quantique activé ! Les pièces peuvent se téléporter !&quot;,
                quantumDeactivated: &quot;Mode Quantique désactivé&quot;,
                gameSaved: &quot;Partie sauvegardée !&quot;,
                gameLoaded: &quot;Partie chargée !&quot;,
                loadSavedGame: &quot;Voulez-vous charger la partie sauvegardée ?&quot;,
                welcome: &quot;Bienvenue dans Brainova Échecs Quantiques ! Choisissez votre mode de jeu.&quot;,
                aiCalculating: &quot;IA Quantique calcule le meilleur coup...&quot;,
                undoInDevelopment: &quot;Fonction d&#x27;annulation en développement&quot;,
                aiAnalyzing: &quot;Analyse IA en cours...&quot;,
                bestMovesCalculating: &quot;Calcul des meilleurs coups...&quot;,
                suggestion: &quot;Suggestion:&quot;,
                noMovesAvailable: &quot;Aucun coup disponible&quot;,
                difficultyChanged: &quot;Difficulté changée:&quot;,
                whiteAdvantage: &quot;Avantage significatif aux Blancs&quot;,
                blackAdvantage: &quot;Avantage significatif aux Noirs&quot;,
                slightWhiteAdvantage: &quot;Léger avantage aux Blancs&quot;,
                slightBlackAdvantage: &quot;Léger avantage aux Noirs&quot;,
                balancedPosition: &quot;Position équilibrée&quot;,
                victory: &quot;Victoire des&quot;,
                whites: &quot;Blancs&quot;,
                blacks: &quot;Noirs&quot;,
                difficulties: {
                    easy: &quot;facile&quot;,
                    normal: &quot;normal&quot;,
                    hard: &quot;difficile&quot;,
                    expert: &quot;expert&quot;
                },
                pauseText: &quot;⏸️ Pause&quot;,
                resumeText: &quot;▶️ Reprendre&quot;,
                gamePaused: &quot;Jeu en pause&quot;,
                gameResumed: &quot;Jeu repris&quot;
            },
            en: {
                gameTitle: &quot;Brainova Quantum Chess&quot;,
                quantumBadge: &quot;🚀 QUANTUM AI&quot;,
                controlsTitle: &quot;🎮 Quantum Controls&quot;,
                gameModeTitle: &quot;🎮 Game Mode&quot;,
                aiMoveText: &quot;Quantum AI Move&quot;,
                undoText: &quot;Undo Move&quot;,
                quantumModeText: &quot;Quantum Mode&quot;,
                newGameText: &quot;New Game&quot;,
                statsTitle: &quot;📊 Statistics&quot;,
                movesLabel: &quot;Moves Played&quot;,
                aiLevelLabel: &quot;AI Level&quot;,
                timeLabel: &quot;Time&quot;,
                scoreLabel: &quot;Score&quot;,
                aiModeText: &quot;Play vs AI&quot;,
                humanModeText: &quot;2 Players&quot;,
                gameStatus: &quot;New game - Whites start&quot;,
                playerWhite: &quot;Yellow Player&quot;,
                playerBlack: &quot;Red Player&quot;,
                aiPlayer: &quot;Quantum AI&quot;,
                historyTitle: &quot;📜 History&quot;,
                gameStarted: &quot;Game started&quot;,
                optionsTitle: &quot;⚙️ AI Options&quot;,
                difficultyText: &quot;Difficulty: Expert&quot;,
                analysisText: &quot;AI Analysis&quot;,
                hintText: &quot;Best Moves&quot;,
                saveText: &quot;Save Game&quot;,
                aiThinking: &quot;Quantum AI analyzing...&quot;,
                closeBtn: &quot;Close&quot;,
                turnOf: &quot;Turn of&quot;,
                gameEnded: &quot;Game ended&quot;,
                newGameStarted: &quot;New game started&quot;,
                quantumActivated: &quot;Quantum Mode activated! Pieces can teleport!&quot;,
                quantumDeactivated: &quot;Quantum Mode deactivated&quot;,
                gameSaved: &quot;Game saved!&quot;,
                gameLoaded: &quot;Game loaded!&quot;,
                loadSavedGame: &quot;Do you want to load the saved game?&quot;,
                welcome: &quot;Welcome to Brainova Quantum Chess! Choose your game mode.&quot;,
                aiCalculating: &quot;Quantum AI calculating best move...&quot;,
                undoInDevelopment: &quot;Undo function in development&quot;,
                aiAnalyzing: &quot;AI analysis in progress...&quot;,
                bestMovesCalculating: &quot;Calculating best moves...&quot;,
                suggestion: &quot;Suggestion:&quot;,
                noMovesAvailable: &quot;No moves available&quot;,
                difficultyChanged: &quot;Difficulty changed:&quot;,
                whiteAdvantage: &quot;Significant advantage to White&quot;,
                blackAdvantage: &quot;Significant advantage to Black&quot;,
                slightWhiteAdvantage: &quot;Slight advantage to White&quot;,
                slightBlackAdvantage: &quot;Slight advantage to Black&quot;,
                balancedPosition: &quot;Balanced position&quot;,
                victory: &quot;Victory for&quot;,
                whites: &quot;White&quot;,
                blacks: &quot;Black&quot;,
                difficulties: {
                    easy: &quot;easy&quot;,
                    normal: &quot;normal&quot;,
                    hard: &quot;hard&quot;,
                    expert: &quot;expert&quot;
                },
                pauseText: &quot;⏸️ Pause&quot;,
                resumeText: &quot;▶️ Resume&quot;,
                gamePaused: &quot;Game paused&quot;,
                gameResumed: &quot;Game resumed&quot;
            },
            ar: {
                gameTitle: &quot;برينوفا شطرنج كمي&quot;,
                quantumBadge: &quot;🚀 ذكاء كمي&quot;,
                controlsTitle: &quot;🎮 تحكم كمي&quot;,
                gameModeTitle: &quot;🎮 وضع اللعب&quot;,
                aiMoveText: &quot;حركة الذكاء الكمي&quot;,
                undoText: &quot;تراجع عن الحركة&quot;,
                quantumModeText: &quot;الوضع الكمي&quot;,
                newGameText: &quot;لعبة جديدة&quot;,
                statsTitle: &quot;📊 إحصائيات&quot;,
                movesLabel: &quot;الحركات المُلعبة&quot;,
                aiLevelLabel: &quot;مستوى الذكاء&quot;,
                timeLabel: &quot;الوقت&quot;,
                scoreLabel: &quot;النقاط&quot;,
                aiModeText: &quot;العب ضد الذكاء&quot;,
                humanModeText: &quot;لاعبان&quot;,
                gameStatus: &quot;لعبة جديدة - الأبيض يبدأ&quot;,
                playerWhite: &quot;اللاعب الأبيض&quot;,
                playerBlack: &quot;اللاعب الأسود&quot;,
                aiPlayer: &quot;الذكاء الكمي&quot;,
                historyTitle: &quot;📜 التاريخ&quot;,
                gameStarted: &quot;بدأت اللعبة&quot;,
                optionsTitle: &quot;⚙️ خيارات الذكاء&quot;,
                difficultyText: &quot;الصعوبة: خبير&quot;,
                analysisText: &quot;تحليل الذكاء&quot;,
                hintText: &quot;أفضل الحركات&quot;,
                saveText: &quot;حفظ اللعبة&quot;,
                aiThinking: &quot;الذكاء الكمي يحلل...&quot;,
                closeBtn: &quot;إغلاق&quot;,
                turnOf: &quot;دور&quot;,
                gameEnded: &quot;انتهت اللعبة&quot;,
                newGameStarted: &quot;بدأت لعبة جديدة&quot;,
                quantumActivated: &quot;تم تفعيل الوضع الكمي! يمكن للقطع الانتقال الفوري!&quot;,
                quantumDeactivated: &quot;تم إلغاء الوضع الكمي&quot;,
                gameSaved: &quot;تم حفظ اللعبة!&quot;,
                gameLoaded: &quot;تم تحميل اللعبة!&quot;,
                loadSavedGame: &quot;هل تريد تحميل اللعبة المحفوظة؟&quot;,
                welcome: &quot;مرحباً بك في برينوفا شطرنج كمي! اختر وضع اللعب.&quot;,
                aiCalculating: &quot;الذكاء الكمي يحسب أفضل حركة...&quot;,
                undoInDevelopment: &quot;وظيفة التراجع قيد التطوير&quot;,
                aiAnalyzing: &quot;تحليل الذكاء جاري...&quot;,
                bestMovesCalculating: &quot;حساب أفضل الحركات...&quot;,
                suggestion: &quot;اقتراح:&quot;,
                noMovesAvailable: &quot;لا توجد حركات متاحة&quot;,
                difficultyChanged: &quot;تم تغيير الصعوبة:&quot;,
                whiteAdvantage: &quot;ميزة كبيرة للأبيض&quot;,
                blackAdvantage: &quot;ميزة كبيرة للأسود&quot;,
                slightWhiteAdvantage: &quot;ميزة طفيفة للأبيض&quot;,
                slightBlackAdvantage: &quot;ميزة طفيفة للأسود&quot;,
                balancedPosition: &quot;موقف متوازن&quot;,
                victory: &quot;انتصار&quot;,
                whites: &quot;الأبيض&quot;,
                blacks: &quot;الأسود&quot;,
                difficulties: {
                    easy: &quot;سهل&quot;,
                    normal: &quot;عادي&quot;,
                    hard: &quot;صعب&quot;,
                    expert: &quot;خبير&quot;
                },
                pauseText: &quot;⏸️ إيقاف&quot;,
                resumeText: &quot;▶️ استئناف&quot;,
                gamePaused: &quot;اللعبة متوقفة&quot;,
                gameResumed: &quot;تم استئناف اللعبة&quot;
            },
            es: {
                gameTitle: &quot;Brainova Ajedrez Cuántico&quot;,
                quantumBadge: &quot;🚀 IA CUÁNTICA&quot;,
                controlsTitle: &quot;🎮 Controles Cuánticos&quot;,
                gameModeTitle: &quot;🎮 Modo de Juego&quot;,
                aiMoveText: &quot;Movimiento IA Cuántica&quot;,
                undoText: &quot;Deshacer Movimiento&quot;,
                quantumModeText: &quot;Modo Cuántico&quot;,
                newGameText: &quot;Nueva Partida&quot;,
                statsTitle: &quot;📊 Estadísticas&quot;,
                movesLabel: &quot;Movimientos Jugados&quot;,
                aiLevelLabel: &quot;Nivel IA&quot;,
                timeLabel: &quot;Tiempo&quot;,
                scoreLabel: &quot;Puntuación&quot;,
                aiModeText: &quot;Jugar vs IA&quot;,
                humanModeText: &quot;2 Jugadores&quot;,
                gameStatus: &quot;Nueva partida - Blancas empiezan&quot;,
                playerWhite: &quot;Jugador Blanco&quot;,
                playerBlack: &quot;Jugador Negro&quot;,
                aiPlayer: &quot;IA Cuántica&quot;,
                historyTitle: &quot;📜 Historial&quot;,
                gameStarted: &quot;Partida iniciada&quot;,
                optionsTitle: &quot;⚙️ Opciones IA&quot;,
                difficultyText: &quot;Dificultad: Experto&quot;,
                analysisText: &quot;Análisis IA&quot;,
                hintText: &quot;Mejores Movimientos&quot;,
                saveText: &quot;Guardar Partida&quot;,
                aiThinking: &quot;IA Cuántica analizando...&quot;,
                closeBtn: &quot;Cerrar&quot;,
                turnOf: &quot;Turno de&quot;,
                gameEnded: &quot;Partida terminada&quot;,
                newGameStarted: &quot;Nueva partida iniciada&quot;,
                quantumActivated: &quot;¡Modo Cuántico activado! ¡Las piezas pueden teletransportarse!&quot;,
                quantumDeactivated: &quot;Modo Cuántico desactivado&quot;,
                gameSaved: &quot;¡Partida guardada!&quot;,
                gameLoaded: &quot;¡Partida cargada!&quot;,
                loadSavedGame: &quot;¿Quieres cargar la partida guardada?&quot;,
                welcome: &quot;¡Bienvenido a Brainova Ajedrez Cuántico! Elige tu modo de juego.&quot;,
                aiCalculating: &quot;IA Cuántica calculando mejor movimiento...&quot;,
                undoInDevelopment: &quot;Función de deshacer en desarrollo&quot;,
                aiAnalyzing: &quot;Análisis IA en progreso...&quot;,
                bestMovesCalculating: &quot;Calculando mejores movimientos...&quot;,
                suggestion: &quot;Sugerencia:&quot;,
                noMovesAvailable: &quot;No hay movimientos disponibles&quot;,
                difficultyChanged: &quot;Dificultad cambiada:&quot;,
                whiteAdvantage: &quot;Ventaja significativa para Blancas&quot;,
                blackAdvantage: &quot;Ventaja significativa para Negras&quot;,
                slightWhiteAdvantage: &quot;Ligera ventaja para Blancas&quot;,
                slightBlackAdvantage: &quot;Ligera ventaja para Negras&quot;,
                balancedPosition: &quot;Posición equilibrada&quot;,
                victory: &quot;Victoria de&quot;,
                whites: &quot;Blancas&quot;,
                blacks: &quot;Negras&quot;,
                difficulties: {
                    easy: &quot;fácil&quot;,
                    normal: &quot;normal&quot;,
                    hard: &quot;difícil&quot;,
                    expert: &quot;experto&quot;
                },
                pauseText: &quot;⏸️ Pausa&quot;,
                resumeText: &quot;▶️ Reanudar&quot;,
                gamePaused: &quot;Juego pausado&quot;,
                gameResumed: &quot;Juego reanudado&quot;
            },
            de: {
                gameTitle: &quot;Brainova Quanten-Schach&quot;,
                quantumBadge: &quot;🚀 QUANTEN-KI&quot;,
                controlsTitle: &quot;🎮 Quanten-Steuerung&quot;,
                gameModeTitle: &quot;🎮 Spielmodus&quot;,
                aiMoveText: &quot;Quanten-KI Zug&quot;,
                undoText: &quot;Zug rückgängig&quot;,
                quantumModeText: &quot;Quanten-Modus&quot;,
                newGameText: &quot;Neues Spiel&quot;,
                statsTitle: &quot;📊 Statistiken&quot;,
                movesLabel: &quot;Gespielte Züge&quot;,
                aiLevelLabel: &quot;KI-Level&quot;,
                timeLabel: &quot;Zeit&quot;,
                scoreLabel: &quot;Punkte&quot;,
                aiModeText: &quot;Gegen KI spielen&quot;,
                humanModeText: &quot;2 Spieler&quot;,
                gameStatus: &quot;Neues Spiel - Weiß beginnt&quot;,
                playerWhite: &quot;Weißer Spieler&quot;,
                playerBlack: &quot;Schwarzer Spieler&quot;,
                aiPlayer: &quot;Quanten-KI&quot;,
                historyTitle: &quot;📜 Verlauf&quot;,
                gameStarted: &quot;Spiel gestartet&quot;,
                optionsTitle: &quot;⚙️ KI-Optionen&quot;,
                difficultyText: &quot;Schwierigkeit: Experte&quot;,
                analysisText: &quot;KI-Analyse&quot;,
                hintText: &quot;Beste Züge&quot;,
                saveText: &quot;Spiel speichern&quot;,
                aiThinking: &quot;Quanten-KI analysiert...&quot;,
                closeBtn: &quot;Schließen&quot;,
                turnOf: &quot;Zug von&quot;,
                gameEnded: &quot;Spiel beendet&quot;,
                newGameStarted: &quot;Neues Spiel gestartet&quot;,
                quantumActivated: &quot;Quanten-Modus aktiviert! Figuren können sich teleportieren!&quot;,
                quantumDeactivated: &quot;Quanten-Modus deaktiviert&quot;,
                gameSaved: &quot;Spiel gespeichert!&quot;,
                gameLoaded: &quot;Spiel geladen!&quot;,
                loadSavedGame: &quot;Möchten Sie das gespeicherte Spiel laden?&quot;,
                welcome: &quot;Willkommen bei Brainova Quanten-Schach! Wählen Sie Ihren Spielmodus.&quot;,
                aiCalculating: &quot;Quanten-KI berechnet besten Zug...&quot;,
                undoInDevelopment: &quot;Rückgängig-Funktion in Entwicklung&quot;,
                aiAnalyzing: &quot;KI-Analyse läuft...&quot;,
                bestMovesCalculating: &quot;Berechne beste Züge...&quot;,
                suggestion: &quot;Vorschlag:&quot;,
                noMovesAvailable: &quot;Keine Züge verfügbar&quot;,
                difficultyChanged: &quot;Schwierigkeit geändert:&quot;,
                whiteAdvantage: &quot;Signifikanter Vorteil für Weiß&quot;,
                blackAdvantage: &quot;Signifikanter Vorteil für Schwarz&quot;,
                slightWhiteAdvantage: &quot;Leichter Vorteil für Weiß&quot;,
                slightBlackAdvantage: &quot;Leichter Vorteil für Schwarz&quot;,
                balancedPosition: &quot;Ausgeglichene Position&quot;,
                victory: &quot;Sieg für&quot;,
                whites: &quot;Weiß&quot;,
                blacks: &quot;Schwarz&quot;,
                difficulties: {
                    easy: &quot;einfach&quot;,
                    normal: &quot;normal&quot;,
                    hard: &quot;schwer&quot;,
                    expert: &quot;experte&quot;
                },
                pauseText: &quot;⏸️ Pause&quot;,
                resumeText: &quot;▶️ Fortsetzen&quot;,
                gamePaused: &quot;Spiel pausiert&quot;,
                gameResumed: &quot;Spiel fortgesetzt&quot;
            },
            nl: {
                gameTitle: &quot;Brainova Quantum Schaak&quot;,
                quantumBadge: &quot;🚀 QUANTUM AI&quot;,
                controlsTitle: &quot;🎮 Quantum Besturing&quot;,
                aiMoveText: &quot;Quantum AI Zet&quot;,
                undoText: &quot;Zet Ongedaan&quot;,
                quantumModeText: &quot;Quantum Modus&quot;,
                newGameText: &quot;Nieuw Spel&quot;,
                statsTitle: &quot;📊 Statistieken&quot;,
                movesLabel: &quot;Gespeelde Zetten&quot;,
                aiLevelLabel: &quot;AI Niveau&quot;,
                timeLabel: &quot;Tijd&quot;,
                scoreLabel: &quot;Score&quot;,
                aiModeText: &quot;Speel tegen AI&quot;,
                humanModeText: &quot;2 Spelers&quot;,
                gameStatus: &quot;Nieuw spel - Wit begint&quot;,
                playerWhite: &quot;Witte Speler&quot;,
                playerBlack: &quot;Zwarte Speler&quot;,
                aiPlayer: &quot;Quantum AI&quot;,
                historyTitle: &quot;📜 Geschiedenis&quot;,
                gameStarted: &quot;Spel gestart&quot;,
                optionsTitle: &quot;⚙️ AI Opties&quot;,
                difficultyText: &quot;Moeilijkheid: Expert&quot;,
                analysisText: &quot;AI Analyse&quot;,
                hintText: &quot;Beste Zetten&quot;,
                saveText: &quot;Spel Opslaan&quot;,
                aiThinking: &quot;Quantum AI analyseert...&quot;,
                closeBtn: &quot;Sluiten&quot;,
                turnOf: &quot;Beurt van&quot;,
                gameEnded: &quot;Spel beëindigd&quot;,
                newGameStarted: &quot;Nieuw spel gestart&quot;,
                quantumActivated: &quot;Quantum Modus geactiveerd! Stukken kunnen teleporteren!&quot;,
                quantumDeactivated: &quot;Quantum Modus gedeactiveerd&quot;,
                gameSaved: &quot;Spel opgeslagen!&quot;,
                gameLoaded: &quot;Spel geladen!&quot;,
                loadSavedGame: &quot;Wilt u het opgeslagen spel laden?&quot;,
                welcome: &quot;Welkom bij Brainova Quantum Schaak! Kies uw spelmodus.&quot;,
                aiCalculating: &quot;Quantum AI berekent beste zet...&quot;,
                undoInDevelopment: &quot;Ongedaan maken functie in ontwikkeling&quot;,
                aiAnalyzing: &quot;AI analyse bezig...&quot;,
                bestMovesCalculating: &quot;Beste zetten berekenen...&quot;,
                suggestion: &quot;Suggestie:&quot;,
                noMovesAvailable: &quot;Geen zetten beschikbaar&quot;,
                difficultyChanged: &quot;Moeilijkheid gewijzigd:&quot;,
                whiteAdvantage: &quot;Significant voordeel voor Wit&quot;,
                blackAdvantage: &quot;Significant voordeel voor Zwart&quot;,
                slightWhiteAdvantage: &quot;Licht voordeel voor Wit&quot;,
                slightBlackAdvantage: &quot;Licht voordeel voor Zwart&quot;,
                balancedPosition: &quot;Gebalanceerde positie&quot;,
                victory: &quot;Overwinning voor&quot;,
                whites: &quot;Wit&quot;,
                blacks: &quot;Zwart&quot;,
                difficulties: {
                    easy: &quot;makkelijk&quot;,
                    normal: &quot;normaal&quot;,
                    hard: &quot;moeilijk&quot;,
                    expert: &quot;expert&quot;
                },
                pauseText: &quot;⏸️ Pauze&quot;,
                resumeText: &quot;▶️ Hervatten&quot;,
                gamePaused: &quot;Spel gepauzeerd&quot;,
                gameResumed: &quot;Spel hervat&quot;
            },
            sv: {
                gameTitle: &quot;Brainova Kvantschack&quot;,
                quantumBadge: &quot;🚀 KVANT AI&quot;,
                controlsTitle: &quot;🎮 Kvantkontroller&quot;,
                aiMoveText: &quot;Kvant AI Drag&quot;,
                undoText: &quot;Ångra Drag&quot;,
                quantumModeText: &quot;Kvantläge&quot;,
                newGameText: &quot;Nytt Spel&quot;,
                statsTitle: &quot;📊 Statistik&quot;,
                movesLabel: &quot;Spelade Drag&quot;,
                aiLevelLabel: &quot;AI Nivå&quot;,
                timeLabel: &quot;Tid&quot;,
                scoreLabel: &quot;Poäng&quot;,
                aiModeText: &quot;Spela mot AI&quot;,
                humanModeText: &quot;2 Spelare&quot;,
                gameStatus: &quot;Nytt spel - Vit börjar&quot;,
                playerWhite: &quot;Vit Spelare&quot;,
                playerBlack: &quot;Svart Spelare&quot;,
                aiPlayer: &quot;Kvant AI&quot;,
                historyTitle: &quot;📜 Historia&quot;,
                gameStarted: &quot;Spel startat&quot;,
                optionsTitle: &quot;⚙️ AI Alternativ&quot;,
                difficultyText: &quot;Svårighet: Expert&quot;,
                analysisText: &quot;AI Analys&quot;,
                hintText: &quot;Bästa Drag&quot;,
                saveText: &quot;Spara Spel&quot;,
                aiThinking: &quot;Kvant AI analyserar...&quot;,
                closeBtn: &quot;Stäng&quot;,
                turnOf: &quot;Tur för&quot;,
                gameEnded: &quot;Spel avslutat&quot;,
                newGameStarted: &quot;Nytt spel startat&quot;,
                quantumActivated: &quot;Kvantläge aktiverat! Pjäser kan teleportera!&quot;,
                quantumDeactivated: &quot;Kvantläge deaktiverat&quot;,
                gameSaved: &quot;Spel sparat!&quot;,
                gameLoaded: &quot;Spel laddat!&quot;,
                loadSavedGame: &quot;Vill du ladda det sparade spelet?&quot;,
                welcome: &quot;Välkommen till Brainova Kvantschack! Välj ditt spelläge.&quot;,
                aiCalculating: &quot;Kvant AI beräknar bästa drag...&quot;,
                undoInDevelopment: &quot;Ångra-funktion under utveckling&quot;,
                aiAnalyzing: &quot;AI analys pågår...&quot;,
                bestMovesCalculating: &quot;Beräknar bästa drag...&quot;,
                suggestion: &quot;Förslag:&quot;,
                noMovesAvailable: &quot;Inga drag tillgängliga&quot;,
                difficultyChanged: &quot;Svårighet ändrad:&quot;,
                whiteAdvantage: &quot;Betydande fördel för Vit&quot;,
                blackAdvantage: &quot;Betydande fördel för Svart&quot;,
                slightWhiteAdvantage: &quot;Liten fördel för Vit&quot;,
                slightBlackAdvantage: &quot;Liten fördel för Svart&quot;,
                balancedPosition: &quot;Balanserad position&quot;,
                victory: &quot;Seger för&quot;,
                whites: &quot;Vit&quot;,
                blacks: &quot;Svart&quot;,
                difficulties: {
                    easy: &quot;lätt&quot;,
                    normal: &quot;normal&quot;,
                    hard: &quot;svår&quot;,
                    expert: &quot;expert&quot;
                }
            },
            no: {
                gameTitle: &quot;Brainova Kvantsjakk&quot;,
                quantumBadge: &quot;🚀 KVANTE AI&quot;,
                controlsTitle: &quot;🎮 Kvantekontroller&quot;,
                aiMoveText: &quot;Kvante AI Trekk&quot;,
                undoText: &quot;Angre Trekk&quot;,
                quantumModeText: &quot;Kvantemodus&quot;,
                newGameText: &quot;Nytt Spill&quot;,
                statsTitle: &quot;📊 Statistikk&quot;,
                movesLabel: &quot;Spilte Trekk&quot;,
                aiLevelLabel: &quot;AI Nivå&quot;,
                timeLabel: &quot;Tid&quot;,
                scoreLabel: &quot;Poeng&quot;,
                aiModeText: &quot;Spill mot AI&quot;,
                humanModeText: &quot;2 Spillere&quot;,
                gameStatus: &quot;Nytt spill - Hvit begynner&quot;,
                playerWhite: &quot;Hvit Spiller&quot;,
                playerBlack: &quot;Svart Spiller&quot;,
                aiPlayer: &quot;Kvante AI&quot;,
                historyTitle: &quot;📜 Historie&quot;,
                gameStarted: &quot;Spill startet&quot;,
                optionsTitle: &quot;⚙️ AI Alternativer&quot;,
                difficultyText: &quot;Vanskelighet: Ekspert&quot;,
                analysisText: &quot;AI Analyse&quot;,
                hintText: &quot;Beste Trekk&quot;,
                saveText: &quot;Lagre Spill&quot;,
                aiThinking: &quot;Kvante AI analyserer...&quot;,
                closeBtn: &quot;Lukk&quot;,
                turnOf: &quot;Tur for&quot;,
                gameEnded: &quot;Spill avsluttet&quot;,
                newGameStarted: &quot;Nytt spill startet&quot;,
                quantumActivated: &quot;Kvantemodus aktivert! Brikker kan teleportere!&quot;,
                quantumDeactivated: &quot;Kvantemodus deaktivert&quot;,
                gameSaved: &quot;Spill lagret!&quot;,
                gameLoaded: &quot;Spill lastet!&quot;,
                loadSavedGame: &quot;Vil du laste det lagrede spillet?&quot;,
                welcome: &quot;Velkommen til Brainova Kvantsjakk! Velg spillmodus.&quot;,
                aiCalculating: &quot;Kvante AI beregner beste trekk...&quot;,
                undoInDevelopment: &quot;Angre-funksjon under utvikling&quot;,
                aiAnalyzing: &quot;AI analyse pågår...&quot;,
                bestMovesCalculating: &quot;Beregner beste trekk...&quot;,
                suggestion: &quot;Forslag:&quot;,
                noMovesAvailable: &quot;Ingen trekk tilgjengelig&quot;,
                difficultyChanged: &quot;Vanskelighet endret:&quot;,
                whiteAdvantage: &quot;Betydelig fordel for Hvit&quot;,
                blackAdvantage: &quot;Betydelig fordel for Svart&quot;,
                slightWhiteAdvantage: &quot;Liten fordel for Hvit&quot;,
                slightBlackAdvantage: &quot;Liten fordel for Svart&quot;,
                balancedPosition: &quot;Balansert posisjon&quot;,
                victory: &quot;Seier for&quot;,
                whites: &quot;Hvit&quot;,
                blacks: &quot;Svart&quot;,
                difficulties: {
                    easy: &quot;lett&quot;,
                    normal: &quot;normal&quot;,
                    hard: &quot;vanskelig&quot;,
                    expert: &quot;ekspert&quot;
                }
            },
            da: {
                gameTitle: &quot;Brainova Kvanteskak&quot;,
                quantumBadge: &quot;🚀 KVANTE AI&quot;,
                controlsTitle: &quot;🎮 Kvantekontroller&quot;,
                aiMoveText: &quot;Kvante AI Træk&quot;,
                undoText: &quot;Fortryd Træk&quot;,
                quantumModeText: &quot;Kvantetilstand&quot;,
                newGameText: &quot;Nyt Spil&quot;,
                statsTitle: &quot;📊 Statistik&quot;,
                movesLabel: &quot;Spillede Træk&quot;,
                aiLevelLabel: &quot;AI Niveau&quot;,
                timeLabel: &quot;Tid&quot;,
                scoreLabel: &quot;Score&quot;,
                aiModeText: &quot;Spil mod AI&quot;,
                humanModeText: &quot;2 Spillere&quot;,
                gameStatus: &quot;Nyt spil - Hvid begynder&quot;,
                playerWhite: &quot;Hvid Spiller&quot;,
                playerBlack: &quot;Sort Spiller&quot;,
                aiPlayer: &quot;Kvante AI&quot;,
                historyTitle: &quot;📜 Historie&quot;,
                gameStarted: &quot;Spil startet&quot;,
                optionsTitle: &quot;⚙️ AI Muligheder&quot;,
                difficultyText: &quot;Sværhedsgrad: Ekspert&quot;,
                analysisText: &quot;AI Analyse&quot;,
                hintText: &quot;Bedste Træk&quot;,
                saveText: &quot;Gem Spil&quot;,
                aiThinking: &quot;Kvante AI analyserer...&quot;,
                closeBtn: &quot;Luk&quot;,
                turnOf: &quot;Tur for&quot;,
                gameEnded: &quot;Spil afsluttet&quot;,
                newGameStarted: &quot;Nyt spil startet&quot;,
                quantumActivated: &quot;Kvantetilstand aktiveret! Brikker kan teleportere!&quot;,
                quantumDeactivated: &quot;Kvantetilstand deaktiveret&quot;,
                gameSaved: &quot;Spil gemt!&quot;,
                gameLoaded: &quot;Spil indlæst!&quot;,
                loadSavedGame: &quot;Vil du indlæse det gemte spil?&quot;,
                welcome: &quot;Velkommen til Brainova Kvanteskak! Vælg din spiltilstand.&quot;,
                aiCalculating: &quot;Kvante AI beregner bedste træk...&quot;,
                undoInDevelopment: &quot;Fortryd-funktion under udvikling&quot;,
                aiAnalyzing: &quot;AI analyse i gang...&quot;,
                bestMovesCalculating: &quot;Beregner bedste træk...&quot;,
                suggestion: &quot;Forslag:&quot;,
                noMovesAvailable: &quot;Ingen træk tilgængelige&quot;,
                difficultyChanged: &quot;Sværhedsgrad ændret:&quot;,
                whiteAdvantage: &quot;Betydelig fordel til Hvid&quot;,
                blackAdvantage: &quot;Betydelig fordel til Sort&quot;,
                slightWhiteAdvantage: &quot;Lille fordel til Hvid&quot;,
                slightBlackAdvantage: &quot;Lille fordel til Sort&quot;,
                balancedPosition: &quot;Balanceret position&quot;,
                victory: &quot;Sejr til&quot;,
                whites: &quot;Hvid&quot;,
                blacks: &quot;Sort&quot;,
                difficulties: {
                    easy: &quot;let&quot;,
                    normal: &quot;normal&quot;,
                    hard: &quot;svær&quot;,
                    expert: &quot;ekspert&quot;
                }
            },
            fi: {
                gameTitle: &quot;Brainova Kvanttishakki&quot;,
                quantumBadge: &quot;🚀 KVANTTI AI&quot;,
                controlsTitle: &quot;🎮 Kvanttiohjaimet&quot;,
                aiMoveText: &quot;Kvantti AI Siirto&quot;,
                undoText: &quot;Peru Siirto&quot;,
                quantumModeText: &quot;Kvanttitila&quot;,
                newGameText: &quot;Uusi Peli&quot;,
                statsTitle: &quot;📊 Tilastot&quot;,
                movesLabel: &quot;Pelatut Siirrot&quot;,
                aiLevelLabel: &quot;AI Taso&quot;,
                timeLabel: &quot;Aika&quot;,
                scoreLabel: &quot;Pisteet&quot;,
                aiModeText: &quot;Pelaa AI:ta vastaan&quot;,
                humanModeText: &quot;2 Pelaajaa&quot;,
                gameStatus: &quot;Uusi peli - Valkoinen aloittaa&quot;,
                playerWhite: &quot;Valkoinen Pelaaja&quot;,
                playerBlack: &quot;Musta Pelaaja&quot;,
                aiPlayer: &quot;Kvantti AI&quot;,
                historyTitle: &quot;📜 Historia&quot;,
                gameStarted: &quot;Peli aloitettu&quot;,
                optionsTitle: &quot;⚙️ AI Asetukset&quot;,
                difficultyText: &quot;Vaikeus: Asiantuntija&quot;,
                analysisText: &quot;AI Analyysi&quot;,
                hintText: &quot;Parhaat Siirrot&quot;,
                saveText: &quot;Tallenna Peli&quot;,
                aiThinking: &quot;Kvantti AI analysoi...&quot;,
                closeBtn: &quot;Sulje&quot;,
                turnOf: &quot;Vuoro:&quot;,
                gameEnded: &quot;Peli päättynyt&quot;,
                newGameStarted: &quot;Uusi peli aloitettu&quot;,
                quantumActivated: &quot;Kvanttitila aktivoitu! Nappulat voivat teleportata!&quot;,
                quantumDeactivated: &quot;Kvanttitila deaktivoitu&quot;,
                gameSaved: &quot;Peli tallennettu!&quot;,
                gameLoaded: &quot;Peli ladattu!&quot;,
                loadSavedGame: &quot;Haluatko ladata tallennetun pelin?&quot;,
                welcome: &quot;Tervetuloa Brainova Kvanttishakkiin! Valitse pelitila.&quot;,
                aiCalculating: &quot;Kvantti AI laskee parasta siirtoa...&quot;,
                undoInDevelopment: &quot;Peru-toiminto kehitteillä&quot;,
                aiAnalyzing: &quot;AI analyysi käynnissä...&quot;,
                bestMovesCalculating: &quot;Lasketaan parhaita siirtoja...&quot;,
                suggestion: &quot;Ehdotus:&quot;,
                noMovesAvailable: &quot;Ei siirtoja saatavilla&quot;,
                difficultyChanged: &quot;Vaikeus muutettu:&quot;,
                whiteAdvantage: &quot;Merkittävä etu Valkoiselle&quot;,
                blackAdvantage: &quot;Merkittävä etu Mustalle&quot;,
                slightWhiteAdvantage: &quot;Pieni etu Valkoiselle&quot;,
                slightBlackAdvantage: &quot;Pieni etu Mustalle&quot;,
                balancedPosition: &quot;Tasapainoinen asema&quot;,
                victory: &quot;Voitto:&quot;,
                whites: &quot;Valkoinen&quot;,
                blacks: &quot;Musta&quot;,
                difficulties: {
                    easy: &quot;helppo&quot;,
                    normal: &quot;normaali&quot;,
                    hard: &quot;vaikea&quot;,
                    expert: &quot;asiantuntija&quot;
                }
            },
            pl: {
                gameTitle: &quot;Brainova Szachy Kwantowe&quot;,
                quantumBadge: &quot;🚀 KWANTOWE AI&quot;,
                controlsTitle: &quot;🎮 Kontrole Kwantowe&quot;,
                aiMoveText: &quot;Ruch Kwantowego AI&quot;,
                undoText: &quot;Cofnij Ruch&quot;,
                quantumModeText: &quot;Tryb Kwantowy&quot;,
                newGameText: &quot;Nowa Gra&quot;,
                statsTitle: &quot;📊 Statystyki&quot;,
                movesLabel: &quot;Zagrane Ruchy&quot;,
                aiLevelLabel: &quot;Poziom AI&quot;,
                timeLabel: &quot;Czas&quot;,
                scoreLabel: &quot;Wynik&quot;,
                aiModeText: &quot;Graj przeciw AI&quot;,
                humanModeText: &quot;2 Graczy&quot;,
                gameStatus: &quot;Nowa gra - Białe zaczynają&quot;,
                playerWhite: &quot;Gracz Biały&quot;,
                playerBlack: &quot;Gracz Czarny&quot;,
                aiPlayer: &quot;Kwantowe AI&quot;,
                historyTitle: &quot;📜 Historia&quot;,
                gameStarted: &quot;Gra rozpoczęta&quot;,
                optionsTitle: &quot;⚙️ Opcje AI&quot;,
                difficultyText: &quot;Trudność: Ekspert&quot;,
                analysisText: &quot;Analiza AI&quot;,
                hintText: &quot;Najlepsze Ruchy&quot;,
                saveText: &quot;Zapisz Grę&quot;,
                aiThinking: &quot;Kwantowe AI analizuje...&quot;,
                closeBtn: &quot;Zamknij&quot;,
                turnOf: &quot;Tura:&quot;,
                gameEnded: &quot;Gra zakończona&quot;,
                newGameStarted: &quot;Nowa gra rozpoczęta&quot;,
                quantumActivated: &quot;Tryb Kwantowy aktywowany! Figury mogą się teleportować!&quot;,
                quantumDeactivated: &quot;Tryb Kwantowy dezaktywowany&quot;,
                gameSaved: &quot;Gra zapisana!&quot;,
                gameLoaded: &quot;Gra wczytana!&quot;,
                loadSavedGame: &quot;Czy chcesz wczytać zapisaną grę?&quot;,
                welcome: &quot;Witaj w Brainova Szachy Kwantowe! Wybierz tryb gry.&quot;,
                aiCalculating: &quot;Kwantowe AI oblicza najlepszy ruch...&quot;,
                undoInDevelopment: &quot;Funkcja cofania w rozwoju&quot;,
                aiAnalyzing: &quot;Analiza AI w toku...&quot;,
                bestMovesCalculating: &quot;Obliczanie najlepszych ruchów...&quot;,
                suggestion: &quot;Sugestia:&quot;,
                noMovesAvailable: &quot;Brak dostępnych ruchów&quot;,
                difficultyChanged: &quot;Trudność zmieniona:&quot;,
                whiteAdvantage: &quot;Znacząca przewaga Białych&quot;,
                blackAdvantage: &quot;Znacząca przewaga Czarnych&quot;,
                slightWhiteAdvantage: &quot;Niewielka przewaga Białych&quot;,
                slightBlackAdvantage: &quot;Niewielka przewaga Czarnych&quot;,
                balancedPosition: &quot;Zrównoważona pozycja&quot;,
                victory: &quot;Zwycięstwo:&quot;,
                whites: &quot;Białe&quot;,
                blacks: &quot;Czarne&quot;,
                difficulties: {
                    easy: &quot;łatwy&quot;,
                    normal: &quot;normalny&quot;,
                    hard: &quot;trudny&quot;,
                    expert: &quot;ekspert&quot;
                }
            },
            tr: {
                gameTitle: &quot;Brainova Kuantum Satranç&quot;,
                quantumBadge: &quot;🚀 KUANTUM AI&quot;,
                controlsTitle: &quot;🎮 Kuantum Kontrolleri&quot;,
                aiMoveText: &quot;Kuantum AI Hamlesi&quot;,
                undoText: &quot;Hamleyi Geri Al&quot;,
                quantumModeText: &quot;Kuantum Modu&quot;,
                newGameText: &quot;Yeni Oyun&quot;,
                statsTitle: &quot;📊 İstatistikler&quot;,
                movesLabel: &quot;Oynanan Hamleler&quot;,
                aiLevelLabel: &quot;AI Seviyesi&quot;,
                timeLabel: &quot;Zaman&quot;,
                scoreLabel: &quot;Skor&quot;,
                aiModeText: &quot;AI&#x27;ya Karşı Oyna&quot;,
                humanModeText: &quot;2 Oyuncu&quot;,
                gameStatus: &quot;Yeni oyun - Beyaz başlar&quot;,
                playerWhite: &quot;Beyaz Oyuncu&quot;,
                playerBlack: &quot;Siyah Oyuncu&quot;,
                aiPlayer: &quot;Kuantum AI&quot;,
                historyTitle: &quot;📜 Geçmiş&quot;,
                gameStarted: &quot;Oyun başladı&quot;,
                optionsTitle: &quot;⚙️ AI Seçenekleri&quot;,
                difficultyText: &quot;Zorluk: Uzman&quot;,
                analysisText: &quot;AI Analizi&quot;,
                hintText: &quot;En İyi Hamleler&quot;,
                saveText: &quot;Oyunu Kaydet&quot;,
                aiThinking: &quot;Kuantum AI analiz ediyor...&quot;,
                closeBtn: &quot;Kapat&quot;,
                turnOf: &quot;Sıra:&quot;,
                gameEnded: &quot;Oyun bitti&quot;,
                newGameStarted: &quot;Yeni oyun başladı&quot;,
                quantumActivated: &quot;Kuantum Modu etkinleştirildi! Taşlar ışınlanabilir!&quot;,
                quantumDeactivated: &quot;Kuantum Modu devre dışı&quot;,
                gameSaved: &quot;Oyun kaydedildi!&quot;,
                gameLoaded: &quot;Oyun yüklendi!&quot;,
                loadSavedGame: &quot;Kayıtlı oyunu yüklemek istiyor musunuz?&quot;,
                welcome: &quot;Brainova Kuantum Satranç&#x27;a hoş geldiniz! Oyun modunuzu seçin.&quot;,
                aiCalculating: &quot;Kuantum AI en iyi hamleyi hesaplıyor...&quot;,
                undoInDevelopment: &quot;Geri alma işlevi geliştiriliyor&quot;,
                aiAnalyzing: &quot;AI analizi devam ediyor...&quot;,
                bestMovesCalculating: &quot;En iyi hamleler hesaplanıyor...&quot;,
                suggestion: &quot;Öneri:&quot;,
                noMovesAvailable: &quot;Mevcut hamle yok&quot;,
                difficultyChanged: &quot;Zorluk değiştirildi:&quot;,
                whiteAdvantage: &quot;Beyaz&#x27;ın önemli avantajı&quot;,
                blackAdvantage: &quot;Siyah&#x27;ın önemli avantajı&quot;,
                slightWhiteAdvantage: &quot;Beyaz&#x27;ın hafif avantajı&quot;,
                slightBlackAdvantage: &quot;Siyah&#x27;ın hafif avantajı&quot;,
                balancedPosition: &quot;Dengeli pozisyon&quot;,
                victory: &quot;Zafer:&quot;,
                whites: &quot;Beyaz&quot;,
                blacks: &quot;Siyah&quot;,
                difficulties: {
                    easy: &quot;kolay&quot;,
                    normal: &quot;normal&quot;,
                    hard: &quot;zor&quot;,
                    expert: &quot;uzman&quot;
                }
            },
            zh: {
                gameTitle: &quot;脑诺瓦量子象棋&quot;,
                quantumBadge: &quot;🚀 量子人工智能&quot;,
                controlsTitle: &quot;🎮 量子控制&quot;,
                aiMoveText: &quot;量子AI走棋&quot;,
                undoText: &quot;撤销走棋&quot;,
                quantumModeText: &quot;量子模式&quot;,
                newGameText: &quot;新游戏&quot;,
                statsTitle: &quot;📊 统计数据&quot;,
                movesLabel: &quot;已走步数&quot;,
                aiLevelLabel: &quot;AI等级&quot;,
                timeLabel: &quot;时间&quot;,
                scoreLabel: &quot;得分&quot;,
                aiModeText: &quot;对战AI&quot;,
                humanModeText: &quot;双人对战&quot;,
                gameStatus: &quot;新游戏 - 白方先行&quot;,
                playerWhite: &quot;白方玩家&quot;,
                playerBlack: &quot;黑方玩家&quot;,
                aiPlayer: &quot;量子AI&quot;,
                historyTitle: &quot;📜 历史记录&quot;,
                gameStarted: &quot;游戏开始&quot;,
                optionsTitle: &quot;⚙️ AI选项&quot;,
                difficultyText: &quot;难度：专家&quot;,
                analysisText: &quot;AI分析&quot;,
                hintText: &quot;最佳走法&quot;,
                saveText: &quot;保存游戏&quot;,
                aiThinking: &quot;量子AI分析中...&quot;,
                closeBtn: &quot;关闭&quot;,
                turnOf: &quot;轮到&quot;,
                gameEnded: &quot;游戏结束&quot;,
                newGameStarted: &quot;新游戏开始&quot;,
                quantumActivated: &quot;量子模式已激活！棋子可以瞬移！&quot;,
                quantumDeactivated: &quot;量子模式已关闭&quot;,
                gameSaved: &quot;游戏已保存！&quot;,
                gameLoaded: &quot;游戏已加载！&quot;,
                loadSavedGame: &quot;您要加载保存的游戏吗？&quot;,
                welcome: &quot;欢迎来到脑诺瓦量子象棋！选择您的游戏模式。&quot;,
                aiCalculating: &quot;量子AI正在计算最佳走法...&quot;,
                undoInDevelopment: &quot;撤销功能开发中&quot;,
                aiAnalyzing: &quot;AI分析进行中...&quot;,
                bestMovesCalculating: &quot;计算最佳走法中...&quot;,
                suggestion: &quot;建议：&quot;,
                noMovesAvailable: &quot;无可用走法&quot;,
                difficultyChanged: &quot;难度已更改：&quot;,
                whiteAdvantage: &quot;白方显著优势&quot;,
                blackAdvantage: &quot;黑方显著优势&quot;,
                slightWhiteAdvantage: &quot;白方轻微优势&quot;,
                slightBlackAdvantage: &quot;黑方轻微优势&quot;,
                balancedPosition: &quot;平衡局面&quot;,
                victory: &quot;获胜方&quot;,
                whites: &quot;白方&quot;,
                blacks: &quot;黑方&quot;,
                difficulties: {
                    easy: &quot;简单&quot;,
                    normal: &quot;普通&quot;,
                    hard: &quot;困难&quot;,
                    expert: &quot;专家&quot;
                },
                pauseText: &quot;⏸️ 暂停&quot;,
                resumeText: &quot;▶️ 继续&quot;,
                gamePaused: &quot;游戏已暂停&quot;,
                gameResumed: &quot;游戏已继续&quot;
            },
            it: {
                gameTitle: &quot;Brainova Scacchi Quantici&quot;,
                quantumBadge: &quot;🚀 IA QUANTICA&quot;,
                controlsTitle: &quot;🎮 Controlli Quantici&quot;,
                aiMoveText: &quot;Mossa IA Quantica&quot;,
                undoText: &quot;Annulla Mossa&quot;,
                quantumModeText: &quot;Modalità Quantica&quot;,
                newGameText: &quot;Nuova Partita&quot;,
                statsTitle: &quot;📊 Statistiche&quot;,
                movesLabel: &quot;Mosse Giocate&quot;,
                aiLevelLabel: &quot;Livello IA&quot;,
                timeLabel: &quot;Tempo&quot;,
                scoreLabel: &quot;Punteggio&quot;,
                aiModeText: &quot;Gioca vs IA&quot;,
                humanModeText: &quot;2 Giocatori&quot;,
                gameStatus: &quot;Nuova partita - Bianco inizia&quot;,
                playerWhite: &quot;Giocatore Bianco&quot;,
                playerBlack: &quot;Giocatore Nero&quot;,
                aiPlayer: &quot;IA Quantica&quot;,
                historyTitle: &quot;📜 Cronologia&quot;,
                gameStarted: &quot;Partita iniziata&quot;,
                optionsTitle: &quot;⚙️ Opzioni IA&quot;,
                difficultyText: &quot;Difficoltà: Esperto&quot;,
                analysisText: &quot;Analisi IA&quot;,
                hintText: &quot;Migliori Mosse&quot;,
                saveText: &quot;Salva Partita&quot;,
                aiThinking: &quot;IA Quantica in analisi...&quot;,
                closeBtn: &quot;Chiudi&quot;,
                turnOf: &quot;Turno di&quot;,
                gameEnded: &quot;Partita terminata&quot;,
                newGameStarted: &quot;Nuova partita iniziata&quot;,
                quantumActivated: &quot;Modalità Quantica attivata! I pezzi possono teletrasportarsi!&quot;,
                quantumDeactivated: &quot;Modalità Quantica disattivata&quot;,
                gameSaved: &quot;Partita salvata!&quot;,
                gameLoaded: &quot;Partita caricata!&quot;,
                loadSavedGame: &quot;Vuoi caricare la partita salvata?&quot;,
                welcome: &quot;Benvenuto in Brainova Scacchi Quantici! Scegli la modalità di gioco.&quot;,
                aiCalculating: &quot;IA Quantica calcola la mossa migliore...&quot;,
                undoInDevelopment: &quot;Funzione annulla in sviluppo&quot;,
                aiAnalyzing: &quot;Analisi IA in corso...&quot;,
                bestMovesCalculating: &quot;Calcolo migliori mosse...&quot;,
                suggestion: &quot;Suggerimento:&quot;,
                noMovesAvailable: &quot;Nessuna mossa disponibile&quot;,
                difficultyChanged: &quot;Difficoltà cambiata:&quot;,
                whiteAdvantage: &quot;Vantaggio significativo al Bianco&quot;,
                blackAdvantage: &quot;Vantaggio significativo al Nero&quot;,
                slightWhiteAdvantage: &quot;Leggero vantaggio al Bianco&quot;,
                slightBlackAdvantage: &quot;Leggero vantaggio al Nero&quot;,
                balancedPosition: &quot;Posizione equilibrata&quot;,
                victory: &quot;Vittoria del&quot;,
                whites: &quot;Bianco&quot;,
                blacks: &quot;Nero&quot;,
                difficulties: {
                    easy: &quot;facile&quot;,
                    normal: &quot;normale&quot;,
                    hard: &quot;difficile&quot;,
                    expert: &quot;esperto&quot;
                }
            },
            pt: {
                gameTitle: &quot;Brainova Xadrez Quântico&quot;,
                quantumBadge: &quot;🚀 IA QUÂNTICA&quot;,
                controlsTitle: &quot;🎮 Controles Quânticos&quot;,
                aiMoveText: &quot;Jogada IA Quântica&quot;,
                undoText: &quot;Desfazer Jogada&quot;,
                quantumModeText: &quot;Modo Quântico&quot;,
                newGameText: &quot;Nova Partida&quot;,
                statsTitle: &quot;📊 Estatísticas&quot;,
                movesLabel: &quot;Jogadas Feitas&quot;,
                aiLevelLabel: &quot;Nível IA&quot;,
                timeLabel: &quot;Tempo&quot;,
                scoreLabel: &quot;Pontuação&quot;,
                aiModeText: &quot;Jogar vs IA&quot;,
                humanModeText: &quot;2 Jogadores&quot;,
                gameStatus: &quot;Nova partida - Brancas começam&quot;,
                playerWhite: &quot;Jogador Branco&quot;,
                playerBlack: &quot;Jogador Preto&quot;,
                aiPlayer: &quot;IA Quântica&quot;,
                historyTitle: &quot;📜 Histórico&quot;,
                gameStarted: &quot;Partida iniciada&quot;,
                optionsTitle: &quot;⚙️ Opções IA&quot;,
                difficultyText: &quot;Dificuldade: Especialista&quot;,
                analysisText: &quot;Análise IA&quot;,
                hintText: &quot;Melhores Jogadas&quot;,
                saveText: &quot;Salvar Partida&quot;,
                aiThinking: &quot;IA Quântica analisando...&quot;,
                closeBtn: &quot;Fechar&quot;,
                turnOf: &quot;Vez do&quot;,
                gameEnded: &quot;Partida terminada&quot;,
                newGameStarted: &quot;Nova partida iniciada&quot;,
                quantumActivated: &quot;Modo Quântico ativado! As peças podem se teletransportar!&quot;,
                quantumDeactivated: &quot;Modo Quântico desativado&quot;,
                gameSaved: &quot;Partida salva!&quot;,
                gameLoaded: &quot;Partida carregada!&quot;,
                loadSavedGame: &quot;Deseja carregar a partida salva?&quot;,
                welcome: &quot;Bem-vindo ao Brainova Xadrez Quântico! Escolha seu modo de jogo.&quot;,
                aiCalculating: &quot;IA Quântica calculando melhor jogada...&quot;,
                undoInDevelopment: &quot;Função desfazer em desenvolvimento&quot;,
                aiAnalyzing: &quot;Análise IA em progresso...&quot;,
                bestMovesCalculating: &quot;Calculando melhores jogadas...&quot;,
                suggestion: &quot;Sugestão:&quot;,
                noMovesAvailable: &quot;Nenhuma jogada disponível&quot;,
                difficultyChanged: &quot;Dificuldade alterada:&quot;,
                whiteAdvantage: &quot;Vantagem significativa para as Brancas&quot;,
                blackAdvantage: &quot;Vantagem significativa para as Pretas&quot;,
                slightWhiteAdvantage: &quot;Ligeira vantagem para as Brancas&quot;,
                slightBlackAdvantage: &quot;Ligeira vantagem para as Pretas&quot;,
                balancedPosition: &quot;Posição equilibrada&quot;,
                victory: &quot;Vitória das&quot;,
                whites: &quot;Brancas&quot;,
                blacks: &quot;Pretas&quot;,
                difficulties: {
                    easy: &quot;fácil&quot;,
                    normal: &quot;normal&quot;,
                    hard: &quot;difícil&quot;,
                    expert: &quot;especialista&quot;
                }
            },
            ru: {
                gameTitle: &quot;Brainova Квантовые Шахматы&quot;,
                quantumBadge: &quot;🚀 КВАНТОВЫЙ ИИ&quot;,
                controlsTitle: &quot;🎮 Квантовое Управление&quot;,
                aiMoveText: &quot;Ход Квантового ИИ&quot;,
                undoText: &quot;Отменить Ход&quot;,
                quantumModeText: &quot;Квантовый Режим&quot;,
                newGameText: &quot;Новая Игра&quot;,
                statsTitle: &quot;📊 Статистика&quot;,
                movesLabel: &quot;Сделано Ходов&quot;,
                aiLevelLabel: &quot;Уровень ИИ&quot;,
                timeLabel: &quot;Время&quot;,
                scoreLabel: &quot;Счёт&quot;,
                aiModeText: &quot;Играть против ИИ&quot;,
                humanModeText: &quot;2 Игрока&quot;,
                gameStatus: &quot;Новая игра - Белые начинают&quot;,
                playerWhite: &quot;Белый Игрок&quot;,
                playerBlack: &quot;Чёрный Игрок&quot;,
                aiPlayer: &quot;Квантовый ИИ&quot;,
                historyTitle: &quot;📜 История&quot;,
                gameStarted: &quot;Игра началась&quot;,
                optionsTitle: &quot;⚙️ Настройки ИИ&quot;,
                difficultyText: &quot;Сложность: Эксперт&quot;,
                analysisText: &quot;Анализ ИИ&quot;,
                hintText: &quot;Лучшие Ходы&quot;,
                saveText: &quot;Сохранить Игру&quot;,
                aiThinking: &quot;Квантовый ИИ анализирует...&quot;,
                closeBtn: &quot;Закрыть&quot;,
                turnOf: &quot;Ход&quot;,
                gameEnded: &quot;Игра окончена&quot;,
                newGameStarted: &quot;Новая игра началась&quot;,
                quantumActivated: &quot;Квантовый режим активирован! Фигуры могут телепортироваться!&quot;,
                quantumDeactivated: &quot;Квантовый режим отключён&quot;,
                gameSaved: &quot;Игра сохранена!&quot;,
                gameLoaded: &quot;Игра загружена!&quot;,
                loadSavedGame: &quot;Хотите загрузить сохранённую игру?&quot;,
                welcome: &quot;Добро пожаловать в Brainova Квантовые Шахматы! Выберите режим игры.&quot;,
                aiCalculating: &quot;Квантовый ИИ вычисляет лучший ход...&quot;,
                undoInDevelopment: &quot;Функция отмены в разработке&quot;,
                aiAnalyzing: &quot;Анализ ИИ в процессе...&quot;,
                bestMovesCalculating: &quot;Вычисление лучших ходов...&quot;,
                suggestion: &quot;Предложение:&quot;,
                noMovesAvailable: &quot;Нет доступных ходов&quot;,
                difficultyChanged: &quot;Сложность изменена:&quot;,
                whiteAdvantage: &quot;Значительное преимущество у Белых&quot;,
                blackAdvantage: &quot;Значительное преимущество у Чёрных&quot;,
                slightWhiteAdvantage: &quot;Небольшое преимущество у Белых&quot;,
                slightBlackAdvantage: &quot;Небольшое преимущество у Чёрных&quot;,
                balancedPosition: &quot;Сбалансированная позиция&quot;,
                victory: &quot;Победа&quot;,
                whites: &quot;Белых&quot;,
                blacks: &quot;Чёрных&quot;,
                difficulties: {
                    easy: &quot;лёгкий&quot;,
                    normal: &quot;обычный&quot;,
                    hard: &quot;сложный&quot;,
                    expert: &quot;эксперт&quot;
                }
            },
            ja: {
                gameTitle: &quot;ブレイノバ量子チェス&quot;,
                quantumBadge: &quot;🚀 量子AI&quot;,
                controlsTitle: &quot;🎮 量子コントロール&quot;,
                aiMoveText: &quot;量子AI指し手&quot;,
                undoText: &quot;手を戻す&quot;,
                quantumModeText: &quot;量子モード&quot;,
                newGameText: &quot;新しいゲーム&quot;,
                statsTitle: &quot;📊 統計&quot;,
                movesLabel: &quot;指し手数&quot;,
                aiLevelLabel: &quot;AIレベル&quot;,
                timeLabel: &quot;時間&quot;,
                scoreLabel: &quot;スコア&quot;,
                aiModeText: &quot;AI対戦&quot;,
                humanModeText: &quot;2プレイヤー&quot;,
                gameStatus: &quot;新しいゲーム - 白番開始&quot;,
                playerWhite: &quot;白プレイヤー&quot;,
                playerBlack: &quot;黒プレイヤー&quot;,
                aiPlayer: &quot;量子AI&quot;,
                historyTitle: &quot;📜 履歴&quot;,
                gameStarted: &quot;ゲーム開始&quot;,
                optionsTitle: &quot;⚙️ AIオプション&quot;,
                difficultyText: &quot;難易度：エキスパート&quot;,
                analysisText: &quot;AI分析&quot;,
                hintText: &quot;最善手&quot;,
                saveText: &quot;ゲーム保存&quot;,
                aiThinking: &quot;量子AI分析中...&quot;,
                closeBtn: &quot;閉じる&quot;,
                turnOf: &quot;手番&quot;,
                gameEnded: &quot;ゲーム終了&quot;,
                newGameStarted: &quot;新しいゲームが始まりました&quot;,
                quantumActivated: &quot;量子モード有効！駒がテレポートできます！&quot;,
                quantumDeactivated: &quot;量子モード無効&quot;,
                gameSaved: &quot;ゲーム保存完了！&quot;,
                gameLoaded: &quot;ゲーム読み込み完了！&quot;,
                loadSavedGame: &quot;保存されたゲームを読み込みますか？&quot;,
                welcome: &quot;ブレイノバ量子チェスへようこそ！ゲームモードを選択してください。&quot;,
                aiCalculating: &quot;量子AIが最善手を計算中...&quot;,
                undoInDevelopment: &quot;取り消し機能は開発中&quot;,
                aiAnalyzing: &quot;AI分析進行中...&quot;,
                bestMovesCalculating: &quot;最善手計算中...&quot;,
                suggestion: &quot;提案：&quot;,
                noMovesAvailable: &quot;利用可能な手がありません&quot;,
                difficultyChanged: &quot;難易度変更：&quot;,
                whiteAdvantage: &quot;白の大きな優勢&quot;,
                blackAdvantage: &quot;黒の大きな優勢&quot;,
                slightWhiteAdvantage: &quot;白のわずかな優勢&quot;,
                slightBlackAdvantage: &quot;黒のわずかな優勢&quot;,
                balancedPosition: &quot;均衡した局面&quot;,
                victory: &quot;勝利&quot;,
                whites: &quot;白&quot;,
                blacks: &quot;黒&quot;,
                difficulties: {
                    easy: &quot;簡単&quot;,
                    normal: &quot;普通&quot;,
                    hard: &quot;難しい&quot;,
                    expert: &quot;エキスパート&quot;
                }
            },
            ko: {
                gameTitle: &quot;브레이노바 양자 체스&quot;,
                quantumBadge: &quot;🚀 양자 AI&quot;,
                controlsTitle: &quot;🎮 양자 컨트롤&quot;,
                aiMoveText: &quot;양자 AI 수&quot;,
                undoText: &quot;수 되돌리기&quot;,
                quantumModeText: &quot;양자 모드&quot;,
                newGameText: &quot;새 게임&quot;,
                statsTitle: &quot;📊 통계&quot;,
                movesLabel: &quot;플레이한 수&quot;,
                aiLevelLabel: &quot;AI 레벨&quot;,
                timeLabel: &quot;시간&quot;,
                scoreLabel: &quot;점수&quot;,
                aiModeText: &quot;AI 대전&quot;,
                humanModeText: &quot;2인 플레이&quot;,
                gameStatus: &quot;새 게임 - 백이 시작&quot;,
                playerWhite: &quot;백 플레이어&quot;,
                playerBlack: &quot;흑 플레이어&quot;,
                aiPlayer: &quot;양자 AI&quot;,
                historyTitle: &quot;📜 기록&quot;,
                gameStarted: &quot;게임 시작&quot;,
                optionsTitle: &quot;⚙️ AI 옵션&quot;,
                difficultyText: &quot;난이도: 전문가&quot;,
                analysisText: &quot;AI 분석&quot;,
                hintText: &quot;최선의 수&quot;,
                saveText: &quot;게임 저장&quot;,
                aiThinking: &quot;양자 AI 분석 중...&quot;,
                closeBtn: &quot;닫기&quot;,
                turnOf: &quot;차례&quot;,
                gameEnded: &quot;게임 종료&quot;,
                newGameStarted: &quot;새 게임이 시작되었습니다&quot;,
                quantumActivated: &quot;양자 모드 활성화! 기물이 순간이동할 수 있습니다!&quot;,
                quantumDeactivated: &quot;양자 모드 비활성화&quot;,
                gameSaved: &quot;게임 저장 완료!&quot;,
                gameLoaded: &quot;게임 로드 완료!&quot;,
                loadSavedGame: &quot;저장된 게임을 로드하시겠습니까?&quot;,
                welcome: &quot;브레이노바 양자 체스에 오신 것을 환영합니다! 게임 모드를 선택하세요.&quot;,
                aiCalculating: &quot;양자 AI가 최선의 수를 계산 중...&quot;,
                undoInDevelopment: &quot;되돌리기 기능 개발 중&quot;,
                aiAnalyzing: &quot;AI 분석 진행 중...&quot;,
                bestMovesCalculating: &quot;최선의 수 계산 중...&quot;,
                suggestion: &quot;제안:&quot;,
                noMovesAvailable: &quot;사용 가능한 수가 없습니다&quot;,
                difficultyChanged: &quot;난이도 변경:&quot;,
                whiteAdvantage: &quot;백의 상당한 우세&quot;,
                blackAdvantage: &quot;흑의 상당한 우세&quot;,
                slightWhiteAdvantage: &quot;백의 약간의 우세&quot;,
                slightBlackAdvantage: &quot;흑의 약간의 우세&quot;,
                balancedPosition: &quot;균형잡힌 포지션&quot;,
                victory: &quot;승리&quot;,
                whites: &quot;백&quot;,
                blacks: &quot;흑&quot;,
                difficulties: {
                    easy: &quot;쉬움&quot;,
                    normal: &quot;보통&quot;,
                    hard: &quot;어려움&quot;,
                    expert: &quot;전문가&quot;
                }
            },
            hi: {
                gameTitle: &quot;ब्रेनोवा क्वांटम शतरंज&quot;,
                quantumBadge: &quot;🚀 क्वांटम AI&quot;,
                controlsTitle: &quot;🎮 क्वांटम नियंत्रण&quot;,
                aiMoveText: &quot;क्वांटम AI चाल&quot;,
                undoText: &quot;चाल वापस करें&quot;,
                quantumModeText: &quot;क्वांटम मोड&quot;,
                newGameText: &quot;नया खेल&quot;,
                statsTitle: &quot;📊 आंकड़े&quot;,
                movesLabel: &quot;खेली गई चालें&quot;,
                aiLevelLabel: &quot;AI स्तर&quot;,
                timeLabel: &quot;समय&quot;,
                scoreLabel: &quot;स्कोर&quot;,
                aiModeText: &quot;AI के विरुद्ध खेलें&quot;,
                humanModeText: &quot;2 खिलाड़ी&quot;,
                gameStatus: &quot;नया खेल - सफेद शुरू करता है&quot;,
                playerWhite: &quot;सफेद खिलाड़ी&quot;,
                playerBlack: &quot;काला खिलाड़ी&quot;,
                aiPlayer: &quot;क्वांटम AI&quot;,
                historyTitle: &quot;📜 इतिहास&quot;,
                gameStarted: &quot;खेल शुरू हुआ&quot;,
                optionsTitle: &quot;⚙️ AI विकल्प&quot;,
                difficultyText: &quot;कठिनाई: विशेषज्ञ&quot;,
                analysisText: &quot;AI विश्लेषण&quot;,
                hintText: &quot;सर्वोत्तम चालें&quot;,
                saveText: &quot;खेल सहेजें&quot;,
                aiThinking: &quot;क्वांटम AI विश्लेषण कर रहा है...&quot;,
                closeBtn: &quot;बंद करें&quot;,
                turnOf: &quot;की बारी&quot;,
                gameEnded: &quot;खेल समाप्त&quot;,
                newGameStarted: &quot;नया खेल शुरू हुआ&quot;,
                quantumActivated: &quot;क्वांटम मोड सक्रिय! मोहरे टेलीपोर्ट कर सकते हैं!&quot;,
                quantumDeactivated: &quot;क्वांटम मोड निष्क्रिय&quot;,
                gameSaved: &quot;खेल सहेजा गया!&quot;,
                gameLoaded: &quot;खेल लोड किया गया!&quot;,
                loadSavedGame: &quot;क्या आप सहेजा गया खेल लोड करना चाहते हैं?&quot;,
                welcome: &quot;ब्रेनोवा क्वांटम शतरंज में आपका स्वागत है! अपना खेल मोड चुनें।&quot;,
                aiCalculating: &quot;क्वांटम AI सर्वोत्तम चाल की गणना कर रहा है...&quot;,
                undoInDevelopment: &quot;वापसी फ़ंक्शन विकास में है&quot;,
                aiAnalyzing: &quot;AI विश्लेषण प्रगति में...&quot;,
                bestMovesCalculating: &quot;सर्वोत्तम चालों की गणना...&quot;,
                suggestion: &quot;सुझाव:&quot;,
                noMovesAvailable: &quot;कोई चाल उपलब्ध नहीं&quot;,
                difficultyChanged: &quot;कठिनाई बदली गई:&quot;,
                whiteAdvantage: &quot;सफेद का महत्वपूर्ण फायदा&quot;,
                blackAdvantage: &quot;काले का महत्वपूर्ण फायदा&quot;,
                slightWhiteAdvantage: &quot;सफेद का थोड़ा फायदा&quot;,
                slightBlackAdvantage: &quot;काले का थोड़ा फायदा&quot;,
                balancedPosition: &quot;संतुलित स्थिति&quot;,
                victory: &quot;जीत&quot;,
                whites: &quot;सफेद&quot;,
                blacks: &quot;काला&quot;,
                difficulties: {
                    easy: &quot;आसान&quot;,
                    normal: &quot;सामान्य&quot;,
                    hard: &quot;कठिन&quot;,
                    expert: &quot;विशेषज्ञ&quot;
                }
            }
        };

        // État du jeu
    var gameState = {
            board: [],
            currentPlayer: &#x27;white&#x27;,
            gameMode: &#x27;ai&#x27;, // &#x27;ai&#x27; ou &#x27;human&#x27;
            selectedSquare: null,
            possibleMoves: [],
            moveHistory: [],
            moveCount: 0,
            startTime: null,
            timer: null,
            aiLevel: 5,
            score: 0,
            isGameActive: true,
            quantumMode: false,
            aiThinking: false,
            difficulty: &#x27;expert&#x27;,
            capturedPieces: { white: [], black: [] },
            currentLanguage: &#x27;fr&#x27;,
            isPaused: false
        };

        // Définition des pièces d&#x27;échecs
        const chessPieces = {
            white: {
                king: &#x27;♔&#x27;,
                queen: &#x27;♕&#x27;,
                rook: &#x27;♖&#x27;,
                bishop: &#x27;♗&#x27;,
                knight: &#x27;♘&#x27;,
                pawn: &#x27;♙&#x27;
            },
            black: {
                king: &#x27;♚&#x27;,
                queen: &#x27;♛&#x27;,
                rook: &#x27;♜&#x27;,
                bishop: &#x27;♝&#x27;,
                knight: &#x27;♞&#x27;,
                pawn: &#x27;♟&#x27;
            }
        };

        // Position initiale des pièces
        const initialBoard = [
            [&#x27;♜&#x27;, &#x27;♞&#x27;, &#x27;♝&#x27;, &#x27;♛&#x27;, &#x27;♚&#x27;, &#x27;♝&#x27;, &#x27;♞&#x27;, &#x27;♜&#x27;],
            [&#x27;♟&#x27;, &#x27;♟&#x27;, &#x27;♟&#x27;, &#x27;♟&#x27;, &#x27;♟&#x27;, &#x27;♟&#x27;, &#x27;♟&#x27;, &#x27;♟&#x27;],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            [&#x27;♙&#x27;, &#x27;♙&#x27;, &#x27;♙&#x27;, &#x27;♙&#x27;, &#x27;♙&#x27;, &#x27;♙&#x27;, &#x27;♙&#x27;, &#x27;♙&#x27;],
            [&#x27;♖&#x27;, &#x27;♘&#x27;, &#x27;♗&#x27;, &#x27;♕&#x27;, &#x27;♔&#x27;, &#x27;♗&#x27;, &#x27;♘&#x27;, &#x27;♖&#x27;]
        ];

        // Fonction de changement de langue
        function changeLanguage() {
            const selector = document.getElementById(&#x27;languageSelector&#x27;);
            const selectedLang = selector.value;
            gameState.currentLanguage = selectedLang;
            
            const t = translations[selectedLang];
            
            // Mettre à jour tous les textes
            document.getElementById(&#x27;gameTitle&#x27;).textContent = t.gameTitle;
            document.getElementById(&#x27;quantumBadge&#x27;).textContent = t.quantumBadge;
            document.getElementById(&#x27;controlsTitle&#x27;).textContent = t.controlsTitle;
            document.getElementById(&#x27;aiMoveText&#x27;).textContent = t.aiMoveText;
            document.getElementById(&#x27;undoText&#x27;).textContent = t.undoText;
            document.getElementById(&#x27;quantumModeText&#x27;).textContent = t.quantumModeText;
            document.getElementById(&#x27;newGameText&#x27;).textContent = t.newGameText;
            document.getElementById(&#x27;statsTitle&#x27;).textContent = t.statsTitle;
            document.getElementById(&#x27;movesLabel&#x27;).textContent = t.movesLabel;
            document.getElementById(&#x27;aiLevelLabel&#x27;).textContent = t.aiLevelLabel;
            document.getElementById(&#x27;timeLabel&#x27;).textContent = t.timeLabel;
            document.getElementById(&#x27;scoreLabel&#x27;).textContent = t.scoreLabel;
            document.getElementById(&#x27;aiModeText&#x27;).textContent = t.aiModeText;
            document.getElementById(&#x27;humanModeText&#x27;).textContent = t.humanModeText;
            document.getElementById(&#x27;historyTitle&#x27;).textContent = t.historyTitle;
            document.getElementById(&#x27;gameModeTitle&#x27;).textContent = t.gameModeTitle;
            document.getElementById(&#x27;optionsTitle&#x27;).textContent = t.optionsTitle;
            document.getElementById(&#x27;analysisText&#x27;).textContent = t.analysisText;
            document.getElementById(&#x27;hintText&#x27;).textContent = t.hintText;
            document.getElementById(&#x27;saveText&#x27;).textContent = t.saveText;
            document.getElementById(&#x27;closeBtn&#x27;).title = t.closeBtn;
            
            // Mettre à jour le bouton pause
            const pauseText = gameState.isPaused ? t.resumeText : t.pauseText;
            document.getElementById(&#x27;pauseText&#x27;).textContent = pauseText;
            
            // Mettre à jour le texte de difficulté
            const diffText = t.difficultyText.replace(&#x27;Expert&#x27;, t.difficulties[gameState.difficulty]);
            document.getElementById(&#x27;difficultyText&#x27;).textContent = diffText;
            
            // Mettre à jour le message &quot;Partie commencée&quot; dans l&#x27;historique
            const gameStartedElement = document.getElementById(&#x27;gameStarted&#x27;);
            if(gameStartedElement) {
                gameStartedElement.textContent = t.gameStarted;
            }
            
            updateUI();
        }

        // Créer les particules quantiques
        function createQuantumParticles() {
            const container = document.getElementById(&#x27;quantumParticles&#x27;);
            
            for(let i = 0; i &lt; 30; i++) {
                const particle = document.createElement(&#x27;div&#x27;);
                particle.className = &#x27;quantum-particle&#x27;;
                particle.style.left = Math.random() * 100 + &#x27;%&#x27;;
                particle.style.animationDelay = Math.random() * 12 + &#x27;s&#x27;;
                particle.style.animationDuration = (12 + Math.random() * 6) + &#x27;s&#x27;;
                container.appendChild(particle);
            }
        }

        // Créer les lignes d&#x27;énergie
        function createEnergyLines() {
            const container = document.getElementById(&#x27;energyLines&#x27;);
            
            for(let i = 0; i &lt; 8; i++) {
                const line = document.createElement(&#x27;div&#x27;);
                line.className = &#x27;energy-line&#x27;;
                line.style.top = Math.random() * 100 + &#x27;%&#x27;;
                line.style.width = (200 + Math.random() * 400) + &#x27;px&#x27;;
                line.style.animationDelay = Math.random() * 8 + &#x27;s&#x27;;
                line.style.animationDuration = (8 + Math.random() * 4) + &#x27;s&#x27;;
                container.appendChild(line);
            }
        }

        // Créer les cercles d&#x27;énergie
        function createEnergyCircles() {
            const container = document.getElementById(&#x27;energyCircles&#x27;);
            
            for(let i = 0; i &lt; 6; i++) {
                const circle = document.createElement(&#x27;div&#x27;);
                circle.className = &#x27;energy-circle&#x27;;
                circle.style.left = Math.random() * 100 + &#x27;%&#x27;;
                circle.style.top = Math.random() * 100 + &#x27;%&#x27;;
                circle.style.width = (50 + Math.random() * 100) + &#x27;px&#x27;;
                circle.style.height = circle.style.width;
                circle.style.animationDelay = Math.random() * 6 + &#x27;s&#x27;;
                circle.style.animationDuration = (6 + Math.random() * 3) + &#x27;s&#x27;;
                container.appendChild(circle);
            }
        }

        // Créer les vagues d&#x27;énergie
        function createEnergyWaves() {
            const container = document.getElementById(&#x27;energyWaves&#x27;);
            
            for(let i = 0; i &lt; 3; i++) {
                const wave = document.createElement(&#x27;div&#x27;);
                wave.className = &#x27;energy-wave&#x27;;
                wave.style.animationDelay = i * 5 + &#x27;s&#x27;;
                wave.style.animationDuration = (15 + Math.random() * 5) + &#x27;s&#x27;;
                container.appendChild(wave);
            }
        }

        // Créer les rayons laser
        function createLaserBeams() {
            const container = document.getElementById(&#x27;laserBeams&#x27;);
            
            for(let i = 0; i &lt; 4; i++) {
                const beam = document.createElement(&#x27;div&#x27;);
                beam.className = &#x27;laser-beam&#x27;;
                beam.style.left = Math.random() * 100 + &#x27;%&#x27;;
                beam.style.animationDelay = Math.random() * 12 + &#x27;s&#x27;;
                beam.style.animationDuration = (12 + Math.random() * 6) + &#x27;s&#x27;;
                container.appendChild(beam);
            }
        }

        // Créer les orbes d&#x27;énergie
        function createEnergyOrbs() {
            const container = document.getElementById(&#x27;energyOrbs&#x27;);
            
            for(let i = 0; i &lt; 10; i++) {
                const orb = document.createElement(&#x27;div&#x27;);
                orb.className = &#x27;energy-orb&#x27;;
                orb.style.left = Math.random() * 100 + &#x27;%&#x27;;
                orb.style.animationDelay = Math.random() * 18 + &#x27;s&#x27;;
                orb.style.animationDuration = (18 + Math.random() * 10) + &#x27;s&#x27;;
                container.appendChild(orb);
            }
        }

        // Initialiser tous les effets futuristes
        function initFuturisticEffects() {
            createQuantumParticles();
            createEnergyLines();
            createEnergyCircles();
            createEnergyWaves();
            createLaserBeams();
            createEnergyOrbs();
        }

        // Initialiser le jeu
        function initGame() {
            gameState.board = initialBoard.map(row =&gt; [...row]);
            gameState.currentPlayer = &#x27;white&#x27;;
            gameState.selectedSquare = null;
            gameState.possibleMoves = [];
            gameState.moveHistory = [];
            gameState.moveCount = 0;
            gameState.startTime = Date.now();
            gameState.isGameActive = true;
            gameState.quantumMode = false;
            
            createChessboard();
            updateUI();
            startTimer();
            
            const t = translations[gameState.currentLanguage];
            
            // Vider l&#x27;historique et ajouter le message de début
            const historyElement = document.getElementById(&#x27;moveHistory&#x27;);
            historyElement.innerHTML = &#x27;&#x27;;
            const gameStartedElement = document.createElement(&#x27;div&#x27;);
            gameStartedElement.className = &#x27;move-item&#x27;;
            gameStartedElement.id = &#x27;gameStarted&#x27;;
            gameStartedElement.textContent = t.gameStarted;
            historyElement.appendChild(gameStartedElement);
        }

        // Créer le plateau d&#x27;échecs
        function createChessboard() {
            const chessboard = document.getElementById(&#x27;chessboard&#x27;);
            chessboard.innerHTML = &#x27;&#x27;;
            
            for(let row = 0; row &lt; 8; row++) {
                for(let col = 0; col &lt; 8; col++) {
                    const square = document.createElement(&#x27;div&#x27;);
                    square.className = `chess-square ${(row + col) % 2 === 0 ? &#x27;light&#x27; : &#x27;dark&#x27;}`;
                    square.dataset.row = row;
                    square.dataset.col = col;
                    square.onclick = () =&gt; handleSquareClick(row, col);
                    
                    const piece = gameState.board[row][col];
                    if(piece) {
                        const pieceElement = document.createElement(&#x27;div&#x27;);
                        pieceElement.className = `chess-piece ${getPieceColor(piece)}`;
                        pieceElement.textContent = piece;
                        square.appendChild(pieceElement);
                    }
                    
                    chessboard.appendChild(square);
                }
            }
        }

        // Obtenir la couleur d&#x27;une pièce
        function getPieceColor(piece) {
            const whitePieces = [&#x27;♔&#x27;, &#x27;♕&#x27;, &#x27;♖&#x27;, &#x27;♗&#x27;, &#x27;♘&#x27;, &#x27;♙&#x27;];
            return whitePieces.includes(piece) ? &#x27;white&#x27; : &#x27;black&#x27;;
        }

        // Gérer le clic sur une case
        function handleSquareClick(row, col) {
            if(!gameState.isGameActive || gameState.aiThinking || gameState.isPaused) return;
            
            const piece = gameState.board[row][col];
            const square = document.querySelector(`[data-row=&quot;${row}&quot;][data-col=&quot;${col}&quot;]`);
            
            // Si aucune pièce n&#x27;est sélectionnée
            if(!gameState.selectedSquare) {
                if(piece &amp;&amp; getPieceColor(piece) === gameState.currentPlayer) {
                    selectSquare(row, col);
                }
                return;
            }
            
            // Si on clique sur la même case
            if(gameState.selectedSquare.row === row &amp;&amp; gameState.selectedSquare.col === col) {
                deselectSquare();
                return;
            }
            
            // Si on clique sur une case de mouvement possible
            if(gameState.possibleMoves.some(move =&gt; move.row === row &amp;&amp; move.col === col)) {
                makeMove(gameState.selectedSquare.row, gameState.selectedSquare.col, row, col);
                return;
            }
            
            // Si on clique sur une autre pièce de la même couleur
            if(piece &amp;&amp; getPieceColor(piece) === gameState.currentPlayer) {
                deselectSquare();
                selectSquare(row, col);
                return;
            }
            
            // Sinon, désélectionner
            deselectSquare();
        }

        // Sélectionner une case
        function selectSquare(row, col) {
            gameState.selectedSquare = { row, col };
            gameState.possibleMoves = calculatePossibleMoves(row, col);
            
            // Mettre en évidence la case sélectionnée
            const square = document.querySelector(`[data-row=&quot;${row}&quot;][data-col=&quot;${col}&quot;]`);
            square.classList.add(&#x27;selected&#x27;);
            
            // Mettre en évidence les mouvements possibles
            gameState.possibleMoves.forEach(move =&gt; {
                const moveSquare = document.querySelector(`[data-row=&quot;${move.row}&quot;][data-col=&quot;${move.col}&quot;]`);
                moveSquare.classList.add(&#x27;possible-move&#x27;);
            });
        }

        // Désélectionner une case
        function deselectSquare() {
            if(gameState.selectedSquare) {
                const square = document.querySelector(`[data-row=&quot;${gameState.selectedSquare.row}&quot;][data-col=&quot;${gameState.selectedSquare.col}&quot;]`);
                square.classList.remove(&#x27;selected&#x27;);
            }
            
            // Enlever la mise en évidence des mouvements possibles
            document.querySelectorAll(&#x27;.possible-move&#x27;).forEach(square =&gt; {
                square.classList.remove(&#x27;possible-move&#x27;);
            });
            
            gameState.selectedSquare = null;
            gameState.possibleMoves = [];
        }

        // Calculer les mouvements possibles pour une pièce
        function calculatePossibleMoves(row, col) {
            const piece = gameState.board[row][col];
            if(!piece) return [];
            
            const moves = [];
            const pieceType = getPieceType(piece);
            const color = getPieceColor(piece);
            
            switch(pieceType) {
                case &#x27;pawn&#x27;:
                    moves.push(...calculatePawnMoves(row, col, color));
                    break;
                case &#x27;rook&#x27;:
                    moves.push(...calculateRookMoves(row, col, color));
                    break;
                case &#x27;bishop&#x27;:
                    moves.push(...calculateBishopMoves(row, col, color));
                    break;
                case &#x27;knight&#x27;:
                    moves.push(...calculateKnightMoves(row, col, color));
                    break;
                case &#x27;queen&#x27;:
                    moves.push(...calculateQueenMoves(row, col, color));
                    break;
                case &#x27;king&#x27;:
                    moves.push(...calculateKingMoves(row, col, color));
                    break;
            }
            
            return moves.filter(move =&gt; isValidMove(row, col, move.row, move.col));
        }

        // Obtenir le type d&#x27;une pièce
        function getPieceType(piece) {
            const pieceMap = {
                &#x27;♔&#x27;: &#x27;king&#x27;, &#x27;♚&#x27;: &#x27;king&#x27;,
                &#x27;♕&#x27;: &#x27;queen&#x27;, &#x27;♛&#x27;: &#x27;queen&#x27;,
                &#x27;♖&#x27;: &#x27;rook&#x27;, &#x27;♜&#x27;: &#x27;rook&#x27;,
                &#x27;♗&#x27;: &#x27;bishop&#x27;, &#x27;♝&#x27;: &#x27;bishop&#x27;,
                &#x27;♘&#x27;: &#x27;knight&#x27;, &#x27;♞&#x27;: &#x27;knight&#x27;,
                &#x27;♙&#x27;: &#x27;pawn&#x27;, &#x27;♟&#x27;: &#x27;pawn&#x27;
            };
            return pieceMap[piece];
        }

        // Calculer les mouvements du pion
        function calculatePawnMoves(row, col, color) {
            const moves = [];
            const direction = color === &#x27;white&#x27; ? -1 : 1;
            const startRow = color === &#x27;white&#x27; ? 6 : 1;
            
            // Mouvement vers l&#x27;avant
            if(row + direction &gt;= 0 &amp;&amp; row + direction &lt; 8 &amp;&amp; !gameState.board[row + direction][col]) {
                moves.push({ row: row + direction, col });
                
                // Double mouvement depuis la position initiale
                if(row === startRow &amp;&amp; !gameState.board[row + 2 * direction][col]) {
                    moves.push({ row: row + 2 * direction, col });
                }
            }
            
            // Captures en diagonale
            for(let dcol of [-1, 1]) {
                const newRow = row + direction;
                const newCol = col + dcol;
                if(newRow &gt;= 0 &amp;&amp; newRow &lt; 8 &amp;&amp; newCol &gt;= 0 &amp;&amp; newCol &lt; 8) {
                    const targetPiece = gameState.board[newRow][newCol];
                    if(targetPiece &amp;&amp; getPieceColor(targetPiece) !== color) {
                        moves.push({ row: newRow, col: newCol });
                    }
                }
            }
            
            return moves;
        }

        // Calculer les mouvements de la tour
        function calculateRookMoves(row, col, color) {
            const moves = [];
            const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];
            
            for(let [drow, dcol] of directions) {
                for(let i = 1; i &lt; 8; i++) {
                    const newRow = row + i * drow;
                    const newCol = col + i * dcol;
                    
                    if(newRow &lt; 0 || newRow &gt;= 8 || newCol &lt; 0 || newCol &gt;= 8) break;
                    
                    const targetPiece = gameState.board[newRow][newCol];
                    if(!targetPiece) {
                        moves.push({ row: newRow, col: newCol });
                    } else {
                        if(getPieceColor(targetPiece) !== color) {
                            moves.push({ row: newRow, col: newCol });
                        }
                        break;
                    }
                }
            }
            
            return moves;
        }

        // Calculer les mouvements du fou
        function calculateBishopMoves(row, col, color) {
            const moves = [];
            const directions = [[1, 1], [1, -1], [-1, 1], [-1, -1]];
            
            for(let [drow, dcol] of directions) {
                for(let i = 1; i &lt; 8; i++) {
                    const newRow = row + i * drow;
                    const newCol = col + i * dcol;
                    
                    if(newRow &lt; 0 || newRow &gt;= 8 || newCol &lt; 0 || newCol &gt;= 8) break;
                    
                    const targetPiece = gameState.board[newRow][newCol];
                    if(!targetPiece) {
                        moves.push({ row: newRow, col: newCol });
                    } else {
                        if(getPieceColor(targetPiece) !== color) {
                            moves.push({ row: newRow, col: newCol });
                        }
                        break;
                    }
                }
            }
            
            return moves;
        }

        // Calculer les mouvements du cavalier
        function calculateKnightMoves(row, col, color) {
            const moves = [];
            const knightMoves = [
                [-2, -1], [-2, 1], [-1, -2], [-1, 2],
                [1, -2], [1, 2], [2, -1], [2, 1]
            ];
            
            for(let [drow, dcol] of knightMoves) {
                const newRow = row + drow;
                const newCol = col + dcol;
                
                if(newRow &gt;= 0 &amp;&amp; newRow &lt; 8 &amp;&amp; newCol &gt;= 0 &amp;&amp; newCol &lt; 8) {
                    const targetPiece = gameState.board[newRow][newCol];
                    if(!targetPiece || getPieceColor(targetPiece) !== color) {
                        moves.push({ row: newRow, col: newCol });
                    }
                }
            }
            
            return moves;
        }

        // Calculer les mouvements de la reine
        function calculateQueenMoves(row, col, color) {
            return [
                ...calculateRookMoves(row, col, color),
                ...calculateBishopMoves(row, col, color)
            ];
        }

        // Calculer les mouvements du roi
        function calculateKingMoves(row, col, color) {
            const moves = [];
            const directions = [
                [-1, -1], [-1, 0], [-1, 1],
                [0, -1],           [0, 1],
                [1, -1],  [1, 0],  [1, 1]
            ];
            
            for(let [drow, dcol] of directions) {
                const newRow = row + drow;
                const newCol = col + dcol;
                
                if(newRow &gt;= 0 &amp;&amp; newRow &lt; 8 &amp;&amp; newCol &gt;= 0 &amp;&amp; newCol &lt; 8) {
                    const targetPiece = gameState.board[newRow][newCol];
                    if(!targetPiece || getPieceColor(targetPiece) !== color) {
                        moves.push({ row: newRow, col: newCol });
                    }
                }
            }
            
            return moves;
        }

        // Vérifier si un mouvement est valide
        function isValidMove(fromRow, fromCol, toRow, toCol) {
            // Vérifications de base
            if(toRow &lt; 0 || toRow &gt;= 8 || toCol &lt; 0 || toCol &gt;= 8) return false;
            
            const piece = gameState.board[fromRow][fromCol];
            const targetPiece = gameState.board[toRow][toCol];
            
            if(!piece) return false;
            if(targetPiece &amp;&amp; getPieceColor(piece) === getPieceColor(targetPiece)) return false;
            
            return true;
        }

        // Effectuer un mouvement
        function makeMove(fromRow, fromCol, toRow, toCol) {
            const piece = gameState.board[fromRow][fromCol];
            const capturedPiece = gameState.board[toRow][toCol];
            
            // Effectuer le mouvement
            gameState.board[toRow][toCol] = piece;
            gameState.board[fromRow][fromCol] = null;
            
            // Ajouter à l&#x27;historique
            const moveNotation = `${piece} ${String.fromCharCode(97 + fromCol)}${8 - fromRow} → ${String.fromCharCode(97 + toCol)}${8 - toRow}`;
            addMoveToHistory(moveNotation);
            
            // Gérer les captures
            if(capturedPiece) {
                const capturedColor = getPieceColor(capturedPiece);
                gameState.capturedPieces[capturedColor].push(capturedPiece);
                gameState.score += getPieceValue(capturedPiece);
            }
            
            gameState.moveCount++;
            deselectSquare();
            createChessboard();
            
            // Changer de joueur
            gameState.currentPlayer = gameState.currentPlayer === &#x27;white&#x27; ? &#x27;black&#x27; : &#x27;white&#x27;;
            
            // Vérifier la fin de partie
            if(isCheckmate() || isStalemate()) {
                endGame();
            } else {
                updateUI();
                
                // Si c&#x27;est le tour de l&#x27;IA
                if(gameState.gameMode === &#x27;ai&#x27; &amp;&amp; gameState.currentPlayer === &#x27;black&#x27;) {
                    setTimeout(() =&gt; makeAIMove(), 1000);
                }
            }
        }

        // Obtenir la valeur d&#x27;une pièce
        function getPieceValue(piece) {
            const values = {
                &#x27;♙&#x27;: 1, &#x27;♟&#x27;: 1,
                &#x27;♘&#x27;: 3, &#x27;♞&#x27;: 3,
                &#x27;♗&#x27;: 3, &#x27;♝&#x27;: 3,
                &#x27;♖&#x27;: 5, &#x27;♜&#x27;: 5,
                &#x27;♕&#x27;: 9, &#x27;♛&#x27;: 9,
                &#x27;♔&#x27;: 0, &#x27;♚&#x27;: 0
            };
            return values[piece] || 0;
        }

        // Ajouter un coup à l&#x27;historique
        function addMoveToHistory(move) {
            gameState.moveHistory.push(move);
            const historyElement = document.getElementById(&#x27;moveHistory&#x27;);
            const moveElement = document.createElement(&#x27;div&#x27;);
            moveElement.className = &#x27;move-item&#x27;;
            moveElement.textContent = `${gameState.moveHistory.length}. ${move}`;
            historyElement.appendChild(moveElement);
            historyElement.scrollTop = historyElement.scrollHeight;
        }

        // Coup de l&#x27;IA
        function makeAIMove() {
            if(gameState.currentPlayer !== &#x27;black&#x27; || !gameState.isGameActive || gameState.isPaused) return;
            
            gameState.aiThinking = true;
            const t = translations[gameState.currentLanguage];
            showAIMessage(t.aiCalculating, 0);
            
            setTimeout(() =&gt; {
                const bestMove = calculateBestMove();
                if(bestMove) {
                    makeMove(bestMove.fromRow, bestMove.fromCol, bestMove.toRow, bestMove.toCol);
                }
                gameState.aiThinking = false;
                hideAIMessage();
            }, 1500 + Math.random() * 2000);
        }

        // Calculer le meilleur coup pour l&#x27;IA
        function calculateBestMove() {
            const allMoves = [];
            
            // Générer tous les coups possibles pour les pièces noires
            for(let row = 0; row &lt; 8; row++) {
                for(let col = 0; col &lt; 8; col++) {
                    const piece = gameState.board[row][col];
                    if(piece &amp;&amp; getPieceColor(piece) === &#x27;black&#x27;) {
                        const moves = calculatePossibleMoves(row, col);
                        moves.forEach(move =&gt; {
                            allMoves.push({
                                fromRow: row,
                                fromCol: col,
                                toRow: move.row,
                                toCol: move.col,
                                score: evaluateMove(row, col, move.row, move.col)
                            });
                        });
                    }
                }
            }
            
            if(allMoves.length === 0) return null;
            
            // Trier par score et prendre le meilleur
            allMoves.sort((a, b) =&gt; b.score - a.score);
            
            // Ajouter un peu d&#x27;aléatoire selon la difficulté
            const randomFactor = gameState.difficulty === &#x27;easy&#x27; ? 0.5 : 
                                 gameState.difficulty === &#x27;normal&#x27; ? 0.2 : 0.05;
            
            if(Math.random() &lt; randomFactor) {
                return allMoves[Math.floor(Math.random() * Math.min(3, allMoves.length))];
            }
            
            return allMoves[0];
        }

        // Évaluer un coup
        function evaluateMove(fromRow, fromCol, toRow, toCol) {
            let score = 0;
            
            const capturedPiece = gameState.board[toRow][toCol];
            if(capturedPiece) {
                score += getPieceValue(capturedPiece) * 10;
            }
            
            // Bonus pour contrôler le centre
            const centerDistance = Math.abs(toRow - 3.5) + Math.abs(toCol - 3.5);
            score += (7 - centerDistance) * 2;
            
            // Bonus pour avancer les pions
            const piece = gameState.board[fromRow][fromCol];
            if(getPieceType(piece) === &#x27;pawn&#x27;) {
                score += (fromRow - toRow) * 3;
            }
            
            return score + Math.random() * 5;
        }

        // Vérifier l&#x27;échec et mat
        function isCheckmate() {
            // Implémentation simplifiée
            return false;
        }

        // Vérifier le pat
        function isStalemate() {
            // Implémentation simplifiée
            return false;
        }

        // Terminer la partie
        function endGame() {
            gameState.isGameActive = false;
            clearInterval(gameState.timer);
            
            const t = translations[gameState.currentLanguage];
            const winner = gameState.currentPlayer === &#x27;white&#x27; ? t.blacks : t.whites;
            showAIMessage(`${t.gameEnded} ! ${t.victory} ${winner}`, 5000);
        }

        // Afficher un message IA
        function showAIMessage(message, duration = 2000) {
            const aiThinking = document.getElementById(&#x27;aiThinking&#x27;);
            const aiMessage = document.getElementById(&#x27;aiMessage&#x27;);
            
            aiMessage.textContent = message;
            aiThinking.classList.add(&#x27;active&#x27;);
            
            if(duration &gt; 0) {
                setTimeout(() =&gt; {
                    aiThinking.classList.remove(&#x27;active&#x27;);
                }, duration);
            }
        }

        // Masquer le message IA
        function hideAIMessage() {
            const aiThinking = document.getElementById(&#x27;aiThinking&#x27;);
            aiThinking.classList.remove(&#x27;active&#x27;);
        }

        // Démarrer le timer
        function startTimer() {
            if(gameState.timer) {
                clearInterval(gameState.timer);
            }
            
            gameState.timer = setInterval(() =&gt; {
                if(gameState.isGameActive &amp;&amp; !gameState.isPaused) {
                    updateUI();
                }
            }, 1000);
        }

        // Mettre à jour l&#x27;interface utilisateur
        function updateUI() {
            document.getElementById(&#x27;moveCount&#x27;).textContent = gameState.moveCount;
            document.getElementById(&#x27;aiLevel&#x27;).textContent = gameState.aiLevel;
            document.getElementById(&#x27;gameScore&#x27;).textContent = gameState.score;
            
            // Mettre à jour le temps
            if(gameState.startTime) {
                const elapsedTime = Date.now() - gameState.startTime;
                const minutes = Math.floor(elapsedTime / 60000);
                const seconds = Math.floor((elapsedTime % 60000) / 1000);
                document.getElementById(&#x27;gameTime&#x27;).textContent = 
                    `${minutes.toString().padStart(2, &#x27;0&#x27;)}:${seconds.toString().padStart(2, &#x27;0&#x27;)}`;
            }
            
            // Mettre à jour le bouton statut du joueur
            const t = translations[gameState.currentLanguage];
            const playerName = gameState.currentPlayer === &#x27;white&#x27; ? t.playerWhite : 
                              (gameState.gameMode === &#x27;ai&#x27; ? t.aiPlayer : t.playerBlack);
            const playerIcon = gameState.currentPlayer === &#x27;white&#x27; ? &#x27;♔&#x27; : &#x27;♚&#x27;;
            
            document.getElementById(&#x27;currentPlayer&#x27;).textContent = playerIcon;
            document.getElementById(&#x27;playerName&#x27;).textContent = playerName;
            
            // Changer la couleur du bouton selon le joueur
            const playerBtn = document.getElementById(&#x27;playerStatusBtn&#x27;);
            playerBtn.classList.remove(&#x27;yellow-player&#x27;, &#x27;red-player&#x27;);
            if(gameState.currentPlayer === &#x27;white&#x27;) {
                playerBtn.classList.add(&#x27;yellow-player&#x27;);
            } else {
                playerBtn.classList.add(&#x27;red-player&#x27;);
            }
        }

        // Fonction pour changer de joueur manuellement (mode 2 joueurs uniquement)
        function switchPlayer() {
            if(gameState.gameMode === &#x27;human&#x27; &amp;&amp; gameState.isGameActive &amp;&amp; !gameState.aiThinking &amp;&amp; !gameState.isPaused) {
                gameState.currentPlayer = gameState.currentPlayer === &#x27;white&#x27; ? &#x27;black&#x27; : &#x27;white&#x27;;
                deselectSquare();
                updateUI();
                
                const t = translations[gameState.currentLanguage];
                showAIMessage(`${t.turnOf} ${gameState.currentPlayer === &#x27;white&#x27; ? t.playerWhite : t.playerBlack}`, 1500);
            }
        }

        // Fonction pour basculer la pause
        function togglePause() {
            if(!gameState.isGameActive) return;
            
            gameState.isPaused = !gameState.isPaused;
            const t = translations[gameState.currentLanguage];
            
            // Mettre à jour le texte du bouton
            const pauseText = gameState.isPaused ? t.resumeText : t.pauseText;
            document.getElementById(&#x27;pauseText&#x27;).textContent = pauseText;
            
            // Afficher le message approprié
            const message = gameState.isPaused ? t.gamePaused : t.gameResumed;
            showAIMessage(message, 2000);
            
            // Si on reprend le jeu et que c&#x27;est le tour de l&#x27;IA
            if(!gameState.isPaused &amp;&amp; gameState.gameMode === &#x27;ai&#x27; &amp;&amp; gameState.currentPlayer === &#x27;black&#x27;) {
                setTimeout(() =&gt; makeAIMove(), 1000);
            }
        }

        // Fonctions des boutons
        function setGameMode(mode) {
            gameState.gameMode = mode;
            
            const aiBtn = document.getElementById(&#x27;aiModeBtn&#x27;);
            const humanBtn = document.getElementById(&#x27;humanModeBtn&#x27;);
            
            if(mode === &#x27;ai&#x27;) {
                aiBtn.classList.add(&#x27;active&#x27;);
                humanBtn.classList.remove(&#x27;active&#x27;);
            } else {
                humanBtn.classList.add(&#x27;active&#x27;);
                aiBtn.classList.remove(&#x27;active&#x27;);
            }
            
            resetGame();
        }

        function undoMove() {
            if(gameState.moveHistory.length &lt;= 1) return;
            
            const t = translations[gameState.currentLanguage];
            showAIMessage(t.undoInDevelopment, 2000);
        }

        function activateQuantumMode() {
            gameState.quantumMode = !gameState.quantumMode;
            const btn = document.getElementById(&#x27;quantumBtn&#x27;);
            const t = translations[gameState.currentLanguage];
            
            if(gameState.quantumMode) {
                btn.style.background = &#x27;linear-gradient(145deg, #00b894, #00a085)&#x27;;
                showAIMessage(t.quantumActivated, 3000);
                
                // Ajouter des effets visuels quantiques
                document.querySelectorAll(&#x27;.chess-square&#x27;).forEach(square =&gt; {
                    if(Math.random() &lt; 0.1) {
                        square.classList.add(&#x27;quantum-state&#x27;);
                        setTimeout(() =&gt; {
                            square.classList.remove(&#x27;quantum-state&#x27;);
                        }, 2000);
                    }
                });
            } else {
                btn.style.background = &#x27;linear-gradient(145deg, #ff6b6b, #ee5a52)&#x27;;
                showAIMessage(t.quantumDeactivated, 2000);
            }
        }

        function resetGame() {
            const t = translations[gameState.currentLanguage];
            showAIMessage(t.newGameStarted, 2000);
            initGame();
        }

        function changeDifficulty() {
            const difficulties = [&#x27;easy&#x27;, &#x27;normal&#x27;, &#x27;hard&#x27;, &#x27;expert&#x27;];
            const currentIndex = difficulties.indexOf(gameState.difficulty);
            const nextIndex = (currentIndex + 1) % difficulties.length;
            gameState.difficulty = difficulties[nextIndex];
            
            gameState.aiLevel = nextIndex + 2;
            
            const t = translations[gameState.currentLanguage];
            const diffText = t.difficultyText.replace(&#x27;Expert&#x27;, t.difficulties[gameState.difficulty]);
            document.getElementById(&#x27;difficultyText&#x27;).textContent = diffText;
            
            showAIMessage(`${t.difficultyChanged} ${t.difficulties[gameState.difficulty]}`, 2000);
        }

        function toggleAIAnalysis() {
            const t = translations[gameState.currentLanguage];
            showAIMessage(t.aiAnalyzing, 3000);
            
            setTimeout(() =&gt; {
                const analysis = analyzePosition();
                showAIMessage(analysis, 5000);
            }, 2000);
        }

        function analyzePosition() {
            let whiteScore = 0;
            let blackScore = 0;
            
            for(let row = 0; row &lt; 8; row++) {
                for(let col = 0; col &lt; 8; col++) {
                    const piece = gameState.board[row][col];
                    if(piece) {
                        const value = getPieceValue(piece);
                        if(getPieceColor(piece) === &#x27;white&#x27;) {
                            whiteScore += value;
                        } else {
                            blackScore += value;
                        }
                    }
                }
            }
            
            const t = translations[gameState.currentLanguage];
            const advantage = whiteScore - blackScore;
            if(advantage &gt; 3) return t.whiteAdvantage;
            if(advantage &lt; -3) return t.blackAdvantage;
            if(advantage &gt; 0) return t.slightWhiteAdvantage;
            if(advantage &lt; 0) return t.slightBlackAdvantage;
            return t.balancedPosition;
        }

        function showBestMoves() {
            const t = translations[gameState.currentLanguage];
            showAIMessage(t.bestMovesCalculating, 2000);
            
            setTimeout(() =&gt; {
                const moves = calculateBestMove();
                if(moves) {
                    const suggestion = `${t.suggestion} ${String.fromCharCode(97 + moves.fromCol)}${8 - moves.fromRow} → ${String.fromCharCode(97 + moves.toCol)}${8 - moves.toRow}`;
                    showAIMessage(suggestion, 4000);
                } else {
                    showAIMessage(t.noMovesAvailable, 2000);
                }
            }, 2000);
        }

        function saveGame() {
            const saveData = {
                board: gameState.board,
                currentPlayer: gameState.currentPlayer,
                gameMode: gameState.gameMode,
                moveHistory: gameState.moveHistory,
                moveCount: gameState.moveCount,
                score: gameState.score,
                difficulty: gameState.difficulty,
                currentLanguage: gameState.currentLanguage
            };
            
            localStorage.setItem(&#x27;quantumChessSave&#x27;, JSON.stringify(saveData));
            const t = translations[gameState.currentLanguage];
            showAIMessage(t.gameSaved, 2000);
        }

        function loadGame() {
            const saveData = localStorage.getItem(&#x27;quantumChessSave&#x27;);
            if(saveData) {
                const data = JSON.parse(saveData);
                gameState.board = data.board;
                gameState.currentPlayer = data.currentPlayer;
                gameState.gameMode = data.gameMode;
                gameState.moveHistory = data.moveHistory;
                gameState.moveCount = data.moveCount;
                gameState.score = data.score;
                gameState.difficulty = data.difficulty;
                if(data.currentLanguage) {
                    gameState.currentLanguage = data.currentLanguage;
                    document.getElementById(&#x27;languageSelector&#x27;).value = data.currentLanguage;
                    changeLanguage();
                }
                
                createChessboard();
                updateUI();
                const t = translations[gameState.currentLanguage];
                showAIMessage(t.gameLoaded, 2000);
            }
        }

        // Initialisation
        document.addEventListener(&#x27;DOMContentLoaded&#x27;, function() {
            initFuturisticEffects();
            initGame();
            
            // Charger une sauvegarde si elle existe
            if(localStorage.getItem(&#x27;quantumChessSave&#x27;)) {
                setTimeout(() =&gt; {
                    const t = translations[gameState.currentLanguage];
                    if(confirm(t.loadSavedGame)) {
                        loadGame();
                    }
                }, 1000);
            }
            
            // Message de bienvenue
            setTimeout(() =&gt; {
                const t = translations[gameState.currentLanguage];
                showAIMessage(t.welcome, 4000);
            }, 1000);
        });
    &lt;/script&gt;
&lt;script&gt;(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement(&#x27;script&#x27;);d.innerHTML=&quot;window.__CF$cv$params={r:&#x27;9848d49b957f7784&#x27;,t:&#x27;MTc1ODc4NTU3Ni4wMDAwMDA=&#x27;};var a=document.createElement(&#x27;script&#x27;);a.nonce=&#x27;&#x27;;a.src=&#x27;/cdn-cgi/challenge-platform/scripts/jsd/main.js&#x27;;document.getElementsByTagName(&#x27;head&#x27;)[0].appendChild(a);&quot;;b.getElementsByTagName(&#x27;head&#x27;)[0].appendChild(d)}}if(document.body){var a=document.createElement(&#x27;iframe&#x27;);a.height=1;a.width=1;a.style.position=&#x27;absolute&#x27;;a.style.top=0;a.style.left=0;a.style.border=&#x27;none&#x27;;a.style.visibility=&#x27;hidden&#x27;;document.body.appendChild(a);if(&#x27;loading&#x27;!==document.readyState)c();else if(window.addEventListener)document.addEventListener(&#x27;DOMContentLoaded&#x27;,c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);&#x27;loading&#x27;!==document.readyState&amp;&amp;(document.onreadystatechange=e,c())}}}})();&lt;/script&gt;&lt;/body&gt;
&lt;/html&gt;
" style="width:100%;height:100%;border:none;"></iframe>
</div>

<script>
function launchGame4() {
  const overlay = document.getElementById("game4Overlay");
  overlay.style.display = "block";
}
function closeGame4() {
  const overlay = document.getElementById("game4Overlay");
  overlay.style.display = "none";
}
document.addEventListener("keydown", function(e) {
  if (e.key === "Escape") {
    const overlay = document.getElementById("game4Overlay");
    if (overlay && overlay.style.display === "block") {
      e.preventDefault();
      e.stopPropagation();
      closeGame4();
    }
  }
}, true);
</script>


<div id="game5Overlay" style="display:none;position:fixed;inset:0;background:#000;z-index:9999;">
  <button onclick="closeGame5()" style="position:absolute;top:10px;right:10px;z-index:10000;font-size:24px;background:red;color:white;border:none;border-radius:50%;width:40px;height:40px;cursor:pointer;">✖</button>
  <iframe id="iframeGame5" srcdoc="&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;fr&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;🔥 Brainova Quantum Dames - IA Futuriste&lt;/title&gt;
    &lt;script src=&quot;https://cdn.tailwindcss.com&quot;&gt;&lt;/script&gt;
    &lt;style&gt;
        body {
            box-sizing: border-box;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: &#x27;Segoe UI&#x27;, Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a3a 30%, #2d1b69 70%, #4c1d95 100%);
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }

        /* Particules quantiques d&#x27;arrière-plan */
        .quantum-particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .quantum-particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: #ff6b35;
            border-radius: 50%;
            animation: quantumFloat 15s infinite linear;
            box-shadow: 0 0 12px #ff6b35, 0 0 24px #ff6b35;
        }

        @keyframes quantumFloat {
            0% {
                transform: translateY(100vh) translateX(0) rotate(0deg) scale(0);
                opacity: 0;
            }
            10% {
                opacity: 1;
                transform: translateY(90vh) translateX(30px) rotate(45deg) scale(1);
            }
            50% {
                transform: translateY(50vh) translateX(-40px) rotate(180deg) scale(1.8);
            }
            90% {
                opacity: 1;
                transform: translateY(10vh) translateX(60px) rotate(315deg) scale(1);
            }
            100% {
                transform: translateY(-10vh) translateX(120px) rotate(360deg) scale(0);
                opacity: 0;
            }
        }

        /* Lignes d&#x27;énergie futuristes */
        .energy-lines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
            overflow: hidden;
        }

        .energy-line {
            position: absolute;
            height: 3px;
            background: linear-gradient(90deg, transparent, #ff6b35, transparent);
            animation: energyFlow 10s infinite linear;
            box-shadow: 0 0 15px #ff6b35;
        }

        @keyframes energyFlow {
            0% {
                transform: translateX(-100%);
                opacity: 0;
            }
            10% {
                opacity: 1;
            }
            90% {
                opacity: 1;
            }
            100% {
                transform: translateX(100vw);
                opacity: 0;
            }
        }

        /* Cercles d&#x27;énergie pulsants */
        .energy-circles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .energy-circle {
            position: absolute;
            border: 3px solid rgba(255, 107, 53, 0.4);
            border-radius: 50%;
            animation: energyPulse 8s infinite ease-in-out;
        }

        @keyframes energyPulse {
            0% {
                transform: scale(0) rotate(0deg);
                opacity: 1;
                border-color: rgba(255, 107, 53, 0.9);
            }
            50% {
                transform: scale(1.2) rotate(180deg);
                opacity: 0.6;
                border-color: rgba(255, 107, 53, 0.5);
            }
            100% {
                transform: scale(2.5) rotate(360deg);
                opacity: 0;
                border-color: rgba(255, 107, 53, 0.1);
            }
        }

        /* Grille quantique de fond */
        .quantum-grid {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(255, 107, 53, 0.15) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 107, 53, 0.15) 1px, transparent 1px);
            background-size: 80px 80px;
            animation: quantumGridMove 30s linear infinite;
            z-index: 1;
        }

        @keyframes quantumGridMove {
            0% { transform: translate(0, 0) rotate(0deg); }
            50% { transform: translate(40px, 40px) rotate(2deg); }
            100% { transform: translate(80px, 80px) rotate(0deg); }
        }

        /* Rayons laser */
        .laser-beams {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .laser-beam {
            position: absolute;
            width: 3px;
            height: 100vh;
            background: linear-gradient(to bottom, 
                transparent 0%, 
                rgba(255, 107, 53, 0.9) 20%, 
                rgba(255, 107, 53, 0.5) 50%, 
                rgba(255, 107, 53, 0.9) 80%, 
                transparent 100%);
            animation: laserScan 15s infinite linear;
            box-shadow: 0 0 25px rgba(255, 107, 53, 0.7);
        }

        @keyframes laserScan {
            0% {
                transform: translateX(-15px);
                opacity: 0;
            }
            10% {
                opacity: 1;
            }
            90% {
                opacity: 1;
            }
            100% {
                transform: translateX(100vw);
                opacity: 0;
            }
        }

        /* Container principal */
        .quantum-dames-container {
            position: relative;
            z-index: 10;
            display: grid;
            grid-template-columns: 180px 1fr 180px;
            gap: 12px;
            min-height: 100vh;
            padding: 10px;
            max-width: 1200px;
            margin: 0 auto;
            padding-top: 15px;
        }

        .left-panel, .right-panel {
            background: linear-gradient(145deg, 
                rgba(30, 30, 58, 0.95) 0%,
                rgba(45, 27, 105, 0.95) 50%,
                rgba(76, 29, 149, 0.95) 100%);
            backdrop-filter: blur(30px);
            border-radius: 15px;
            padding: 12px;
            height: fit-content;
            box-shadow: 
                0 15px 30px rgba(0, 0, 0, 0.7),
                0 0 60px rgba(255, 107, 53, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 107, 53, 0.5);
            animation: quantumPanelGlow 5s ease-in-out infinite alternate;
        }

        .game-panel {
            background: linear-gradient(145deg, 
                rgba(30, 30, 58, 0.95) 0%,
                rgba(45, 27, 105, 0.95) 50%,
                rgba(76, 29, 149, 0.95) 100%);
            backdrop-filter: blur(30px);
            border-radius: 20px;
            padding: 20px;
            width: 100%;
            height: fit-content;
            box-shadow: 
                0 25px 50px rgba(0, 0, 0, 0.7),
                0 0 100px rgba(255, 107, 53, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 107, 53, 0.5);
            animation: quantumPanelGlow 5s ease-in-out infinite alternate;
        }

        @keyframes quantumPanelGlow {
            from { 
                box-shadow: 
                    0 25px 50px rgba(0, 0, 0, 0.7),
                    0 0 100px rgba(255, 107, 53, 0.2),
                    inset 0 1px 0 rgba(255, 255, 255, 0.1);
            }
            to { 
                box-shadow: 
                    0 30px 60px rgba(0, 0, 0, 0.7),
                    0 0 120px rgba(255, 107, 53, 0.3),
                    inset 0 1px 0 rgba(255, 255, 255, 0.2);
            }
        }

        /* En-tête du jeu */
        .quantum-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid rgba(255, 107, 53, 0.5);
        }

        .quantum-title {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .quantum-title h1 {
            color: #ff6b35;
            margin: 0;
            font-size: 18px;
            font-weight: 700;
            text-shadow: 0 0 30px rgba(255, 107, 53, 0.9);
            animation: quantumTitlePulse 4s infinite alternate;
        }

        @keyframes quantumTitlePulse {
            from { 
                text-shadow: 0 0 30px rgba(255, 107, 53, 0.9);
                transform: scale(1);
            }
            to { 
                text-shadow: 0 0 40px rgba(255, 107, 53, 1);
                transform: scale(1.03);
            }
        }

        .quantum-icon {
            font-size: 28px;
            animation: quantumIconSpin 8s linear infinite;
            filter: drop-shadow(0 0 20px #ff6b35);
            color: #fbbf24;
            text-shadow: 
                0 0 15px rgba(251, 191, 36, 0.9),
                0 0 30px rgba(251, 191, 36, 0.7),
                0 0 45px rgba(251, 191, 36, 0.5);
        }

        @keyframes quantumIconSpin {
            0% { transform: rotate(0deg) scale(1); }
            25% { transform: rotate(90deg) scale(1.15); }
            50% { transform: rotate(180deg) scale(1); }
            75% { transform: rotate(270deg) scale(1.15); }
            100% { transform: rotate(360deg) scale(1); }
        }

        .quantum-badge {
            background: linear-gradient(45deg, #ff6b35, #f59e0b, #ef4444, #8b5cf6);
            background-size: 400% 400%;
            color: white;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 10px;
            font-weight: bold;
            animation: quantumBadgeShine 5s ease-in-out infinite;
            box-shadow: 0 0 25px rgba(255, 107, 53, 0.7);
        }

        @keyframes quantumBadgeShine {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .close-btn {
            background: rgba(255, 0, 0, 0.25);
            border: 2px solid rgba(255, 0, 0, 0.6);
            color: #ff4757;
            width: 45px;
            height: 45px;
            border-radius: 50%;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .close-btn:hover {
            background: rgba(255, 0, 0, 0.5);
            transform: scale(1.15) rotate(90deg);
            box-shadow: 0 0 30px rgba(255, 71, 87, 0.9);
        }

        /* Sélecteur de langue */
        .language-selector {
            background: linear-gradient(145deg, #ff6b35, #f59e0b);
            color: white;
            border: 2px solid rgba(255, 107, 53, 0.5);
            border-radius: 15px;
            padding: 12px 18px;
            font-weight: bold;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.3s ease;
            box-shadow: 0 0 25px rgba(255, 107, 53, 0.5);
            backdrop-filter: blur(15px);
            min-width: 160px;
            max-height: 220px;
            overflow-y: auto;
        }

        .language-selector:hover {
            background: linear-gradient(145deg, #ff8c42, #fbbf24);
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(255, 107, 53, 0.7);
            border-color: rgba(255, 107, 53, 0.7);
        }

        .language-selector:focus {
            outline: none;
            box-shadow: 0 0 35px rgba(255, 107, 53, 0.9);
            border-color: rgba(255, 107, 53, 0.9);
        }

        .language-selector option {
            background: #1e1e3a;
            color: white;
            padding: 10px 15px;
            border: none;
            font-size: 13px;
        }

        .language-selector option:hover {
            background: #ff6b35;
        }

        /* Contrôles de mode de jeu */
        .game-mode-controls {
            display: flex;
            justify-content: center;
            gap: 12px;
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 12px;
            border: 2px solid rgba(255, 107, 53, 0.4);
        }

        .mode-btn {
            padding: 12px 20px;
            background: linear-gradient(145deg, #ff6b35, #f59e0b);
            color: white;
            border: none;
            border-radius: 12px;
            font-weight: bold;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 1.2px;
            min-width: 130px;
        }

        .mode-btn::before {
            content: &#x27;&#x27;;
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.5), transparent);
            transition: left 0.6s ease;
        }

        .mode-btn:hover::before {
            left: 100%;
        }

        .mode-btn:hover {
            transform: translateY(-4px);
            box-shadow: 0 12px 35px rgba(255, 107, 53, 0.6);
            background: linear-gradient(145deg, #ff8c42, #fbbf24);
        }

        .mode-btn.active {
            background: linear-gradient(145deg, #8b5cf6, #7c3aed);
            box-shadow: 0 0 30px rgba(139, 92, 246, 0.7);
        }

        .mode-btn.active:hover {
            background: linear-gradient(145deg, #a78bfa, #8b5cf6);
        }

        /* Plateau de dames quantique */
        .quantum-dameboard-container {
            display: flex;
            justify-content: center;
            margin-bottom: 15px;
            position: relative;
            margin-top: 15px;
        }

        .quantum-dameboard {
            width: 480px;
            height: 480px;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            border: 4px solid rgba(255, 107, 53, 0.9);
            border-radius: 18px;
            box-shadow: 
                0 0 35px rgba(255, 107, 53, 0.7),
                0 0 70px rgba(255, 107, 53, 0.4),
                inset 0 0 25px rgba(255, 107, 53, 0.25);
            animation: quantumBoardGlow 6s ease-in-out infinite alternate;
            position: relative;
            overflow: hidden;
        }

        @keyframes quantumBoardGlow {
            from { 
                box-shadow: 
                    0 0 30px rgba(255, 107, 53, 0.5),
                    0 0 60px rgba(255, 107, 53, 0.3),
                    inset 0 0 20px rgba(255, 107, 53, 0.2);
            }
            to { 
                box-shadow: 
                    0 0 40px rgba(255, 107, 53, 0.7),
                    0 0 80px rgba(255, 107, 53, 0.4),
                    inset 0 0 30px rgba(255, 107, 53, 0.25);
            }
        }

        .dame-square {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 107, 53, 0.4);
            box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.2);
        }

        .dame-square.light {
            background: linear-gradient(145deg, #f3f4f6, #d1d5db);
            box-shadow: 
                inset 0 0 20px rgba(255, 255, 255, 0.5),
                inset 0 0 12px rgba(255, 107, 53, 0.2);
        }

        .dame-square.dark {
            background: linear-gradient(145deg, #374151, #1f2937);
            box-shadow: 
                inset 0 0 20px rgba(0, 0, 0, 0.7),
                inset 0 0 12px rgba(255, 107, 53, 0.3);
        }

        .dame-square:hover {
            transform: scale(1.08);
            z-index: 15;
            box-shadow: 
                0 0 30px rgba(255, 107, 53, 0.9),
                inset 0 0 25px rgba(255, 107, 53, 0.3);
            border: 2px solid rgba(255, 107, 53, 0.7);
        }

        .dame-square.selected {
            background: linear-gradient(145deg, #fbbf24, #f59e0b) !important;
            box-shadow: 
                0 0 35px rgba(251, 191, 36, 1),
                inset 0 0 25px rgba(251, 191, 36, 0.4),
                0 0 60px rgba(251, 191, 36, 0.6);
            transform: scale(1.12);
            z-index: 25;
            border: 3px solid #fbbf24;
            animation: selectedPulse 2s ease-in-out infinite alternate;
        }

        @keyframes selectedPulse {
            from { 
                box-shadow: 
                    0 0 35px rgba(251, 191, 36, 1),
                    inset 0 0 25px rgba(251, 191, 36, 0.4),
                    0 0 60px rgba(251, 191, 36, 0.6);
            }
            to { 
                box-shadow: 
                    0 0 45px rgba(251, 191, 36, 1),
                    inset 0 0 35px rgba(251, 191, 36, 0.5),
                    0 0 80px rgba(251, 191, 36, 0.8);
            }
        }

        .dame-square.possible-move {
            background: linear-gradient(145deg, #10b981, #059669) !important;
            box-shadow: 
                0 0 25px rgba(16, 185, 129, 0.9),
                inset 0 0 20px rgba(16, 185, 129, 0.3);
            border: 2px solid #10b981;
            animation: possibleMovePulse 2.5s ease-in-out infinite alternate;
        }

        @keyframes possibleMovePulse {
            from { 
                box-shadow: 
                    0 0 25px rgba(16, 185, 129, 0.9),
                    inset 0 0 20px rgba(16, 185, 129, 0.3);
            }
            to { 
                box-shadow: 
                    0 0 35px rgba(16, 185, 129, 1),
                    inset 0 0 30px rgba(16, 185, 129, 0.4);
            }
        }

        .dame-square.quantum-state {
            background: linear-gradient(145deg, #ec4899, #db2777) !important;
            box-shadow: 
                0 0 30px rgba(236, 72, 153, 1),
                inset 0 0 25px rgba(236, 72, 153, 0.4);
            animation: quantumPulse 1.2s infinite alternate;
            border: 2px solid #ec4899;
        }

        @keyframes quantumPulse {
            from { transform: scale(1); }
            to { transform: scale(1.08); }
        }

        /* Pions de dames */
        .dame-piece {
            width: 42px;
            height: 42px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: 900;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            z-index: 10;
            border: 2px solid rgba(0, 0, 0, 0.3);
            box-shadow: 
                0 6px 12px rgba(0, 0, 0, 0.4),
                inset 0 2px 4px rgba(255, 255, 255, 0.3);
        }

        .dame-piece:hover {
            transform: scale(1.2);
            z-index: 20;
            box-shadow: 
                0 12px 24px rgba(0, 0, 0, 0.5),
                0 0 25px currentColor,
                inset 0 2px 4px rgba(255, 255, 255, 0.4);
            animation: pieceGlow 0.6s ease-in-out;
        }

        @keyframes pieceGlow {
            0% { transform: scale(1.2); }
            50% { transform: scale(1.25); }
            100% { transform: scale(1.2); }
        }

        .dame-piece.white {
            background: linear-gradient(145deg, #fbbf24, #f59e0b);
            color: #1f2937;
            text-shadow: 
                2px 2px 4px rgba(0, 0, 0, 0.3),
                0 0 15px rgba(251, 191, 36, 0.8);
            border-color: rgba(31, 41, 55, 0.4);
        }

        .dame-piece.white:hover {
            background: linear-gradient(145deg, #fcd34d, #fbbf24);
            text-shadow: 
                2px 2px 4px rgba(0, 0, 0, 0.4),
                0 0 20px rgba(252, 211, 77, 1);
        }

        .dame-piece.black {
            background: linear-gradient(145deg, #ef4444, #dc2626);
            color: #f9fafb;
            text-shadow: 
                2px 2px 4px rgba(0, 0, 0, 0.6),
                0 0 15px rgba(239, 68, 68, 0.8);
            border-color: rgba(249, 250, 251, 0.4);
        }

        .dame-piece.black:hover {
            background: linear-gradient(145deg, #f87171, #ef4444);
            text-shadow: 
                2px 2px 4px rgba(0, 0, 0, 0.7),
                0 0 20px rgba(248, 113, 113, 1);
        }

        .dame-piece.king {
            font-size: 24px;
            border-width: 3px;
            box-shadow: 
                0 8px 16px rgba(0, 0, 0, 0.5),
                0 0 25px currentColor,
                inset 0 3px 6px rgba(255, 255, 255, 0.4);
        }

        /* Panneau de titre des sections */
        .panel-title {
            color: #ff6b35;
            font-size: 13px;
            font-weight: bold;
            margin-bottom: 12px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            text-shadow: 0 0 15px rgba(255, 107, 53, 0.9);
            border-bottom: 2px solid rgba(255, 107, 53, 0.5);
            padding-bottom: 8px;
        }

        /* Contrôles quantiques */
        .quantum-controls {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px;
            margin-bottom: 12px;
        }

        .quantum-btn {
            padding: 10px 14px;
            background: linear-gradient(145deg, #ff6b35, #f59e0b);
            color: white;
            border: none;
            border-radius: 10px;
            font-weight: bold;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 0.6px;
        }

        .quantum-btn::before {
            content: &#x27;&#x27;;
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            transition: left 0.6s ease;
        }

        .quantum-btn:hover::before {
            left: 100%;
        }

        .quantum-btn:hover {
            transform: translateY(-4px);
            box-shadow: 0 10px 30px rgba(255, 107, 53, 0.5);
            background: linear-gradient(145deg, #ff8c42, #fbbf24);
        }

        .quantum-btn:active {
            transform: translateY(-2px);
        }

        .quantum-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        /* Boutons spécialisés */
        .ai-btn {
            background: linear-gradient(145deg, #8b5cf6, #7c3aed);
        }

        .ai-btn:hover {
            background: linear-gradient(145deg, #a78bfa, #8b5cf6);
        }

        .reset-btn {
            background: linear-gradient(145deg, #ef4444, #dc2626);
        }

        .reset-btn:hover {
            background: linear-gradient(145deg, #f87171, #ef4444);
        }

        .quantum-special-btn {
            background: linear-gradient(145deg, #ec4899, #db2777);
        }

        .quantum-special-btn:hover {
            background: linear-gradient(145deg, #f472b6, #ec4899);
        }

        /* Bouton statut du joueur */
        .player-status-btn {
            display: inline-flex;
            align-items: center;
            gap: 12px;
            padding: 12px 18px;
            background: linear-gradient(145deg, #ff6b35, #f59e0b);
            color: white;
            border: none;
            border-radius: 15px;
            font-weight: bold;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            box-shadow: 0 4px 12px rgba(255, 107, 53, 0.5);
            border: 2px solid rgba(255, 107, 53, 0.4);
        }

        .player-status-btn::before {
            content: &#x27;&#x27;;
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            transition: left 0.6s ease;
        }

        .player-status-btn:hover::before {
            left: 100%;
        }

        .player-status-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(255, 107, 53, 0.7);
            background: linear-gradient(145deg, #ff8c42, #fbbf24);
            border-color: rgba(255, 107, 53, 0.6);
        }

        .player-status-btn:active {
            transform: translateY(-1px);
        }

        .player-status-btn.yellow-player {
            background: linear-gradient(145deg, #fef08a, #fbbf24);
            border-color: rgba(254, 240, 138, 0.6);
            color: #1f2937;
            text-shadow: 0 0 10px rgba(254, 240, 138, 0.9);
        }

        .player-status-btn.yellow-player:hover {
            background: linear-gradient(145deg, #fefce8, #fef08a);
            border-color: rgba(254, 240, 138, 0.8);
            box-shadow: 0 10px 30px rgba(254, 240, 138, 0.7);
        }

        .player-status-btn.red-player {
            background: linear-gradient(145deg, #ef4444, #dc2626);
            border-color: rgba(239, 68, 68, 0.6);
            color: white;
        }

        .player-status-btn.red-player:hover {
            background: linear-gradient(145deg, #f87171, #ef4444);
            border-color: rgba(239, 68, 68, 0.8);
            box-shadow: 0 10px 30px rgba(239, 68, 68, 0.7);
        }

        .player-status-btn #currentPlayer {
            font-size: 18px;
            text-shadow: 0 0 12px rgba(255, 255, 255, 0.9);
        }

        /* IA Quantique Status */
        .quantum-ai-status {
            margin-bottom: 18px;
            text-align: center;
            min-height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .ai-thinking {
            display: inline-flex;
            align-items: center;
            gap: 15px;
            color: #ff6b35;
            font-size: 15px;
            opacity: 0;
            transition: opacity 0.6s ease;
            background: rgba(255, 107, 53, 0.2);
            padding: 12px 25px;
            border-radius: 30px;
            border: 1px solid rgba(255, 107, 53, 0.5);
        }

        .ai-thinking.active {
            opacity: 1;
        }

        .quantum-pulse {
            width: 15px;
            height: 15px;
            background: #ff6b35;
            border-radius: 50%;
            animation: quantumAIPulse 2.5s infinite;
            box-shadow: 0 0 20px #ff6b35;
        }

        @keyframes quantumAIPulse {
            0%, 100% { 
                transform: scale(1); 
                opacity: 1; 
            }
            50% { 
                transform: scale(2); 
                opacity: 0.4; 
            }
        }

        /* Statistiques du jeu */
        .game-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 12px;
        }

        .stat-item {
            background: rgba(255, 107, 53, 0.15);
            padding: 8px;
            border-radius: 12px;
            text-align: center;
            border: 2px solid rgba(255, 107, 53, 0.4);
            position: relative;
            overflow: hidden;
        }

        .stat-item::before {
            content: &#x27;&#x27;;
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 107, 53, 0.3), transparent);
            animation: statQuantumScan 5s linear infinite;
        }

        @keyframes statQuantumScan {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .stat-label {
            display: block;
            color: #9ca3af;
            font-size: 10px;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 1.2px;
        }

        .stat-value {
            display: block;
            color: #ff6b35;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 0 0 15px rgba(255, 107, 53, 0.9);
            position: relative;
            z-index: 1;
        }

        /* Historique des coups */
        .move-history {
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid rgba(255, 107, 53, 0.4);
            border-radius: 12px;
            padding: 10px;
            max-height: 150px;
            overflow-y: auto;
        }

        .move-item {
            color: #ff6b35;
            font-size: 12px;
            padding: 5px 10px;
            margin-bottom: 5px;
            background: rgba(255, 107, 53, 0.15);
            border-radius: 8px;
            border-left: 3px solid #ff6b35;
        }

        /* Responsive */
        @media (max-width: 1100px) {
            .quantum-dames-container {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .left-panel, .right-panel {
                display: none;
            }
            
            .quantum-dameboard {
                width: 450px;
                height: 450px;
            }
            
            .dame-piece {
                width: 38px;
                height: 38px;
                font-size: 18px;
            }
        }

        @media (max-width: 768px) {
            .game-panel {
                padding: 15px;
                margin: 8px;
            }
            
            .game-mode-controls {
                flex-direction: column;
                gap: 12px;
            }
            
            .quantum-title h1 {
                font-size: 16px;
            }
            
            .quantum-dameboard {
                width: 480px;
                height: 480px;
            }
            
            .dame-piece {
                width: 40px;
                height: 40px;
                font-size: 20px;
            }
        }

        @media (max-width: 520px) {
            .quantum-dameboard {
                width: 400px;
                height: 400px;
            }
            
            .dame-piece {
                width: 35px;
                height: 35px;
                font-size: 18px;
            }
            
            .game-stats {
                grid-template-columns: 1fr;
            }
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!-- Particules quantiques d&#x27;arrière-plan --&gt;
    &lt;div class=&quot;quantum-particles&quot; id=&quot;quantumParticles&quot;&gt;&lt;/div&gt;
    
    &lt;!-- Grille quantique --&gt;
    &lt;div class=&quot;quantum-grid&quot;&gt;&lt;/div&gt;
    
    &lt;!-- Lignes d&#x27;énergie futuristes --&gt;
    &lt;div class=&quot;energy-lines&quot; id=&quot;energyLines&quot;&gt;&lt;/div&gt;
    
    &lt;!-- Cercles d&#x27;énergie pulsants --&gt;
    &lt;div class=&quot;energy-circles&quot; id=&quot;energyCircles&quot;&gt;&lt;/div&gt;
    
    &lt;!-- Rayons laser --&gt;
    &lt;div class=&quot;laser-beams&quot; id=&quot;laserBeams&quot;&gt;&lt;/div&gt;
    
    &lt;!-- Container principal --&gt;
    &lt;div class=&quot;quantum-dames-container&quot;&gt;
        &lt;!-- Panneau gauche --&gt;
        &lt;div class=&quot;left-panel&quot;&gt;
            &lt;div class=&quot;panel-section&quot;&gt;
                &lt;div class=&quot;panel-title&quot; id=&quot;controlsTitle&quot;&gt;🎮 Contrôles Quantiques&lt;/div&gt;
                &lt;div class=&quot;quantum-controls&quot;&gt;
                    &lt;button class=&quot;quantum-btn&quot; onclick=&quot;undoMove()&quot; id=&quot;undoBtn&quot;&gt;
                        ↶ &lt;span id=&quot;undoText&quot;&gt;Annuler Coup&lt;/span&gt;
                    &lt;/button&gt;
                    &lt;button class=&quot;quantum-btn quantum-special-btn&quot; onclick=&quot;activateQuantumMode()&quot; id=&quot;quantumBtn&quot;&gt;
                        ⚛️ &lt;span id=&quot;quantumModeText&quot;&gt;Mode Quantique&lt;/span&gt;
                    &lt;/button&gt;
                    &lt;button class=&quot;quantum-btn reset-btn&quot; onclick=&quot;resetGame()&quot;&gt;
                        🔄 &lt;span id=&quot;newGameText&quot;&gt;Nouvelle Partie&lt;/span&gt;
                    &lt;/button&gt;
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;div class=&quot;panel-section&quot;&gt;
                &lt;div class=&quot;panel-title&quot; id=&quot;statsTitle&quot;&gt;📊 Statistiques&lt;/div&gt;
                &lt;div class=&quot;game-stats&quot;&gt;
                    &lt;div class=&quot;stat-item&quot;&gt;
                        &lt;span class=&quot;stat-label&quot; id=&quot;movesLabel&quot;&gt;Coups Joués&lt;/span&gt;
                        &lt;span class=&quot;stat-value&quot; id=&quot;moveCount&quot;&gt;0&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;stat-item&quot;&gt;
                        &lt;span class=&quot;stat-label&quot; id=&quot;aiLevelLabel&quot;&gt;Niveau IA&lt;/span&gt;
                        &lt;span class=&quot;stat-value&quot; id=&quot;aiLevel&quot;&gt;5&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;stat-item&quot;&gt;
                        &lt;span class=&quot;stat-label&quot; id=&quot;timeLabel&quot;&gt;Temps&lt;/span&gt;
                        &lt;span class=&quot;stat-value&quot; id=&quot;gameTime&quot;&gt;00:00&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;stat-item&quot;&gt;
                        &lt;span class=&quot;stat-label&quot; id=&quot;scoreLabel&quot;&gt;Score&lt;/span&gt;
                        &lt;span class=&quot;stat-value&quot; id=&quot;gameScore&quot;&gt;0&lt;/span&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;

        &lt;!-- Panneau central --&gt;
        &lt;div class=&quot;game-panel&quot;&gt;
            &lt;!-- En-tête --&gt;
            &lt;div class=&quot;quantum-header&quot;&gt;
                &lt;div class=&quot;quantum-title&quot;&gt;
                    &lt;span class=&quot;quantum-icon&quot;&gt;🔥&lt;/span&gt;
                    &lt;h1 id=&quot;gameTitle&quot;&gt;Brainova Quantum Dames&lt;/h1&gt;
                    &lt;span class=&quot;quantum-badge&quot; id=&quot;quantumBadge&quot;&gt;🚀 IA QUANTIQUE&lt;/span&gt;
                &lt;/div&gt;
                &lt;div style=&quot;display: flex; align-items: center; gap: 18px;&quot;&gt;
                    &lt;select id=&quot;languageSelector&quot; onchange=&quot;changeLanguage()&quot; class=&quot;language-selector&quot;&gt;
                        &lt;option value=&quot;fr&quot;&gt;🇫🇷 Français&lt;/option&gt;
                        &lt;option value=&quot;en&quot;&gt;🇺🇸 English&lt;/option&gt;
                        &lt;option value=&quot;ar&quot;&gt;🇸🇦 العربية&lt;/option&gt;
                        &lt;option value=&quot;es&quot;&gt;🇪🇸 Español&lt;/option&gt;
                        &lt;option value=&quot;de&quot;&gt;🇩🇪 Deutsch&lt;/option&gt;
                        &lt;option value=&quot;zh&quot;&gt;🇨🇳 中文&lt;/option&gt;
                    &lt;/select&gt;
                    &lt;button class=&quot;close-btn&quot; onclick=&quot;window.close()&quot; id=&quot;closeBtn&quot; title=&quot;Fermer&quot;&gt;✕&lt;/button&gt;
                &lt;/div&gt;
            &lt;/div&gt;



            &lt;!-- Contrôles de jeu en haut --&gt;
            &lt;div style=&quot;display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;&quot;&gt;
                &lt;!-- Bouton Pause/Reprendre à gauche --&gt;
                &lt;button class=&quot;quantum-btn&quot; id=&quot;pauseBtn&quot; onclick=&quot;togglePause()&quot; style=&quot;background: linear-gradient(145deg, #8b5cf6, #7c3aed);&quot;&gt;
                    ⏸️ &lt;span id=&quot;pauseText&quot;&gt;Pause&lt;/span&gt;
                &lt;/button&gt;
                
                &lt;!-- Bouton statut du joueur au centre --&gt;
                &lt;button class=&quot;player-status-btn yellow-player&quot; id=&quot;playerStatusBtn&quot; onclick=&quot;switchPlayer()&quot;&gt;
                    &lt;span id=&quot;currentPlayer&quot;&gt;🔥&lt;/span&gt;
                    &lt;span id=&quot;playerName&quot;&gt;Joueur Jaune&lt;/span&gt;
                &lt;/button&gt;
                
                &lt;!-- Bouton IA Quantique à droite --&gt;
                &lt;button class=&quot;quantum-btn ai-btn&quot; onclick=&quot;makeAIMove()&quot; id=&quot;aiMoveBtn&quot;&gt;
                    🤖 &lt;span id=&quot;aiMoveText&quot;&gt;Coup IA Quantique&lt;/span&gt;
                &lt;/button&gt;
            &lt;/div&gt;

            &lt;!-- Plateau de dames quantique --&gt;
            &lt;div class=&quot;quantum-dameboard-container&quot; style=&quot;margin-top: 5px;&quot;&gt;
                &lt;div class=&quot;quantum-dameboard&quot; id=&quot;dameboard&quot;&gt;
                    &lt;!-- Les cases seront générées dynamiquement --&gt;
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;!-- Statut IA Quantique --&gt;
            &lt;div class=&quot;quantum-ai-status&quot;&gt;
                &lt;div class=&quot;ai-thinking&quot; id=&quot;aiThinking&quot;&gt;
                    &lt;span class=&quot;quantum-pulse&quot;&gt;&lt;/span&gt;
                    &lt;span id=&quot;aiMessage&quot;&gt;IA Quantique en analyse...&lt;/span&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;

        &lt;!-- Panneau droit --&gt;
        &lt;div class=&quot;right-panel&quot;&gt;
            &lt;div class=&quot;panel-section&quot;&gt;
                &lt;div class=&quot;panel-title&quot; id=&quot;historyTitle&quot;&gt;📜 Historique&lt;/div&gt;
                &lt;div class=&quot;move-history&quot; id=&quot;moveHistory&quot;&gt;
                    &lt;div class=&quot;move-item&quot; id=&quot;gameStarted&quot;&gt;&lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;div class=&quot;panel-section&quot;&gt;
                &lt;div class=&quot;panel-title&quot; id=&quot;gameModeTitle&quot;&gt;🎮 Mode de Jeu&lt;/div&gt;
                &lt;div class=&quot;quantum-controls&quot;&gt;
                    &lt;button class=&quot;mode-btn active&quot; onclick=&quot;setGameMode(&#x27;ai&#x27;)&quot; id=&quot;aiModeBtn&quot;&gt;
                        🤖 &lt;span id=&quot;aiModeText&quot;&gt;Jouer vs IA&lt;/span&gt;
                    &lt;/button&gt;
                    &lt;button class=&quot;mode-btn&quot; onclick=&quot;setGameMode(&#x27;human&#x27;)&quot; id=&quot;humanModeBtn&quot;&gt;
                        👥 &lt;span id=&quot;humanModeText&quot;&gt;2 Joueurs&lt;/span&gt;
                    &lt;/button&gt;
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;div class=&quot;panel-section&quot;&gt;
                &lt;div class=&quot;panel-title&quot; id=&quot;optionsTitle&quot;&gt;⚙️ Options IA&lt;/div&gt;
                &lt;div class=&quot;quantum-controls&quot;&gt;
                    &lt;button class=&quot;quantum-btn&quot; onclick=&quot;changeDifficulty()&quot; id=&quot;difficultyBtn&quot;&gt;
                        🎯 &lt;span id=&quot;difficultyText&quot;&gt;Difficulté: Expert&lt;/span&gt;
                    &lt;/button&gt;
                    &lt;button class=&quot;quantum-btn ai-btn&quot; onclick=&quot;toggleAIAnalysis()&quot; id=&quot;analysisBtn&quot;&gt;
                        🔍 &lt;span id=&quot;analysisText&quot;&gt;Analyse IA&lt;/span&gt;
                    &lt;/button&gt;
                    &lt;button class=&quot;quantum-btn quantum-special-btn&quot; onclick=&quot;showBestMoves()&quot; id=&quot;hintBtn&quot;&gt;
                        💡 &lt;span id=&quot;hintText&quot;&gt;Meilleurs Coups&lt;/span&gt;
                    &lt;/button&gt;
                    &lt;button class=&quot;quantum-btn&quot; onclick=&quot;saveGame()&quot; id=&quot;saveBtn&quot;&gt;
                        💾 &lt;span id=&quot;saveText&quot;&gt;Sauvegarder&lt;/span&gt;
                    &lt;/button&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;script&gt;
        // Traductions multilingues
        const translations = {
            fr: {
                gameTitle: &quot;Brainova Quantum Dames&quot;,
                quantumBadge: &quot;🚀 IA QUANTIQUE&quot;,
                controlsTitle: &quot;🎮 Contrôles Quantiques&quot;,
                gameModeTitle: &quot;🎮 Mode de Jeu&quot;,
                aiMoveText: &quot;Coup IA Quantique&quot;,
                undoText: &quot;Annuler Coup&quot;,
                quantumModeText: &quot;Mode Quantique&quot;,
                newGameText: &quot;Nouvelle Partie&quot;,
                statsTitle: &quot;📊 Statistiques&quot;,
                movesLabel: &quot;Coups Joués&quot;,
                aiLevelLabel: &quot;Niveau IA&quot;,
                timeLabel: &quot;Temps&quot;,
                scoreLabel: &quot;Score&quot;,
                aiModeText: &quot;Jouer vs IA&quot;,
                humanModeText: &quot;2 Joueurs&quot;,
                gameStatus: &quot;Nouvelle partie - Jaunes commencent&quot;,
                playerYellow: &quot;Joueur Jaune&quot;,
                playerRed: &quot;Joueur Rouge&quot;,
                aiPlayer: &quot;IA Quantique&quot;,
                historyTitle: &quot;📜 Historique&quot;,
                gameStarted: &quot;Partie commencée&quot;,
                optionsTitle: &quot;⚙️ Options IA&quot;,
                difficultyText: &quot;Difficulté: Expert&quot;,
                analysisText: &quot;Analyse IA&quot;,
                hintText: &quot;Meilleurs Coups&quot;,
                saveText: &quot;Sauvegarder&quot;,
                aiThinking: &quot;IA Quantique en analyse...&quot;,
                closeBtn: &quot;Fermer&quot;,
                turnOf: &quot;Tour du&quot;,
                gameEnded: &quot;Partie terminée&quot;,
                newGameStarted: &quot;Nouvelle partie commencée&quot;,
                quantumActivated: &quot;Mode Quantique activé ! Les pions peuvent se téléporter !&quot;,
                quantumDeactivated: &quot;Mode Quantique désactivé&quot;,
                gameSaved: &quot;Partie sauvegardée !&quot;,
                gameLoaded: &quot;Partie chargée !&quot;,
                loadSavedGame: &quot;Voulez-vous charger la partie sauvegardée ?&quot;,
                welcome: &quot;Bienvenue dans Brainova Quantum Dames ! Choisissez votre mode de jeu.&quot;,
                aiCalculating: &quot;IA Quantique calcule le meilleur coup...&quot;,
                undoInDevelopment: &quot;Fonction d&#x27;annulation en développement&quot;,
                aiAnalyzing: &quot;Analyse IA en cours...&quot;,
                bestMovesCalculating: &quot;Calcul des meilleurs coups...&quot;,
                suggestion: &quot;Suggestion:&quot;,
                noMovesAvailable: &quot;Aucun coup disponible&quot;,
                difficultyChanged: &quot;Difficulté changée:&quot;,
                yellowAdvantage: &quot;Avantage significatif aux Jaunes&quot;,
                redAdvantage: &quot;Avantage significatif aux Rouges&quot;,
                slightYellowAdvantage: &quot;Léger avantage aux Jaunes&quot;,
                slightRedAdvantage: &quot;Léger avantage aux Rouges&quot;,
                balancedPosition: &quot;Position équilibrée&quot;,
                victory: &quot;Victoire des&quot;,
                yellows: &quot;Jaunes&quot;,
                reds: &quot;Rouges&quot;,
                difficulties: {
                    easy: &quot;facile&quot;,
                    normal: &quot;normal&quot;,
                    hard: &quot;difficile&quot;,
                    expert: &quot;expert&quot;
                },
                mustCapture: &quot;Vous devez prendre un pion adverse !&quot;,
                invalidMove: &quot;Mouvement invalide !&quot;,
                piecePromoted: &quot;Pion promu en Dame !&quot;,
                multipleCaptures: &quot;Captures multiples possibles !&quot;,
                allPiecesCaptured: &quot;Toutes les pièces capturées&quot;,
                noMovesLeft: &quot;Aucun mouvement possible&quot;,
                morePieces: &quot;Plus de pièces restantes&quot;,
                strategicAdvantage: &quot;Avantage stratégique&quot;,
                reason: &quot;Raison&quot;,
                finalScore: &quot;Score Final&quot;,
                totalMoves: &quot;Total Coups&quot;,
                pauseText: &quot;Pause&quot;,
                resumeText: &quot;Reprendre&quot;,
                gamePaused: &quot;Jeu en pause&quot;,
                gameResumed: &quot;Jeu repris&quot;
            },
            en: {
                gameTitle: &quot;Brainova Quantum Checkers&quot;,
                quantumBadge: &quot;🚀 QUANTUM AI&quot;,
                controlsTitle: &quot;🎮 Quantum Controls&quot;,
                gameModeTitle: &quot;🎮 Game Mode&quot;,
                aiMoveText: &quot;Quantum AI Move&quot;,
                undoText: &quot;Undo Move&quot;,
                quantumModeText: &quot;Quantum Mode&quot;,
                newGameText: &quot;New Game&quot;,
                statsTitle: &quot;📊 Statistics&quot;,
                movesLabel: &quot;Moves Played&quot;,
                aiLevelLabel: &quot;AI Level&quot;,
                timeLabel: &quot;Time&quot;,
                scoreLabel: &quot;Score&quot;,
                aiModeText: &quot;Play vs AI&quot;,
                humanModeText: &quot;2 Players&quot;,
                gameStatus: &quot;New game - Yellow starts&quot;,
                playerYellow: &quot;Yellow Player&quot;,
                playerRed: &quot;Red Player&quot;,
                aiPlayer: &quot;Quantum AI&quot;,
                historyTitle: &quot;📜 History&quot;,
                gameStarted: &quot;Game started&quot;,
                optionsTitle: &quot;⚙️ AI Options&quot;,
                difficultyText: &quot;Difficulty: Expert&quot;,
                analysisText: &quot;AI Analysis&quot;,
                hintText: &quot;Best Moves&quot;,
                saveText: &quot;Save Game&quot;,
                aiThinking: &quot;Quantum AI analyzing...&quot;,
                closeBtn: &quot;Close&quot;,
                turnOf: &quot;Turn of&quot;,
                gameEnded: &quot;Game ended&quot;,
                newGameStarted: &quot;New game started&quot;,
                quantumActivated: &quot;Quantum Mode activated! Pieces can teleport!&quot;,
                quantumDeactivated: &quot;Quantum Mode deactivated&quot;,
                gameSaved: &quot;Game saved!&quot;,
                gameLoaded: &quot;Game loaded!&quot;,
                loadSavedGame: &quot;Do you want to load the saved game?&quot;,
                welcome: &quot;Welcome to Brainova Quantum Checkers! Choose your game mode.&quot;,
                aiCalculating: &quot;Quantum AI calculating best move...&quot;,
                undoInDevelopment: &quot;Undo function in development&quot;,
                aiAnalyzing: &quot;AI analysis in progress...&quot;,
                bestMovesCalculating: &quot;Calculating best moves...&quot;,
                suggestion: &quot;Suggestion:&quot;,
                noMovesAvailable: &quot;No moves available&quot;,
                difficultyChanged: &quot;Difficulty changed:&quot;,
                yellowAdvantage: &quot;Significant advantage to Yellow&quot;,
                redAdvantage: &quot;Significant advantage to Red&quot;,
                slightYellowAdvantage: &quot;Slight advantage to Yellow&quot;,
                slightRedAdvantage: &quot;Slight advantage to Red&quot;,
                balancedPosition: &quot;Balanced position&quot;,
                victory: &quot;Victory for&quot;,
                yellows: &quot;Yellow&quot;,
                reds: &quot;Red&quot;,
                difficulties: {
                    easy: &quot;easy&quot;,
                    normal: &quot;normal&quot;,
                    hard: &quot;hard&quot;,
                    expert: &quot;expert&quot;
                },
                mustCapture: &quot;You must capture an opponent piece!&quot;,
                invalidMove: &quot;Invalid move!&quot;,
                piecePromoted: &quot;Piece promoted to King!&quot;,
                multipleCaptures: &quot;Multiple captures possible!&quot;,
                allPiecesCaptured: &quot;All pieces captured&quot;,
                noMovesLeft: &quot;No moves left&quot;,
                morePieces: &quot;More pieces remaining&quot;,
                strategicAdvantage: &quot;Strategic advantage&quot;,
                reason: &quot;Reason&quot;,
                finalScore: &quot;Final Score&quot;,
                totalMoves: &quot;Total Moves&quot;,
                pauseText: &quot;Pause&quot;,
                resumeText: &quot;Resume&quot;,
                gamePaused: &quot;Game paused&quot;,
                gameResumed: &quot;Game resumed&quot;
            },
            ar: {
                gameTitle: &quot;برينوفا الداما الكمية&quot;,
                quantumBadge: &quot;🚀 ذكاء كمي&quot;,
                controlsTitle: &quot;🎮 تحكم كمي&quot;,
                gameModeTitle: &quot;🎮 وضع اللعب&quot;,
                aiMoveText: &quot;حركة الذكاء الكمي&quot;,
                undoText: &quot;تراجع عن الحركة&quot;,
                quantumModeText: &quot;الوضع الكمي&quot;,
                newGameText: &quot;لعبة جديدة&quot;,
                statsTitle: &quot;📊 إحصائيات&quot;,
                movesLabel: &quot;الحركات المُلعبة&quot;,
                aiLevelLabel: &quot;مستوى الذكاء&quot;,
                timeLabel: &quot;الوقت&quot;,
                scoreLabel: &quot;النقاط&quot;,
                aiModeText: &quot;العب ضد الذكاء&quot;,
                humanModeText: &quot;لاعبان&quot;,
                gameStatus: &quot;لعبة جديدة - الأصفر يبدأ&quot;,
                playerYellow: &quot;اللاعب الأصفر&quot;,
                playerRed: &quot;اللاعب الأحمر&quot;,
                aiPlayer: &quot;الذكاء الكمي&quot;,
                historyTitle: &quot;📜 التاريخ&quot;,
                gameStarted: &quot;بدأت اللعبة&quot;,
                optionsTitle: &quot;⚙️ خيارات الذكاء&quot;,
                difficultyText: &quot;الصعوبة: خبير&quot;,
                analysisText: &quot;تحليل الذكاء&quot;,
                hintText: &quot;أفضل الحركات&quot;,
                saveText: &quot;حفظ اللعبة&quot;,
                aiThinking: &quot;الذكاء الكمي يحلل...&quot;,
                closeBtn: &quot;إغلاق&quot;,
                turnOf: &quot;دور&quot;,
                gameEnded: &quot;انتهت اللعبة&quot;,
                newGameStarted: &quot;بدأت لعبة جديدة&quot;,
                quantumActivated: &quot;تم تفعيل الوضع الكمي! يمكن للقطع الانتقال الفوري!&quot;,
                quantumDeactivated: &quot;تم إلغاء الوضع الكمي&quot;,
                gameSaved: &quot;تم حفظ اللعبة!&quot;,
                gameLoaded: &quot;تم تحميل اللعبة!&quot;,
                loadSavedGame: &quot;هل تريد تحميل اللعبة المحفوظة؟&quot;,
                welcome: &quot;مرحباً بك في برينوفا الداما الكمية! اختر وضع اللعب.&quot;,
                aiCalculating: &quot;الذكاء الكمي يحسب أفضل حركة...&quot;,
                undoInDevelopment: &quot;وظيفة التراجع قيد التطوير&quot;,
                aiAnalyzing: &quot;تحليل الذكاء جاري...&quot;,
                bestMovesCalculating: &quot;حساب أفضل الحركات...&quot;,
                suggestion: &quot;اقتراح:&quot;,
                noMovesAvailable: &quot;لا توجد حركات متاحة&quot;,
                difficultyChanged: &quot;تم تغيير الصعوبة:&quot;,
                yellowAdvantage: &quot;ميزة كبيرة للأصفر&quot;,
                redAdvantage: &quot;ميزة كبيرة للأحمر&quot;,
                slightYellowAdvantage: &quot;ميزة طفيفة للأصفر&quot;,
                slightRedAdvantage: &quot;ميزة طفيفة للأحمر&quot;,
                balancedPosition: &quot;موقف متوازن&quot;,
                victory: &quot;انتصار&quot;,
                yellows: &quot;الأصفر&quot;,
                reds: &quot;الأحمر&quot;,
                difficulties: {
                    easy: &quot;سهل&quot;,
                    normal: &quot;عادي&quot;,
                    hard: &quot;صعب&quot;,
                    expert: &quot;خبير&quot;
                },
                mustCapture: &quot;يجب أن تأخذ قطعة الخصم!&quot;,
                invalidMove: &quot;حركة غير صحيحة!&quot;,
                piecePromoted: &quot;تم ترقية القطعة إلى ملك!&quot;,
                multipleCaptures: &quot;عدة التقاطات ممكنة!&quot;,
                allPiecesCaptured: &quot;تم أسر جميع القطع&quot;,
                noMovesLeft: &quot;لا توجد حركات متبقية&quot;,
                morePieces: &quot;قطع أكثر متبقية&quot;,
                strategicAdvantage: &quot;ميزة استراتيجية&quot;,
                reason: &quot;السبب&quot;,
                finalScore: &quot;النتيجة النهائية&quot;,
                totalMoves: &quot;إجمالي الحركات&quot;,
                pauseText: &quot;إيقاف&quot;,
                resumeText: &quot;استئناف&quot;,
                gamePaused: &quot;اللعبة متوقفة&quot;,
                gameResumed: &quot;تم استئناف اللعبة&quot;
            },
            es: {
                gameTitle: &quot;Brainova Damas Cuánticas&quot;,
                quantumBadge: &quot;🚀 IA CUÁNTICA&quot;,
                controlsTitle: &quot;🎮 Controles Cuánticos&quot;,
                gameModeTitle: &quot;🎮 Modo de Juego&quot;,
                aiMoveText: &quot;Movimiento IA Cuántica&quot;,
                undoText: &quot;Deshacer Movimiento&quot;,
                quantumModeText: &quot;Modo Cuántico&quot;,
                newGameText: &quot;Nueva Partida&quot;,
                statsTitle: &quot;📊 Estadísticas&quot;,
                movesLabel: &quot;Movimientos Jugados&quot;,
                aiLevelLabel: &quot;Nivel IA&quot;,
                timeLabel: &quot;Tiempo&quot;,
                scoreLabel: &quot;Puntuación&quot;,
                aiModeText: &quot;Jugar vs IA&quot;,
                humanModeText: &quot;2 Jugadores&quot;,
                gameStatus: &quot;Nueva partida - Amarillo empieza&quot;,
                playerYellow: &quot;Jugador Amarillo&quot;,
                playerRed: &quot;Jugador Rojo&quot;,
                aiPlayer: &quot;IA Cuántica&quot;,
                historyTitle: &quot;📜 Historial&quot;,
                gameStarted: &quot;Partida iniciada&quot;,
                optionsTitle: &quot;⚙️ Opciones IA&quot;,
                difficultyText: &quot;Dificultad: Experto&quot;,
                analysisText: &quot;Análisis IA&quot;,
                hintText: &quot;Mejores Movimientos&quot;,
                saveText: &quot;Guardar Partida&quot;,
                aiThinking: &quot;IA Cuántica analizando...&quot;,
                closeBtn: &quot;Cerrar&quot;,
                turnOf: &quot;Turno de&quot;,
                gameEnded: &quot;Partida terminada&quot;,
                newGameStarted: &quot;Nueva partida iniciada&quot;,
                quantumActivated: &quot;¡Modo Cuántico activado! ¡Las piezas pueden teletransportarse!&quot;,
                quantumDeactivated: &quot;Modo Cuántico desactivado&quot;,
                gameSaved: &quot;¡Partida guardada!&quot;,
                gameLoaded: &quot;¡Partida cargada!&quot;,
                loadSavedGame: &quot;¿Quieres cargar la partida guardada?&quot;,
                welcome: &quot;¡Bienvenido a Brainova Damas Cuánticas! Elige tu modo de juego.&quot;,
                aiCalculating: &quot;IA Cuántica calculando mejor movimiento...&quot;,
                undoInDevelopment: &quot;Función de deshacer en desarrollo&quot;,
                aiAnalyzing: &quot;Análisis IA en progreso...&quot;,
                bestMovesCalculating: &quot;Calculando mejores movimientos...&quot;,
                suggestion: &quot;Sugerencia:&quot;,
                noMovesAvailable: &quot;No hay movimientos disponibles&quot;,
                difficultyChanged: &quot;Dificultad cambiada:&quot;,
                yellowAdvantage: &quot;Ventaja significativa para Amarillo&quot;,
                redAdvantage: &quot;Ventaja significativa para Rojo&quot;,
                slightYellowAdvantage: &quot;Ligera ventaja para Amarillo&quot;,
                slightRedAdvantage: &quot;Ligera ventaja para Rojo&quot;,
                balancedPosition: &quot;Posición equilibrada&quot;,
                victory: &quot;Victoria de&quot;,
                yellows: &quot;Amarillo&quot;,
                reds: &quot;Rojo&quot;,
                difficulties: {
                    easy: &quot;fácil&quot;,
                    normal: &quot;normal&quot;,
                    hard: &quot;difícil&quot;,
                    expert: &quot;experto&quot;
                },
                mustCapture: &quot;¡Debes capturar una pieza oponente!&quot;,
                invalidMove: &quot;¡Movimiento inválido!&quot;,
                piecePromoted: &quot;¡Pieza promovida a Rey!&quot;,
                multipleCaptures: &quot;¡Múltiples capturas posibles!&quot;,
                allPiecesCaptured: &quot;Todas las piezas capturadas&quot;,
                noMovesLeft: &quot;No quedan movimientos&quot;,
                morePieces: &quot;Más piezas restantes&quot;,
                strategicAdvantage: &quot;Ventaja estratégica&quot;,
                reason: &quot;Razón&quot;,
                finalScore: &quot;Puntuación Final&quot;,
                totalMoves: &quot;Movimientos Totales&quot;,
                pauseText: &quot;Pausa&quot;,
                resumeText: &quot;Reanudar&quot;,
                gamePaused: &quot;Juego pausado&quot;,
                gameResumed: &quot;Juego reanudado&quot;
            },
            de: {
                gameTitle: &quot;Brainova Quanten-Dame&quot;,
                quantumBadge: &quot;🚀 QUANTEN-KI&quot;,
                controlsTitle: &quot;🎮 Quanten-Steuerung&quot;,
                gameModeTitle: &quot;🎮 Spielmodus&quot;,
                aiMoveText: &quot;Quanten-KI Zug&quot;,
                undoText: &quot;Zug rückgängig&quot;,
                quantumModeText: &quot;Quanten-Modus&quot;,
                newGameText: &quot;Neues Spiel&quot;,
                statsTitle: &quot;📊 Statistiken&quot;,
                movesLabel: &quot;Gespielte Züge&quot;,
                aiLevelLabel: &quot;KI-Level&quot;,
                timeLabel: &quot;Zeit&quot;,
                scoreLabel: &quot;Punkte&quot;,
                aiModeText: &quot;Gegen KI spielen&quot;,
                humanModeText: &quot;2 Spieler&quot;,
                gameStatus: &quot;Neues Spiel - Gelb beginnt&quot;,
                playerYellow: &quot;Gelber Spieler&quot;,
                playerRed: &quot;Roter Spieler&quot;,
                aiPlayer: &quot;Quanten-KI&quot;,
                historyTitle: &quot;📜 Verlauf&quot;,
                gameStarted: &quot;Spiel gestartet&quot;,
                optionsTitle: &quot;⚙️ KI-Optionen&quot;,
                difficultyText: &quot;Schwierigkeit: Experte&quot;,
                analysisText: &quot;KI-Analyse&quot;,
                hintText: &quot;Beste Züge&quot;,
                saveText: &quot;Spiel speichern&quot;,
                aiThinking: &quot;Quanten-KI analysiert...&quot;,
                closeBtn: &quot;Schließen&quot;,
                turnOf: &quot;Zug von&quot;,
                gameEnded: &quot;Spiel beendet&quot;,
                newGameStarted: &quot;Neues Spiel gestartet&quot;,
                quantumActivated: &quot;Quanten-Modus aktiviert! Figuren können sich teleportieren!&quot;,
                quantumDeactivated: &quot;Quanten-Modus deaktiviert&quot;,
                gameSaved: &quot;Spiel gespeichert!&quot;,
                gameLoaded: &quot;Spiel geladen!&quot;,
                loadSavedGame: &quot;Möchten Sie das gespeicherte Spiel laden?&quot;,
                welcome: &quot;Willkommen bei Brainova Quanten-Dame! Wählen Sie Ihren Spielmodus.&quot;,
                aiCalculating: &quot;Quanten-KI berechnet besten Zug...&quot;,
                undoInDevelopment: &quot;Rückgängig-Funktion in Entwicklung&quot;,
                aiAnalyzing: &quot;KI-Analyse läuft...&quot;,
                bestMovesCalculating: &quot;Berechne beste Züge...&quot;,
                suggestion: &quot;Vorschlag:&quot;,
                noMovesAvailable: &quot;Keine Züge verfügbar&quot;,
                difficultyChanged: &quot;Schwierigkeit geändert:&quot;,
                yellowAdvantage: &quot;Signifikanter Vorteil für Gelb&quot;,
                redAdvantage: &quot;Signifikanter Vorteil für Rot&quot;,
                slightYellowAdvantage: &quot;Leichter Vorteil für Gelb&quot;,
                slightRedAdvantage: &quot;Leichter Vorteil für Rot&quot;,
                balancedPosition: &quot;Ausgeglichene Position&quot;,
                victory: &quot;Sieg für&quot;,
                yellows: &quot;Gelb&quot;,
                reds: &quot;Rot&quot;,
                difficulties: {
                    easy: &quot;einfach&quot;,
                    normal: &quot;normal&quot;,
                    hard: &quot;schwer&quot;,
                    expert: &quot;experte&quot;
                },
                mustCapture: &quot;Sie müssen eine gegnerische Figur schlagen!&quot;,
                invalidMove: &quot;Ungültiger Zug!&quot;,
                piecePromoted: &quot;Figur zur Dame befördert!&quot;,
                multipleCaptures: &quot;Mehrere Schläge möglich!&quot;,
                allPiecesCaptured: &quot;Alle Figuren geschlagen&quot;,
                noMovesLeft: &quot;Keine Züge übrig&quot;,
                morePieces: &quot;Mehr Figuren übrig&quot;,
                strategicAdvantage: &quot;Strategischer Vorteil&quot;,
                reason: &quot;Grund&quot;,
                finalScore: &quot;Endpunktzahl&quot;,
                totalMoves: &quot;Gesamtzüge&quot;,
                pauseText: &quot;Pause&quot;,
                resumeText: &quot;Fortsetzen&quot;,
                gamePaused: &quot;Spiel pausiert&quot;,
                gameResumed: &quot;Spiel fortgesetzt&quot;
            },
            zh: {
                gameTitle: &quot;脑诺瓦量子跳棋&quot;,
                quantumBadge: &quot;🚀 量子人工智能&quot;,
                controlsTitle: &quot;🎮 量子控制&quot;,
                gameModeTitle: &quot;🎮 游戏模式&quot;,
                aiMoveText: &quot;量子AI走棋&quot;,
                undoText: &quot;撤销走棋&quot;,
                quantumModeText: &quot;量子模式&quot;,
                newGameText: &quot;新游戏&quot;,
                statsTitle: &quot;📊 统计数据&quot;,
                movesLabel: &quot;已走步数&quot;,
                aiLevelLabel: &quot;AI等级&quot;,
                timeLabel: &quot;时间&quot;,
                scoreLabel: &quot;得分&quot;,
                aiModeText: &quot;对战AI&quot;,
                humanModeText: &quot;双人对战&quot;,
                gameStatus: &quot;新游戏 - 黄方先行&quot;,
                playerYellow: &quot;黄方玩家&quot;,
                playerRed: &quot;红方玩家&quot;,
                aiPlayer: &quot;量子AI&quot;,
                historyTitle: &quot;📜 历史记录&quot;,
                gameStarted: &quot;游戏开始&quot;,
                optionsTitle: &quot;⚙️ AI选项&quot;,
                difficultyText: &quot;难度：专家&quot;,
                analysisText: &quot;AI分析&quot;,
                hintText: &quot;最佳走法&quot;,
                saveText: &quot;保存游戏&quot;,
                aiThinking: &quot;量子AI分析中...&quot;,
                closeBtn: &quot;关闭&quot;,
                turnOf: &quot;轮到&quot;,
                gameEnded: &quot;游戏结束&quot;,
                newGameStarted: &quot;新游戏开始&quot;,
                quantumActivated: &quot;量子模式已激活！棋子可以瞬移！&quot;,
                quantumDeactivated: &quot;量子模式已关闭&quot;,
                gameSaved: &quot;游戏已保存！&quot;,
                gameLoaded: &quot;游戏已加载！&quot;,
                loadSavedGame: &quot;您要加载保存的游戏吗？&quot;,
                welcome: &quot;欢迎来到脑诺瓦量子跳棋！选择您的游戏模式。&quot;,
                aiCalculating: &quot;量子AI正在计算最佳走法...&quot;,
                undoInDevelopment: &quot;撤销功能开发中&quot;,
                aiAnalyzing: &quot;AI分析进行中...&quot;,
                bestMovesCalculating: &quot;计算最佳走法中...&quot;,
                suggestion: &quot;建议：&quot;,
                noMovesAvailable: &quot;无可用走法&quot;,
                difficultyChanged: &quot;难度已更改：&quot;,
                yellowAdvantage: &quot;黄方显著优势&quot;,
                redAdvantage: &quot;红方显著优势&quot;,
                slightYellowAdvantage: &quot;黄方轻微优势&quot;,
                slightRedAdvantage: &quot;红方轻微优势&quot;,
                balancedPosition: &quot;平衡局面&quot;,
                victory: &quot;获胜方&quot;,
                yellows: &quot;黄方&quot;,
                reds: &quot;红方&quot;,
                difficulties: {
                    easy: &quot;简单&quot;,
                    normal: &quot;普通&quot;,
                    hard: &quot;困难&quot;,
                    expert: &quot;专家&quot;
                },
                mustCapture: &quot;您必须吃掉对方棋子！&quot;,
                invalidMove: &quot;无效移动！&quot;,
                piecePromoted: &quot;棋子升级为王！&quot;,
                multipleCaptures: &quot;可以连续吃子！&quot;,
                allPiecesCaptured: &quot;所有棋子被吃&quot;,
                noMovesLeft: &quot;无剩余走法&quot;,
                morePieces: &quot;剩余棋子更多&quot;,
                strategicAdvantage: &quot;战略优势&quot;,
                reason: &quot;原因&quot;,
                finalScore: &quot;最终得分&quot;,
                totalMoves: &quot;总步数&quot;,
                pauseText: &quot;暂停&quot;,
                resumeText: &quot;继续&quot;,
                gamePaused: &quot;游戏已暂停&quot;,
                gameResumed: &quot;游戏已继续&quot;
            }
        };

        // État du jeu
    var gameState = {
            board: [],
            currentPlayer: &#x27;yellow&#x27;,
            gameMode: &#x27;ai&#x27;, // &#x27;ai&#x27; ou &#x27;human&#x27;
            selectedSquare: null,
            possibleMoves: [],
            moveHistory: [],
            moveCount: 0,
            startTime: null,
            timer: null,
            aiLevel: 5,
            score: 0,
            isGameActive: true,
            quantumMode: false,
            aiThinking: false,
            difficulty: &#x27;expert&#x27;,
            capturedPieces: { yellow: [], red: [] },
            currentLanguage: &#x27;fr&#x27;,
            mustCapture: false,
            captureSequence: [],
            isPaused: false
        };

        // Position initiale des pions
        const initialBoard = [
            [null, &#x27;🔴&#x27;, null, &#x27;🔴&#x27;, null, &#x27;🔴&#x27;, null, &#x27;🔴&#x27;],
            [&#x27;🔴&#x27;, null, &#x27;🔴&#x27;, null, &#x27;🔴&#x27;, null, &#x27;🔴&#x27;, null],
            [null, &#x27;🔴&#x27;, null, &#x27;🔴&#x27;, null, &#x27;🔴&#x27;, null, &#x27;🔴&#x27;],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            [&#x27;🟡&#x27;, null, &#x27;🟡&#x27;, null, &#x27;🟡&#x27;, null, &#x27;🟡&#x27;, null],
            [null, &#x27;🟡&#x27;, null, &#x27;🟡&#x27;, null, &#x27;🟡&#x27;, null, &#x27;🟡&#x27;],
            [&#x27;🟡&#x27;, null, &#x27;🟡&#x27;, null, &#x27;🟡&#x27;, null, &#x27;🟡&#x27;, null]
        ];

        // Fonction de changement de langue
        function changeLanguage() {
            const selector = document.getElementById(&#x27;languageSelector&#x27;);
            const selectedLang = selector.value;
            gameState.currentLanguage = selectedLang;
            
            const t = translations[selectedLang];
            
            // Mettre à jour tous les textes
            document.getElementById(&#x27;gameTitle&#x27;).textContent = t.gameTitle;
            document.getElementById(&#x27;quantumBadge&#x27;).textContent = t.quantumBadge;
            document.getElementById(&#x27;controlsTitle&#x27;).textContent = t.controlsTitle;
            if(document.getElementById(&#x27;gameModeTitle&#x27;)) {
                document.getElementById(&#x27;gameModeTitle&#x27;).textContent = t.gameModeTitle;
            }
            document.getElementById(&#x27;aiMoveText&#x27;).textContent = t.aiMoveText;
            document.getElementById(&#x27;undoText&#x27;).textContent = t.undoText;
            document.getElementById(&#x27;quantumModeText&#x27;).textContent = t.quantumModeText;
            document.getElementById(&#x27;newGameText&#x27;).textContent = t.newGameText;
            document.getElementById(&#x27;statsTitle&#x27;).textContent = t.statsTitle;
            document.getElementById(&#x27;movesLabel&#x27;).textContent = t.movesLabel;
            document.getElementById(&#x27;aiLevelLabel&#x27;).textContent = t.aiLevelLabel;
            document.getElementById(&#x27;timeLabel&#x27;).textContent = t.timeLabel;
            document.getElementById(&#x27;scoreLabel&#x27;).textContent = t.scoreLabel;
            document.getElementById(&#x27;aiModeText&#x27;).textContent = t.aiModeText;
            document.getElementById(&#x27;humanModeText&#x27;).textContent = t.humanModeText;
            document.getElementById(&#x27;historyTitle&#x27;).textContent = t.historyTitle;
            document.getElementById(&#x27;optionsTitle&#x27;).textContent = t.optionsTitle;
            document.getElementById(&#x27;analysisText&#x27;).textContent = t.analysisText;
            document.getElementById(&#x27;hintText&#x27;).textContent = t.hintText;
            document.getElementById(&#x27;saveText&#x27;).textContent = t.saveText;
            document.getElementById(&#x27;closeBtn&#x27;).title = t.closeBtn;
            
            // Mettre à jour le texte de difficulté
            const diffText = t.difficultyText.replace(&#x27;Expert&#x27;, t.difficulties[gameState.difficulty]);
            document.getElementById(&#x27;difficultyText&#x27;).textContent = diffText;
            
            // Mettre à jour le message &quot;Partie commencée&quot; dans l&#x27;historique
            const gameStartedElement = document.getElementById(&#x27;gameStarted&#x27;);
            if(gameStartedElement) {
                gameStartedElement.textContent = t.gameStarted;
            }
            
            // Mettre à jour le bouton pause
            const pauseTextElement = document.getElementById(&#x27;pauseText&#x27;);
            if(pauseTextElement) {
                pauseTextElement.textContent = gameState.isPaused ? t.resumeText : t.pauseText;
            }
            
            updateUI();
        }

        // Créer les particules quantiques
        function createQuantumParticles() {
            const container = document.getElementById(&#x27;quantumParticles&#x27;);
            
            for(let i = 0; i &lt; 35; i++) {
                const particle = document.createElement(&#x27;div&#x27;);
                particle.className = &#x27;quantum-particle&#x27;;
                particle.style.left = Math.random() * 100 + &#x27;%&#x27;;
                particle.style.animationDelay = Math.random() * 15 + &#x27;s&#x27;;
                particle.style.animationDuration = (15 + Math.random() * 8) + &#x27;s&#x27;;
                container.appendChild(particle);
            }
        }

        // Créer les lignes d&#x27;énergie
        function createEnergyLines() {
            const container = document.getElementById(&#x27;energyLines&#x27;);
            
            for(let i = 0; i &lt; 10; i++) {
                const line = document.createElement(&#x27;div&#x27;);
                line.className = &#x27;energy-line&#x27;;
                line.style.top = Math.random() * 100 + &#x27;%&#x27;;
                line.style.width = (250 + Math.random() * 500) + &#x27;px&#x27;;
                line.style.animationDelay = Math.random() * 10 + &#x27;s&#x27;;
                line.style.animationDuration = (10 + Math.random() * 5) + &#x27;s&#x27;;
                container.appendChild(line);
            }
        }

        // Créer les cercles d&#x27;énergie
        function createEnergyCircles() {
            const container = document.getElementById(&#x27;energyCircles&#x27;);
            
            for(let i = 0; i &lt; 8; i++) {
                const circle = document.createElement(&#x27;div&#x27;);
                circle.className = &#x27;energy-circle&#x27;;
                circle.style.left = Math.random() * 100 + &#x27;%&#x27;;
                circle.style.top = Math.random() * 100 + &#x27;%&#x27;;
                circle.style.width = (60 + Math.random() * 120) + &#x27;px&#x27;;
                circle.style.height = circle.style.width;
                circle.style.animationDelay = Math.random() * 8 + &#x27;s&#x27;;
                circle.style.animationDuration = (8 + Math.random() * 4) + &#x27;s&#x27;;
                container.appendChild(circle);
            }
        }

        // Créer les rayons laser
        function createLaserBeams() {
            const container = document.getElementById(&#x27;laserBeams&#x27;);
            
            for(let i = 0; i &lt; 6; i++) {
                const beam = document.createElement(&#x27;div&#x27;);
                beam.className = &#x27;laser-beam&#x27;;
                beam.style.left = Math.random() * 100 + &#x27;%&#x27;;
                beam.style.animationDelay = Math.random() * 15 + &#x27;s&#x27;;
                beam.style.animationDuration = (15 + Math.random() * 8) + &#x27;s&#x27;;
                container.appendChild(beam);
            }
        }

        // Initialiser tous les effets futuristes
        function initFuturisticEffects() {
            createQuantumParticles();
            createEnergyLines();
            createEnergyCircles();
            createLaserBeams();
        }

        // Initialiser le jeu
        function initGame() {
            gameState.board = initialBoard.map(row =&gt; [...row]);
            gameState.currentPlayer = &#x27;yellow&#x27;;
            gameState.selectedSquare = null;
            gameState.possibleMoves = [];
            gameState.moveHistory = [];
            gameState.moveCount = 0;
            gameState.startTime = Date.now();
            gameState.isGameActive = true;
            gameState.quantumMode = false;
            gameState.mustCapture = false;
            gameState.captureSequence = [];
            
            createDameboard();
            updateUI();
            startTimer();
            
            const t = translations[gameState.currentLanguage];
            
            // Vider l&#x27;historique et ajouter le message de début
            const historyElement = document.getElementById(&#x27;moveHistory&#x27;);
            historyElement.innerHTML = &#x27;&#x27;;
            const gameStartedElement = document.createElement(&#x27;div&#x27;);
            gameStartedElement.className = &#x27;move-item&#x27;;
            gameStartedElement.id = &#x27;gameStarted&#x27;;
            gameStartedElement.textContent = t.gameStarted;
            historyElement.appendChild(gameStartedElement);
        }

        // Créer le plateau de dames
        function createDameboard() {
            const dameboard = document.getElementById(&#x27;dameboard&#x27;);
            dameboard.innerHTML = &#x27;&#x27;;
            
            for(let row = 0; row &lt; 8; row++) {
                for(let col = 0; col &lt; 8; col++) {
                    const square = document.createElement(&#x27;div&#x27;);
                    square.className = `dame-square ${(row + col) % 2 === 0 ? &#x27;light&#x27; : &#x27;dark&#x27;}`;
                    square.dataset.row = row;
                    square.dataset.col = col;
                    square.onclick = () =&gt; handleSquareClick(row, col);
                    
                    const piece = gameState.board[row][col];
                    if(piece) {
                        const pieceElement = document.createElement(&#x27;div&#x27;);
                        pieceElement.className = `dame-piece ${getPieceColor(piece)} ${isKing(piece) ? &#x27;king&#x27; : &#x27;&#x27;}`;
                        pieceElement.textContent = piece;
                        square.appendChild(pieceElement);
                    }
                    
                    dameboard.appendChild(square);
                }
            }
        }

        // Obtenir la couleur d&#x27;une pièce
        function getPieceColor(piece) {
            if(piece === &#x27;🟡&#x27; || piece === &#x27;👑&#x27;) return &#x27;yellow&#x27;;
            if(piece === &#x27;🔴&#x27; || piece === &#x27;♛&#x27;) return &#x27;red&#x27;;
            return null;
        }

        // Vérifier si une pièce est un roi/dame
        function isKing(piece) {
            return piece === &#x27;👑&#x27; || piece === &#x27;♛&#x27;;
        }

        // Gérer le clic sur une case
        function handleSquareClick(row, col) {
            if(!gameState.isGameActive || gameState.aiThinking || gameState.isPaused) return;
            
            const piece = gameState.board[row][col];
            
            // Si on est en mode capture multiple, seul le pion qui capture peut bouger
            if(gameState.mustCapture &amp;&amp; gameState.captureSequence.length &gt; 0) {
                const lastCapture = gameState.captureSequence[gameState.captureSequence.length - 1];
                
                // Si on clique sur une case de mouvement possible pour continuer la capture
                if(gameState.selectedSquare &amp;&amp; 
                   gameState.selectedSquare.row === lastCapture.row &amp;&amp; 
                   gameState.selectedSquare.col === lastCapture.col &amp;&amp;
                   gameState.possibleMoves.some(move =&gt; move.row === row &amp;&amp; move.col === col)) {
                    makeMove(gameState.selectedSquare.row, gameState.selectedSquare.col, row, col);
                    return;
                }
                
                // Sinon, on ne peut sélectionner que le pion qui doit continuer à capturer
                if(row === lastCapture.row &amp;&amp; col === lastCapture.col) {
                    selectSquare(row, col);
                } else {
                    // Message d&#x27;erreur si on essaie de sélectionner autre chose
                    const t = translations[gameState.currentLanguage];
                    showAIMessage(t.mustCapture || &quot;Vous devez continuer avec le même pion !&quot;, 2000);
                }
                return;
            }
            
            // Si aucune pièce n&#x27;est sélectionnée
            if(!gameState.selectedSquare) {
                if(piece &amp;&amp; getPieceColor(piece) === gameState.currentPlayer) {
                    selectSquare(row, col);
                }
                return;
            }
            
            // Si on clique sur la même case
            if(gameState.selectedSquare.row === row &amp;&amp; gameState.selectedSquare.col === col) {
                deselectSquare();
                return;
            }
            
            // Si on clique sur une case de mouvement possible
            if(gameState.possibleMoves.some(move =&gt; move.row === row &amp;&amp; move.col === col)) {
                makeMove(gameState.selectedSquare.row, gameState.selectedSquare.col, row, col);
                return;
            }
            
            // Si on clique sur une autre pièce de la même couleur (et pas en capture multiple)
            if(piece &amp;&amp; getPieceColor(piece) === gameState.currentPlayer &amp;&amp; !gameState.mustCapture) {
                deselectSquare();
                selectSquare(row, col);
                return;
            }
            
            // Sinon, désélectionner
            deselectSquare();
        }

        // Sélectionner une case
        function selectSquare(row, col) {
            gameState.selectedSquare = { row, col };
            gameState.possibleMoves = calculatePossibleMoves(row, col);
            
            // Mettre en évidence la case sélectionnée
            const square = document.querySelector(`[data-row=&quot;${row}&quot;][data-col=&quot;${col}&quot;]`);
            square.classList.add(&#x27;selected&#x27;);
            
            // Mettre en évidence les mouvements possibles
            gameState.possibleMoves.forEach(move =&gt; {
                const moveSquare = document.querySelector(`[data-row=&quot;${move.row}&quot;][data-col=&quot;${move.col}&quot;]`);
                moveSquare.classList.add(&#x27;possible-move&#x27;);
            });
        }

        // Désélectionner une case
        function deselectSquare() {
            if(gameState.selectedSquare) {
                const square = document.querySelector(`[data-row=&quot;${gameState.selectedSquare.row}&quot;][data-col=&quot;${gameState.selectedSquare.col}&quot;]`);
                square.classList.remove(&#x27;selected&#x27;);
            }
            
            // Enlever la mise en évidence des mouvements possibles
            document.querySelectorAll(&#x27;.possible-move&#x27;).forEach(square =&gt; {
                square.classList.remove(&#x27;possible-move&#x27;);
            });
            
            gameState.selectedSquare = null;
            gameState.possibleMoves = [];
        }

        // Calculer les mouvements possibles pour une pièce
        function calculatePossibleMoves(row, col) {
            const piece = gameState.board[row][col];
            if(!piece) return [];
            
            const moves = [];
            const color = getPieceColor(piece);
            const king = isKing(piece);
            
            // Directions de mouvement
            let directions = [];
            if(king) {
                directions = [[-1, -1], [-1, 1], [1, -1], [1, 1]]; // Toutes les diagonales
            } else if(color === &#x27;yellow&#x27;) {
                directions = [[-1, -1], [-1, 1]]; // Vers le haut
            } else {
                directions = [[1, -1], [1, 1]]; // Vers le bas
            }
            
            // Vérifier les captures obligatoires d&#x27;abord
            const captures = [];
            for(let [drow, dcol] of directions) {
                if(king) {
                    // Pour les dames : vérifier les captures à longue distance
                    const longCaptures = checkLongRangeCapture(row, col, drow, dcol);
                    captures.push(...longCaptures);
                } else {
                    // Pour les pions : capture simple
                    const captureMove = checkCapture(row, col, drow, dcol);
                    if(captureMove) {
                        captures.push(captureMove);
                    }
                }
            }
            
            // Si des captures sont possibles, elles sont obligatoires
            if(captures.length &gt; 0) {
                return captures;
            }
            
            // Sinon, mouvements normaux
            if(king) {
                // Les dames peuvent se déplacer sur toute la diagonale
                for(let [drow, dcol] of directions) {
                    for(let distance = 1; distance &lt; 8; distance++) {
                        const newRow = row + drow * distance;
                        const newCol = col + dcol * distance;
                        
                        if(newRow &gt;= 0 &amp;&amp; newRow &lt; 8 &amp;&amp; newCol &gt;= 0 &amp;&amp; newCol &lt; 8) {
                            if(!gameState.board[newRow][newCol]) {
                                moves.push({ row: newRow, col: newCol, type: &#x27;move&#x27; });
                            } else {
                                break; // Arrêter si on rencontre une pièce
                            }
                        } else {
                            break; // Arrêter si on sort du plateau
                        }
                    }
                }
            } else {
                // Les pions ne peuvent se déplacer que d&#x27;une case
                for(let [drow, dcol] of directions) {
                    const newRow = row + drow;
                    const newCol = col + dcol;
                    
                    if(newRow &gt;= 0 &amp;&amp; newRow &lt; 8 &amp;&amp; newCol &gt;= 0 &amp;&amp; newCol &lt; 8) {
                        if(!gameState.board[newRow][newCol]) {
                            moves.push({ row: newRow, col: newCol, type: &#x27;move&#x27; });
                        }
                    }
                }
            }
            
            return moves;
        }

        // Vérifier une capture possible (pour les pions)
        function checkCapture(row, col, drow, dcol) {
            const jumpRow = row + drow;
            const jumpCol = col + dcol;
            const landRow = row + 2 * drow;
            const landCol = col + 2 * dcol;
            
            // Vérifier les limites
            if(landRow &lt; 0 || landRow &gt;= 8 || landCol &lt; 0 || landCol &gt;= 8) return null;
            
            const jumpPiece = gameState.board[jumpRow][jumpCol];
            const landSquare = gameState.board[landRow][landCol];
            
            // Il doit y avoir une pièce adverse à sauter et une case vide pour atterrir
            if(jumpPiece &amp;&amp; getPieceColor(jumpPiece) !== gameState.currentPlayer &amp;&amp; !landSquare) {
                return { 
                    row: landRow, 
                    col: landCol, 
                    type: &#x27;capture&#x27;,
                    capturedRow: jumpRow,
                    capturedCol: jumpCol
                };
            }
            
            return null;
        }

        // Vérifier les captures à longue distance (pour les dames)
        function checkLongRangeCapture(row, col, drow, dcol) {
            const captures = [];
            let foundEnemy = false;
            let enemyRow = -1;
            let enemyCol = -1;
            let capturedPieces = [];
            
            // Parcourir la diagonale
            for(let distance = 1; distance &lt; 8; distance++) {
                const checkRow = row + drow * distance;
                const checkCol = col + dcol * distance;
                
                // Vérifier les limites
                if(checkRow &lt; 0 || checkRow &gt;= 8 || checkCol &lt; 0 || checkCol &gt;= 8) break;
                
                const piece = gameState.board[checkRow][checkCol];
                
                if(piece) {
                    if(getPieceColor(piece) !== gameState.currentPlayer) {
                        // Pièce ennemie trouvée
                        if(foundEnemy) {
                            // Déjà une pièce ennemie trouvée, arrêter
                            break;
                        }
                        foundEnemy = true;
                        enemyRow = checkRow;
                        enemyCol = checkCol;
                        capturedPieces.push({ row: checkRow, col: checkCol });
                    } else {
                        // Pièce alliée, arrêter
                        break;
                    }
                } else if(foundEnemy) {
                    // Case vide après une pièce ennemie = capture possible
                    // Continuer à chercher d&#x27;autres cases vides
                    captures.push({
                        row: checkRow,
                        col: checkCol,
                        type: &#x27;capture&#x27;,
                        capturedPieces: [...capturedPieces]
                    });
                }
            }
            
            return captures;
        }

        // Effectuer un mouvement
        function makeMove(fromRow, fromCol, toRow, toCol) {
            const piece = gameState.board[fromRow][fromCol];
            const move = gameState.possibleMoves.find(m =&gt; m.row === toRow &amp;&amp; m.col === toCol);
            
            if(!move) return;
            
            // Effectuer le mouvement
            gameState.board[toRow][toCol] = piece;
            gameState.board[fromRow][fromCol] = null;
            
            let moveNotation = `${piece} ${String.fromCharCode(97 + fromCol)}${8 - fromRow} → ${String.fromCharCode(97 + toCol)}${8 - toRow}`;
            let continueCapturing = false;
            
            // Gérer les captures
            if(move.type === &#x27;capture&#x27;) {
                // Capturer toutes les pièces dans le chemin (pour les dames)
                if(move.capturedPieces) {
                    move.capturedPieces.forEach(captured =&gt; {
                        const capturedPiece = gameState.board[captured.row][captured.col];
                        gameState.board[captured.row][captured.col] = null;
                        
                        const capturedColor = getPieceColor(capturedPiece);
                        gameState.capturedPieces[capturedColor].push(capturedPiece);
                        gameState.score += isKing(capturedPiece) ? 3 : 1;
                        moveNotation += ` (capture ${capturedPiece})`;
                    });
                } else {
                    // Capture simple (pion normal)
                    const capturedPiece = gameState.board[move.capturedRow][move.capturedCol];
                    gameState.board[move.capturedRow][move.capturedCol] = null;
                    
                    const capturedColor = getPieceColor(capturedPiece);
                    gameState.capturedPieces[capturedColor].push(capturedPiece);
                    gameState.score += isKing(capturedPiece) ? 3 : 1;
                    moveNotation += ` (capture ${capturedPiece})`;
                }
                
                // Vérifier les captures multiples avec LE MÊME PION
                const additionalCaptures = calculatePossibleMoves(toRow, toCol).filter(m =&gt; m.type === &#x27;capture&#x27;);
                if(additionalCaptures.length &gt; 0) {
                    gameState.mustCapture = true;
                    gameState.captureSequence.push({ row: toRow, col: toCol });
                    continueCapturing = true;
                    
                    // Sélectionner automatiquement LA MÊME pièce pour continuer
                    setTimeout(() =&gt; {
                        selectSquare(toRow, toCol);
                        const t = translations[gameState.currentLanguage];
                        showAIMessage(t.multipleCaptures, 2500);
                    }, 300);
                }
            }
            
            // Promotion en dame/roi
            if(!isKing(piece)) {
                if((getPieceColor(piece) === &#x27;yellow&#x27; &amp;&amp; toRow === 0) || 
                   (getPieceColor(piece) === &#x27;red&#x27; &amp;&amp; toRow === 7)) {
                    gameState.board[toRow][toCol] = getPieceColor(piece) === &#x27;yellow&#x27; ? &#x27;👑&#x27; : &#x27;♛&#x27;;
                    const t = translations[gameState.currentLanguage];
                    showAIMessage(t.piecePromoted, 2000);
                }
            }
            
            // Ajouter à l&#x27;historique
            addMoveToHistory(moveNotation);
            gameState.moveCount++;
            
            // Si pas de capture multiple, terminer le tour
            if(!continueCapturing) {
                gameState.mustCapture = false;
                gameState.captureSequence = [];
                deselectSquare();
                
                // Changer de joueur seulement si pas de capture multiple
                gameState.currentPlayer = gameState.currentPlayer === &#x27;yellow&#x27; ? &#x27;red&#x27; : &#x27;yellow&#x27;;
            } else {
                // Ne pas désélectionner si capture multiple avec LE MÊME PION
                // Le joueur actuel garde la main avec le même pion
            }
            
            createDameboard();
            
            // Vérifier la fin de partie
            if(isGameOver()) {
                endGame();
                return;
            }
            
            updateUI();
            
            // Si c&#x27;est le tour de l&#x27;IA en mode IA ET pas de capture multiple
            if(gameState.gameMode === &#x27;ai&#x27; &amp;&amp; gameState.currentPlayer === &#x27;red&#x27; &amp;&amp; gameState.isGameActive &amp;&amp; !continueCapturing) {
                setTimeout(() =&gt; {
                    if(gameState.isGameActive &amp;&amp; gameState.currentPlayer === &#x27;red&#x27;) {
                        makeAIMove();
                    }
                }, 1200);
            }
            
            // Si l&#x27;IA doit continuer une capture multiple avec le même pion
            if(gameState.gameMode === &#x27;ai&#x27; &amp;&amp; gameState.currentPlayer === &#x27;red&#x27; &amp;&amp; gameState.isGameActive &amp;&amp; continueCapturing) {
                setTimeout(() =&gt; {
                    if(gameState.isGameActive &amp;&amp; gameState.currentPlayer === &#x27;red&#x27; &amp;&amp; gameState.mustCapture) {
                        makeAIMove();
                    }
                }, 1500);
            }
        }

        // Ajouter un coup à l&#x27;historique
        function addMoveToHistory(move) {
            gameState.moveHistory.push(move);
            const historyElement = document.getElementById(&#x27;moveHistory&#x27;);
            const moveElement = document.createElement(&#x27;div&#x27;);
            moveElement.className = &#x27;move-item&#x27;;
            moveElement.textContent = `${gameState.moveHistory.length}. ${move}`;
            historyElement.appendChild(moveElement);
            historyElement.scrollTop = historyElement.scrollHeight;
        }

        // Coup de l&#x27;IA
        function makeAIMove() {
            if(gameState.currentPlayer !== &#x27;red&#x27; || !gameState.isGameActive || gameState.gameMode !== &#x27;ai&#x27; || gameState.isPaused) return;
            
            gameState.aiThinking = true;
            const t = translations[gameState.currentLanguage];
            showAIMessage(t.aiCalculating, 0);
            
            setTimeout(() =&gt; {
                if(gameState.isGameActive &amp;&amp; gameState.currentPlayer === &#x27;red&#x27; &amp;&amp; gameState.gameMode === &#x27;ai&#x27;) {
                    const bestMove = calculateBestMove();
                    if(bestMove) {
                        // Simuler la sélection et le mouvement de l&#x27;IA
                        gameState.selectedSquare = { row: bestMove.fromRow, col: bestMove.fromCol };
                        gameState.possibleMoves = calculatePossibleMoves(bestMove.fromRow, bestMove.fromCol);
                        makeMove(bestMove.fromRow, bestMove.fromCol, bestMove.toRow, bestMove.toCol);
                    }
                }
                gameState.aiThinking = false;
                hideAIMessage();
            }, 1800 + Math.random() * 2500);
        }

        // Calculer le meilleur coup pour l&#x27;IA
        function calculateBestMove() {
            const allMoves = [];
            
            // Générer tous les coups possibles pour les pièces rouges
            for(let row = 0; row &lt; 8; row++) {
                for(let col = 0; col &lt; 8; col++) {
                    const piece = gameState.board[row][col];
                    if(piece &amp;&amp; getPieceColor(piece) === &#x27;red&#x27;) {
                        const moves = calculatePossibleMoves(row, col);
                        moves.forEach(move =&gt; {
                            allMoves.push({
                                fromRow: row,
                                fromCol: col,
                                toRow: move.row,
                                toCol: move.col,
                                type: move.type,
                                score: evaluateMove(row, col, move.row, move.col, move)
                            });
                        });
                    }
                }
            }
            
            if(allMoves.length === 0) return null;
            
            // Prioriser les captures
            const captures = allMoves.filter(m =&gt; m.type === &#x27;capture&#x27;);
            if(captures.length &gt; 0) {
                captures.sort((a, b) =&gt; b.score - a.score);
                return captures[0];
            }
            
            // Trier par score et prendre le meilleur
            allMoves.sort((a, b) =&gt; b.score - a.score);
            
            // Ajouter un peu d&#x27;aléatoire selon la difficulté
            const randomFactor = gameState.difficulty === &#x27;easy&#x27; ? 0.6 : 
                                 gameState.difficulty === &#x27;normal&#x27; ? 0.3 : 0.1;
            
            if(Math.random() &lt; randomFactor) {
                return allMoves[Math.floor(Math.random() * Math.min(4, allMoves.length))];
            }
            
            return allMoves[0];
        }

        // Évaluer un coup
        function evaluateMove(fromRow, fromCol, toRow, toCol, move) {
            let score = 0;
            
            // Bonus énorme pour les captures
            if(move.type === &#x27;capture&#x27;) {
                const capturedPiece = gameState.board[move.capturedRow][move.capturedCol];
                score += isKing(capturedPiece) ? 30 : 10;
            }
            
            // Bonus pour avancer vers la promotion
            if(!isKing(gameState.board[fromRow][fromCol])) {
                score += (toRow - fromRow) * 2; // Plus on avance, mieux c&#x27;est
            }
            
            // Bonus pour contrôler le centre
            const centerDistance = Math.abs(toRow - 3.5) + Math.abs(toCol - 3.5);
            score += (7 - centerDistance) * 1.5;
            
            // Bonus pour la sécurité (éviter les bords)
            if(toRow &gt; 0 &amp;&amp; toRow &lt; 7 &amp;&amp; toCol &gt; 0 &amp;&amp; toCol &lt; 7) {
                score += 2;
            }
            
            return score + Math.random() * 3;
        }

        // Vérifier la fin de partie
        function isGameOver() {
            // Compter les pièces
            let yellowPieces = 0;
            let redPieces = 0;
            let yellowMoves = 0;
            let redMoves = 0;
            
            for(let row = 0; row &lt; 8; row++) {
                for(let col = 0; col &lt; 8; col++) {
                    const piece = gameState.board[row][col];
                    if(piece) {
                        if(getPieceColor(piece) === &#x27;yellow&#x27;) {
                            yellowPieces++;
                            yellowMoves += calculatePossibleMoves(row, col).length;
                        } else {
                            redPieces++;
                            redMoves += calculatePossibleMoves(row, col).length;
                        }
                    }
                }
            }
            
            // Fin de partie si plus de pièces ou plus de mouvements possibles
            return yellowPieces === 0 || redPieces === 0 || 
                   (gameState.currentPlayer === &#x27;yellow&#x27; &amp;&amp; yellowMoves === 0) ||
                   (gameState.currentPlayer === &#x27;red&#x27; &amp;&amp; redMoves === 0);
        }

        // Terminer la partie
        function endGame() {
            gameState.isGameActive = false;
            clearInterval(gameState.timer);
            
            const t = translations[gameState.currentLanguage];
            
            // Déterminer le gagnant
            let yellowPieces = 0;
            let redPieces = 0;
            let yellowMoves = 0;
            let redMoves = 0;
            
            for(let row = 0; row &lt; 8; row++) {
                for(let col = 0; col &lt; 8; col++) {
                    const piece = gameState.board[row][col];
                    if(piece) {
                        if(getPieceColor(piece) === &#x27;yellow&#x27;) {
                            yellowPieces++;
                            yellowMoves += calculatePossibleMoves(row, col).length;
                        } else {
                            redPieces++;
                            redMoves += calculatePossibleMoves(row, col).length;
                        }
                    }
                }
            }
            
            let winner;
            let reason = &quot;&quot;;
            
            // Déterminer la raison de la victoire
            if(yellowPieces === 0) {
                winner = t.reds;
                reason = t.allPiecesCaptured || &quot;Toutes les pièces capturées&quot;;
            } else if(redPieces === 0) {
                winner = t.yellows;
                reason = t.allPiecesCaptured || &quot;Toutes les pièces capturées&quot;;
            } else if(gameState.currentPlayer === &#x27;yellow&#x27; &amp;&amp; yellowMoves === 0) {
                winner = t.reds;
                reason = t.noMovesLeft || &quot;Aucun mouvement possible&quot;;
            } else if(gameState.currentPlayer === &#x27;red&#x27; &amp;&amp; redMoves === 0) {
                winner = t.yellows;
                reason = t.noMovesLeft || &quot;Aucun mouvement possible&quot;;
            } else if(yellowPieces &gt; redPieces) {
                winner = t.yellows;
                reason = t.morePieces || &quot;Plus de pièces&quot;;
            } else if(redPieces &gt; yellowPieces) {
                winner = t.reds;
                reason = t.morePieces || &quot;Plus de pièces&quot;;
            } else {
                winner = gameState.currentPlayer === &#x27;yellow&#x27; ? t.reds : t.yellows;
                reason = t.strategicAdvantage || &quot;Avantage stratégique&quot;;
            }
            
            // Afficher un message de fin de partie détaillé
            const finalMessage = `🏆 ${t.gameEnded}!\n\n${t.victory}: ${winner}\n${t.reason || &quot;Raison&quot;}: ${reason}\n\n${t.finalScore || &quot;Score final&quot;}: ${gameState.score} points\n${t.totalMoves || &quot;Total coups&quot;}: ${gameState.moveCount}`;
            
            // Afficher le message avec style
            showGameEndMessage(finalMessage);
            
            // Ajouter à l&#x27;historique
            addMoveToHistory(`🏆 ${t.victory}: ${winner} (${reason})`);
        }
        
        // Afficher le message de fin de partie avec style
        function showGameEndMessage(message) {
            // Créer une overlay pour le message de fin
            const overlay = document.createElement(&#x27;div&#x27;);
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 1000;
                backdrop-filter: blur(10px);
            `;
            
            const messageBox = document.createElement(&#x27;div&#x27;);
            messageBox.style.cssText = `
                background: linear-gradient(145deg, rgba(30, 30, 58, 0.95), rgba(76, 29, 149, 0.95));
                border: 3px solid #ff6b35;
                border-radius: 20px;
                padding: 40px;
                text-align: center;
                color: white;
                font-size: 18px;
                font-weight: bold;
                max-width: 500px;
                box-shadow: 0 0 50px rgba(255, 107, 53, 0.7);
                animation: gameEndPulse 2s ease-in-out infinite alternate;
                white-space: pre-line;
            `;
            
            messageBox.textContent = message;
            
            const closeButton = document.createElement(&#x27;button&#x27;);
            closeButton.textContent = &#x27;✨ Nouvelle Partie&#x27;;
            closeButton.style.cssText = `
                margin-top: 30px;
                padding: 15px 30px;
                background: linear-gradient(145deg, #ff6b35, #f59e0b);
                color: white;
                border: none;
                border-radius: 15px;
                font-size: 16px;
                font-weight: bold;
                cursor: pointer;
                transition: all 0.3s ease;
            `;
            
            closeButton.onmouseover = () =&gt; {
                closeButton.style.transform = &#x27;scale(1.1)&#x27;;
                closeButton.style.boxShadow = &#x27;0 10px 30px rgba(255, 107, 53, 0.7)&#x27;;
            };
            
            closeButton.onmouseout = () =&gt; {
                closeButton.style.transform = &#x27;scale(1)&#x27;;
                closeButton.style.boxShadow = &#x27;none&#x27;;
            };
            
            closeButton.onclick = () =&gt; {
                document.body.removeChild(overlay);
                resetGame();
            };
            
            messageBox.appendChild(closeButton);
            overlay.appendChild(messageBox);
            document.body.appendChild(overlay);
            
            // Ajouter l&#x27;animation CSS
            const style = document.createElement(&#x27;style&#x27;);
            style.textContent = `
                @keyframes gameEndPulse {
                    from { 
                        box-shadow: 0 0 50px rgba(255, 107, 53, 0.7);
                        transform: scale(1);
                    }
                    to { 
                        box-shadow: 0 0 80px rgba(255, 107, 53, 1);
                        transform: scale(1.02);
                    }
                }
            `;
            document.head.appendChild(style);
        }

        // Afficher un message IA
        function showAIMessage(message, duration = 2500) {
            const aiThinking = document.getElementById(&#x27;aiThinking&#x27;);
            const aiMessage = document.getElementById(&#x27;aiMessage&#x27;);
            
            aiMessage.textContent = message;
            aiThinking.classList.add(&#x27;active&#x27;);
            
            if(duration &gt; 0) {
                setTimeout(() =&gt; {
                    aiThinking.classList.remove(&#x27;active&#x27;);
                }, duration);
            }
        }

        // Masquer le message IA
        function hideAIMessage() {
            const aiThinking = document.getElementById(&#x27;aiThinking&#x27;);
            aiThinking.classList.remove(&#x27;active&#x27;);
        }

        // Démarrer le timer
        function startTimer() {
            if(gameState.timer) {
                clearInterval(gameState.timer);
            }
            
            gameState.timer = setInterval(() =&gt; {
                if(gameState.isGameActive) {
                    updateUI();
                }
            }, 1000);
        }

        // Mettre à jour l&#x27;interface utilisateur
        function updateUI() {
            document.getElementById(&#x27;moveCount&#x27;).textContent = gameState.moveCount;
            document.getElementById(&#x27;aiLevel&#x27;).textContent = gameState.aiLevel;
            document.getElementById(&#x27;gameScore&#x27;).textContent = gameState.score;
            
            // Mettre à jour le temps
            if(gameState.startTime) {
                const elapsedTime = Date.now() - gameState.startTime;
                const minutes = Math.floor(elapsedTime / 60000);
                const seconds = Math.floor((elapsedTime % 60000) / 1000);
                document.getElementById(&#x27;gameTime&#x27;).textContent = 
                    `${minutes.toString().padStart(2, &#x27;0&#x27;)}:${seconds.toString().padStart(2, &#x27;0&#x27;)}`;
            }
            
            // Mettre à jour le bouton statut du joueur
            const t = translations[gameState.currentLanguage];
            const playerName = gameState.currentPlayer === &#x27;yellow&#x27; ? t.playerYellow : 
                              (gameState.gameMode === &#x27;ai&#x27; ? t.aiPlayer : t.playerRed);
            const playerIcon = gameState.currentPlayer === &#x27;yellow&#x27; ? &#x27;🔥&#x27; : &#x27;🤖&#x27;;
            
            document.getElementById(&#x27;currentPlayer&#x27;).textContent = playerIcon;
            document.getElementById(&#x27;playerName&#x27;).textContent = playerName;
            
            // Changer la couleur du bouton selon le joueur
            const playerBtn = document.getElementById(&#x27;playerStatusBtn&#x27;);
            playerBtn.classList.remove(&#x27;yellow-player&#x27;, &#x27;red-player&#x27;);
            if(gameState.currentPlayer === &#x27;yellow&#x27;) {
                playerBtn.classList.add(&#x27;yellow-player&#x27;);
            } else {
                playerBtn.classList.add(&#x27;red-player&#x27;);
            }
        }

        // Fonction pour changer de joueur manuellement (mode 2 joueurs uniquement)
        function switchPlayer() {
            if(gameState.gameMode === &#x27;human&#x27; &amp;&amp; gameState.isGameActive &amp;&amp; !gameState.aiThinking) {
                gameState.currentPlayer = gameState.currentPlayer === &#x27;yellow&#x27; ? &#x27;red&#x27; : &#x27;yellow&#x27;;
                deselectSquare();
                updateUI();
                
                const t = translations[gameState.currentLanguage];
                showAIMessage(`${t.turnOf} ${gameState.currentPlayer === &#x27;yellow&#x27; ? t.playerYellow : t.playerRed}`, 1800);
            }
        }

        // Fonctions des boutons
        function setGameMode(mode) {
            gameState.gameMode = mode;
            
            const aiBtn = document.getElementById(&#x27;aiModeBtn&#x27;);
            const humanBtn = document.getElementById(&#x27;humanModeBtn&#x27;);
            
            if(mode === &#x27;ai&#x27;) {
                aiBtn.classList.add(&#x27;active&#x27;);
                humanBtn.classList.remove(&#x27;active&#x27;);
            } else {
                humanBtn.classList.add(&#x27;active&#x27;);
                aiBtn.classList.remove(&#x27;active&#x27;);
            }
            
            resetGame();
        }

        function undoMove() {
            if(gameState.moveHistory.length &lt;= 1) return;
            
            const t = translations[gameState.currentLanguage];
            showAIMessage(t.undoInDevelopment, 2500);
        }

        function activateQuantumMode() {
            gameState.quantumMode = !gameState.quantumMode;
            const btn = document.getElementById(&#x27;quantumBtn&#x27;);
            const t = translations[gameState.currentLanguage];
            
            if(gameState.quantumMode) {
                btn.style.background = &#x27;linear-gradient(145deg, #10b981, #059669)&#x27;;
                showAIMessage(t.quantumActivated, 3500);
                
                // Ajouter des effets visuels quantiques
                document.querySelectorAll(&#x27;.dame-square&#x27;).forEach(square =&gt; {
                    if(Math.random() &lt; 0.12) {
                        square.classList.add(&#x27;quantum-state&#x27;);
                        setTimeout(() =&gt; {
                            square.classList.remove(&#x27;quantum-state&#x27;);
                        }, 2500);
                    }
                });
            } else {
                btn.style.background = &#x27;linear-gradient(145deg, #ec4899, #db2777)&#x27;;
                showAIMessage(t.quantumDeactivated, 2500);
            }
        }

        function resetGame() {
            const t = translations[gameState.currentLanguage];
            showAIMessage(t.newGameStarted, 2500);
            initGame();
        }

        function changeDifficulty() {
            const difficulties = [&#x27;easy&#x27;, &#x27;normal&#x27;, &#x27;hard&#x27;, &#x27;expert&#x27;];
            const currentIndex = difficulties.indexOf(gameState.difficulty);
            const nextIndex = (currentIndex + 1) % difficulties.length;
            gameState.difficulty = difficulties[nextIndex];
            
            gameState.aiLevel = nextIndex + 2;
            
            const t = translations[gameState.currentLanguage];
            const diffText = t.difficultyText.replace(&#x27;Expert&#x27;, t.difficulties[gameState.difficulty]);
            document.getElementById(&#x27;difficultyText&#x27;).textContent = diffText;
            
            showAIMessage(`${t.difficultyChanged} ${t.difficulties[gameState.difficulty]}`, 2500);
        }

        function toggleAIAnalysis() {
            const t = translations[gameState.currentLanguage];
            showAIMessage(t.aiAnalyzing, 3500);
            
            setTimeout(() =&gt; {
                const analysis = analyzePosition();
                showAIMessage(analysis, 6000);
            }, 2500);
        }

        function analyzePosition() {
            let yellowScore = 0;
            let redScore = 0;
            
            for(let row = 0; row &lt; 8; row++) {
                for(let col = 0; col &lt; 8; col++) {
                    const piece = gameState.board[row][col];
                    if(piece) {
                        const value = isKing(piece) ? 3 : 1;
                        if(getPieceColor(piece) === &#x27;yellow&#x27;) {
                            yellowScore += value;
                        } else {
                            redScore += value;
                        }
                    }
                }
            }
            
            const t = translations[gameState.currentLanguage];
            const advantage = yellowScore - redScore;
            if(advantage &gt; 4) return t.yellowAdvantage;
            if(advantage &lt; -4) return t.redAdvantage;
            if(advantage &gt; 0) return t.slightYellowAdvantage;
            if(advantage &lt; 0) return t.slightRedAdvantage;
            return t.balancedPosition;
        }

        function showBestMoves() {
            const t = translations[gameState.currentLanguage];
            showAIMessage(t.bestMovesCalculating, 2500);
            
            setTimeout(() =&gt; {
                const moves = calculateBestMove();
                if(moves) {
                    const suggestion = `${t.suggestion} ${String.fromCharCode(97 + moves.fromCol)}${8 - moves.fromRow} → ${String.fromCharCode(97 + moves.toCol)}${8 - moves.toRow}`;
                    showAIMessage(suggestion, 5000);
                } else {
                    showAIMessage(t.noMovesAvailable, 2500);
                }
            }, 2500);
        }

        function saveGame() {
            const saveData = {
                board: gameState.board,
                currentPlayer: gameState.currentPlayer,
                gameMode: gameState.gameMode,
                moveHistory: gameState.moveHistory,
                moveCount: gameState.moveCount,
                score: gameState.score,
                difficulty: gameState.difficulty,
                currentLanguage: gameState.currentLanguage
            };
            
            localStorage.setItem(&#x27;quantumDamesSave&#x27;, JSON.stringify(saveData));
            const t = translations[gameState.currentLanguage];
            showAIMessage(t.gameSaved, 2500);
        }

        function loadGame() {
            const saveData = localStorage.getItem(&#x27;quantumDamesSave&#x27;);
            if(saveData) {
                const data = JSON.parse(saveData);
                gameState.board = data.board;
                gameState.currentPlayer = data.currentPlayer;
                gameState.gameMode = data.gameMode;
                gameState.moveHistory = data.moveHistory;
                gameState.moveCount = data.moveCount;
                gameState.score = data.score;
                gameState.difficulty = data.difficulty;
                if(data.currentLanguage) {
                    gameState.currentLanguage = data.currentLanguage;
                    document.getElementById(&#x27;languageSelector&#x27;).value = data.currentLanguage;
                    changeLanguage();
                }
                
                createDameboard();
                updateUI();
                const t = translations[gameState.currentLanguage];
                showAIMessage(t.gameLoaded, 2500);
            }
        }

        // Fonction pour basculer pause/reprendre
        function togglePause() {
            const t = translations[gameState.currentLanguage];
            const pauseBtn = document.getElementById(&#x27;pauseBtn&#x27;);
            const pauseTextElement = document.getElementById(&#x27;pauseText&#x27;);
            
            gameState.isPaused = !gameState.isPaused;
            
            if(gameState.isPaused) {
                // Mettre en pause
                pauseBtn.innerHTML = &#x27;▶️ &lt;span id=&quot;pauseText&quot;&gt;&#x27; + t.resumeText + &#x27;&lt;/span&gt;&#x27;;
                pauseBtn.style.background = &#x27;linear-gradient(145deg, #10b981, #059669)&#x27;;
                showAIMessage(t.gamePaused, 2000);
                
                // Arrêter le timer
                if(gameState.timer) {
                    clearInterval(gameState.timer);
                }
            } else {
                // Reprendre
                pauseBtn.innerHTML = &#x27;⏸️ &lt;span id=&quot;pauseText&quot;&gt;&#x27; + t.pauseText + &#x27;&lt;/span&gt;&#x27;;
                pauseBtn.style.background = &#x27;linear-gradient(145deg, #8b5cf6, #7c3aed)&#x27;;
                showAIMessage(t.gameResumed, 2000);
                
                // Redémarrer le timer
                startTimer();
            }
        }

        // Initialisation
        document.addEventListener(&#x27;DOMContentLoaded&#x27;, function() {
            initFuturisticEffects();
            initGame();
            
            // Charger une sauvegarde si elle existe
            if(localStorage.getItem(&#x27;quantumDamesSave&#x27;)) {
                setTimeout(() =&gt; {
                    const t = translations[gameState.currentLanguage];
                    if(confirm(t.loadSavedGame)) {
                        loadGame();
                    }
                }, 1200);
            }
            
            // Message de bienvenue
            setTimeout(() =&gt; {
                const t = translations[gameState.currentLanguage];
                showAIMessage(t.welcome, 5000);
            }, 1200);
        });
    &lt;/script&gt;
&lt;script&gt;(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement(&#x27;script&#x27;);d.innerHTML=&quot;window.__CF$cv$params={r:&#x27;984959ce0269777e&#x27;,t:&#x27;MTc1ODc5MTAzMi4wMDAwMDA=&#x27;};var a=document.createElement(&#x27;script&#x27;);a.nonce=&#x27;&#x27;;a.src=&#x27;/cdn-cgi/challenge-platform/scripts/jsd/main.js&#x27;;document.getElementsByTagName(&#x27;head&#x27;)[0].appendChild(a);&quot;;b.getElementsByTagName(&#x27;head&#x27;)[0].appendChild(d)}}if(document.body){var a=document.createElement(&#x27;iframe&#x27;);a.height=1;a.width=1;a.style.position=&#x27;absolute&#x27;;a.style.top=0;a.style.left=0;a.style.border=&#x27;none&#x27;;a.style.visibility=&#x27;hidden&#x27;;document.body.appendChild(a);if(&#x27;loading&#x27;!==document.readyState)c();else if(window.addEventListener)document.addEventListener(&#x27;DOMContentLoaded&#x27;,c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);&#x27;loading&#x27;!==document.readyState&amp;&amp;(document.onreadystatechange=e,c())}}}})();&lt;/script&gt;&lt;/body&gt;
&lt;/html&gt;
" style="width:100%;height:100%;border:none;"></iframe>
</div>

<script>
function launchGame5() {
  const overlay = document.getElementById("game5Overlay");
  overlay.style.display = "block";
}
function closeGame5() {
  const overlay = document.getElementById("game5Overlay");
  overlay.style.display = "none";
}
document.addEventListener("keydown", function(e) {
  if (e.key === "Escape") {
    const overlay = document.getElementById("game5Overlay");
    if (overlay && overlay.style.display === "block") {
      e.preventDefault();
      e.stopPropagation();
      closeGame5();
    }
  }
}, true);
</script>


<div id="game6Overlay" style="display:none;position:fixed;inset:0;background:#000;z-index:9999;">
  <button onclick="closeGame6()" style="position:absolute;top:10px;right:10px;z-index:10000;font-size:24px;background:red;color:white;border:none;border-radius:50%;width:40px;height:40px;cursor:pointer;">✖</button>
  <iframe id="iframeGame6" srcdoc="&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;fr&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;🌟 Quantum Pac-Man - IA Futuriste&lt;/title&gt;
    &lt;script src=&quot;https://cdn.tailwindcss.com&quot;&gt;&lt;/script&gt;
    &lt;style&gt;
        body {
            box-sizing: border-box;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: &#x27;Segoe UI&#x27;, Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a3a 30%, #2d1b69 70%, #4c1d95 100%);
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }

        /* Particules quantiques d&#x27;arrière-plan */
        .quantum-particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .quantum-particle {
            position: absolute;
            width: 3px;
            height: 3px;
            background: #00ff88;
            border-radius: 50%;
            animation: quantumFloat 12s infinite linear;
            box-shadow: 0 0 10px #00ff88, 0 0 20px #00ff88;
        }

        @keyframes quantumFloat {
            0% {
                transform: translateY(100vh) translateX(0) rotate(0deg) scale(0);
                opacity: 0;
            }
            10% {
                opacity: 1;
                transform: translateY(90vh) translateX(20px) rotate(45deg) scale(1);
            }
            50% {
                transform: translateY(50vh) translateX(-30px) rotate(180deg) scale(1.5);
            }
            90% {
                opacity: 1;
                transform: translateY(10vh) translateX(40px) rotate(315deg) scale(1);
            }
            100% {
                transform: translateY(-10vh) translateX(80px) rotate(360deg) scale(0);
                opacity: 0;
            }
        }

        /* Grille quantique de fond */
        .quantum-grid {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(0, 255, 136, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 136, 0.1) 1px, transparent 1px);
            background-size: 60px 60px;
            animation: quantumGridMove 25s linear infinite;
            z-index: 1;
        }

        @keyframes quantumGridMove {
            0% { transform: translate(0, 0); }
            100% { transform: translate(60px, 60px); }
        }

        /* Container principal */
        .quantum-pacman-container {
            position: relative;
            z-index: 10;
            display: grid;
            grid-template-columns: 200px 1fr 200px;
            gap: 15px;
            min-height: 100vh;
            padding: 15px;
            max-width: 1400px;
            margin: 0 auto;
        }

        .left-panel, .right-panel {
            background: linear-gradient(145deg, 
                rgba(30, 30, 58, 0.95) 0%,
                rgba(45, 27, 105, 0.95) 50%,
                rgba(76, 29, 149, 0.95) 100%);
            backdrop-filter: blur(30px);
            border-radius: 15px;
            padding: 15px;
            height: fit-content;
            box-shadow: 
                0 15px 30px rgba(0, 0, 0, 0.7),
                0 0 60px rgba(0, 255, 136, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(0, 255, 136, 0.5);
            animation: quantumPanelGlow 4s ease-in-out infinite alternate;
        }

        .game-panel {
            background: linear-gradient(145deg, 
                rgba(30, 30, 58, 0.95) 0%,
                rgba(45, 27, 105, 0.95) 50%,
                rgba(76, 29, 149, 0.95) 100%);
            backdrop-filter: blur(30px);
            border-radius: 20px;
            padding: 20px;
            width: 100%;
            height: fit-content;
            box-shadow: 
                0 25px 50px rgba(0, 0, 0, 0.7),
                0 0 100px rgba(0, 255, 136, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(0, 255, 136, 0.5);
            animation: quantumPanelGlow 4s ease-in-out infinite alternate;
        }

        @keyframes quantumPanelGlow {
            from { 
                box-shadow: 
                    0 25px 50px rgba(0, 0, 0, 0.7),
                    0 0 100px rgba(0, 255, 136, 0.2),
                    inset 0 1px 0 rgba(255, 255, 255, 0.1);
            }
            to { 
                box-shadow: 
                    0 30px 60px rgba(0, 0, 0, 0.7),
                    0 0 120px rgba(0, 255, 136, 0.3),
                    inset 0 1px 0 rgba(255, 255, 255, 0.2);
            }
        }

        /* En-tête du jeu */
        .quantum-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid rgba(0, 255, 136, 0.5);
        }

        .quantum-title {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .quantum-title h1 {
            color: #00ff88;
            margin: 0;
            font-size: 20px;
            font-weight: 700;
            text-shadow: 0 0 30px rgba(0, 255, 136, 0.9);
            animation: quantumTitlePulse 3s infinite alternate;
        }

        @keyframes quantumTitlePulse {
            from { 
                text-shadow: 0 0 30px rgba(0, 255, 136, 0.9);
                transform: scale(1);
            }
            to { 
                text-shadow: 0 0 40px rgba(0, 255, 136, 1);
                transform: scale(1.03);
            }
        }

        .quantum-icon {
            font-size: 32px;
            animation: quantumIconSpin 6s linear infinite;
            filter: drop-shadow(0 0 20px #00ff88);
            color: #fbbf24;
        }

        @keyframes quantumIconSpin {
            0% { transform: rotate(0deg) scale(1); }
            25% { transform: rotate(90deg) scale(1.1); }
            50% { transform: rotate(180deg) scale(1); }
            75% { transform: rotate(270deg) scale(1.1); }
            100% { transform: rotate(360deg) scale(1); }
        }

        .quantum-badge {
            background: linear-gradient(45deg, #00ff88, #0099ff, #ff0099, #ffaa00);
            background-size: 400% 400%;
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 11px;
            font-weight: bold;
            animation: quantumBadgeShine 4s ease-in-out infinite;
            box-shadow: 0 0 25px rgba(0, 255, 136, 0.7);
        }

        @keyframes quantumBadgeShine {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        /* Sélecteur de langue */
        .language-selector {
            background: linear-gradient(145deg, 
                rgba(30, 30, 58, 0.95) 0%,
                rgba(45, 27, 105, 0.95) 30%,
                rgba(76, 29, 149, 0.95) 70%,
                rgba(139, 92, 246, 0.95) 100%);
            color: #00ff88;
            border: 2px solid rgba(0, 255, 136, 0.6);
            border-radius: 15px;
            padding: 12px 18px;
            font-weight: bold;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.3s ease;
            box-shadow: 
                0 0 25px rgba(0, 255, 136, 0.5),
                0 0 40px rgba(139, 92, 246, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(15px);
            min-width: 160px;
            max-height: 220px;
            overflow-y: auto;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.8);
        }

        .language-selector:hover {
            background: linear-gradient(145deg, 
                rgba(0, 255, 136, 0.9) 0%,
                rgba(0, 153, 255, 0.9) 30%,
                rgba(139, 92, 246, 0.9) 70%,
                rgba(255, 0, 153, 0.9) 100%);
            transform: translateY(-3px);
            box-shadow: 
                0 10px 30px rgba(0, 255, 136, 0.7),
                0 0 50px rgba(139, 92, 246, 0.5),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
            color: white;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.8);
        }

        .language-selector option {
            background: linear-gradient(145deg, #2d1b69, #4c1d95) !important;
            color: #00ff88 !important;
            padding: 10px 15px;
            font-weight: bold;
            border: 1px solid rgba(0, 255, 136, 0.4) !important;
        }

        .language-selector option:hover {
            background: linear-gradient(145deg, #00ff88, #0099ff) !important;
            color: white !important;
        }

        .language-selector option:checked {
            background: linear-gradient(145deg, #00ff88, #0099ff) !important;
            color: white !important;
        }

        .language-selector option:focus {
            background: linear-gradient(145deg, #8b5cf6, #7c3aed) !important;
            color: white !important;
        }

        /* Contrôles de configuration */
        .config-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 15px;
            border: 2px solid rgba(0, 255, 136, 0.4);
        }

        .config-btn {
            padding: 12px 18px;
            background: linear-gradient(145deg, #00ff88, #0099ff);
            color: white;
            border: none;
            border-radius: 12px;
            font-weight: bold;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .config-btn::before {
            content: &#x27;&#x27;;
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            transition: left 0.6s ease;
        }

        .config-btn:hover::before {
            left: 100%;
        }

        .config-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(0, 255, 136, 0.6);
            background: linear-gradient(145deg, #00ffaa, #00bbff);
        }

        .config-btn.active {
            background: linear-gradient(145deg, #ff0099, #ffaa00);
            box-shadow: 0 0 25px rgba(255, 0, 153, 0.7);
        }

        /* Plateau de jeu */
        .game-board-container {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
            position: relative;
        }

        .game-board {
            display: grid;
            gap: 1px;
            border: 3px solid rgba(0, 255, 136, 0.8);
            border-radius: 15px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.8);
            box-shadow: 
                0 0 40px rgba(0, 255, 136, 0.6),
                inset 0 0 20px rgba(0, 255, 136, 0.2);
            animation: gameBoardGlow 5s ease-in-out infinite alternate;
        }

        @keyframes gameBoardGlow {
            from { 
                box-shadow: 
                    0 0 40px rgba(0, 255, 136, 0.6),
                    inset 0 0 20px rgba(0, 255, 136, 0.2);
            }
            to { 
                box-shadow: 
                    0 0 60px rgba(0, 255, 136, 0.8),
                    inset 0 0 30px rgba(0, 255, 136, 0.3);
            }
        }

        .game-cell {
            width: 45px;
            height: 45px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            position: relative;
            transition: all 0.2s ease;
            font-size: 28px;
        }

        .game-cell.wall {
            background: linear-gradient(145deg, #1e40af, #3730a3);
            border: 1px solid #00ff88;
            box-shadow: inset 0 0 10px rgba(0, 255, 136, 0.3);
        }

        .game-cell.path {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(0, 255, 136, 0.2);
        }

        .game-cell.dot {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(0, 255, 136, 0.2);
        }

        .game-cell.dot::after {
            content: &#x27;&#x27;;
            width: 10px;
            height: 10px;
            background: #fbbf24;
            border-radius: 50%;
            box-shadow: 0 0 15px #fbbf24, 0 0 25px #fbbf24;
            animation: dotPulse 2s ease-in-out infinite alternate;
        }

        @keyframes dotPulse {
            from { transform: scale(1); opacity: 0.8; }
            to { transform: scale(1.3); opacity: 1; }
        }

        .game-cell.power-dot {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(0, 255, 136, 0.2);
        }

        .game-cell.power-dot::after {
            content: &#x27;&#x27;;
            width: 18px;
            height: 18px;
            background: #ff0099;
            border-radius: 50%;
            box-shadow: 0 0 20px #ff0099, 0 0 35px #ff0099;
            animation: powerDotPulse 1s ease-in-out infinite alternate;
        }

        @keyframes powerDotPulse {
            from { transform: scale(1); opacity: 0.8; }
            to { transform: scale(1.5); opacity: 1; }
        }

        .game-cell.pacman {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(0, 255, 136, 0.2);
            animation: pacmanGlow 1.5s ease-in-out infinite alternate;
            position: relative;
        }

        .pacman-sprite {
            width: 35px;
            height: 35px;
            background: #fbbf24;
            border-radius: 50%;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 20px #fbbf24, 0 0 30px #fbbf24;
            animation: pacmanBounce 0.3s ease-in-out infinite alternate;
        }

        .pacman-sprite::before {
            content: &#x27;&#x27;;
            position: absolute;
            width: 0;
            height: 0;
            border-style: solid;
            animation: pacmanMouth 0.6s ease-in-out infinite alternate;
            z-index: 2;
            top: 50%;
            left: 50%;
        }

        /* Directions de Pac-Man - bouche parfaitement centrée et agrandie */
        .pacman-right::before {
            border-left: 20px solid #0f0f23;
            border-top: 15px solid transparent;
            border-bottom: 15px solid transparent;
            transform: translate(-25%, -50%);
        }

        .pacman-left::before {
            border-right: 20px solid #0f0f23;
            border-top: 15px solid transparent;
            border-bottom: 15px solid transparent;
            transform: translate(-75%, -50%);
        }

        .pacman-up::before {
            border-bottom: 20px solid #0f0f23;
            border-left: 15px solid transparent;
            border-right: 15px solid transparent;
            transform: translate(-50%, -75%);
        }

        .pacman-down::before {
            border-top: 20px solid #0f0f23;
            border-left: 15px solid transparent;
            border-right: 15px solid transparent;
            transform: translate(-50%, -25%);
        }

        @keyframes pacmanGlow {
            from { box-shadow: 0 0 15px #fbbf24; }
            to { box-shadow: 0 0 25px #fbbf24, 0 0 35px #fbbf24; }
        }

        @keyframes pacmanBounce {
            from { transform: scale(1); }
            to { transform: scale(1.1); }
        }

        @keyframes pacmanMouth {
            0% { 
                transform: scale(0);
                opacity: 0;
            }
            50% {
                transform: scale(1);
                opacity: 1;
            }
            100% { 
                transform: scale(1.2);
                opacity: 1;
            }
        }

        /* Animation de manger */
        .eating-animation {
            animation: eatPulse 0.3s ease-out;
        }

        @keyframes eatPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); }
            100% { transform: scale(1); }
        }

        .game-cell.ghost {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(0, 255, 136, 0.2);
            animation: ghostGlow 2s ease-in-out infinite alternate;
        }

        @keyframes ghostGlow {
            from { box-shadow: 0 0 10px currentColor; }
            to { box-shadow: 0 0 20px currentColor, 0 0 30px currentColor; }
        }

        .game-cell.scared-ghost {
            animation: scaredGhostBlink 0.3s ease-in-out infinite alternate, scaredGhostShake 0.1s ease-in-out infinite;
        }

        @keyframes scaredGhostBlink {
            from { opacity: 1; }
            to { opacity: 0.6; }
        }

        @keyframes scaredGhostShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-1px); }
            75% { transform: translateX(1px); }
        }

        /* Panneau de titre des sections */
        .panel-title {
            color: #00ff88;
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 15px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            text-shadow: 0 0 15px rgba(0, 255, 136, 0.9);
            border-bottom: 2px solid rgba(0, 255, 136, 0.5);
            padding-bottom: 10px;
        }

        /* Contrôles quantiques */
        .quantum-controls {
            display: grid;
            grid-template-columns: 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        .quantum-btn {
            padding: 12px 16px;
            background: linear-gradient(145deg, #00ff88, #0099ff);
            color: white;
            border: none;
            border-radius: 10px;
            font-weight: bold;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 0.8px;
        }

        .quantum-btn::before {
            content: &#x27;&#x27;;
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            transition: left 0.6s ease;
        }

        .quantum-btn:hover::before {
            left: 100%;
        }

        .quantum-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0, 255, 136, 0.5);
            background: linear-gradient(145deg, #00ffaa, #00bbff);
        }

        .quantum-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        /* Boutons spécialisés */
        .ai-btn {
            background: linear-gradient(145deg, #8b5cf6, #7c3aed);
        }

        .ai-btn:hover {
            background: linear-gradient(145deg, #a78bfa, #8b5cf6);
        }

        .reset-btn {
            background: linear-gradient(145deg, #ef4444, #dc2626);
        }

        .reset-btn:hover {
            background: linear-gradient(145deg, #f87171, #ef4444);
        }

        .pause-btn {
            background: linear-gradient(145deg, #f59e0b, #d97706);
        }

        .pause-btn:hover {
            background: linear-gradient(145deg, #fbbf24, #f59e0b);
        }

        /* Statistiques du jeu */
        .game-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        .stat-item {
            background: rgba(0, 255, 136, 0.15);
            padding: 10px;
            border-radius: 12px;
            text-align: center;
            border: 2px solid rgba(0, 255, 136, 0.4);
            position: relative;
            overflow: hidden;
        }

        .stat-item::before {
            content: &#x27;&#x27;;
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 136, 0.3), transparent);
            animation: statQuantumScan 4s linear infinite;
        }

        @keyframes statQuantumScan {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .stat-label {
            display: block;
            color: #9ca3af;
            font-size: 10px;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-value {
            display: block;
            color: #00ff88;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 0 0 15px rgba(0, 255, 136, 0.9);
            position: relative;
            z-index: 1;
        }

        /* Messages de jeu */
        .game-message {
            text-align: center;
            margin-bottom: 15px;
            padding: 15px;
            border-radius: 12px;
            background: rgba(0, 255, 136, 0.1);
            border: 2px solid rgba(0, 255, 136, 0.3);
            color: #00ff88;
            font-weight: bold;
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Responsive */
        @media (max-width: 1200px) {
            .quantum-pacman-container {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .left-panel, .right-panel {
                display: none;
            }
        }

        @media (max-width: 768px) {
            .game-panel {
                padding: 15px;
                margin: 10px;
            }
            
            .config-controls {
                grid-template-columns: 1fr;
            }
            
            .quantum-title h1 {
                font-size: 18px;
            }
            
            .game-cell {
                width: 38px;
                height: 38px;
                font-size: 22px;
            }
            
            .pacman-sprite {
                width: 28px;
                height: 28px;
            }
        }

        @media (max-width: 480px) {
            .game-cell {
                width: 32px;
                height: 32px;
                font-size: 18px;
            }
            
            .pacman-sprite {
                width: 24px;
                height: 24px;
            }
            
            .game-stats {
                grid-template-columns: 1fr;
            }
        }

        /* Animations de victoire */
        .victory-animation {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        .victory-content {
            background: linear-gradient(145deg, rgba(30, 30, 58, 0.95), rgba(76, 29, 149, 0.95));
            border: 3px solid #00ff88;
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            color: white;
            font-size: 20px;
            font-weight: bold;
            max-width: 500px;
            box-shadow: 0 0 50px rgba(0, 255, 136, 0.7);
            animation: victoryPulse 2s ease-in-out infinite alternate;
        }

        @keyframes victoryPulse {
            from { 
                box-shadow: 0 0 50px rgba(0, 255, 136, 0.7);
                transform: scale(1);
            }
            to { 
                box-shadow: 0 0 80px rgba(0, 255, 136, 1);
                transform: scale(1.05);
            }
        }

        .victory-fireworks {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #00ff88;
            border-radius: 50%;
            animation: fireworks 3s ease-out infinite;
        }

        @keyframes fireworks {
            0% {
                transform: scale(0) rotate(0deg);
                opacity: 1;
            }
            50% {
                transform: scale(1) rotate(180deg);
                opacity: 0.8;
            }
            100% {
                transform: scale(2) rotate(360deg);
                opacity: 0;
            }
        }

        /* Animation de défaite */
        .defeat-animation {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        .defeat-content {
            background: linear-gradient(145deg, rgba(139, 69, 19, 0.95), rgba(185, 28, 28, 0.95));
            border: 3px solid #ef4444;
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            color: white;
            font-size: 20px;
            font-weight: bold;
            max-width: 500px;
            box-shadow: 0 0 50px rgba(239, 68, 68, 0.7);
            animation: defeatShake 1s ease-in-out infinite;
        }

        @keyframes defeatShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!-- Particules quantiques d&#x27;arrière-plan --&gt;
    &lt;div class=&quot;quantum-particles&quot; id=&quot;quantumParticles&quot;&gt;&lt;/div&gt;
    
    &lt;!-- Grille quantique --&gt;
    &lt;div class=&quot;quantum-grid&quot;&gt;&lt;/div&gt;
    
    &lt;!-- Container principal --&gt;
    &lt;div class=&quot;quantum-pacman-container&quot;&gt;
        &lt;!-- Panneau gauche --&gt;
        &lt;div class=&quot;left-panel&quot;&gt;
            &lt;div class=&quot;panel-section&quot;&gt;
                &lt;div class=&quot;panel-title&quot; id=&quot;controlsTitle&quot;&gt;🎮 Contrôles Quantiques&lt;/div&gt;
                &lt;div class=&quot;quantum-controls&quot;&gt;
                    &lt;button class=&quot;quantum-btn pause-btn&quot; onclick=&quot;togglePause()&quot; id=&quot;pauseBtn&quot;&gt;
                        ⏸️ &lt;span id=&quot;pauseText&quot;&gt;Pause&lt;/span&gt;
                    &lt;/button&gt;
                    &lt;button class=&quot;quantum-btn ai-btn&quot; onclick=&quot;toggleAIMode()&quot; id=&quot;aiBtn&quot;&gt;
                        🤖 &lt;span id=&quot;aiModeText&quot;&gt;Mode IA&lt;/span&gt;
                    &lt;/button&gt;
                    &lt;button class=&quot;quantum-btn reset-btn&quot; onclick=&quot;resetGame()&quot;&gt;
                        🔄 &lt;span id=&quot;newGameText&quot;&gt;Nouveau Jeu&lt;/span&gt;
                    &lt;/button&gt;
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;div class=&quot;panel-section&quot;&gt;
                &lt;div class=&quot;panel-title&quot; id=&quot;statsTitle&quot;&gt;📊 Statistiques&lt;/div&gt;
                &lt;div class=&quot;game-stats&quot;&gt;
                    &lt;div class=&quot;stat-item&quot;&gt;
                        &lt;span class=&quot;stat-label&quot; id=&quot;scoreLabel&quot;&gt;Score&lt;/span&gt;
                        &lt;span class=&quot;stat-value&quot; id=&quot;scoreValue&quot;&gt;0&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;stat-item&quot;&gt;
                        &lt;span class=&quot;stat-label&quot; id=&quot;levelLabel&quot;&gt;Niveau&lt;/span&gt;
                        &lt;span class=&quot;stat-value&quot; id=&quot;levelValue&quot;&gt;1&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;stat-item&quot;&gt;
                        &lt;span class=&quot;stat-label&quot; id=&quot;livesLabel&quot;&gt;Vies&lt;/span&gt;
                        &lt;span class=&quot;stat-value&quot; id=&quot;livesValue&quot;&gt;3&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;stat-item&quot;&gt;
                        &lt;span class=&quot;stat-label&quot; id=&quot;dotsLabel&quot;&gt;Points&lt;/span&gt;
                        &lt;span class=&quot;stat-value&quot; id=&quot;dotsValue&quot;&gt;0&lt;/span&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;

        &lt;!-- Panneau central --&gt;
        &lt;div class=&quot;game-panel&quot;&gt;
            &lt;!-- En-tête --&gt;
            &lt;div class=&quot;quantum-header&quot;&gt;
                &lt;div class=&quot;quantum-title&quot;&gt;
                    &lt;span class=&quot;quantum-icon&quot;&gt;🌟&lt;/span&gt;
                    &lt;h1 id=&quot;gameTitle&quot;&gt;Quantum Pac-Man&lt;/h1&gt;
                    &lt;span class=&quot;quantum-badge&quot; id=&quot;quantumBadge&quot;&gt;🚀 IA FUTURISTE&lt;/span&gt;
                &lt;/div&gt;
                &lt;div style=&quot;display: flex; align-items: center; gap: 18px;&quot;&gt;
                    &lt;select id=&quot;languageSelector&quot; onchange=&quot;changeLanguage()&quot; class=&quot;language-selector&quot;&gt;
                        &lt;option value=&quot;fr&quot;&gt;🇫🇷 Français&lt;/option&gt;
                        &lt;option value=&quot;en&quot;&gt;🇺🇸 English&lt;/option&gt;
                        &lt;option value=&quot;ar&quot;&gt;🇸🇦 العربية&lt;/option&gt;
                        &lt;option value=&quot;es&quot;&gt;🇪🇸 Español&lt;/option&gt;
                        &lt;option value=&quot;de&quot;&gt;🇩🇪 Deutsch&lt;/option&gt;
                        &lt;option value=&quot;zh&quot;&gt;🇨🇳 中文&lt;/option&gt;
                    &lt;/select&gt;
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;!-- Configuration du jeu --&gt;
            &lt;div style=&quot;display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px; padding: 10px; background: rgba(0, 0, 0, 0.3); border-radius: 10px; border: 1px solid rgba(0, 255, 136, 0.3);&quot;&gt;
                &lt;div&gt;
                    &lt;div style=&quot;color: #00ff88; font-size: 11px; font-weight: bold; margin-bottom: 8px; text-align: center;&quot; id=&quot;sizeTitle&quot;&gt;📏 Taille&lt;/div&gt;
                    &lt;div style=&quot;display: grid; grid-template-columns: 1fr 1fr; gap: 4px;&quot;&gt;
                        &lt;button class=&quot;config-btn active&quot; onclick=&quot;setBoardSize(8)&quot; id=&quot;size8&quot; style=&quot;padding: 6px 8px; font-size: 10px;&quot;&gt;8×8&lt;/button&gt;
                        &lt;button class=&quot;config-btn&quot; onclick=&quot;setBoardSize(9)&quot; id=&quot;size9&quot; style=&quot;padding: 6px 8px; font-size: 10px;&quot;&gt;9×9&lt;/button&gt;
                        &lt;button class=&quot;config-btn&quot; onclick=&quot;setBoardSize(10)&quot; id=&quot;size10&quot; style=&quot;padding: 6px 8px; font-size: 10px;&quot;&gt;10×10&lt;/button&gt;
                        &lt;button class=&quot;config-btn&quot; onclick=&quot;setBoardSize(11)&quot; id=&quot;size11&quot; style=&quot;padding: 6px 8px; font-size: 10px;&quot;&gt;11×11&lt;/button&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
                &lt;div&gt;
                    &lt;div style=&quot;color: #00ff88; font-size: 11px; font-weight: bold; margin-bottom: 8px; text-align: center;&quot; id=&quot;difficultyTitle&quot;&gt;⚡ Difficulté&lt;/div&gt;
                    &lt;div style=&quot;display: grid; grid-template-columns: 1fr 1fr; gap: 4px;&quot;&gt;
                        &lt;button class=&quot;config-btn&quot; onclick=&quot;setDifficulty(&#x27;easy&#x27;)&quot; id=&quot;diffEasy&quot; style=&quot;padding: 6px 8px; font-size: 10px;&quot;&gt;
                            &lt;span id=&quot;easyText&quot;&gt;Facile&lt;/span&gt;
                        &lt;/button&gt;
                        &lt;button class=&quot;config-btn&quot; onclick=&quot;setDifficulty(&#x27;normal&#x27;)&quot; id=&quot;diffNormal&quot; style=&quot;padding: 6px 8px; font-size: 10px;&quot;&gt;
                            &lt;span id=&quot;normalText&quot;&gt;Normal&lt;/span&gt;
                        &lt;/button&gt;
                        &lt;button class=&quot;config-btn active&quot; onclick=&quot;setDifficulty(&#x27;hard&#x27;)&quot; id=&quot;diffHard&quot; style=&quot;padding: 6px 8px; font-size: 10px;&quot;&gt;
                            &lt;span id=&quot;hardText&quot;&gt;Difficile&lt;/span&gt;
                        &lt;/button&gt;
                        &lt;button class=&quot;config-btn&quot; onclick=&quot;setDifficulty(&#x27;expert&#x27;)&quot; id=&quot;diffExpert&quot; style=&quot;padding: 6px 8px; font-size: 10px;&quot;&gt;
                            &lt;span id=&quot;expertText&quot;&gt;Expert&lt;/span&gt;
                        &lt;/button&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;!-- Bouton Pause et Message de bienvenue --&gt;
            &lt;div style=&quot;display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; gap: 20px;&quot;&gt;
                &lt;button onclick=&quot;togglePause()&quot; id=&quot;gamePauseBtn&quot; style=&quot;
                    padding: 10px 20px;
                    background: linear-gradient(145deg, #f59e0b, #d97706);
                    color: white;
                    border: none;
                    border-radius: 12px;
                    font-weight: bold;
                    font-size: 14px;
                    cursor: pointer;
                    transition: all 0.3s ease;
                    box-shadow: 0 4px 15px rgba(245, 158, 11, 0.4);
                    display: flex;
                    align-items: center;
                    gap: 8px;
                    flex-shrink: 0;
                &quot;&gt;
                    &lt;span id=&quot;pauseIcon&quot;&gt;⏸️&lt;/span&gt;
                    &lt;span id=&quot;gamePauseText&quot;&gt;Pause&lt;/span&gt;
                &lt;/button&gt;
                
                &lt;!-- Message de jeu --&gt;
                &lt;div style=&quot;
                    flex: 1;
                    text-align: center;
                    padding: 8px 15px;
                    border-radius: 10px;
                    background: rgba(0, 255, 136, 0.1);
                    border: 2px solid rgba(0, 255, 136, 0.3);
                    color: #00ff88;
                    font-weight: bold;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    min-height: 35px;
                    font-size: 13px;
                    max-width: 300px;
                &quot; id=&quot;gameMessage&quot;&gt;
                    &lt;span id=&quot;welcomeMessage&quot;&gt;Bienvenue dans Quantum Pac-Man ! Utilisez les flèches pour vous déplacer.&lt;/span&gt;
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;!-- Plateau de jeu avec contrôles --&gt;
            &lt;div style=&quot;display: flex; justify-content: center; align-items: flex-start; gap: 30px; margin-bottom: 20px; margin-top: -5px;&quot;&gt;
                &lt;!-- Plateau de jeu --&gt;
                &lt;div class=&quot;game-board-container&quot; style=&quot;margin: 0;&quot;&gt;
                    &lt;div class=&quot;game-board&quot; id=&quot;gameBoard&quot;&gt;
                        &lt;!-- Le plateau sera généré dynamiquement --&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
                
                &lt;!-- Contrôles tactiles à droite --&gt;
                &lt;div style=&quot;display: grid; grid-template-columns: 1fr 1fr 1fr; grid-template-rows: 1fr 1fr 1fr; gap: 8px; width: 180px; height: 180px;&quot;&gt;
                    &lt;div&gt;&lt;/div&gt;
                    &lt;button onclick=&quot;movePacman(&#x27;up&#x27;)&quot; style=&quot;
                        background: linear-gradient(145deg, #00ff88, #0099ff);
                        border: none;
                        border-radius: 15px;
                        color: white;
                        font-size: 24px;
                        cursor: pointer;
                        transition: all 0.2s ease;
                        box-shadow: 0 4px 15px rgba(0, 255, 136, 0.4);
                    &quot; onmousedown=&quot;this.style.transform=&#x27;scale(0.95)&#x27;&quot; onmouseup=&quot;this.style.transform=&#x27;scale(1)&#x27;&quot;&gt;⬆️&lt;/button&gt;
                    &lt;div&gt;&lt;/div&gt;
                    
                    &lt;button onclick=&quot;movePacman(&#x27;left&#x27;)&quot; style=&quot;
                        background: linear-gradient(145deg, #00ff88, #0099ff);
                        border: none;
                        border-radius: 15px;
                        color: white;
                        font-size: 24px;
                        cursor: pointer;
                        transition: all 0.2s ease;
                        box-shadow: 0 4px 15px rgba(0, 255, 136, 0.4);
                    &quot; onmousedown=&quot;this.style.transform=&#x27;scale(0.95)&#x27;&quot; onmouseup=&quot;this.style.transform=&#x27;scale(1)&#x27;&quot;&gt;⬅️&lt;/button&gt;
                    &lt;div style=&quot;
                        background: rgba(0, 255, 136, 0.2);
                        border-radius: 50%;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-size: 20px;
                        border: 2px solid rgba(0, 255, 136, 0.5);
                    &quot;&gt;🎮&lt;/div&gt;
                    &lt;button onclick=&quot;movePacman(&#x27;right&#x27;)&quot; style=&quot;
                        background: linear-gradient(145deg, #00ff88, #0099ff);
                        border: none;
                        border-radius: 15px;
                        color: white;
                        font-size: 24px;
                        cursor: pointer;
                        transition: all 0.2s ease;
                        box-shadow: 0 4px 15px rgba(0, 255, 136, 0.4);
                    &quot; onmousedown=&quot;this.style.transform=&#x27;scale(0.95)&#x27;&quot; onmouseup=&quot;this.style.transform=&#x27;scale(1)&#x27;&quot;&gt;➡️&lt;/button&gt;
                    
                    &lt;div&gt;&lt;/div&gt;
                    &lt;button onclick=&quot;movePacman(&#x27;down&#x27;)&quot; style=&quot;
                        background: linear-gradient(145deg, #00ff88, #0099ff);
                        border: none;
                        border-radius: 15px;
                        color: white;
                        font-size: 24px;
                        cursor: pointer;
                        transition: all 0.2s ease;
                        box-shadow: 0 4px 15px rgba(0, 255, 136, 0.4);
                    &quot; onmousedown=&quot;this.style.transform=&#x27;scale(0.95)&#x27;&quot; onmouseup=&quot;this.style.transform=&#x27;scale(1)&#x27;&quot;&gt;⬇️&lt;/button&gt;
                    &lt;div&gt;&lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;

        &lt;!-- Panneau droit --&gt;
        &lt;div class=&quot;right-panel&quot;&gt;
            &lt;div class=&quot;panel-section&quot;&gt;
                &lt;div class=&quot;panel-title&quot; id=&quot;instructionsTitle&quot;&gt;📖 Instructions&lt;/div&gt;
                &lt;div style=&quot;color: #9ca3af; font-size: 12px; line-height: 1.6;&quot;&gt;
                    &lt;p id=&quot;instructionsText&quot;&gt;
                        • Utilisez les flèches pour vous déplacer&lt;br&gt;
                        • Mangez tous les points pour gagner&lt;br&gt;
                        • Évitez les fantômes&lt;br&gt;
                        • Les gros points vous donnent des pouvoirs&lt;br&gt;
                        • L&#x27;IA s&#x27;adapte à votre niveau
                    &lt;/p&gt;
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;div class=&quot;panel-section&quot;&gt;
                &lt;div class=&quot;panel-title&quot; id=&quot;powerUpsTitle&quot;&gt;⚡ Power-Ups&lt;/div&gt;
                &lt;div style=&quot;color: #9ca3af; font-size: 12px; line-height: 1.8;&quot;&gt;
                    &lt;div style=&quot;margin-bottom: 8px;&quot;&gt;
                        &lt;span style=&quot;color: #fbbf24;&quot;&gt;●&lt;/span&gt; &lt;span id=&quot;normalDotText&quot;&gt;Point normal (+10)&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div style=&quot;margin-bottom: 8px;&quot;&gt;
                        &lt;span style=&quot;color: #ff0099;&quot;&gt;●&lt;/span&gt; &lt;span id=&quot;powerDotText&quot;&gt;Super point (+50)&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div style=&quot;margin-bottom: 8px;&quot;&gt;
                        &lt;span style=&quot;color: #00ff88;&quot;&gt;😱&lt;/span&gt; &lt;span id=&quot;scaredGhostText&quot;&gt;Fantôme effrayé (+100)&lt;/span&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;div class=&quot;panel-section&quot;&gt;
                &lt;div class=&quot;panel-title&quot; id=&quot;aiStatusTitle&quot;&gt;🤖 Statut IA&lt;/div&gt;
                &lt;div id=&quot;aiStatus&quot; style=&quot;color: #00ff88; font-size: 12px; text-align: center; padding: 10px;&quot;&gt;
                    &lt;span id=&quot;aiStatusText&quot;&gt;IA Quantique Active&lt;/span&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;script&gt;
        // Traductions multilingues
        const translations = {
            fr: {
                gameTitle: &quot;Quantum Pac-Man&quot;,
                quantumBadge: &quot;🚀 IA FUTURISTE&quot;,
                controlsTitle: &quot;🎮 Contrôles Quantiques&quot;,
                statsTitle: &quot;📊 Statistiques&quot;,
                sizeTitle: &quot;📏 Taille&quot;,
                difficultyTitle: &quot;⚡ Difficulté&quot;,
                instructionsTitle: &quot;📖 Instructions&quot;,
                powerUpsTitle: &quot;⚡ Power-Ups&quot;,
                aiStatusTitle: &quot;🤖 Statut IA&quot;,
                pauseText: &quot;Pause&quot;,
                resumeText: &quot;Reprendre&quot;,
                aiModeText: &quot;Mode IA&quot;,
                newGameText: &quot;Nouveau Jeu&quot;,
                scoreLabel: &quot;Score&quot;,
                levelLabel: &quot;Niveau&quot;,
                livesLabel: &quot;Vies&quot;,
                dotsLabel: &quot;Points&quot;,
                easyText: &quot;Facile&quot;,
                normalText: &quot;Normal&quot;,
                hardText: &quot;Difficile&quot;,
                expertText: &quot;Expert&quot;,
                welcomeMessage: &quot;Bienvenue dans Quantum Pac-Man ! Utilisez les flèches pour vous déplacer.&quot;,
                instructionsText: &quot;• Utilisez les flèches pour vous déplacer&lt;br&gt;• Mangez tous les points pour gagner&lt;br&gt;• Évitez les fantômes&lt;br&gt;• Les gros points vous donnent des pouvoirs&lt;br&gt;• L&#x27;IA s&#x27;adapte à votre niveau&quot;,
                normalDotText: &quot;Point normal (+10)&quot;,
                powerDotText: &quot;Super point (+50)&quot;,
                scaredGhostText: &quot;Fantôme effrayé (+100)&quot;,
                enemyEaten: &quot;Fantôme mangé !&quot;,
                enemyCaught: &quot;Attrapé par un fantôme !&quot;,
                aiStatusText: &quot;IA Quantique Active&quot;,
                victoryTitle: &quot;🎉 VICTOIRE ! 🎉&quot;,
                victoryMessage: &quot;Félicitations ! Vous avez terminé le niveau !&quot;,
                defeatTitle: &quot;💀 GAME OVER 💀&quot;,
                defeatMessage: &quot;Vous avez perdu toutes vos vies !&quot;,
                tryAgainText: &quot;Essayer à nouveau&quot;,
                nextLevelText: &quot;Niveau suivant&quot;,
                gamePaused: &quot;Jeu en pause&quot;,
                gameResumed: &quot;Jeu repris&quot;,
                levelComplete: &quot;Niveau terminé !&quot;,
                allDotsEaten: &quot;Tous les points mangés !&quot;,
                ghostCaught: &quot;Attrapé par un fantôme !&quot;,
                powerModeActive: &quot;Mode pouvoir activé !&quot;,
                aiModeEnabled: &quot;Mode IA activé&quot;,
                aiModeDisabled: &quot;Mode IA désactivé&quot;
            },
            en: {
                gameTitle: &quot;Quantum Pac-Man&quot;,
                quantumBadge: &quot;🚀 FUTURISTIC AI&quot;,
                controlsTitle: &quot;🎮 Quantum Controls&quot;,
                statsTitle: &quot;📊 Statistics&quot;,
                sizeTitle: &quot;📏 Size&quot;,
                difficultyTitle: &quot;⚡ Difficulty&quot;,
                instructionsTitle: &quot;📖 Instructions&quot;,
                powerUpsTitle: &quot;⚡ Power-Ups&quot;,
                aiStatusTitle: &quot;🤖 AI Status&quot;,
                pauseText: &quot;Pause&quot;,
                resumeText: &quot;Resume&quot;,
                aiModeText: &quot;AI Mode&quot;,
                newGameText: &quot;New Game&quot;,
                scoreLabel: &quot;Score&quot;,
                levelLabel: &quot;Level&quot;,
                livesLabel: &quot;Lives&quot;,
                dotsLabel: &quot;Dots&quot;,
                easyText: &quot;Easy&quot;,
                normalText: &quot;Normal&quot;,
                hardText: &quot;Hard&quot;,
                expertText: &quot;Expert&quot;,
                welcomeMessage: &quot;Welcome to Quantum Pac-Man! Use arrow keys to move.&quot;,
                instructionsText: &quot;• Use arrow keys to move&lt;br&gt;• Eat all dots to win&lt;br&gt;• Avoid ghosts&lt;br&gt;• Big dots give you power&lt;br&gt;• AI adapts to your level&quot;,
                normalDotText: &quot;Normal dot (+10)&quot;,
                powerDotText: &quot;Power dot (+50)&quot;,
                scaredGhostText: &quot;Scared ghost (+100)&quot;,
                enemyEaten: &quot;Ghost eaten!&quot;,
                enemyCaught: &quot;Caught by ghost!&quot;,
                aiStatusText: &quot;Quantum AI Active&quot;,
                victoryTitle: &quot;🎉 VICTORY! 🎉&quot;,
                victoryMessage: &quot;Congratulations! You completed the level!&quot;,
                defeatTitle: &quot;💀 GAME OVER 💀&quot;,
                defeatMessage: &quot;You lost all your lives!&quot;,
                tryAgainText: &quot;Try Again&quot;,
                nextLevelText: &quot;Next Level&quot;,
                gamePaused: &quot;Game paused&quot;,
                gameResumed: &quot;Game resumed&quot;,
                levelComplete: &quot;Level complete!&quot;,
                allDotsEaten: &quot;All dots eaten!&quot;,
                ghostCaught: &quot;Caught by ghost!&quot;,
                powerModeActive: &quot;Power mode active!&quot;,
                aiModeEnabled: &quot;AI mode enabled&quot;,
                aiModeDisabled: &quot;AI mode disabled&quot;
            },
            ar: {
                gameTitle: &quot;باك مان الكمي&quot;,
                quantumBadge: &quot;🚀 ذكاء مستقبلي&quot;,
                controlsTitle: &quot;🎮 تحكم كمي&quot;,
                statsTitle: &quot;📊 إحصائيات&quot;,
                sizeTitle: &quot;📏 الحجم&quot;,
                difficultyTitle: &quot;⚡ الصعوبة&quot;,
                instructionsTitle: &quot;📖 التعليمات&quot;,
                powerUpsTitle: &quot;⚡ القوى الخاصة&quot;,
                aiStatusTitle: &quot;🤖 حالة الذكاء&quot;,
                pauseText: &quot;إيقاف&quot;,
                resumeText: &quot;استئناف&quot;,
                aiModeText: &quot;وضع الذكاء&quot;,
                newGameText: &quot;لعبة جديدة&quot;,
                scoreLabel: &quot;النقاط&quot;,
                levelLabel: &quot;المستوى&quot;,
                livesLabel: &quot;الأرواح&quot;,
                dotsLabel: &quot;النقاط&quot;,
                easyText: &quot;سهل&quot;,
                normalText: &quot;عادي&quot;,
                hardText: &quot;صعب&quot;,
                expertText: &quot;خبير&quot;,
                welcomeMessage: &quot;مرحباً بك في باك مان الكمي! استخدم الأسهم للحركة.&quot;,
                instructionsText: &quot;• استخدم الأسهم للحركة&lt;br&gt;• كل النقاط للفوز&lt;br&gt;• تجنب الأشباح&lt;br&gt;• النقاط الكبيرة تعطي قوة&lt;br&gt;• الذكاء الاصطناعي يتكيف مع مستواك&quot;,
                normalDotText: &quot;نقطة عادية (+10)&quot;,
                powerDotText: &quot;نقطة قوة (+50)&quot;,
                scaredGhostText: &quot;شبح خائف (+100)&quot;,
                enemyEaten: &quot;تم أكل الشبح!&quot;,
                enemyCaught: &quot;تم الإمساك بك من قبل شبح!&quot;,
                aiStatusText: &quot;الذكاء الكمي نشط&quot;,
                victoryTitle: &quot;🎉 انتصار! 🎉&quot;,
                victoryMessage: &quot;تهانينا! أكملت المستوى!&quot;,
                defeatTitle: &quot;💀 انتهت اللعبة 💀&quot;,
                defeatMessage: &quot;فقدت جميع أرواحك!&quot;,
                tryAgainText: &quot;حاول مرة أخرى&quot;,
                nextLevelText: &quot;المستوى التالي&quot;,
                gamePaused: &quot;اللعبة متوقفة&quot;,
                gameResumed: &quot;تم استئناف اللعبة&quot;,
                levelComplete: &quot;المستوى مكتمل!&quot;,
                allDotsEaten: &quot;تم أكل جميع النقاط!&quot;,
                ghostCaught: &quot;تم الإمساك بك من قبل شبح!&quot;,
                powerModeActive: &quot;وضع القوة نشط!&quot;,
                aiModeEnabled: &quot;تم تفعيل وضع الذكاء&quot;,
                aiModeDisabled: &quot;تم إلغاء وضع الذكاء&quot;
            },
            es: {
                gameTitle: &quot;Quantum Pac-Man&quot;,
                quantumBadge: &quot;🚀 IA FUTURISTA&quot;,
                controlsTitle: &quot;🎮 Controles Cuánticos&quot;,
                statsTitle: &quot;📊 Estadísticas&quot;,
                sizeTitle: &quot;📏 Tamaño&quot;,
                difficultyTitle: &quot;⚡ Dificultad&quot;,
                instructionsTitle: &quot;📖 Instrucciones&quot;,
                powerUpsTitle: &quot;⚡ Potenciadores&quot;,
                aiStatusTitle: &quot;🤖 Estado IA&quot;,
                pauseText: &quot;Pausa&quot;,
                resumeText: &quot;Reanudar&quot;,
                aiModeText: &quot;Modo IA&quot;,
                newGameText: &quot;Nuevo Juego&quot;,
                scoreLabel: &quot;Puntuación&quot;,
                levelLabel: &quot;Nivel&quot;,
                livesLabel: &quot;Vidas&quot;,
                dotsLabel: &quot;Puntos&quot;,
                easyText: &quot;Fácil&quot;,
                normalText: &quot;Normal&quot;,
                hardText: &quot;Difícil&quot;,
                expertText: &quot;Experto&quot;,
                welcomeMessage: &quot;¡Bienvenido a Quantum Pac-Man! Usa las flechas para moverte.&quot;,
                instructionsText: &quot;• Usa las flechas para moverte&lt;br&gt;• Come todos los puntos para ganar&lt;br&gt;• Evita los fantasmas&lt;br&gt;• Los puntos grandes dan poder&lt;br&gt;• La IA se adapta a tu nivel&quot;,
                normalDotText: &quot;Punto normal (+10)&quot;,
                powerDotText: &quot;Punto de poder (+50)&quot;,
                scaredGhostText: &quot;Fantasma asustado (+100)&quot;,
                enemyEaten: &quot;¡Fantasma comido!&quot;,
                enemyCaught: &quot;¡Atrapado por fantasma!&quot;,
                aiStatusText: &quot;IA Cuántica Activa&quot;,
                victoryTitle: &quot;🎉 ¡VICTORIA! 🎉&quot;,
                victoryMessage: &quot;¡Felicidades! ¡Completaste el nivel!&quot;,
                defeatTitle: &quot;💀 GAME OVER 💀&quot;,
                defeatMessage: &quot;¡Perdiste todas tus vidas!&quot;,
                tryAgainText: &quot;Intentar de nuevo&quot;,
                nextLevelText: &quot;Siguiente nivel&quot;,
                gamePaused: &quot;Juego pausado&quot;,
                gameResumed: &quot;Juego reanudado&quot;,
                levelComplete: &quot;¡Nivel completado!&quot;,
                allDotsEaten: &quot;¡Todos los puntos comidos!&quot;,
                ghostCaught: &quot;¡Atrapado por fantasma!&quot;,
                powerModeActive: &quot;¡Modo poder activo!&quot;,
                aiModeEnabled: &quot;Modo IA activado&quot;,
                aiModeDisabled: &quot;Modo IA desactivado&quot;
            },
            de: {
                gameTitle: &quot;Quantum Pac-Man&quot;,
                quantumBadge: &quot;🚀 FUTURISTISCHE KI&quot;,
                controlsTitle: &quot;🎮 Quanten-Steuerung&quot;,
                statsTitle: &quot;📊 Statistiken&quot;,
                sizeTitle: &quot;📏 Größe&quot;,
                difficultyTitle: &quot;⚡ Schwierigkeit&quot;,
                instructionsTitle: &quot;📖 Anweisungen&quot;,
                powerUpsTitle: &quot;⚡ Power-Ups&quot;,
                aiStatusTitle: &quot;🤖 KI-Status&quot;,
                pauseText: &quot;Pause&quot;,
                resumeText: &quot;Fortsetzen&quot;,
                aiModeText: &quot;KI-Modus&quot;,
                newGameText: &quot;Neues Spiel&quot;,
                scoreLabel: &quot;Punkte&quot;,
                levelLabel: &quot;Level&quot;,
                livesLabel: &quot;Leben&quot;,
                dotsLabel: &quot;Punkte&quot;,
                easyText: &quot;Einfach&quot;,
                normalText: &quot;Normal&quot;,
                hardText: &quot;Schwer&quot;,
                expertText: &quot;Experte&quot;,
                welcomeMessage: &quot;Willkommen bei Quantum Pac-Man! Verwende die Pfeiltasten zum Bewegen.&quot;,
                instructionsText: &quot;• Verwende Pfeiltasten zum Bewegen&lt;br&gt;• Iss alle Punkte zum Gewinnen&lt;br&gt;• Vermeide Geister&lt;br&gt;• Große Punkte geben Kraft&lt;br&gt;• KI passt sich deinem Level an&quot;,
                normalDotText: &quot;Normaler Punkt (+10)&quot;,
                powerDotText: &quot;Kraft-Punkt (+50)&quot;,
                scaredGhostText: &quot;Erschreckter Geist (+100)&quot;,
                enemyEaten: &quot;Geist gefressen!&quot;,
                enemyCaught: &quot;Von Geist gefangen!&quot;,
                aiStatusText: &quot;Quanten-KI Aktiv&quot;,
                victoryTitle: &quot;🎉 SIEG! 🎉&quot;,
                victoryMessage: &quot;Glückwunsch! Du hast das Level geschafft!&quot;,
                defeatTitle: &quot;💀 GAME OVER 💀&quot;,
                defeatMessage: &quot;Du hast alle Leben verloren!&quot;,
                tryAgainText: &quot;Nochmal versuchen&quot;,
                nextLevelText: &quot;Nächstes Level&quot;,
                gamePaused: &quot;Spiel pausiert&quot;,
                gameResumed: &quot;Spiel fortgesetzt&quot;,
                levelComplete: &quot;Level abgeschlossen!&quot;,
                allDotsEaten: &quot;Alle Punkte gegessen!&quot;,
                ghostCaught: &quot;Von Geist gefangen!&quot;,
                powerModeActive: &quot;Kraft-Modus aktiv!&quot;,
                aiModeEnabled: &quot;KI-Modus aktiviert&quot;,
                aiModeDisabled: &quot;KI-Modus deaktiviert&quot;
            },
            zh: {
                gameTitle: &quot;量子吃豆人&quot;,
                quantumBadge: &quot;🚀 未来人工智能&quot;,
                controlsTitle: &quot;🎮 量子控制&quot;,
                statsTitle: &quot;📊 统计数据&quot;,
                sizeTitle: &quot;📏 大小&quot;,
                difficultyTitle: &quot;⚡ 难度&quot;,
                instructionsTitle: &quot;📖 说明&quot;,
                powerUpsTitle: &quot;⚡ 能量道具&quot;,
                aiStatusTitle: &quot;🤖 AI状态&quot;,
                pauseText: &quot;暂停&quot;,
                resumeText: &quot;继续&quot;,
                aiModeText: &quot;AI模式&quot;,
                newGameText: &quot;新游戏&quot;,
                scoreLabel: &quot;得分&quot;,
                levelLabel: &quot;等级&quot;,
                livesLabel: &quot;生命&quot;,
                dotsLabel: &quot;点数&quot;,
                easyText: &quot;简单&quot;,
                normalText: &quot;普通&quot;,
                hardText: &quot;困难&quot;,
                expertText: &quot;专家&quot;,
                welcomeMessage: &quot;欢迎来到量子吃豆人！使用方向键移动。&quot;,
                instructionsText: &quot;• 使用方向键移动&lt;br&gt;• 吃掉所有点数获胜&lt;br&gt;• 避开幽灵&lt;br&gt;• 大点数给予力量&lt;br&gt;• AI会适应你的水平&quot;,
                normalDotText: &quot;普通点数 (+10)&quot;,
                powerDotText: &quot;能量点数 (+50)&quot;,
                scaredGhostText: &quot;害怕的幽灵 (+200)&quot;,
                enemyEaten: &quot;幽灵被吃掉！&quot;,
                enemyCaught: &quot;被幽灵抓住！&quot;,
                aiStatusText: &quot;量子AI已启用&quot;,
                victoryTitle: &quot;🎉 胜利！🎉&quot;,
                victoryMessage: &quot;恭喜！你完成了这一关！&quot;,
                defeatTitle: &quot;💀 游戏结束 💀&quot;,
                defeatMessage: &quot;你失去了所有生命！&quot;,
                tryAgainText: &quot;再试一次&quot;,
                nextLevelText: &quot;下一关&quot;,
                gamePaused: &quot;游戏暂停&quot;,
                gameResumed: &quot;游戏继续&quot;,
                levelComplete: &quot;关卡完成！&quot;,
                allDotsEaten: &quot;所有点数已吃完！&quot;,
                ghostCaught: &quot;被幽灵抓住！&quot;,
                powerModeActive: &quot;能量模式激活！&quot;,
                aiModeEnabled: &quot;AI模式已启用&quot;,
                aiModeDisabled: &quot;AI模式已禁用&quot;
            }
        };

        // État du jeu
    var gameState = {
            board: [],
            boardSize: 8,
            difficulty: &#x27;hard&#x27;,
            currentLanguage: &#x27;fr&#x27;,
            pacman: { x: 1, y: 1, direction: &#x27;right&#x27; },
            ghosts: [],
            score: 0,
            level: 1,
            lives: 3,
            totalDots: 0,
            eatenDots: 0,
            isGameActive: false,
            isPaused: false,
            aiMode: true,
            powerMode: false,
            powerModeTimer: 0,
            gameLoop: null,
            ghostMoveTimer: 0,
            aiMoveTimer: 0,
            ghostPauseTimer: 0 // Timer pour donner un avantage à Pac-Man
        };

        // Types de cellules
        const CELL_TYPES = {
            WALL: 0,
            DOT: 1,
            POWER_DOT: 2,
            EMPTY: 3,
            PACMAN: 4,
            GHOST: 5
        };

        // Directions
        const DIRECTIONS = {
            up: { x: 0, y: -1 },
            down: { x: 0, y: 1 },
            left: { x: -1, y: 0 },
            right: { x: 1, y: 0 }
        };

        // Créer les particules quantiques
        function createQuantumParticles() {
            const container = document.getElementById(&#x27;quantumParticles&#x27;);
            
            for(let i = 0; i &lt; 30; i++) {
                const particle = document.createElement(&#x27;div&#x27;);
                particle.className = &#x27;quantum-particle&#x27;;
                particle.style.left = Math.random() * 100 + &#x27;%&#x27;;
                particle.style.animationDelay = Math.random() * 12 + &#x27;s&#x27;;
                particle.style.animationDuration = (12 + Math.random() * 6) + &#x27;s&#x27;;
                container.appendChild(particle);
            }
        }

        // Fonction de changement de langue
        function changeLanguage() {
            const selector = document.getElementById(&#x27;languageSelector&#x27;);
            const selectedLang = selector.value;
            gameState.currentLanguage = selectedLang;
            
            const t = translations[selectedLang];
            
            // Mettre à jour tous les textes
            document.getElementById(&#x27;gameTitle&#x27;).textContent = t.gameTitle;
            document.getElementById(&#x27;quantumBadge&#x27;).textContent = t.quantumBadge;
            document.getElementById(&#x27;controlsTitle&#x27;).textContent = t.controlsTitle;
            document.getElementById(&#x27;statsTitle&#x27;).textContent = t.statsTitle;
            document.getElementById(&#x27;sizeTitle&#x27;).textContent = t.sizeTitle;
            document.getElementById(&#x27;difficultyTitle&#x27;).textContent = t.difficultyTitle;
            document.getElementById(&#x27;instructionsTitle&#x27;).textContent = t.instructionsTitle;
            document.getElementById(&#x27;powerUpsTitle&#x27;).textContent = t.powerUpsTitle;
            document.getElementById(&#x27;aiStatusTitle&#x27;).textContent = t.aiStatusTitle;
            
            document.getElementById(&#x27;pauseText&#x27;).textContent = gameState.isPaused ? t.resumeText : t.pauseText;
            document.getElementById(&#x27;aiModeText&#x27;).textContent = t.aiModeText;
            document.getElementById(&#x27;newGameText&#x27;).textContent = t.newGameText;
            
            // Mettre à jour le bouton pause principal
            const gamePauseBtn = document.getElementById(&#x27;gamePauseText&#x27;);
            const pauseIcon = document.getElementById(&#x27;pauseIcon&#x27;);
            if(gamePauseBtn &amp;&amp; pauseIcon) {
                gamePauseBtn.textContent = gameState.isPaused ? t.resumeText : t.pauseText;
                pauseIcon.textContent = gameState.isPaused ? &#x27;▶️&#x27; : &#x27;⏸️&#x27;;
            }
            
            document.getElementById(&#x27;scoreLabel&#x27;).textContent = t.scoreLabel;
            document.getElementById(&#x27;levelLabel&#x27;).textContent = t.levelLabel;
            document.getElementById(&#x27;livesLabel&#x27;).textContent = t.livesLabel;
            document.getElementById(&#x27;dotsLabel&#x27;).textContent = t.dotsLabel;
            
            document.getElementById(&#x27;easyText&#x27;).textContent = t.easyText;
            document.getElementById(&#x27;normalText&#x27;).textContent = t.normalText;
            document.getElementById(&#x27;hardText&#x27;).textContent = t.hardText;
            document.getElementById(&#x27;expertText&#x27;).textContent = t.expertText;
            
            document.getElementById(&#x27;welcomeMessage&#x27;).textContent = t.welcomeMessage;
            document.getElementById(&#x27;instructionsText&#x27;).innerHTML = t.instructionsText;
            document.getElementById(&#x27;normalDotText&#x27;).textContent = t.normalDotText;
            document.getElementById(&#x27;powerDotText&#x27;).textContent = t.powerDotText;
            document.getElementById(&#x27;scaredGhostText&#x27;).textContent = t.scaredGhostText;
            document.getElementById(&#x27;aiStatusText&#x27;).textContent = t.aiStatusText;
            
            // Mettre à jour le statut IA selon le mode actuel
            const aiStatusElement = document.getElementById(&#x27;aiStatusText&#x27;);
            if(aiStatusElement) {
                aiStatusElement.textContent = gameState.aiMode ? t.aiStatusText : t.aiModeDisabled;
            }
        }

        // Générer le plateau de jeu
        function generateBoard() {
            const size = gameState.boardSize;
            gameState.board = [];
            gameState.totalDots = 0;
            gameState.eatenDots = 0;
            
            // Initialiser avec des murs
            for(let y = 0; y &lt; size; y++) {
                gameState.board[y] = [];
                for(let x = 0; x &lt; size; x++) {
                    gameState.board[y][x] = CELL_TYPES.WALL;
                }
            }
            
            // Créer des chemins avec l&#x27;algorithme de labyrinthe
            createMaze();
            
            // Placer les points
            placeDots();
            
            // Placer Pac-Man dans une position de départ sûre
            gameState.pacman = { x: 2, y: 2, direction: &#x27;right&#x27; };
            
            // Placer les fantômes
            placeGhosts();
        }

        // Créer un labyrinthe
        function createMaze() {
            const size = gameState.boardSize;
            const totalCells = size * size;
            const targetEmptyCells = Math.floor(totalCells * 0.8); // 80% des cases doivent être accessibles
            
            // Initialiser toutes les cases comme vides d&#x27;abord
            for(let y = 0; y &lt; size; y++) {
                for(let x = 0; x &lt; size; x++) {
                    gameState.board[y][x] = CELL_TYPES.EMPTY;
                }
            }
            
            // Créer des murs stratégiques pour atteindre exactement 80% de cases libres
            const wallsNeeded = totalCells - targetEmptyCells;
            let wallsPlaced = 0;
            
            // Placer des murs de manière stratégique
            while(wallsPlaced &lt; wallsNeeded) {
                const x = Math.floor(Math.random() * size);
                const y = Math.floor(Math.random() * size);
                
                // Ne pas placer de murs sur les bords (pour garder les extrémités libres)
                if((x === 0 || x === size-1 || y === 0 || y === size-1)) {
                    continue;
                }
                
                // Ne pas placer de mur sur la position de départ de Pac-Man
                if(x === 2 &amp;&amp; y === 2) {
                    continue;
                }
                
                // Placer le mur seulement si la case est vide
                if(gameState.board[y][x] === CELL_TYPES.EMPTY) {
                    gameState.board[y][x] = CELL_TYPES.WALL;
                    
                    // Vérifier que tous les points restent accessibles
                    if(areAllCellsAccessible()) {
                        wallsPlaced++;
                    } else {
                        // Annuler ce mur s&#x27;il rend des zones inaccessibles
                        gameState.board[y][x] = CELL_TYPES.EMPTY;
                    }
                }
            }
            
            // S&#x27;assurer que les extrémités sont libres
            gameState.board[0][0] = CELL_TYPES.EMPTY;
            gameState.board[0][size-1] = CELL_TYPES.EMPTY;
            gameState.board[size-1][0] = CELL_TYPES.EMPTY;
            gameState.board[size-1][size-1] = CELL_TYPES.EMPTY;
            
            // S&#x27;assurer que les bords ont des chemins
            for(let i = 0; i &lt; size; i++) {
                if(Math.random() &gt; 0.7) {
                    gameState.board[0][i] = CELL_TYPES.EMPTY; // Bord haut
                    gameState.board[size-1][i] = CELL_TYPES.EMPTY; // Bord bas
                    gameState.board[i][0] = CELL_TYPES.EMPTY; // Bord gauche
                    gameState.board[i][size-1] = CELL_TYPES.EMPTY; // Bord droit
                }
            }
        }
        
        // Vérifier que toutes les cases vides sont accessibles depuis la position de Pac-Man
        function areAllCellsAccessible() {
            const size = gameState.boardSize;
            const visited = Array(size).fill().map(() =&gt; Array(size).fill(false));
            const queue = [{x: 2, y: 2}]; // Position de départ de Pac-Man
            visited[2][2] = true;
            
            // BFS pour vérifier l&#x27;accessibilité
            while(queue.length &gt; 0) {
                const {x, y} = queue.shift();
                
                // Vérifier les 4 directions
                const directions = [{x: 0, y: -1}, {x: 0, y: 1}, {x: -1, y: 0}, {x: 1, y: 0}];
                directions.forEach(dir =&gt; {
                    const newX = x + dir.x;
                    const newY = y + dir.y;
                    
                    if(newX &gt;= 0 &amp;&amp; newX &lt; size &amp;&amp; newY &gt;= 0 &amp;&amp; newY &lt; size &amp;&amp;
                       !visited[newY][newX] &amp;&amp; gameState.board[newY][newX] !== CELL_TYPES.WALL) {
                        visited[newY][newX] = true;
                        queue.push({x: newX, y: newY});
                    }
                });
            }
            
            // Vérifier que toutes les cases vides sont visitées
            for(let y = 0; y &lt; size; y++) {
                for(let x = 0; x &lt; size; x++) {
                    if(gameState.board[y][x] !== CELL_TYPES.WALL &amp;&amp; !visited[y][x]) {
                        return false;
                    }
                }
            }
            
            return true;
        }

        // Placer les points
        function placeDots() {
            const size = gameState.boardSize;
            
            for(let y = 0; y &lt; size; y++) {
                for(let x = 0; x &lt; size; x++) {
                    if(gameState.board[y][x] === CELL_TYPES.EMPTY) {
                        // Placer des super points dans les coins
                        if((x === 1 &amp;&amp; y === 1) || 
                           (x === size-2 &amp;&amp; y === 1) || 
                           (x === 1 &amp;&amp; y === size-2) || 
                           (x === size-2 &amp;&amp; y === size-2)) {
                            gameState.board[y][x] = CELL_TYPES.POWER_DOT;
                        } else {
                            gameState.board[y][x] = CELL_TYPES.DOT;
                        }
                        gameState.totalDots++;
                    }
                }
            }
        }

        // Placer les fantômes
        function placeGhosts() {
            gameState.ghosts = [];
            const size = gameState.boardSize;
            const numGhosts = Math.min(4, Math.floor(size / 3));
            
            const ghostColors = [&#x27;#ff0066&#x27;, &#x27;#00ff66&#x27;, &#x27;#6600ff&#x27;, &#x27;#ff6600&#x27;];
            const ghostEmojis = [&#x27;💀&#x27;, &#x27;☠️&#x27;, &#x27;👹&#x27;, &#x27;😈&#x27;];
            
            for(let i = 0; i &lt; numGhosts; i++) {
                let x, y;
                do {
                    x = Math.floor(Math.random() * (size - 2)) + 1;
                    y = Math.floor(Math.random() * (size - 2)) + 1;
                } while(gameState.board[y][x] === CELL_TYPES.WALL || 
                        (x === gameState.pacman.x &amp;&amp; y === gameState.pacman.y) ||
                        Math.abs(x - gameState.pacman.x) + Math.abs(y - gameState.pacman.y) &lt; 3);
                
                gameState.ghosts.push({
                    x: x,
                    y: y,
                    emoji: ghostEmojis[i],
                    color: ghostColors[i],
                    direction: [&#x27;up&#x27;, &#x27;down&#x27;, &#x27;left&#x27;, &#x27;right&#x27;][Math.floor(Math.random() * 4)],
                    scared: false,
                    scaredTimer: 0
                });
            }
        }

        // Créer l&#x27;affichage du plateau
        function createBoardDisplay() {
            const board = document.getElementById(&#x27;gameBoard&#x27;);
            const size = gameState.boardSize;
            
            board.innerHTML = &#x27;&#x27;;
            board.style.gridTemplateColumns = `repeat(${size}, 1fr)`;
            board.style.gridTemplateRows = `repeat(${size}, 1fr)`;
            
            for(let y = 0; y &lt; size; y++) {
                for(let x = 0; x &lt; size; x++) {
                    const cell = document.createElement(&#x27;div&#x27;);
                    cell.className = &#x27;game-cell&#x27;;
                    cell.id = `cell-${x}-${y}`;
                    
                    const cellType = gameState.board[y][x];
                    
                    if(cellType === CELL_TYPES.WALL) {
                        cell.classList.add(&#x27;wall&#x27;);
                        cell.textContent = &#x27;⬛&#x27;;
                    } else if(cellType === CELL_TYPES.DOT) {
                        cell.classList.add(&#x27;dot&#x27;);
                    } else if(cellType === CELL_TYPES.POWER_DOT) {
                        cell.classList.add(&#x27;power-dot&#x27;);
                    } else {
                        cell.classList.add(&#x27;path&#x27;);
                    }
                    
                    board.appendChild(cell);
                }
            }
            
            updateDisplay();
        }

        // Mettre à jour l&#x27;affichage
        function updateDisplay() {
            const size = gameState.boardSize;
            
            // Effacer les positions précédentes
            document.querySelectorAll(&#x27;.game-cell&#x27;).forEach(cell =&gt; {
                cell.classList.remove(&#x27;pacman&#x27;, &#x27;ghost&#x27;, &#x27;scared-ghost&#x27;);
                cell.innerHTML = &#x27;&#x27;; // Vider complètement le contenu
                
                if(!cell.classList.contains(&#x27;wall&#x27;)) {
                    const coords = cell.id.split(&#x27;-&#x27;);
                    const x = parseInt(coords[1]);
                    const y = parseInt(coords[2]);
                    const cellType = gameState.board[y][x];
                    
                    // Réinitialiser les classes
                    cell.className = &#x27;game-cell&#x27;;
                    
                    if(cellType === CELL_TYPES.DOT) {
                        cell.classList.add(&#x27;dot&#x27;);
                    } else if(cellType === CELL_TYPES.POWER_DOT) {
                        cell.classList.add(&#x27;power-dot&#x27;);
                    } else {
                        cell.classList.add(&#x27;path&#x27;);
                    }
                }
            });
            
            // Afficher Pac-Man
            const pacmanCell = document.getElementById(`cell-${gameState.pacman.x}-${gameState.pacman.y}`);
            if(pacmanCell) {
                // Réinitialiser les classes de la cellule
                pacmanCell.className = &#x27;game-cell pacman&#x27;;
                
                // Créer le sprite de Pac-Man avec animation de bouche
                const pacmanSprite = document.createElement(&#x27;div&#x27;);
                pacmanSprite.className = `pacman-sprite pacman-${gameState.pacman.direction}`;
                
                // Pac-Man sans yeux pour un look plus classique
                
                pacmanCell.appendChild(pacmanSprite);
            }
            
            // Afficher les fantômes
            gameState.ghosts.forEach(ghost =&gt; {
                const ghostCell = document.getElementById(`cell-${ghost.x}-${ghost.y}`);
                if(ghostCell) {
                    ghostCell.classList.add(&#x27;ghost&#x27;);
                    if(gameState.powerMode &amp;&amp; ghost.scared) {
                        ghostCell.classList.add(&#x27;scared-ghost&#x27;);
                        ghostCell.textContent = &#x27;😱&#x27;;
                        ghostCell.style.color = &#x27;#00aaff&#x27;;
                        ghostCell.style.textShadow = &#x27;0 0 15px #00aaff&#x27;;
                    } else {
                        ghostCell.textContent = ghost.emoji;
                        ghostCell.style.color = ghost.color;
                        ghostCell.style.textShadow = `0 0 15px ${ghost.color}`;
                    }
                }
            });
            
            // Mettre à jour les statistiques
            document.getElementById(&#x27;scoreValue&#x27;).textContent = gameState.score;
            document.getElementById(&#x27;levelValue&#x27;).textContent = gameState.level;
            document.getElementById(&#x27;livesValue&#x27;).textContent = gameState.lives;
            document.getElementById(&#x27;dotsValue&#x27;).textContent = `${gameState.eatenDots}/${gameState.totalDots}`;
        }

        // Trouver la direction vers le point le plus proche
        function findDirectionToNearestDot() {
            const pacX = gameState.pacman.x;
            const pacY = gameState.pacman.y;
            let nearestDot = null;
            let minDistance = Infinity;
            
            // Chercher le point le plus proche
            for(let y = 0; y &lt; gameState.boardSize; y++) {
                for(let x = 0; x &lt; gameState.boardSize; x++) {
                    if(gameState.board[y][x] === CELL_TYPES.DOT || gameState.board[y][x] === CELL_TYPES.POWER_DOT) {
                        const distance = Math.abs(x - pacX) + Math.abs(y - pacY);
                        if(distance &lt; minDistance) {
                            minDistance = distance;
                            nearestDot = { x, y };
                        }
                    }
                }
            }
            
            if(!nearestDot) return gameState.pacman.direction;
            
            // Déterminer la direction vers le point le plus proche
            const deltaX = nearestDot.x - pacX;
            const deltaY = nearestDot.y - pacY;
            
            // Prioriser la direction avec la plus grande différence
            if(Math.abs(deltaX) &gt; Math.abs(deltaY)) {
                return deltaX &gt; 0 ? &#x27;right&#x27; : &#x27;left&#x27;;
            } else {
                return deltaY &gt; 0 ? &#x27;down&#x27; : &#x27;up&#x27;;
            }
        }

        // Orienter Pac-Man automatiquement vers les points
        function orientPacmanTowardsDots() {
            if(!gameState.isGameActive || gameState.isPaused) return;
            
            const newDirection = findDirectionToNearestDot();
            if(newDirection !== gameState.pacman.direction) {
                gameState.pacman.direction = newDirection;
                updateDisplay();
            }
        }

        // Déplacer Pac-Man
        function movePacman(direction) {
            if(!gameState.isGameActive || gameState.isPaused) return;
            
            const newX = gameState.pacman.x + DIRECTIONS[direction].x;
            const newY = gameState.pacman.y + DIRECTIONS[direction].y;
            
            // Vérifier les limites et les murs
            if(newX &lt; 0 || newX &gt;= gameState.boardSize || 
               newY &lt; 0 || newY &gt;= gameState.boardSize ||
               gameState.board[newY][newX] === CELL_TYPES.WALL) {
                return;
            }
            
            gameState.pacman.x = newX;
            gameState.pacman.y = newY;
            
            // Orienter Pac-Man dans la direction du mouvement
            gameState.pacman.direction = direction;
            
            // Vérifier si Pac-Man mange un point
            const cellType = gameState.board[newY][newX];
            if(cellType === CELL_TYPES.DOT) {
                gameState.score += 10;
                gameState.eatenDots++;
                gameState.board[newY][newX] = CELL_TYPES.EMPTY;
                
                // Donner un avantage à Pac-Man : ralentir les ennemis temporairement
                gameState.ghostPauseTimer = 800; // 800ms de pause pour les ennemis
                
                // Animation de manger immédiate
                const pacmanCell = document.getElementById(`cell-${newX}-${newY}`);
                if(pacmanCell) {
                    // Supprimer la classe dot pour faire disparaître le point
                    pacmanCell.classList.remove(&#x27;dot&#x27;);
                    pacmanCell.classList.add(&#x27;path&#x27;);
                    
                    setTimeout(() =&gt; {
                        const sprite = pacmanCell.querySelector(&#x27;.pacman-sprite&#x27;);
                        if(sprite) {
                            sprite.classList.add(&#x27;eating-animation&#x27;);
                            setTimeout(() =&gt; {
                                sprite.classList.remove(&#x27;eating-animation&#x27;);
                            }, 300);
                        }
                    }, 50);
                }
                
            } else if(cellType === CELL_TYPES.POWER_DOT) {
                gameState.score += 50;
                gameState.eatenDots++;
                gameState.board[newY][newX] = CELL_TYPES.EMPTY;
                
                // Donner un gros avantage à Pac-Man : pause plus longue pour les ennemis
                gameState.ghostPauseTimer = 1500; // 1.5 secondes de pause pour les ennemis
                
                // Animation de manger immédiate (plus intense pour les power dots)
                const pacmanCell = document.getElementById(`cell-${newX}-${newY}`);
                if(pacmanCell) {
                    // Supprimer la classe power-dot pour faire disparaître le point
                    pacmanCell.classList.remove(&#x27;power-dot&#x27;);
                    pacmanCell.classList.add(&#x27;path&#x27;);
                    
                    setTimeout(() =&gt; {
                        const sprite = pacmanCell.querySelector(&#x27;.pacman-sprite&#x27;);
                        if(sprite) {
                            sprite.classList.add(&#x27;eating-animation&#x27;);
                            sprite.style.animation = &#x27;eatPulse 0.5s ease-out, pacmanBounce 0.3s ease-in-out infinite alternate&#x27;;
                            setTimeout(() =&gt; {
                                sprite.classList.remove(&#x27;eating-animation&#x27;);
                                sprite.style.animation = &#x27;pacmanBounce 0.3s ease-in-out infinite alternate&#x27;;
                            }, 500);
                        }
                    }, 50);
                }
                
                activatePowerMode();
            }
            
            // Vérifier la victoire
            if(gameState.eatenDots &gt;= gameState.totalDots) {
                showVictory();
                return;
            }
            
            // Vérifier les collisions avec les fantômes
            checkGhostCollisions();
            
            updateDisplay();
        }

        // Activer le mode pouvoir
        function activatePowerMode() {
            gameState.powerMode = true;
            gameState.powerModeTimer = 10000; // 10 secondes pour avoir le temps de manger les ennemis
            
            // Effrayer tous les ennemis
            gameState.ghosts.forEach(ghost =&gt; {
                ghost.scared = true;
                ghost.scaredTimer = 10000;
            });
            
            const t = translations[gameState.currentLanguage];
            showMessage(t.powerModeActive, 2000);
        }

        // Déplacer les fantômes
        function moveGhosts() {
            if(!gameState.isGameActive || gameState.isPaused) return;
            
            // Si les ennemis sont en pause (Pac-Man vient de manger), ne pas les déplacer
            if(gameState.ghostPauseTimer &gt; 0) {
                return;
            }
            
            gameState.ghosts.forEach(ghost =&gt; {
                // Réduire le timer de peur
                if(ghost.scared &amp;&amp; ghost.scaredTimer &gt; 0) {
                    ghost.scaredTimer -= 200;
                    if(ghost.scaredTimer &lt;= 0) {
                        ghost.scared = false;
                    }
                }
                
                let newX, newY;
                
                if(gameState.aiMode &amp;&amp; !ghost.scared) {
                    // IA pour poursuivre Pac-Man (mais moins agressive)
                    const moves = getValidMoves(ghost.x, ghost.y);
                    if(moves.length &gt; 0) {
                        // 70% de chance de poursuivre, 30% de mouvement aléatoire pour donner plus d&#x27;avantage à Pac-Man
                        if(Math.random() &lt; 0.7) {
                            // Choisir le mouvement qui rapproche le plus de Pac-Man
                            let bestMove = moves[0];
                            let bestDistance = getDistance(bestMove.x, bestMove.y, gameState.pacman.x, gameState.pacman.y);
                            
                            moves.forEach(move =&gt; {
                                const distance = getDistance(move.x, move.y, gameState.pacman.x, gameState.pacman.y);
                                if(distance &lt; bestDistance) {
                                    bestDistance = distance;
                                    bestMove = move;
                                }
                            });
                            
                            newX = bestMove.x;
                            newY = bestMove.y;
                        } else {
                            // Mouvement aléatoire
                            const randomMove = moves[Math.floor(Math.random() * moves.length)];
                            newX = randomMove.x;
                            newY = randomMove.y;
                        }
                    } else {
                        newX = ghost.x;
                        newY = ghost.y;
                    }
                } else {
                    // Mouvement aléatoire ou fuite si effrayé
                    const moves = getValidMoves(ghost.x, ghost.y);
                    if(moves.length &gt; 0) {
                        if(ghost.scared) {
                            // Fuir Pac-Man
                            let bestMove = moves[0];
                            let bestDistance = getDistance(bestMove.x, bestMove.y, gameState.pacman.x, gameState.pacman.y);
                            
                            moves.forEach(move =&gt; {
                                const distance = getDistance(move.x, move.y, gameState.pacman.x, gameState.pacman.y);
                                if(distance &gt; bestDistance) {
                                    bestDistance = distance;
                                    bestMove = move;
                                }
                            });
                            
                            newX = bestMove.x;
                            newY = bestMove.y;
                        } else {
                            // Mouvement aléatoire
                            const randomMove = moves[Math.floor(Math.random() * moves.length)];
                            newX = randomMove.x;
                            newY = randomMove.y;
                        }
                    } else {
                        newX = ghost.x;
                        newY = ghost.y;
                    }
                }
                
                ghost.x = newX;
                ghost.y = newY;
            });
            
            checkGhostCollisions();
        }

        // Obtenir les mouvements valides
        function getValidMoves(x, y) {
            const moves = [];
            
            Object.values(DIRECTIONS).forEach(dir =&gt; {
                const newX = x + dir.x;
                const newY = y + dir.y;
                
                if(newX &gt;= 0 &amp;&amp; newX &lt; gameState.boardSize &amp;&amp; 
                   newY &gt;= 0 &amp;&amp; newY &lt; gameState.boardSize &amp;&amp;
                   gameState.board[newY][newX] !== CELL_TYPES.WALL) {
                    moves.push({ x: newX, y: newY });
                }
            });
            
            return moves;
        }

        // Calculer la distance
        function getDistance(x1, y1, x2, y2) {
            return Math.abs(x1 - x2) + Math.abs(y1 - y2);
        }

        // Vérifier les collisions avec les ennemis
        function checkGhostCollisions() {
            gameState.ghosts.forEach((ghost, index) =&gt; {
                if(ghost.x === gameState.pacman.x &amp;&amp; ghost.y === gameState.pacman.y) {
                    if(gameState.powerMode &amp;&amp; ghost.scared) {
                        // Pac-Man mange l&#x27;ennemi pendant le mode pouvoir
                        gameState.score += 200;
                        const t = translations[gameState.currentLanguage];
                        showMessage(t.enemyEaten, 1500);
                        
                        // Respawn de l&#x27;ennemi dans un endroit sûr
                        respawnGhost(index);
                    } else if(!gameState.powerMode) {
                        // Pac-Man est attrapé par l&#x27;ennemi - Game Over
                        gameState.lives--;
                        const t = translations[gameState.currentLanguage];
                        showMessage(t.enemyCaught, 2000);
                        
                        if(gameState.lives &lt;= 0) {
                            showDefeat();
                        } else {
                            // Respawn de Pac-Man à la position de départ
                            gameState.pacman.x = 2;
                            gameState.pacman.y = 2;
                            gameState.pacman.direction = &#x27;right&#x27;;
                        }
                    }
                }
            });
        }

        // Respawn d&#x27;un fantôme mangé
        function respawnGhost(index) {
            const size = gameState.boardSize;
            let x, y;
            
            // Respawn dans une zone éloignée de Pac-Man
            do {
                x = Math.floor(Math.random() * (size - 2)) + 1;
                y = Math.floor(Math.random() * (size - 2)) + 1;
            } while(gameState.board[y][x] === CELL_TYPES.WALL || 
                    (x === gameState.pacman.x &amp;&amp; y === gameState.pacman.y) ||
                    Math.abs(x - gameState.pacman.x) + Math.abs(y - gameState.pacman.y) &lt; 4);
            
            gameState.ghosts[index].x = x;
            gameState.ghosts[index].y = y;
            gameState.ghosts[index].scared = false;
            gameState.ghosts[index].scaredTimer = 0;
            
            // Petit délai avant que le fantôme redevienne actif
            setTimeout(() =&gt; {
                if(gameState.ghosts[index]) {
                    gameState.ghosts[index].justRespawned = false;
                }
            }, 1000);
            
            gameState.ghosts[index].justRespawned = true;
        }

        // Afficher un message
        function showMessage(message, duration = 3000) {
            const messageElement = document.getElementById(&#x27;gameMessage&#x27;);
            messageElement.textContent = message;
            
            if(duration &gt; 0) {
                setTimeout(() =&gt; {
                    const t = translations[gameState.currentLanguage];
                    messageElement.textContent = t.welcomeMessage;
                }, duration);
            }
        }

        // Afficher la victoire
        function showVictory() {
            gameState.isGameActive = false;
            clearInterval(gameState.gameLoop);
            
            const t = translations[gameState.currentLanguage];
            
            // Créer l&#x27;animation de victoire
            const overlay = document.createElement(&#x27;div&#x27;);
            overlay.className = &#x27;victory-animation&#x27;;
            
            const content = document.createElement(&#x27;div&#x27;);
            content.className = &#x27;victory-content&#x27;;
            content.innerHTML = `
                &lt;h2&gt;${t.victoryTitle}&lt;/h2&gt;
                &lt;p style=&quot;margin: 20px 0;&quot;&gt;${t.victoryMessage}&lt;/p&gt;
                &lt;p style=&quot;margin: 10px 0; color: #00ff88;&quot;&gt;Score: ${gameState.score}&lt;/p&gt;
                &lt;p style=&quot;margin: 10px 0; color: #fbbf24;&quot;&gt;Niveau: ${gameState.level}&lt;/p&gt;
                &lt;button onclick=&quot;nextLevel()&quot; style=&quot;
                    margin: 20px 10px 10px 10px;
                    padding: 15px 30px;
                    background: linear-gradient(145deg, #00ff88, #0099ff);
                    color: white;
                    border: none;
                    border-radius: 15px;
                    font-size: 16px;
                    font-weight: bold;
                    cursor: pointer;
                    transition: all 0.3s ease;
                &quot;&gt;${t.nextLevelText}&lt;/button&gt;
                &lt;button onclick=&quot;resetGame()&quot; style=&quot;
                    margin: 10px;
                    padding: 15px 30px;
                    background: linear-gradient(145deg, #ef4444, #dc2626);
                    color: white;
                    border: none;
                    border-radius: 15px;
                    font-size: 16px;
                    font-weight: bold;
                    cursor: pointer;
                    transition: all 0.3s ease;
                &quot;&gt;${t.newGameText}&lt;/button&gt;
            `;
            
            // Ajouter des feux d&#x27;artifice
            for(let i = 0; i &lt; 20; i++) {
                const firework = document.createElement(&#x27;div&#x27;);
                firework.className = &#x27;victory-fireworks&#x27;;
                firework.style.left = Math.random() * 100 + &#x27;%&#x27;;
                firework.style.top = Math.random() * 100 + &#x27;%&#x27;;
                firework.style.animationDelay = Math.random() * 3 + &#x27;s&#x27;;
                overlay.appendChild(firework);
            }
            
            overlay.appendChild(content);
            document.body.appendChild(overlay);
        }

        // Afficher la défaite
        function showDefeat() {
            gameState.isGameActive = false;
            clearInterval(gameState.gameLoop);
            
            const t = translations[gameState.currentLanguage];
            
            // Créer l&#x27;animation de défaite
            const overlay = document.createElement(&#x27;div&#x27;);
            overlay.className = &#x27;defeat-animation&#x27;;
            
            const content = document.createElement(&#x27;div&#x27;);
            content.className = &#x27;defeat-content&#x27;;
            content.innerHTML = `
                &lt;h2&gt;${t.defeatTitle}&lt;/h2&gt;
                &lt;p style=&quot;margin: 20px 0;&quot;&gt;${t.defeatMessage}&lt;/p&gt;
                &lt;p style=&quot;margin: 10px 0; color: #ef4444;&quot;&gt;Score Final: ${gameState.score}&lt;/p&gt;
                &lt;p style=&quot;margin: 10px 0; color: #fbbf24;&quot;&gt;Niveau Atteint: ${gameState.level}&lt;/p&gt;
                &lt;button onclick=&quot;resetGame()&quot; style=&quot;
                    margin: 20px 10px;
                    padding: 15px 30px;
                    background: linear-gradient(145deg, #00ff88, #0099ff);
                    color: white;
                    border: none;
                    border-radius: 15px;
                    font-size: 16px;
                    font-weight: bold;
                    cursor: pointer;
                    transition: all 0.3s ease;
                &quot;&gt;${t.tryAgainText}&lt;/button&gt;
            `;
            
            overlay.appendChild(content);
            document.body.appendChild(overlay);
        }

        // Niveau suivant
        function nextLevel() {
            // Fermer l&#x27;overlay de victoire
            const overlay = document.querySelector(&#x27;.victory-animation&#x27;);
            if(overlay) {
                document.body.removeChild(overlay);
            }
            
            gameState.level++;
            gameState.lives = Math.min(gameState.lives + 1, 5); // Bonus de vie
            
            // Augmenter la difficulté
            if(gameState.level % 3 === 0) {
                gameState.boardSize = Math.min(gameState.boardSize + 1, 11);
            }
            
            startGame();
        }

        // Démarrer le jeu
        function startGame() {
            gameState.isGameActive = true;
            gameState.isPaused = false;
            gameState.powerMode = false;
            gameState.powerModeTimer = 0;
            gameState.ghostPauseTimer = 0;
            
            generateBoard();
            createBoardDisplay();
            
            // Démarrer la boucle de jeu
            if(gameState.gameLoop) {
                clearInterval(gameState.gameLoop);
            }
            
            gameState.gameLoop = setInterval(() =&gt; {
                if(gameState.isGameActive &amp;&amp; !gameState.isPaused) {
                    gameState.ghostMoveTimer += 200;
                    
                    // Réduire le timer de pause des ennemis
                    if(gameState.ghostPauseTimer &gt; 0) {
                        gameState.ghostPauseTimer -= 200;
                    }
                    
                    // Déplacer les fantômes selon la difficulté (vitesses réduites)
                    let ghostMoveInterval;
                    switch(gameState.difficulty) {
                        case &#x27;easy&#x27;: ghostMoveInterval = 1200; break;
                        case &#x27;normal&#x27;: ghostMoveInterval = 1000; break;
                        case &#x27;hard&#x27;: ghostMoveInterval = 800; break;
                        case &#x27;expert&#x27;: ghostMoveInterval = 600; break;
                    }
                    
                    if(gameState.ghostMoveTimer &gt;= ghostMoveInterval) {
                        moveGhosts();
                        gameState.ghostMoveTimer = 0;
                    }
                    
                    // Réduire le timer du mode pouvoir
                    if(gameState.powerMode &amp;&amp; gameState.powerModeTimer &gt; 0) {
                        gameState.powerModeTimer -= 200;
                        if(gameState.powerModeTimer &lt;= 0) {
                            gameState.powerMode = false;
                            gameState.ghosts.forEach(ghost =&gt; {
                                ghost.scared = false;
                                ghost.scaredTimer = 0;
                            });
                        }
                    }
                    
                    // Orienter Pac-Man vers les points automatiquement
                    orientPacmanTowardsDots();
                    
                    updateDisplay();
                }
            }, 200);
            
            const t = translations[gameState.currentLanguage];
            showMessage(t.welcomeMessage, 3000);
        }

        // Fonctions de configuration
        function setBoardSize(size) {
            gameState.boardSize = size;
            
            // Mettre à jour les boutons
            document.querySelectorAll(&#x27;[id^=&quot;size&quot;]&#x27;).forEach(btn =&gt; btn.classList.remove(&#x27;active&#x27;));
            document.getElementById(`size${size}`).classList.add(&#x27;active&#x27;);
            
            if(gameState.isGameActive) {
                resetGame();
            }
        }

        function setDifficulty(difficulty) {
            gameState.difficulty = difficulty;
            
            // Mettre à jour les boutons
            document.querySelectorAll(&#x27;[id^=&quot;diff&quot;]&#x27;).forEach(btn =&gt; btn.classList.remove(&#x27;active&#x27;));
            document.getElementById(`diff${difficulty.charAt(0).toUpperCase() + difficulty.slice(1)}`).classList.add(&#x27;active&#x27;);
        }

        // Fonctions de contrôle
        function togglePause() {
            gameState.isPaused = !gameState.isPaused;
            const t = translations[gameState.currentLanguage];
            
            // Mettre à jour le bouton du panneau gauche
            const leftPauseBtn = document.getElementById(&#x27;pauseText&#x27;);
            if(leftPauseBtn) {
                leftPauseBtn.textContent = gameState.isPaused ? t.resumeText : t.pauseText;
            }
            
            // Mettre à jour le bouton principal du jeu
            const gamePauseBtn = document.getElementById(&#x27;gamePauseText&#x27;);
            const pauseIcon = document.getElementById(&#x27;pauseIcon&#x27;);
            if(gamePauseBtn &amp;&amp; pauseIcon) {
                gamePauseBtn.textContent = gameState.isPaused ? t.resumeText : t.pauseText;
                pauseIcon.textContent = gameState.isPaused ? &#x27;▶️&#x27; : &#x27;⏸️&#x27;;
            }
            
            showMessage(gameState.isPaused ? t.gamePaused : t.gameResumed, 1500);
        }

        function toggleAIMode() {
            gameState.aiMode = !gameState.aiMode;
            const t = translations[gameState.currentLanguage];
            
            const btn = document.getElementById(&#x27;aiBtn&#x27;);
            const aiStatusElement = document.getElementById(&#x27;aiStatusText&#x27;);
            
            if(gameState.aiMode) {
                btn.style.background = &#x27;linear-gradient(145deg, #8b5cf6, #7c3aed)&#x27;;
                if(aiStatusElement) aiStatusElement.textContent = t.aiStatusText;
                showMessage(t.aiModeEnabled, 2000);
            } else {
                btn.style.background = &#x27;linear-gradient(145deg, #6b7280, #4b5563)&#x27;;
                if(aiStatusElement) aiStatusElement.textContent = t.aiModeDisabled;
                showMessage(t.aiModeDisabled, 2000);
            }
        }

        function resetGame() {
            // Fermer les overlays
            const victoryOverlay = document.querySelector(&#x27;.victory-animation&#x27;);
            const defeatOverlay = document.querySelector(&#x27;.defeat-animation&#x27;);
            if(victoryOverlay) document.body.removeChild(victoryOverlay);
            if(defeatOverlay) document.body.removeChild(defeatOverlay);
            
            // Réinitialiser l&#x27;état
            gameState.score = 0;
            gameState.level = 1;
            gameState.lives = 3;
            gameState.isGameActive = false;
            gameState.isPaused = false;
            
            if(gameState.gameLoop) {
                clearInterval(gameState.gameLoop);
            }
            
            startGame();
        }

        // Gestion des touches
        document.addEventListener(&#x27;keydown&#x27;, (event) =&gt; {
            if(!gameState.isGameActive || gameState.isPaused) return;
            
            switch(event.key) {
                case &#x27;ArrowUp&#x27;:
                    event.preventDefault();
                    movePacman(&#x27;up&#x27;);
                    break;
                case &#x27;ArrowDown&#x27;:
                    event.preventDefault();
                    movePacman(&#x27;down&#x27;);
                    break;
                case &#x27;ArrowLeft&#x27;:
                    event.preventDefault();
                    movePacman(&#x27;left&#x27;);
                    break;
                case &#x27;ArrowRight&#x27;:
                    event.preventDefault();
                    movePacman(&#x27;right&#x27;);
                    break;
                case &#x27; &#x27;:
                    event.preventDefault();
                    togglePause();
                    break;
            }
        });

        // Initialisation
        document.addEventListener(&#x27;DOMContentLoaded&#x27;, function() {
            createQuantumParticles();
            startGame();
        });
    &lt;/script&gt;
&lt;script&gt;(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement(&#x27;script&#x27;);d.innerHTML=&quot;window.__CF$cv$params={r:&#x27;9849fbb4e7627782&#x27;,t:&#x27;MTc1ODc5NzY2My4wMDAwMDA=&#x27;};var a=document.createElement(&#x27;script&#x27;);a.nonce=&#x27;&#x27;;a.src=&#x27;/cdn-cgi/challenge-platform/scripts/jsd/main.js&#x27;;document.getElementsByTagName(&#x27;head&#x27;)[0].appendChild(a);&quot;;b.getElementsByTagName(&#x27;head&#x27;)[0].appendChild(d)}}if(document.body){var a=document.createElement(&#x27;iframe&#x27;);a.height=1;a.width=1;a.style.position=&#x27;absolute&#x27;;a.style.top=0;a.style.left=0;a.style.border=&#x27;none&#x27;;a.style.visibility=&#x27;hidden&#x27;;document.body.appendChild(a);if(&#x27;loading&#x27;!==document.readyState)c();else if(window.addEventListener)document.addEventListener(&#x27;DOMContentLoaded&#x27;,c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);&#x27;loading&#x27;!==document.readyState&amp;&amp;(document.onreadystatechange=e,c())}}}})();&lt;/script&gt;&lt;/body&gt;
&lt;/html&gt;
" style="width:100%;height:100%;border:none;"></iframe>
</div>

<script>
function launchGame6() {
  const overlay = document.getElementById("game6Overlay");
  overlay.style.display = "block";
}
function closeGame6() {
  const overlay = document.getElementById("game6Overlay");
  overlay.style.display = "none";
}
document.addEventListener("keydown", function(e) {
  if (e.key === "Escape") {
    const overlay = document.getElementById("game6Overlay");
    if (overlay && overlay.style.display === "block") {
      e.preventDefault();
      e.stopPropagation();
      closeGame6();
    }
  }
}, true);
</script>


<div id="game7Overlay" style="display:none;position:fixed;inset:0;background:#000;z-index:9999;">
  <button onclick="closeGame7()" style="position:absolute;top:10px;right:10px;z-index:10000;font-size:24px;background:red;color:white;border:none;border-radius:50%;width:40px;height:40px;cursor:pointer;">✖</button>
  <iframe id="iframeGame7" srcdoc="&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;fr&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;🎮 Simon Says - IA Futuriste&lt;/title&gt;
    &lt;script src=&quot;https://cdn.tailwindcss.com&quot;&gt;&lt;/script&gt;
    &lt;style&gt;
        body {
            box-sizing: border-box;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: &#x27;Segoe UI&#x27;, Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a3a 30%, #2d1b69 70%, #4c1d95 100%);
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }

        /* Particules quantiques d&#x27;arrière-plan */
        .quantum-particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .quantum-particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: #00ff88;
            border-radius: 50%;
            animation: quantumFloat 15s infinite linear;
            box-shadow: 0 0 15px #00ff88, 0 0 25px #00ff88;
        }

        @keyframes quantumFloat {
            0% {
                transform: translateY(100vh) translateX(0) rotate(0deg) scale(0);
                opacity: 0;
            }
            10% {
                opacity: 1;
                transform: translateY(90vh) translateX(30px) rotate(45deg) scale(1);
            }
            50% {
                transform: translateY(50vh) translateX(-40px) rotate(180deg) scale(1.5);
            }
            90% {
                opacity: 1;
                transform: translateY(10vh) translateX(50px) rotate(315deg) scale(1);
            }
            100% {
                transform: translateY(-10vh) translateX(100px) rotate(360deg) scale(0);
                opacity: 0;
            }
        }

        /* Grille quantique de fond */
        .quantum-grid {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(0, 255, 136, 0.08) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 136, 0.08) 1px, transparent 1px);
            background-size: 80px 80px;
            animation: quantumGridMove 30s linear infinite;
            z-index: 1;
        }

        @keyframes quantumGridMove {
            0% { transform: translate(0, 0); }
            100% { transform: translate(80px, 80px); }
        }

        /* Container principal */
        .neural-memory-container {
            position: relative;
            z-index: 10;
            display: grid;
            grid-template-columns: 250px 1fr 250px;
            gap: 20px;
            min-height: 100vh;
            padding: 20px;
            max-width: 1500px;
            margin: 0 auto;
        }



        .game-panel {
            background: linear-gradient(145deg, 
                rgba(30, 30, 58, 0.95) 0%,
                rgba(45, 27, 105, 0.95) 50%,
                rgba(76, 29, 149, 0.95) 100%);
            backdrop-filter: blur(30px);
            border-radius: 25px;
            padding: 25px;
            width: 100%;
            height: fit-content;
            box-shadow: 
                0 30px 60px rgba(0, 0, 0, 0.7),
                0 0 120px rgba(0, 255, 136, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(0, 255, 136, 0.5);
            animation: neuralPanelGlow 5s ease-in-out infinite alternate;
        }

        @keyframes neuralPanelGlow {
            from { 
                box-shadow: 
                    0 30px 60px rgba(0, 0, 0, 0.7),
                    0 0 120px rgba(0, 255, 136, 0.2),
                    inset 0 1px 0 rgba(255, 255, 255, 0.1);
            }
            to { 
                box-shadow: 
                    0 35px 70px rgba(0, 0, 0, 0.7),
                    0 0 140px rgba(0, 255, 136, 0.3),
                    inset 0 1px 0 rgba(255, 255, 255, 0.2);
            }
        }

        /* En-tête du jeu */
        .neural-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 2px solid rgba(0, 255, 136, 0.5);
        }

        .neural-title {
            display: flex;
            align-items: center;
            gap: 25px;
        }

        .neural-title h1 {
            color: #00ff88;
            margin: 0;
            font-size: 24px;
            font-weight: 700;
            text-shadow: 0 0 35px rgba(0, 255, 136, 0.9);
            animation: neuralTitlePulse 4s infinite alternate;
        }

        @keyframes neuralTitlePulse {
            from { 
                text-shadow: 0 0 35px rgba(0, 255, 136, 0.9);
                transform: scale(1);
            }
            to { 
                text-shadow: 0 0 45px rgba(0, 255, 136, 1);
                transform: scale(1.05);
            }
        }

        .neural-icon {
            font-size: 36px;
            animation: neuralIconPulse 3s ease-in-out infinite;
            filter: drop-shadow(0 0 25px #00ff88);
        }

        @keyframes neuralIconPulse {
            0%, 100% { transform: scale(1) rotate(0deg); }
            50% { transform: scale(1.2) rotate(5deg); }
        }

        .neural-badge {
            background: linear-gradient(45deg, #00ff88, #0099ff, #ff0099, #ffaa00);
            background-size: 400% 400%;
            color: white;
            padding: 10px 18px;
            border-radius: 25px;
            font-size: 12px;
            font-weight: bold;
            animation: neuralBadgeShine 5s ease-in-out infinite;
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.7);
        }

        @keyframes neuralBadgeShine {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        /* Sélecteur de langue */
        .language-selector {
            background: linear-gradient(145deg, 
                rgba(30, 30, 58, 0.95) 0%,
                rgba(45, 27, 105, 0.95) 30%,
                rgba(76, 29, 149, 0.95) 70%,
                rgba(139, 92, 246, 0.95) 100%);
            color: #00ff88;
            border: 2px solid rgba(0, 255, 136, 0.6);
            border-radius: 18px;
            padding: 14px 20px;
            font-weight: bold;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
            box-shadow: 
                0 0 30px rgba(0, 255, 136, 0.5),
                0 0 50px rgba(139, 92, 246, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            min-width: 180px;
            max-height: 250px;
            overflow-y: auto;
            text-shadow: 0 0 12px rgba(0, 255, 136, 0.8);
        }

        .language-selector:hover {
            background: linear-gradient(145deg, 
                rgba(0, 255, 136, 0.9) 0%,
                rgba(0, 153, 255, 0.9) 30%,
                rgba(139, 92, 246, 0.9) 70%,
                rgba(255, 0, 153, 0.9) 100%);
            transform: translateY(-3px);
            box-shadow: 
                0 12px 35px rgba(0, 255, 136, 0.7),
                0 0 60px rgba(139, 92, 246, 0.5),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
            color: white;
            text-shadow: 0 0 18px rgba(255, 255, 255, 0.8);
        }

        /* Style pour les options du sélecteur de langue */
        .language-selector option {
            background: linear-gradient(145deg, 
                rgba(20, 20, 40, 0.98) 0%,
                rgba(35, 17, 85, 0.98) 50%,
                rgba(66, 19, 129, 0.98) 100%);
            color: #00ff88;
            padding: 12px 16px;
            font-weight: bold;
            font-size: 14px;
            border: none;
            text-shadow: 0 0 15px rgba(0, 255, 136, 0.9);
            border-bottom: 1px solid rgba(0, 255, 136, 0.3);
        }

        .language-selector option:hover,
        .language-selector option:focus,
        .language-selector option:checked {
            background: linear-gradient(145deg, 
                rgba(0, 255, 136, 0.9) 0%,
                rgba(0, 153, 255, 0.9) 30%,
                rgba(139, 92, 246, 0.9) 70%,
                rgba(255, 0, 153, 0.9) 100%) !important;
            color: white !important;
            text-shadow: 0 0 20px rgba(255, 255, 255, 1) !important;
            box-shadow: 
                0 0 25px rgba(0, 255, 136, 0.8),
                inset 0 0 15px rgba(255, 255, 255, 0.2) !important;
        }

        .language-selector option:selected {
            background: linear-gradient(145deg, 
                rgba(255, 0, 153, 0.95) 0%,
                rgba(139, 92, 246, 0.95) 50%,
                rgba(0, 255, 136, 0.95) 100%) !important;
            color: white !important;
            text-shadow: 0 0 25px rgba(255, 255, 255, 1) !important;
            font-weight: 900 !important;
        }

        /* Panneau de titre des sections */
        .panel-title {
            color: #00ff88;
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 18px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 18px rgba(0, 255, 136, 0.9);
            border-bottom: 2px solid rgba(0, 255, 136, 0.5);
            padding-bottom: 12px;
        }

        /* Configuration du jeu */
        .config-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
            padding: 18px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 15px;
            border: 2px solid rgba(0, 255, 136, 0.3);
        }

        .config-group {
            text-align: center;
        }

        .config-group-title {
            color: #00ff88;
            font-size: 12px;
            font-weight: bold;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .config-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
        }

        .config-btn {
            padding: 8px 12px;
            background: linear-gradient(145deg, #00ff88, #0099ff);
            color: white;
            border: none;
            border-radius: 10px;
            font-weight: bold;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .config-btn::before {
            content: &#x27;&#x27;;
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            transition: left 0.6s ease;
        }

        .config-btn:hover::before {
            left: 100%;
        }

        .config-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0, 255, 136, 0.6);
            background: linear-gradient(145deg, #00ffaa, #00bbff);
        }

        .config-btn.active {
            background: linear-gradient(145deg, #ff0099, #ffaa00);
            box-shadow: 0 0 20px rgba(255, 0, 153, 0.7);
        }

        /* Plateau de jeu neural */
        .neural-board {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 20px;
            max-width: 500px;
            margin: 0 auto 30px auto;
            padding: 30px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 25px;
            border: 3px solid rgba(0, 255, 136, 0.6);
            box-shadow: 
                0 0 50px rgba(0, 255, 136, 0.4),
                inset 0 0 30px rgba(0, 255, 136, 0.1);
        }

        .neural-cell {
            width: 100px;
            height: 100px;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            font-weight: bold;
            border: 3px solid transparent;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.5);
            overflow: hidden;
        }

        .neural-cell::before {
            content: &#x27;&#x27;;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: inherit;
            border-radius: inherit;
            opacity: 0.8;
            z-index: -1;
        }

        .neural-cell::after {
            content: &#x27;&#x27;;
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.3s ease;
            z-index: 1;
        }

        .neural-cell:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.7);
        }

        .neural-cell:hover::after {
            width: 100%;
            height: 100%;
        }

        .neural-cell.active {
            transform: scale(1.1);
            border-color: #ffffff;
            box-shadow: 
                0 0 40px currentColor,
                0 15px 35px rgba(0, 0, 0, 0.7);
            animation: neuralCellPulse 0.6s ease-out;
        }

        @keyframes neuralCellPulse {
            0% { transform: scale(1.1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1.1); }
        }

        .neural-cell.error {
            animation: neuralCellError 0.8s ease-out;
        }

        @keyframes neuralCellError {
            0%, 100% { transform: scale(1); }
            25% { transform: scale(1.1) rotate(-5deg); }
            75% { transform: scale(1.1) rotate(5deg); }
        }

        /* Couleurs des cellules */
        .neural-cell-0 {
            background: linear-gradient(145deg, #ff0066, #ff3388);
            color: white;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.8);
        }

        .neural-cell-1 {
            background: linear-gradient(145deg, #00ff88, #33ffaa);
            color: white;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.8);
        }

        .neural-cell-2 {
            background: linear-gradient(145deg, #0099ff, #33aaff);
            color: white;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.8);
        }

        .neural-cell-3 {
            background: linear-gradient(145deg, #ffaa00, #ffcc33);
            color: white;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.8);
        }

        /* Contrôles du jeu */
        .game-controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 25px;
        }

        .neural-btn {
            padding: 15px 25px;
            background: linear-gradient(145deg, #00ff88, #0099ff);
            color: white;
            border: none;
            border-radius: 15px;
            font-weight: bold;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 1px;
            min-width: 120px;
        }

        .neural-btn::before {
            content: &#x27;&#x27;;
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            transition: left 0.6s ease;
        }

        .neural-btn:hover::before {
            left: 100%;
        }

        .neural-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(0, 255, 136, 0.5);
            background: linear-gradient(145deg, #00ffaa, #00bbff);
        }

        .neural-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .start-btn {
            background: linear-gradient(145deg, #00ff88, #0099ff);
        }

        .reset-btn {
            background: linear-gradient(145deg, #ef4444, #dc2626);
        }

        .reset-btn:hover {
            background: linear-gradient(145deg, #f87171, #ef4444);
        }

        /* Statistiques du jeu */
        .game-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 20px;
        }

        .stat-item {
            background: rgba(0, 255, 136, 0.15);
            padding: 12px;
            border-radius: 15px;
            text-align: center;
            border: 2px solid rgba(0, 255, 136, 0.4);
            position: relative;
            overflow: hidden;
        }

        .stat-item::before {
            content: &#x27;&#x27;;
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 136, 0.3), transparent);
            animation: statNeuralScan 5s linear infinite;
        }

        @keyframes statNeuralScan {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .stat-label {
            display: block;
            color: #9ca3af;
            font-size: 11px;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-value {
            display: block;
            color: #00ff88;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 0 0 18px rgba(0, 255, 136, 0.9);
            position: relative;
            z-index: 1;
        }

        /* Messages de jeu */
        .game-message {
            text-align: center;
            margin-bottom: 20px;
            padding: 18px;
            border-radius: 15px;
            background: rgba(0, 255, 136, 0.1);
            border: 2px solid rgba(0, 255, 136, 0.3);
            color: #00ff88;
            font-weight: bold;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }

        /* Barre de progression */
        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            margin-bottom: 20px;
            overflow: hidden;
            border: 1px solid rgba(0, 255, 136, 0.3);
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff88, #0099ff);
            border-radius: 10px;
            transition: width 0.3s ease;
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.6);
        }

        /* Responsive */
        @media (max-width: 1200px) {
            .neural-memory-container {
                grid-template-columns: 1fr;
                gap: 15px;
                padding: 15px;
            }
        }

        @media (max-width: 768px) {
            .game-panel {
                padding: 15px;
                margin: 10px;
            }
            
            .config-section {
                grid-template-columns: 1fr;
            }
            
            .neural-title h1 {
                font-size: 20px;
            }
            
            .neural-board {
                width: 240px;
                gap: 12px;
                padding: 15px;
            }
            
            .neural-cell {
                width: 90px;
                height: 90px;
                font-size: 28px;
            }
            
            .game-controls {
                flex-direction: column;
                align-items: center;
            }
            
            .theme-section {
                display: none !important;
            }
        }

        @media (max-width: 480px) {
            .neural-cell {
                width: 70px;
                height: 70px;
                font-size: 20px;
            }
            
            .game-stats {
                grid-template-columns: 1fr;
            }
        }

        /* Animations de victoire et défaite */
        .victory-animation, .defeat-animation {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            backdrop-filter: blur(15px);
        }

        .victory-content, .defeat-content {
            background: linear-gradient(145deg, rgba(30, 30, 58, 0.95), rgba(76, 29, 149, 0.95));
            border: 3px solid #00ff88;
            border-radius: 25px;
            padding: 50px;
            text-align: center;
            color: white;
            font-size: 22px;
            font-weight: bold;
            max-width: 600px;
            box-shadow: 0 0 60px rgba(0, 255, 136, 0.7);
            animation: victoryPulse 3s ease-in-out infinite alternate;
        }

        .defeat-content {
            border-color: #ef4444;
            box-shadow: 0 0 60px rgba(239, 68, 68, 0.7);
            animation: defeatShake 1s ease-in-out infinite;
        }

        @keyframes victoryPulse {
            from { 
                box-shadow: 0 0 60px rgba(0, 255, 136, 0.7);
                transform: scale(1);
            }
            to { 
                box-shadow: 0 0 90px rgba(0, 255, 136, 1);
                transform: scale(1.05);
            }
        }

        @keyframes defeatShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-8px); }
            75% { transform: translateX(8px); }
        }

        /* Effets de particules pour les victoires */
        .neural-fireworks {
            position: absolute;
            width: 12px;
            height: 12px;
            background: #00ff88;
            border-radius: 50%;
            animation: neuralFireworks 4s ease-out infinite;
        }

        @keyframes neuralFireworks {
            0% {
                transform: scale(0) rotate(0deg);
                opacity: 1;
            }
            50% {
                transform: scale(1.5) rotate(180deg);
                opacity: 0.8;
            }
            100% {
                transform: scale(3) rotate(360deg);
                opacity: 0;
            }
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!-- Particules quantiques d&#x27;arrière-plan --&gt;
    &lt;div class=&quot;quantum-particles&quot; id=&quot;quantumParticles&quot;&gt;&lt;/div&gt;
    
    &lt;!-- Grille quantique --&gt;
    &lt;div class=&quot;quantum-grid&quot;&gt;&lt;/div&gt;
    
    &lt;!-- Container principal --&gt;
    &lt;div class=&quot;neural-memory-container&quot;&gt;
        &lt;!-- Panneau gauche --&gt;
        &lt;div class=&quot;left-panel&quot;&gt;
            &lt;div class=&quot;panel-section&quot;&gt;
                &lt;div class=&quot;panel-title&quot; id=&quot;controlsTitle&quot;&gt;🎮 Contrôles Neuraux&lt;/div&gt;
                &lt;div style=&quot;display: grid; gap: 12px;&quot;&gt;
                    &lt;button class=&quot;neural-btn start-btn&quot; onclick=&quot;startGame()&quot; id=&quot;startBtn&quot;&gt;
                        🚀 &lt;span id=&quot;startText&quot;&gt;Démarrer&lt;/span&gt;
                    &lt;/button&gt;
                    &lt;button class=&quot;neural-btn reset-btn&quot; onclick=&quot;resetGame()&quot;&gt;
                        🔄 &lt;span id=&quot;resetText&quot;&gt;Réinitialiser&lt;/span&gt;
                    &lt;/button&gt;
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;div class=&quot;panel-section&quot;&gt;
                &lt;div class=&quot;panel-title&quot; id=&quot;statsTitle&quot;&gt;📊 Statistiques&lt;/div&gt;
                &lt;div class=&quot;game-stats&quot;&gt;
                    &lt;div class=&quot;stat-item&quot;&gt;
                        &lt;span class=&quot;stat-label&quot; id=&quot;scoreLabel&quot;&gt;Score&lt;/span&gt;
                        &lt;span class=&quot;stat-value&quot; id=&quot;scoreValue&quot;&gt;0&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;stat-item&quot;&gt;
                        &lt;span class=&quot;stat-label&quot; id=&quot;levelLabel&quot;&gt;Niveau&lt;/span&gt;
                        &lt;span class=&quot;stat-value&quot; id=&quot;levelValue&quot;&gt;1&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;stat-item&quot;&gt;
                        &lt;span class=&quot;stat-label&quot; id=&quot;roundLabel&quot;&gt;Manche&lt;/span&gt;
                        &lt;span class=&quot;stat-value&quot; id=&quot;roundValue&quot;&gt;0&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;stat-item&quot;&gt;
                        &lt;span class=&quot;stat-label&quot; id=&quot;bestLabel&quot;&gt;Record&lt;/span&gt;
                        &lt;span class=&quot;stat-value&quot; id=&quot;bestValue&quot;&gt;0&lt;/span&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;div class=&quot;panel-section&quot;&gt;
                &lt;div class=&quot;panel-title&quot; id=&quot;progressTitle&quot;&gt;📈 Progression&lt;/div&gt;
                &lt;div class=&quot;progress-bar&quot;&gt;
                    &lt;div class=&quot;progress-fill&quot; id=&quot;progressFill&quot; style=&quot;width: 0%;&quot;&gt;&lt;/div&gt;
                &lt;/div&gt;
                &lt;div style=&quot;color: #9ca3af; font-size: 12px; text-align: center;&quot; id=&quot;progressText&quot;&gt;
                    Prêt à commencer
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;

        &lt;!-- Panneau central --&gt;
        &lt;div class=&quot;game-panel&quot;&gt;
            &lt;!-- En-tête --&gt;
            &lt;div class=&quot;neural-header&quot;&gt;
                &lt;div class=&quot;neural-title&quot;&gt;
                    &lt;span class=&quot;neural-icon&quot;&gt;🧠&lt;/span&gt;
                    &lt;h1 id=&quot;gameTitle&quot;&gt;Simon Says&lt;/h1&gt;
                    &lt;span class=&quot;neural-badge&quot; id=&quot;neuralBadge&quot;&gt;🚀 IA FUTURISTE&lt;/span&gt;
                &lt;/div&gt;
                &lt;div style=&quot;display: flex; align-items: center; gap: 20px;&quot;&gt;
                    &lt;select id=&quot;languageSelector&quot; onchange=&quot;changeLanguage()&quot; class=&quot;language-selector&quot;&gt;
                        &lt;option value=&quot;fr&quot;&gt;🇫🇷 Français&lt;/option&gt;
                        &lt;option value=&quot;en&quot;&gt;🇺🇸 English&lt;/option&gt;
                        &lt;option value=&quot;ar&quot;&gt;🇸🇦 العربية&lt;/option&gt;
                        &lt;option value=&quot;es&quot;&gt;🇪🇸 Español&lt;/option&gt;
                        &lt;option value=&quot;de&quot;&gt;🇩🇪 Deutsch&lt;/option&gt;
                        &lt;option value=&quot;zh&quot;&gt;🇨🇳 中文&lt;/option&gt;
                    &lt;/select&gt;
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;!-- Configuration du jeu --&gt;
            &lt;div class=&quot;config-section&quot;&gt;
                &lt;div class=&quot;config-group&quot;&gt;
                    &lt;div class=&quot;config-group-title&quot; id=&quot;difficultyTitle&quot;&gt;⚡ Difficulté&lt;/div&gt;
                    &lt;div class=&quot;config-buttons&quot;&gt;
                        &lt;button class=&quot;config-btn&quot; onclick=&quot;setDifficulty(&#x27;easy&#x27;)&quot; id=&quot;diffEasy&quot;&gt;
                            &lt;span id=&quot;easyText&quot;&gt;Facile&lt;/span&gt;
                        &lt;/button&gt;
                        &lt;button class=&quot;config-btn active&quot; onclick=&quot;setDifficulty(&#x27;normal&#x27;)&quot; id=&quot;diffNormal&quot;&gt;
                            &lt;span id=&quot;normalText&quot;&gt;Normal&lt;/span&gt;
                        &lt;/button&gt;
                        &lt;button class=&quot;config-btn&quot; onclick=&quot;setDifficulty(&#x27;hard&#x27;)&quot; id=&quot;diffHard&quot;&gt;
                            &lt;span id=&quot;hardText&quot;&gt;Difficile&lt;/span&gt;
                        &lt;/button&gt;
                        &lt;button class=&quot;config-btn&quot; onclick=&quot;setDifficulty(&#x27;expert&#x27;)&quot; id=&quot;diffExpert&quot;&gt;
                            &lt;span id=&quot;expertText&quot;&gt;Expert&lt;/span&gt;
                        &lt;/button&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
                &lt;div class=&quot;config-group&quot;&gt;
                    &lt;div class=&quot;config-group-title&quot; id=&quot;speedTitle&quot;&gt;🏃 Vitesse&lt;/div&gt;
                    &lt;div class=&quot;config-buttons&quot;&gt;
                        &lt;button class=&quot;config-btn&quot; onclick=&quot;setSpeed(&#x27;slow&#x27;)&quot; id=&quot;speedSlow&quot;&gt;
                            &lt;span id=&quot;slowText&quot;&gt;Lent&lt;/span&gt;
                        &lt;/button&gt;
                        &lt;button class=&quot;config-btn active&quot; onclick=&quot;setSpeed(&#x27;normal&#x27;)&quot; id=&quot;speedNormal&quot;&gt;
                            &lt;span id=&quot;speedNormalText&quot;&gt;Normal&lt;/span&gt;
                        &lt;/button&gt;
                        &lt;button class=&quot;config-btn&quot; onclick=&quot;setSpeed(&#x27;fast&#x27;)&quot; id=&quot;speedFast&quot;&gt;
                            &lt;span id=&quot;fastText&quot;&gt;Rapide&lt;/span&gt;
                        &lt;/button&gt;
                        &lt;button class=&quot;config-btn&quot; onclick=&quot;setSpeed(&#x27;turbo&#x27;)&quot; id=&quot;speedTurbo&quot;&gt;
                            &lt;span id=&quot;turboText&quot;&gt;Turbo&lt;/span&gt;
                        &lt;/button&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
                &lt;div class=&quot;config-group&quot; style=&quot;grid-column: 1 / -1;&quot;&gt;
                    &lt;div class=&quot;config-group-title&quot; id=&quot;themeTitle&quot;&gt;🎨 Thème Visuel&lt;/div&gt;
                    &lt;div style=&quot;display: grid; grid-template-columns: repeat(5, 1fr); gap: 6px;&quot;&gt;
                        &lt;button class=&quot;config-btn active&quot; onclick=&quot;setTheme(&#x27;classic&#x27;)&quot; id=&quot;themeClassic&quot;&gt;
                            &lt;span id=&quot;themeClassicText&quot;&gt;Classique&lt;/span&gt;
                        &lt;/button&gt;
                        &lt;button class=&quot;config-btn&quot; onclick=&quot;setTheme(&#x27;animals&#x27;)&quot; id=&quot;themeAnimals&quot;&gt;
                            &lt;span id=&quot;themeAnimalsText&quot;&gt;Animaux&lt;/span&gt;
                        &lt;/button&gt;
                        &lt;button class=&quot;config-btn&quot; onclick=&quot;setTheme(&#x27;space&#x27;)&quot; id=&quot;themeSpace&quot;&gt;
                            &lt;span id=&quot;themeSpaceText&quot;&gt;Espace&lt;/span&gt;
                        &lt;/button&gt;
                        &lt;button class=&quot;config-btn&quot; onclick=&quot;setTheme(&#x27;food&#x27;)&quot; id=&quot;themeFood&quot;&gt;
                            &lt;span id=&quot;themeFoodText&quot;&gt;Nourriture&lt;/span&gt;
                        &lt;/button&gt;
                        &lt;button class=&quot;config-btn&quot; onclick=&quot;setTheme(&#x27;nature&#x27;)&quot; id=&quot;themeNature&quot;&gt;
                            &lt;span id=&quot;themeNatureText&quot;&gt;Nature&lt;/span&gt;
                        &lt;/button&gt;
                        &lt;button class=&quot;config-btn&quot; onclick=&quot;setTheme(&#x27;gems&#x27;)&quot; id=&quot;themeGems&quot;&gt;
                            &lt;span id=&quot;themeGemsText&quot;&gt;Gemmes&lt;/span&gt;
                        &lt;/button&gt;
                        &lt;button class=&quot;config-btn&quot; onclick=&quot;setTheme(&#x27;transport&#x27;)&quot; id=&quot;themeTransport&quot;&gt;
                            &lt;span id=&quot;themeTransportText&quot;&gt;Transport&lt;/span&gt;
                        &lt;/button&gt;
                        &lt;button class=&quot;config-btn&quot; onclick=&quot;setTheme(&#x27;music&#x27;)&quot; id=&quot;themeMusic&quot;&gt;
                            &lt;span id=&quot;themeMusicText&quot;&gt;Musique&lt;/span&gt;
                        &lt;/button&gt;
                        &lt;button class=&quot;config-btn&quot; onclick=&quot;setTheme(&#x27;sports&#x27;)&quot; id=&quot;themeSports&quot;&gt;
                            &lt;span id=&quot;themeSportsText&quot;&gt;Sports&lt;/span&gt;
                        &lt;/button&gt;
                        &lt;button class=&quot;config-btn&quot; onclick=&quot;setTheme(&#x27;weather&#x27;)&quot; id=&quot;themeWeather&quot;&gt;
                            &lt;span id=&quot;themeWeatherText&quot;&gt;Météo&lt;/span&gt;
                        &lt;/button&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;!-- Message de jeu --&gt;
            &lt;div class=&quot;game-message&quot; id=&quot;gameMessage&quot;&gt;
                &lt;span id=&quot;welcomeMessage&quot;&gt;Bienvenue dans Neural Memory ! Mémorisez la séquence et répétez-la.&lt;/span&gt;
            &lt;/div&gt;

            &lt;!-- Plateau de jeu --&gt;
            &lt;div class=&quot;neural-board&quot; id=&quot;neuralBoard&quot;&gt;
                &lt;div class=&quot;neural-cell neural-cell-0&quot; data-id=&quot;0&quot; onclick=&quot;playerClick(0)&quot;&gt;
                    &lt;span id=&quot;cell0&quot;&gt;🔴&lt;/span&gt;
                &lt;/div&gt;
                &lt;div class=&quot;neural-cell neural-cell-1&quot; data-id=&quot;1&quot; onclick=&quot;playerClick(1)&quot;&gt;
                    &lt;span id=&quot;cell1&quot;&gt;🟢&lt;/span&gt;
                &lt;/div&gt;
                &lt;div class=&quot;neural-cell neural-cell-2&quot; data-id=&quot;2&quot; onclick=&quot;playerClick(2)&quot;&gt;
                    &lt;span id=&quot;cell2&quot;&gt;🔵&lt;/span&gt;
                &lt;/div&gt;
                &lt;div class=&quot;neural-cell neural-cell-3&quot; data-id=&quot;3&quot; onclick=&quot;playerClick(3)&quot;&gt;
                    &lt;span id=&quot;cell3&quot;&gt;🟡&lt;/span&gt;
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;!-- Contrôles du jeu --&gt;
            &lt;div class=&quot;game-controls&quot;&gt;
                &lt;button class=&quot;neural-btn start-btn&quot; onclick=&quot;startGame()&quot; id=&quot;mainStartBtn&quot;&gt;
                    🚀 &lt;span id=&quot;mainStartText&quot;&gt;Démarrer le Jeu&lt;/span&gt;
                &lt;/button&gt;
                &lt;button class=&quot;neural-btn reset-btn&quot; onclick=&quot;resetGame()&quot; id=&quot;mainResetBtn&quot;&gt;
                    🔄 &lt;span id=&quot;mainResetText&quot;&gt;Nouveau Jeu&lt;/span&gt;
                &lt;/button&gt;
            &lt;/div&gt;
        &lt;/div&gt;

        &lt;!-- Panneau droit --&gt;
        &lt;div class=&quot;right-panel&quot;&gt;
            &lt;div class=&quot;panel-section&quot;&gt;
                &lt;div class=&quot;panel-title&quot; id=&quot;instructionsTitle&quot;&gt;📖 Instructions&lt;/div&gt;
                &lt;div style=&quot;color: #9ca3af; font-size: 13px; line-height: 1.7;&quot;&gt;
                    &lt;p id=&quot;instructionsText&quot;&gt;
                        • Observez la séquence lumineuse&lt;br&gt;
                        • Mémorisez l&#x27;ordre des couleurs&lt;br&gt;
                        • Répétez la séquence exactement&lt;br&gt;
                        • Chaque niveau ajoute une étape&lt;br&gt;
                        • L&#x27;IA analyse vos performances
                    &lt;/p&gt;
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;div class=&quot;panel-section&quot;&gt;
                &lt;div class=&quot;panel-title&quot; id=&quot;colorsTitle&quot;&gt;🎨 Code Couleurs&lt;/div&gt;
                &lt;div style=&quot;color: #9ca3af; font-size: 13px; line-height: 1.8;&quot;&gt;
                    &lt;div style=&quot;margin-bottom: 10px;&quot;&gt;
                        &lt;span style=&quot;color: #ff0066;&quot;&gt;🔴&lt;/span&gt; &lt;span id=&quot;redText&quot;&gt;Rouge Neural&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div style=&quot;margin-bottom: 10px;&quot;&gt;
                        &lt;span style=&quot;color: #00ff88;&quot;&gt;🟢&lt;/span&gt; &lt;span id=&quot;greenText&quot;&gt;Vert Quantique&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div style=&quot;margin-bottom: 10px;&quot;&gt;
                        &lt;span style=&quot;color: #0099ff;&quot;&gt;🔵&lt;/span&gt; &lt;span id=&quot;blueText&quot;&gt;Bleu Cyber&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div style=&quot;margin-bottom: 10px;&quot;&gt;
                        &lt;span style=&quot;color: #ffaa00;&quot;&gt;🟡&lt;/span&gt; &lt;span id=&quot;yellowText&quot;&gt;Jaune Plasma&lt;/span&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;div class=&quot;panel-section&quot;&gt;
                &lt;div class=&quot;panel-title&quot; id=&quot;aiStatusTitle&quot;&gt;🤖 Statut IA&lt;/div&gt;
                &lt;div id=&quot;aiStatus&quot; style=&quot;color: #00ff88; font-size: 13px; text-align: center; padding: 12px;&quot;&gt;
                    &lt;span id=&quot;aiStatusText&quot;&gt;IA Neural Active&lt;/span&gt;
                &lt;/div&gt;
                &lt;div style=&quot;color: #9ca3af; font-size: 11px; text-align: center; margin-top: 10px;&quot; id=&quot;aiAnalysis&quot;&gt;
                    &lt;span id=&quot;aiAnalysisText&quot;&gt;Analyse des patterns en cours...&lt;/span&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;script&gt;
        // Traductions multilingues
        const translations = {
            fr: {
                gameTitle: &quot;Simon Says&quot;,
                neuralBadge: &quot;🚀 IA FUTURISTE&quot;,
                controlsTitle: &quot;🎮 Contrôles Neuraux&quot;,
                statsTitle: &quot;📊 Statistiques&quot;,
                progressTitle: &quot;📈 Progression&quot;,
                difficultyTitle: &quot;⚡ Difficulté&quot;,
                speedTitle: &quot;🏃 Vitesse&quot;,
                instructionsTitle: &quot;📖 Instructions&quot;,
                colorsTitle: &quot;🎨 Code Couleurs&quot;,
                aiStatusTitle: &quot;🤖 Statut IA&quot;,
                startText: &quot;Démarrer&quot;,
                resetText: &quot;Réinitialiser&quot;,
                mainStartText: &quot;Démarrer le Jeu&quot;,
                mainResetText: &quot;Nouveau Jeu&quot;,
                scoreLabel: &quot;Score&quot;,
                levelLabel: &quot;Niveau&quot;,
                roundLabel: &quot;Manche&quot;,
                bestLabel: &quot;Record&quot;,
                easyText: &quot;Facile&quot;,
                normalText: &quot;Normal&quot;,
                hardText: &quot;Difficile&quot;,
                expertText: &quot;Expert&quot;,
                slowText: &quot;Lent&quot;,
                speedNormalText: &quot;Normal&quot;,
                fastText: &quot;Rapide&quot;,
                turboText: &quot;Turbo&quot;,
                welcomeMessage: &quot;Bienvenue dans Simon Says ! Mémorisez la séquence et répétez-la.&quot;,
                instructionsText: &quot;• Observez la séquence lumineuse&lt;br&gt;• Mémorisez l&#x27;ordre des couleurs&lt;br&gt;• Répétez la séquence exactement&lt;br&gt;• Chaque niveau ajoute une étape&lt;br&gt;• L&#x27;IA analyse vos performances&quot;,
                redText: &quot;Rouge Neural&quot;,
                greenText: &quot;Vert Quantique&quot;,
                blueText: &quot;Bleu Cyber&quot;,
                yellowText: &quot;Jaune Plasma&quot;,
                themeTitle: &quot;🎨 Thème Visuel&quot;,
                themeClassic: &quot;Classique&quot;,
                themeAnimals: &quot;Animaux&quot;,
                themeSpace: &quot;Espace&quot;,
                themeFood: &quot;Nourriture&quot;,
                themeNature: &quot;Nature&quot;,
                themeGems: &quot;Gemmes&quot;,
                themeTransport: &quot;Transport&quot;,
                themeMusic: &quot;Musique&quot;,
                themeSports: &quot;Sports&quot;,
                themeWeather: &quot;Météo&quot;,
                aiStatusText: &quot;IA Neural Active&quot;,
                aiAnalysisText: &quot;Analyse des patterns en cours...&quot;,
                progressReady: &quot;Prêt à commencer&quot;,
                progressWatching: &quot;Observez la séquence...&quot;,
                progressYourTurn: &quot;À votre tour !&quot;,
                progressCorrect: &quot;Correct ! Niveau suivant...&quot;,
                progressWrong: &quot;Erreur ! Recommencez...&quot;,
                gameStarted: &quot;Jeu démarré ! Observez attentivement...&quot;,
                watchSequence: &quot;Observez la séquence...&quot;,
                yourTurn: &quot;À votre tour ! Répétez la séquence.&quot;,
                correct: &quot;Excellent ! Niveau suivant...&quot;,
                wrong: &quot;Erreur ! La séquence était différente.&quot;,
                gameOver: &quot;Jeu terminé ! Score final :&quot;,
                newRecord: &quot;Nouveau record !&quot;,
                victoryTitle: &quot;🎉 EXCELLENT ! 🎉&quot;,
                victoryMessage: &quot;Vous avez une mémoire exceptionnelle !&quot;,
                defeatTitle: &quot;💭 FIN DE PARTIE 💭&quot;,
                defeatMessage: &quot;Votre cerveau a besoin d&#x27;entraînement !&quot;,
                tryAgainText: &quot;Réessayer&quot;,
                continueText: &quot;Continuer&quot;,
                aiPerfect: &quot;IA : Performance parfaite détectée !&quot;,
                aiGood: &quot;IA : Bonne progression cognitive&quot;,
                aiAverage: &quot;IA : Capacité de mémorisation moyenne&quot;,
                aiNeedsWork: &quot;IA : Entraînement recommandé&quot;
            },
            en: {
                gameTitle: &quot;Simon Says&quot;,
                neuralBadge: &quot;🚀 FUTURISTIC AI&quot;,
                controlsTitle: &quot;🎮 Neural Controls&quot;,
                statsTitle: &quot;📊 Statistics&quot;,
                progressTitle: &quot;📈 Progress&quot;,
                difficultyTitle: &quot;⚡ Difficulty&quot;,
                speedTitle: &quot;🏃 Speed&quot;,
                instructionsTitle: &quot;📖 Instructions&quot;,
                colorsTitle: &quot;🎨 Color Code&quot;,
                aiStatusTitle: &quot;🤖 AI Status&quot;,
                startText: &quot;Start&quot;,
                resetText: &quot;Reset&quot;,
                mainStartText: &quot;Start Game&quot;,
                mainResetText: &quot;New Game&quot;,
                scoreLabel: &quot;Score&quot;,
                levelLabel: &quot;Level&quot;,
                roundLabel: &quot;Round&quot;,
                bestLabel: &quot;Best&quot;,
                easyText: &quot;Easy&quot;,
                normalText: &quot;Normal&quot;,
                hardText: &quot;Hard&quot;,
                expertText: &quot;Expert&quot;,
                slowText: &quot;Slow&quot;,
                speedNormalText: &quot;Normal&quot;,
                fastText: &quot;Fast&quot;,
                turboText: &quot;Turbo&quot;,
                welcomeMessage: &quot;Welcome to Simon Says! Memorize the sequence and repeat it.&quot;,
                instructionsText: &quot;• Watch the light sequence&lt;br&gt;• Memorize the color order&lt;br&gt;• Repeat the sequence exactly&lt;br&gt;• Each level adds one step&lt;br&gt;• AI analyzes your performance&quot;,
                redText: &quot;Neural Red&quot;,
                greenText: &quot;Quantum Green&quot;,
                blueText: &quot;Cyber Blue&quot;,
                yellowText: &quot;Plasma Yellow&quot;,
                themeTitle: &quot;🎨 Visual Theme&quot;,
                themeClassic: &quot;Classic&quot;,
                themeAnimals: &quot;Animals&quot;,
                themeSpace: &quot;Space&quot;,
                themeFood: &quot;Food&quot;,
                themeNature: &quot;Nature&quot;,
                themeGems: &quot;Gems&quot;,
                themeTransport: &quot;Transport&quot;,
                themeMusic: &quot;Music&quot;,
                themeSports: &quot;Sports&quot;,
                themeWeather: &quot;Weather&quot;,
                aiStatusText: &quot;Neural AI Active&quot;,
                aiAnalysisText: &quot;Pattern analysis in progress...&quot;,
                progressReady: &quot;Ready to start&quot;,
                progressWatching: &quot;Watch the sequence...&quot;,
                progressYourTurn: &quot;Your turn!&quot;,
                progressCorrect: &quot;Correct! Next level...&quot;,
                progressWrong: &quot;Wrong! Try again...&quot;,
                gameStarted: &quot;Game started! Watch carefully...&quot;,
                watchSequence: &quot;Watch the sequence...&quot;,
                yourTurn: &quot;Your turn! Repeat the sequence.&quot;,
                correct: &quot;Excellent! Next level...&quot;,
                wrong: &quot;Wrong! The sequence was different.&quot;,
                gameOver: &quot;Game over! Final score:&quot;,
                newRecord: &quot;New record!&quot;,
                victoryTitle: &quot;🎉 EXCELLENT! 🎉&quot;,
                victoryMessage: &quot;You have exceptional memory!&quot;,
                defeatTitle: &quot;💭 GAME OVER 💭&quot;,
                defeatMessage: &quot;Your brain needs training!&quot;,
                tryAgainText: &quot;Try Again&quot;,
                continueText: &quot;Continue&quot;,
                aiPerfect: &quot;AI: Perfect performance detected!&quot;,
                aiGood: &quot;AI: Good cognitive progression&quot;,
                aiAverage: &quot;AI: Average memorization capacity&quot;,
                aiNeedsWork: &quot;AI: Training recommended&quot;
            },
            ar: {
                gameTitle: &quot;سايمون يقول&quot;,
                neuralBadge: &quot;🚀 ذكاء مستقبلي&quot;,
                controlsTitle: &quot;🎮 تحكم عصبي&quot;,
                statsTitle: &quot;📊 إحصائيات&quot;,
                progressTitle: &quot;📈 التقدم&quot;,
                difficultyTitle: &quot;⚡ الصعوبة&quot;,
                speedTitle: &quot;🏃 السرعة&quot;,
                instructionsTitle: &quot;📖 التعليمات&quot;,
                colorsTitle: &quot;🎨 رمز الألوان&quot;,
                aiStatusTitle: &quot;🤖 حالة الذكاء&quot;,
                startText: &quot;ابدأ&quot;,
                resetText: &quot;إعادة تعيين&quot;,
                mainStartText: &quot;ابدأ اللعبة&quot;,
                mainResetText: &quot;لعبة جديدة&quot;,
                scoreLabel: &quot;النقاط&quot;,
                levelLabel: &quot;المستوى&quot;,
                roundLabel: &quot;الجولة&quot;,
                bestLabel: &quot;الأفضل&quot;,
                easyText: &quot;سهل&quot;,
                normalText: &quot;عادي&quot;,
                hardText: &quot;صعب&quot;,
                expertText: &quot;خبير&quot;,
                slowText: &quot;بطيء&quot;,
                speedNormalText: &quot;عادي&quot;,
                fastText: &quot;سريع&quot;,
                turboText: &quot;توربو&quot;,
                welcomeMessage: &quot;مرحباً بك في سايمون يقول! احفظ التسلسل وكرره.&quot;,
                instructionsText: &quot;• راقب تسلسل الأضواء&lt;br&gt;• احفظ ترتيب الألوان&lt;br&gt;• كرر التسلسل بدقة&lt;br&gt;• كل مستوى يضيف خطوة&lt;br&gt;• الذكاء الاصطناعي يحلل أداءك&quot;,
                redText: &quot;أحمر عصبي&quot;,
                greenText: &quot;أخضر كمي&quot;,
                blueText: &quot;أزرق سيبراني&quot;,
                yellowText: &quot;أصفر بلازما&quot;,
                themeTitle: &quot;🎨 المظهر البصري&quot;,
                themeClassic: &quot;كلاسيكي&quot;,
                themeAnimals: &quot;حيوانات&quot;,
                themeSpace: &quot;فضاء&quot;,
                themeFood: &quot;طعام&quot;,
                themeNature: &quot;طبيعة&quot;,
                themeGems: &quot;أحجار كريمة&quot;,
                themeTransport: &quot;نقل&quot;,
                themeMusic: &quot;موسيقى&quot;,
                themeSports: &quot;رياضة&quot;,
                themeWeather: &quot;طقس&quot;,
                aiStatusText: &quot;الذكاء العصبي نشط&quot;,
                aiAnalysisText: &quot;تحليل الأنماط جاري...&quot;,
                progressReady: &quot;جاهز للبدء&quot;,
                progressWatching: &quot;راقب التسلسل...&quot;,
                progressYourTurn: &quot;دورك!&quot;,
                progressCorrect: &quot;صحيح! المستوى التالي...&quot;,
                progressWrong: &quot;خطأ! حاول مرة أخرى...&quot;,
                gameStarted: &quot;بدأت اللعبة! راقب بعناية...&quot;,
                watchSequence: &quot;راقب التسلسل...&quot;,
                yourTurn: &quot;دورك! كرر التسلسل.&quot;,
                correct: &quot;ممتاز! المستوى التالي...&quot;,
                wrong: &quot;خطأ! التسلسل كان مختلفاً.&quot;,
                gameOver: &quot;انتهت اللعبة! النقاط النهائية:&quot;,
                newRecord: &quot;رقم قياسي جديد!&quot;,
                victoryTitle: &quot;🎉 ممتاز! 🎉&quot;,
                victoryMessage: &quot;لديك ذاكرة استثنائية!&quot;,
                defeatTitle: &quot;💭 انتهت اللعبة 💭&quot;,
                defeatMessage: &quot;عقلك يحتاج إلى تدريب!&quot;,
                tryAgainText: &quot;حاول مرة أخرى&quot;,
                continueText: &quot;متابعة&quot;,
                aiPerfect: &quot;الذكاء: تم اكتشاف أداء مثالي!&quot;,
                aiGood: &quot;الذكاء: تقدم معرفي جيد&quot;,
                aiAverage: &quot;الذكاء: قدرة حفظ متوسطة&quot;,
                aiNeedsWork: &quot;الذكاء: ينصح بالتدريب&quot;
            },
            es: {
                gameTitle: &quot;Simon Says&quot;,
                neuralBadge: &quot;🚀 IA FUTURISTA&quot;,
                controlsTitle: &quot;🎮 Controles Neurales&quot;,
                statsTitle: &quot;📊 Estadísticas&quot;,
                progressTitle: &quot;📈 Progreso&quot;,
                difficultyTitle: &quot;⚡ Dificultad&quot;,
                speedTitle: &quot;🏃 Velocidad&quot;,
                instructionsTitle: &quot;📖 Instrucciones&quot;,
                colorsTitle: &quot;🎨 Código de Colores&quot;,
                aiStatusTitle: &quot;🤖 Estado IA&quot;,
                startText: &quot;Iniciar&quot;,
                resetText: &quot;Reiniciar&quot;,
                mainStartText: &quot;Iniciar Juego&quot;,
                mainResetText: &quot;Nuevo Juego&quot;,
                scoreLabel: &quot;Puntuación&quot;,
                levelLabel: &quot;Nivel&quot;,
                roundLabel: &quot;Ronda&quot;,
                bestLabel: &quot;Mejor&quot;,
                easyText: &quot;Fácil&quot;,
                normalText: &quot;Normal&quot;,
                hardText: &quot;Difícil&quot;,
                expertText: &quot;Experto&quot;,
                slowText: &quot;Lento&quot;,
                speedNormalText: &quot;Normal&quot;,
                fastText: &quot;Rápido&quot;,
                turboText: &quot;Turbo&quot;,
                welcomeMessage: &quot;¡Bienvenido a Simon Says! Memoriza la secuencia y repítela.&quot;,
                instructionsText: &quot;• Observa la secuencia de luces&lt;br&gt;• Memoriza el orden de colores&lt;br&gt;• Repite la secuencia exactamente&lt;br&gt;• Cada nivel añade un paso&lt;br&gt;• La IA analiza tu rendimiento&quot;,
                redText: &quot;Rojo Neural&quot;,
                greenText: &quot;Verde Cuántico&quot;,
                blueText: &quot;Azul Cyber&quot;,
                yellowText: &quot;Amarillo Plasma&quot;,
                themeTitle: &quot;🎨 Tema Visual&quot;,
                themeClassic: &quot;Clásico&quot;,
                themeAnimals: &quot;Animales&quot;,
                themeSpace: &quot;Espacio&quot;,
                themeFood: &quot;Comida&quot;,
                themeNature: &quot;Naturaleza&quot;,
                themeGems: &quot;Gemas&quot;,
                themeTransport: &quot;Transporte&quot;,
                themeMusic: &quot;Música&quot;,
                themeSports: &quot;Deportes&quot;,
                themeWeather: &quot;Clima&quot;,
                aiStatusText: &quot;IA Neural Activa&quot;,
                aiAnalysisText: &quot;Análisis de patrones en progreso...&quot;,
                progressReady: &quot;Listo para empezar&quot;,
                progressWatching: &quot;Observa la secuencia...&quot;,
                progressYourTurn: &quot;¡Tu turno!&quot;,
                progressCorrect: &quot;¡Correcto! Siguiente nivel...&quot;,
                progressWrong: &quot;¡Error! Inténtalo de nuevo...&quot;,
                gameStarted: &quot;¡Juego iniciado! Observa cuidadosamente...&quot;,
                watchSequence: &quot;Observa la secuencia...&quot;,
                yourTurn: &quot;¡Tu turno! Repite la secuencia.&quot;,
                correct: &quot;¡Excelente! Siguiente nivel...&quot;,
                wrong: &quot;¡Error! La secuencia era diferente.&quot;,
                gameOver: &quot;¡Juego terminado! Puntuación final:&quot;,
                newRecord: &quot;¡Nuevo récord!&quot;,
                victoryTitle: &quot;🎉 ¡EXCELENTE! 🎉&quot;,
                victoryMessage: &quot;¡Tienes una memoria excepcional!&quot;,
                defeatTitle: &quot;💭 FIN DEL JUEGO 💭&quot;,
                defeatMessage: &quot;¡Tu cerebro necesita entrenamiento!&quot;,
                tryAgainText: &quot;Intentar de nuevo&quot;,
                continueText: &quot;Continuar&quot;,
                aiPerfect: &quot;IA: ¡Rendimiento perfecto detectado!&quot;,
                aiGood: &quot;IA: Buena progresión cognitiva&quot;,
                aiAverage: &quot;IA: Capacidad de memorización promedio&quot;,
                aiNeedsWork: &quot;IA: Entrenamiento recomendado&quot;
            },
            de: {
                gameTitle: &quot;Simon Says&quot;,
                neuralBadge: &quot;🚀 FUTURISTISCHE KI&quot;,
                controlsTitle: &quot;🎮 Neurale Steuerung&quot;,
                statsTitle: &quot;📊 Statistiken&quot;,
                progressTitle: &quot;📈 Fortschritt&quot;,
                difficultyTitle: &quot;⚡ Schwierigkeit&quot;,
                speedTitle: &quot;🏃 Geschwindigkeit&quot;,
                instructionsTitle: &quot;📖 Anweisungen&quot;,
                colorsTitle: &quot;🎨 Farbcode&quot;,
                aiStatusTitle: &quot;🤖 KI-Status&quot;,
                startText: &quot;Start&quot;,
                resetText: &quot;Zurücksetzen&quot;,
                mainStartText: &quot;Spiel starten&quot;,
                mainResetText: &quot;Neues Spiel&quot;,
                scoreLabel: &quot;Punkte&quot;,
                levelLabel: &quot;Level&quot;,
                roundLabel: &quot;Runde&quot;,
                bestLabel: &quot;Beste&quot;,
                easyText: &quot;Einfach&quot;,
                normalText: &quot;Normal&quot;,
                hardText: &quot;Schwer&quot;,
                expertText: &quot;Experte&quot;,
                slowText: &quot;Langsam&quot;,
                speedNormalText: &quot;Normal&quot;,
                fastText: &quot;Schnell&quot;,
                turboText: &quot;Turbo&quot;,
                welcomeMessage: &quot;Willkommen bei Simon Says! Merke dir die Sequenz und wiederhole sie.&quot;,
                instructionsText: &quot;• Beobachte die Lichtsequenz&lt;br&gt;• Merke dir die Farbreihenfolge&lt;br&gt;• Wiederhole die Sequenz genau&lt;br&gt;• Jedes Level fügt einen Schritt hinzu&lt;br&gt;• KI analysiert deine Leistung&quot;,
                redText: &quot;Neurales Rot&quot;,
                greenText: &quot;Quanten Grün&quot;,
                blueText: &quot;Cyber Blau&quot;,
                yellowText: &quot;Plasma Gelb&quot;,
                themeTitle: &quot;🎨 Visuelles Thema&quot;,
                themeClassic: &quot;Klassisch&quot;,
                themeAnimals: &quot;Tiere&quot;,
                themeSpace: &quot;Weltraum&quot;,
                themeFood: &quot;Essen&quot;,
                themeNature: &quot;Natur&quot;,
                themeGems: &quot;Edelsteine&quot;,
                themeTransport: &quot;Transport&quot;,
                themeMusic: &quot;Musik&quot;,
                themeSports: &quot;Sport&quot;,
                themeWeather: &quot;Wetter&quot;,
                aiStatusText: &quot;Neurale KI Aktiv&quot;,
                aiAnalysisText: &quot;Musteranalyse läuft...&quot;,
                progressReady: &quot;Bereit zu starten&quot;,
                progressWatching: &quot;Beobachte die Sequenz...&quot;,
                progressYourTurn: &quot;Du bist dran!&quot;,
                progressCorrect: &quot;Richtig! Nächstes Level...&quot;,
                progressWrong: &quot;Falsch! Versuche es nochmal...&quot;,
                gameStarted: &quot;Spiel gestartet! Beobachte sorgfältig...&quot;,
                watchSequence: &quot;Beobachte die Sequenz...&quot;,
                yourTurn: &quot;Du bist dran! Wiederhole die Sequenz.&quot;,
                correct: &quot;Ausgezeichnet! Nächstes Level...&quot;,
                wrong: &quot;Falsch! Die Sequenz war anders.&quot;,
                gameOver: &quot;Spiel vorbei! Endpunktzahl:&quot;,
                newRecord: &quot;Neuer Rekord!&quot;,
                victoryTitle: &quot;🎉 AUSGEZEICHNET! 🎉&quot;,
                victoryMessage: &quot;Du hast ein außergewöhnliches Gedächtnis!&quot;,
                defeatTitle: &quot;💭 SPIEL VORBEI 💭&quot;,
                defeatMessage: &quot;Dein Gehirn braucht Training!&quot;,
                tryAgainText: &quot;Nochmal versuchen&quot;,
                continueText: &quot;Weiter&quot;,
                aiPerfect: &quot;KI: Perfekte Leistung erkannt!&quot;,
                aiGood: &quot;KI: Gute kognitive Entwicklung&quot;,
                aiAverage: &quot;KI: Durchschnittliche Merkfähigkeit&quot;,
                aiNeedsWork: &quot;KI: Training empfohlen&quot;
            },
            zh: {
                gameTitle: &quot;西蒙说&quot;,
                neuralBadge: &quot;🚀 未来人工智能&quot;,
                controlsTitle: &quot;🎮 神经控制&quot;,
                statsTitle: &quot;📊 统计数据&quot;,
                progressTitle: &quot;📈 进度&quot;,
                difficultyTitle: &quot;⚡ 难度&quot;,
                speedTitle: &quot;🏃 速度&quot;,
                instructionsTitle: &quot;📖 说明&quot;,
                colorsTitle: &quot;🎨 颜色代码&quot;,
                aiStatusTitle: &quot;🤖 AI状态&quot;,
                startText: &quot;开始&quot;,
                resetText: &quot;重置&quot;,
                mainStartText: &quot;开始游戏&quot;,
                mainResetText: &quot;新游戏&quot;,
                scoreLabel: &quot;得分&quot;,
                levelLabel: &quot;等级&quot;,
                roundLabel: &quot;回合&quot;,
                bestLabel: &quot;最佳&quot;,
                easyText: &quot;简单&quot;,
                normalText: &quot;普通&quot;,
                hardText: &quot;困难&quot;,
                expertText: &quot;专家&quot;,
                slowText: &quot;慢速&quot;,
                speedNormalText: &quot;普通&quot;,
                fastText: &quot;快速&quot;,
                turboText: &quot;涡轮&quot;,
                welcomeMessage: &quot;欢迎来到西蒙说！记住序列并重复它。&quot;,
                instructionsText: &quot;• 观察光序列&lt;br&gt;• 记住颜色顺序&lt;br&gt;• 准确重复序列&lt;br&gt;• 每个级别增加一步&lt;br&gt;• AI分析你的表现&quot;,
                redText: &quot;神经红&quot;,
                greenText: &quot;量子绿&quot;,
                blueText: &quot;网络蓝&quot;,
                yellowText: &quot;等离子黄&quot;,
                themeTitle: &quot;🎨 视觉主题&quot;,
                themeClassic: &quot;经典&quot;,
                themeAnimals: &quot;动物&quot;,
                themeSpace: &quot;太空&quot;,
                themeFood: &quot;食物&quot;,
                themeNature: &quot;自然&quot;,
                themeGems: &quot;宝石&quot;,
                themeTransport: &quot;交通&quot;,
                themeMusic: &quot;音乐&quot;,
                themeSports: &quot;运动&quot;,
                themeWeather: &quot;天气&quot;,
                aiStatusText: &quot;神经AI激活&quot;,
                aiAnalysisText: &quot;模式分析进行中...&quot;,
                progressReady: &quot;准备开始&quot;,
                progressWatching: &quot;观察序列...&quot;,
                progressYourTurn: &quot;轮到你了！&quot;,
                progressCorrect: &quot;正确！下一级...&quot;,
                progressWrong: &quot;错误！再试一次...&quot;,
                gameStarted: &quot;游戏开始！仔细观察...&quot;,
                watchSequence: &quot;观察序列...&quot;,
                yourTurn: &quot;轮到你了！重复序列。&quot;,
                correct: &quot;优秀！下一级...&quot;,
                wrong: &quot;错误！序列不同。&quot;,
                gameOver: &quot;游戏结束！最终得分：&quot;,
                newRecord: &quot;新记录！&quot;,
                victoryTitle: &quot;🎉 优秀！🎉&quot;,
                victoryMessage: &quot;你有非凡的记忆力！&quot;,
                defeatTitle: &quot;💭 游戏结束 💭&quot;,
                defeatMessage: &quot;你的大脑需要训练！&quot;,
                tryAgainText: &quot;再试一次&quot;,
                continueText: &quot;继续&quot;,
                aiPerfect: &quot;AI：检测到完美表现！&quot;,
                aiGood: &quot;AI：良好的认知进展&quot;,
                aiAverage: &quot;AI：平均记忆能力&quot;,
                aiNeedsWork: &quot;AI：建议训练&quot;
            }
        };

        // Thèmes d&#x27;images pour les cellules
        const imageThemes = {
            classic: [&#x27;🔴&#x27;, &#x27;🟢&#x27;, &#x27;🔵&#x27;, &#x27;🟡&#x27;],
            animals: [&#x27;🦁&#x27;, &#x27;🐸&#x27;, &#x27;🐙&#x27;, &#x27;🐝&#x27;],
            space: [&#x27;🚀&#x27;, &#x27;🛸&#x27;, &#x27;⭐&#x27;, &#x27;🌙&#x27;],
            food: [&#x27;🍎&#x27;, &#x27;🥒&#x27;, &#x27;🫐&#x27;, &#x27;🌽&#x27;],
            nature: [&#x27;🌺&#x27;, &#x27;🌿&#x27;, &#x27;🌊&#x27;, &#x27;☀️&#x27;],
            gems: [&#x27;💎&#x27;, &#x27;💚&#x27;, &#x27;🔷&#x27;, &#x27;🟨&#x27;],
            transport: [&#x27;🚗&#x27;, &#x27;🚂&#x27;, &#x27;✈️&#x27;, &#x27;🚢&#x27;],
            music: [&#x27;🎵&#x27;, &#x27;🎸&#x27;, &#x27;🎹&#x27;, &#x27;🥁&#x27;],
            sports: [&#x27;⚽&#x27;, &#x27;🏀&#x27;, &#x27;🎾&#x27;, &#x27;🏐&#x27;],
            weather: [&#x27;🌈&#x27;, &#x27;🌱&#x27;, &#x27;❄️&#x27;, &#x27;🔥&#x27;]
        };

        const themeNames = Object.keys(imageThemes);

        // État du jeu
    var gameState = {
            currentLanguage: &#x27;fr&#x27;,
            difficulty: &#x27;normal&#x27;,
            speed: &#x27;normal&#x27;,
            sequence: [],
            playerSequence: [],
            level: 1,
            round: 0,
            score: 0,
            bestScore: 0,
            isPlaying: false,
            isPlayerTurn: false,
            isShowingSequence: false,
            currentStep: 0,
            gameStarted: false,
            currentTheme: &#x27;classic&#x27;
        };

        // Configuration des difficultés
        const difficultySettings = {
            easy: { baseScore: 10, bonusMultiplier: 1.2, maxLevel: 15 },
            normal: { baseScore: 20, bonusMultiplier: 1.5, maxLevel: 20 },
            hard: { baseScore: 30, bonusMultiplier: 2.0, maxLevel: 25 },
            expert: { baseScore: 50, bonusMultiplier: 3.0, maxLevel: 30 }
        };

        // Configuration des vitesses
        const speedSettings = {
            slow: { sequenceDelay: 1200, cellActiveTime: 800 },
            normal: { sequenceDelay: 900, cellActiveTime: 600 },
            fast: { sequenceDelay: 600, cellActiveTime: 400 },
            turbo: { sequenceDelay: 400, cellActiveTime: 250 }
        };

        // Sons (simulation avec vibration sur mobile)
        const playSound = (frequency) =&gt; {
            if (navigator.vibrate) {
                navigator.vibrate(100);
            }
        };

        // Créer les particules quantiques
        function createQuantumParticles() {
            const container = document.getElementById(&#x27;quantumParticles&#x27;);
            
            for(let i = 0; i &lt; 40; i++) {
                const particle = document.createElement(&#x27;div&#x27;);
                particle.className = &#x27;quantum-particle&#x27;;
                particle.style.left = Math.random() * 100 + &#x27;%&#x27;;
                particle.style.animationDelay = Math.random() * 15 + &#x27;s&#x27;;
                particle.style.animationDuration = (15 + Math.random() * 8) + &#x27;s&#x27;;
                container.appendChild(particle);
            }
        }

        // Fonction de changement de langue
        function changeLanguage() {
            const selector = document.getElementById(&#x27;languageSelector&#x27;);
            const selectedLang = selector.value;
            gameState.currentLanguage = selectedLang;
            
            const t = translations[selectedLang];
            
            // Mettre à jour tous les textes
            document.getElementById(&#x27;gameTitle&#x27;).textContent = t.gameTitle;
            document.getElementById(&#x27;neuralBadge&#x27;).textContent = t.neuralBadge;
            document.getElementById(&#x27;controlsTitle&#x27;).textContent = t.controlsTitle;
            document.getElementById(&#x27;statsTitle&#x27;).textContent = t.statsTitle;
            document.getElementById(&#x27;progressTitle&#x27;).textContent = t.progressTitle;
            document.getElementById(&#x27;difficultyTitle&#x27;).textContent = t.difficultyTitle;
            document.getElementById(&#x27;speedTitle&#x27;).textContent = t.speedTitle;
            document.getElementById(&#x27;instructionsTitle&#x27;).textContent = t.instructionsTitle;
            document.getElementById(&#x27;colorsTitle&#x27;).textContent = t.colorsTitle;
            document.getElementById(&#x27;aiStatusTitle&#x27;).textContent = t.aiStatusTitle;
            
            document.getElementById(&#x27;startText&#x27;).textContent = t.startText;
            document.getElementById(&#x27;resetText&#x27;).textContent = t.resetText;
            document.getElementById(&#x27;mainStartText&#x27;).textContent = t.mainStartText;
            document.getElementById(&#x27;mainResetText&#x27;).textContent = t.mainResetText;
            
            document.getElementById(&#x27;scoreLabel&#x27;).textContent = t.scoreLabel;
            document.getElementById(&#x27;levelLabel&#x27;).textContent = t.levelLabel;
            document.getElementById(&#x27;roundLabel&#x27;).textContent = t.roundLabel;
            document.getElementById(&#x27;bestLabel&#x27;).textContent = t.bestLabel;
            
            document.getElementById(&#x27;easyText&#x27;).textContent = t.easyText;
            document.getElementById(&#x27;normalText&#x27;).textContent = t.normalText;
            document.getElementById(&#x27;hardText&#x27;).textContent = t.hardText;
            document.getElementById(&#x27;expertText&#x27;).textContent = t.expertText;
            
            document.getElementById(&#x27;slowText&#x27;).textContent = t.slowText;
            document.getElementById(&#x27;speedNormalText&#x27;).textContent = t.speedNormalText;
            document.getElementById(&#x27;fastText&#x27;).textContent = t.fastText;
            document.getElementById(&#x27;turboText&#x27;).textContent = t.turboText;
            
            document.getElementById(&#x27;welcomeMessage&#x27;).textContent = t.welcomeMessage;
            document.getElementById(&#x27;instructionsText&#x27;).innerHTML = t.instructionsText;
            document.getElementById(&#x27;redText&#x27;).textContent = t.redText;
            document.getElementById(&#x27;greenText&#x27;).textContent = t.greenText;
            document.getElementById(&#x27;blueText&#x27;).textContent = t.blueText;
            document.getElementById(&#x27;yellowText&#x27;).textContent = t.yellowText;
            document.getElementById(&#x27;aiStatusText&#x27;).textContent = t.aiStatusText;
            document.getElementById(&#x27;aiAnalysisText&#x27;).textContent = t.aiAnalysisText;
            
            // Mettre à jour les textes des thèmes
            document.getElementById(&#x27;themeTitle&#x27;).textContent = t.themeTitle;
            document.getElementById(&#x27;themeClassicText&#x27;).textContent = t.themeClassic;
            document.getElementById(&#x27;themeAnimalsText&#x27;).textContent = t.themeAnimals;
            document.getElementById(&#x27;themeSpaceText&#x27;).textContent = t.themeSpace;
            document.getElementById(&#x27;themeFoodText&#x27;).textContent = t.themeFood;
            document.getElementById(&#x27;themeNatureText&#x27;).textContent = t.themeNature;
            document.getElementById(&#x27;themeGemsText&#x27;).textContent = t.themeGems;
            document.getElementById(&#x27;themeTransportText&#x27;).textContent = t.themeTransport;
            document.getElementById(&#x27;themeMusicText&#x27;).textContent = t.themeMusic;
            document.getElementById(&#x27;themeSportsText&#x27;).textContent = t.themeSports;
            document.getElementById(&#x27;themeWeatherText&#x27;).textContent = t.themeWeather;
            
            // Mettre à jour le texte de progression
            updateProgressText();
        }

        // Définir la difficulté
        function setDifficulty(difficulty) {
            gameState.difficulty = difficulty;
            
            // Mettre à jour les boutons
            document.querySelectorAll(&#x27;[id^=&quot;diff&quot;]&#x27;).forEach(btn =&gt; btn.classList.remove(&#x27;active&#x27;));
            document.getElementById(`diff${difficulty.charAt(0).toUpperCase() + difficulty.slice(1)}`).classList.add(&#x27;active&#x27;);
        }

        // Définir la vitesse
        function setSpeed(speed) {
            gameState.speed = speed;
            
            // Mettre à jour les boutons
            document.querySelectorAll(&#x27;[id^=&quot;speed&quot;]&#x27;).forEach(btn =&gt; btn.classList.remove(&#x27;active&#x27;));
            if(speed === &#x27;normal&#x27;) {
                document.getElementById(&#x27;speedNormal&#x27;).classList.add(&#x27;active&#x27;);
            } else {
                document.getElementById(`speed${speed.charAt(0).toUpperCase() + speed.slice(1)}`).classList.add(&#x27;active&#x27;);
            }
        }

        // Définir le thème
        function setTheme(theme) {
            gameState.currentTheme = theme;
            
            // Mettre à jour les boutons
            document.querySelectorAll(&#x27;[id^=&quot;theme&quot;]&#x27;).forEach(btn =&gt; btn.classList.remove(&#x27;active&#x27;));
            document.getElementById(`theme${theme.charAt(0).toUpperCase() + theme.slice(1)}`).classList.add(&#x27;active&#x27;);
            
            // Mettre à jour les images des cellules
            updateCellImages();
        }

        // Mettre à jour les images des cellules
        function updateCellImages() {
            const currentImages = imageThemes[gameState.currentTheme];
            for(let i = 0; i &lt; 4; i++) {
                document.getElementById(`cell${i}`).textContent = currentImages[i];
            }
        }

        // Changer automatiquement de thème à chaque nouveau jeu
        function changeThemeRandomly() {
            const availableThemes = themeNames.filter(theme =&gt; theme !== gameState.currentTheme);
            const randomTheme = availableThemes[Math.floor(Math.random() * availableThemes.length)];
            setTheme(randomTheme);
        }

        // Démarrer le jeu
        function startGame() {
            if(gameState.isPlaying) return;
            
            gameState.isPlaying = true;
            gameState.gameStarted = true;
            gameState.sequence = [];
            gameState.playerSequence = [];
            gameState.level = 1;
            gameState.round = 0;
            gameState.score = 0;
            gameState.currentStep = 0;
            
            const t = translations[gameState.currentLanguage];
            showMessage(t.gameStarted, 2000);
            
            // Désactiver les boutons de configuration
            document.querySelectorAll(&#x27;.config-btn&#x27;).forEach(btn =&gt; btn.disabled = true);
            
            setTimeout(() =&gt; {
                nextRound();
            }, 2000);
        }

        // Manche suivante
        function nextRound() {
            gameState.round++;
            gameState.playerSequence = [];
            gameState.currentStep = 0;
            gameState.isPlayerTurn = false;
            
            // Ajouter un nouvel élément à la séquence
            gameState.sequence.push(Math.floor(Math.random() * 4));
            
            updateDisplay();
            showSequence();
        }

        // Afficher la séquence
        function showSequence() {
            gameState.isShowingSequence = true;
            const t = translations[gameState.currentLanguage];
            showMessage(t.watchSequence);
            updateProgressText();
            
            const settings = speedSettings[gameState.speed];
            let index = 0;
            
            const showNext = () =&gt; {
                if(index &lt; gameState.sequence.length) {
                    const cellId = gameState.sequence[index];
                    activateCell(cellId);
                    
                    setTimeout(() =&gt; {
                        deactivateCell(cellId);
                        index++;
                        setTimeout(showNext, settings.sequenceDelay - settings.cellActiveTime);
                    }, settings.cellActiveTime);
                } else {
                    // Séquence terminée, c&#x27;est au tour du joueur
                    setTimeout(() =&gt; {
                        gameState.isShowingSequence = false;
                        gameState.isPlayerTurn = true;
                        const t = translations[gameState.currentLanguage];
                        showMessage(t.yourTurn);
                        updateProgressText();
                    }, 500);
                }
            };
            
            setTimeout(showNext, 1000);
        }

        // Activer une cellule
        function activateCell(cellId) {
            const cell = document.querySelector(`[data-id=&quot;${cellId}&quot;]`);
            if(cell) {
                cell.classList.add(&#x27;active&#x27;);
                playSound(200 + cellId * 100);
            }
        }

        // Désactiver une cellule
        function deactivateCell(cellId) {
            const cell = document.querySelector(`[data-id=&quot;${cellId}&quot;]`);
            if(cell) {
                cell.classList.remove(&#x27;active&#x27;);
            }
        }

        // Clic du joueur
        function playerClick(cellId) {
            if(!gameState.isPlayerTurn || gameState.isShowingSequence) return;
            
            activateCell(cellId);
            setTimeout(() =&gt; deactivateCell(cellId), 200);
            
            gameState.playerSequence.push(cellId);
            
            // Vérifier si le clic est correct
            if(gameState.playerSequence[gameState.currentStep] !== gameState.sequence[gameState.currentStep]) {
                // Erreur
                gameError();
                return;
            }
            
            gameState.currentStep++;
            
            // Vérifier si la séquence est complète
            if(gameState.currentStep &gt;= gameState.sequence.length) {
                // Séquence correcte
                gameState.isPlayerTurn = false;
                const settings = difficultySettings[gameState.difficulty];
                const bonus = Math.floor(gameState.level * settings.bonusMultiplier);
                gameState.score += settings.baseScore + bonus;
                
                const t = translations[gameState.currentLanguage];
                showMessage(t.correct, 2000);
                updateProgressText();
                
                // Vérifier si le niveau maximum est atteint
                if(gameState.level &gt;= settings.maxLevel) {
                    setTimeout(() =&gt; showVictory(), 2000);
                } else {
                    gameState.level++;
                    setTimeout(() =&gt; nextRound(), 2000);
                }
            }
            
            updateDisplay();
        }

        // Erreur du joueur
        function gameError() {
            gameState.isPlayerTurn = false;
            const t = translations[gameState.currentLanguage];
            showMessage(t.wrong, 3000);
            updateProgressText();
            
            // Animation d&#x27;erreur
            document.querySelectorAll(&#x27;.neural-cell&#x27;).forEach(cell =&gt; {
                cell.classList.add(&#x27;error&#x27;);
                setTimeout(() =&gt; cell.classList.remove(&#x27;error&#x27;), 800);
            });
            
            setTimeout(() =&gt; {
                endGame();
            }, 3000);
        }

        // Fin de jeu
        function endGame() {
            gameState.isPlaying = false;
            gameState.gameStarted = false;
            
            // Vérifier le record
            if(gameState.score &gt; gameState.bestScore) {
                gameState.bestScore = gameState.score;
                localStorage.setItem(&#x27;neuralMemoryBest&#x27;, gameState.bestScore);
            }
            
            // Réactiver les boutons de configuration
            document.querySelectorAll(&#x27;.config-btn&#x27;).forEach(btn =&gt; btn.disabled = false);
            
            const t = translations[gameState.currentLanguage];
            showMessage(`${t.gameOver} ${gameState.score}`, 5000);
            
            updateDisplay();
            updateAIAnalysis();
            
            setTimeout(() =&gt; showDefeat(), 1000);
        }

        // Réinitialiser le jeu
        function resetGame() {
            // Fermer les overlays
            const victoryOverlay = document.querySelector(&#x27;.victory-animation&#x27;);
            const defeatOverlay = document.querySelector(&#x27;.defeat-animation&#x27;);
            if(victoryOverlay) document.body.removeChild(victoryOverlay);
            if(defeatOverlay) document.body.removeChild(defeatOverlay);
            
            gameState.isPlaying = false;
            gameState.gameStarted = false;
            gameState.sequence = [];
            gameState.playerSequence = [];
            gameState.level = 1;
            gameState.round = 0;
            gameState.score = 0;
            gameState.currentStep = 0;
            gameState.isPlayerTurn = false;
            gameState.isShowingSequence = false;
            
            // Changer automatiquement de thème pour un nouveau jeu
            changeThemeRandomly();
            
            // Réactiver les boutons de configuration
            document.querySelectorAll(&#x27;.config-btn&#x27;).forEach(btn =&gt; btn.disabled = false);
            
            const t = translations[gameState.currentLanguage];
            showMessage(t.welcomeMessage);
            
            updateDisplay();
            updateProgressText();
        }

        // Afficher un message
        function showMessage(message, duration = 0) {
            const messageElement = document.getElementById(&#x27;gameMessage&#x27;);
            messageElement.textContent = message;
            
            if(duration &gt; 0) {
                setTimeout(() =&gt; {
                    const t = translations[gameState.currentLanguage];
                    if(!gameState.isPlaying) {
                        messageElement.textContent = t.welcomeMessage;
                    }
                }, duration);
            }
        }

        // Mettre à jour l&#x27;affichage
        function updateDisplay() {
            document.getElementById(&#x27;scoreValue&#x27;).textContent = gameState.score;
            document.getElementById(&#x27;levelValue&#x27;).textContent = gameState.level;
            document.getElementById(&#x27;roundValue&#x27;).textContent = gameState.round;
            document.getElementById(&#x27;bestValue&#x27;).textContent = gameState.bestScore;
            
            // Mettre à jour la barre de progression
            const settings = difficultySettings[gameState.difficulty];
            const progress = (gameState.level / settings.maxLevel) * 100;
            document.getElementById(&#x27;progressFill&#x27;).style.width = `${Math.min(progress, 100)}%`;
        }

        // Mettre à jour le texte de progression
        function updateProgressText() {
            const t = translations[gameState.currentLanguage];
            const progressText = document.getElementById(&#x27;progressText&#x27;);
            
            if(!gameState.gameStarted) {
                progressText.textContent = t.progressReady;
            } else if(gameState.isShowingSequence) {
                progressText.textContent = t.progressWatching;
            } else if(gameState.isPlayerTurn) {
                progressText.textContent = t.progressYourTurn;
            } else if(gameState.currentStep &gt;= gameState.sequence.length &amp;&amp; gameState.isPlaying) {
                progressText.textContent = t.progressCorrect;
            } else if(!gameState.isPlaying &amp;&amp; gameState.gameStarted) {
                progressText.textContent = t.progressWrong;
            }
        }

        // Mettre à jour l&#x27;analyse IA
        function updateAIAnalysis() {
            const t = translations[gameState.currentLanguage];
            const aiAnalysisElement = document.getElementById(&#x27;aiAnalysisText&#x27;);
            
            const accuracy = gameState.level &gt; 1 ? (gameState.level - 1) / gameState.round : 0;
            
            if(accuracy &gt;= 0.9) {
                aiAnalysisElement.textContent = t.aiPerfect;
            } else if(accuracy &gt;= 0.7) {
                aiAnalysisElement.textContent = t.aiGood;
            } else if(accuracy &gt;= 0.5) {
                aiAnalysisElement.textContent = t.aiAverage;
            } else {
                aiAnalysisElement.textContent = t.aiNeedsWork;
            }
        }

        // Afficher la victoire
        function showVictory() {
            const t = translations[gameState.currentLanguage];
            
            // Créer l&#x27;animation de victoire
            const overlay = document.createElement(&#x27;div&#x27;);
            overlay.className = &#x27;victory-animation&#x27;;
            
            const content = document.createElement(&#x27;div&#x27;);
            content.className = &#x27;victory-content&#x27;;
            content.innerHTML = `
                &lt;h2&gt;${t.victoryTitle}&lt;/h2&gt;
                &lt;p style=&quot;margin: 25px 0;&quot;&gt;${t.victoryMessage}&lt;/p&gt;
                &lt;p style=&quot;margin: 15px 0; color: #00ff88;&quot;&gt;Score Final: ${gameState.score}&lt;/p&gt;
                &lt;p style=&quot;margin: 15px 0; color: #fbbf24;&quot;&gt;Niveau Atteint: ${gameState.level}&lt;/p&gt;
                ${gameState.score &gt; gameState.bestScore ? `&lt;p style=&quot;margin: 15px 0; color: #ff0099;&quot;&gt;${t.newRecord}&lt;/p&gt;` : &#x27;&#x27;}
                &lt;button onclick=&quot;resetGame()&quot; style=&quot;
                    margin: 25px 15px 15px 15px;
                    padding: 18px 35px;
                    background: linear-gradient(145deg, #00ff88, #0099ff);
                    color: white;
                    border: none;
                    border-radius: 18px;
                    font-size: 16px;
                    font-weight: bold;
                    cursor: pointer;
                    transition: all 0.3s ease;
                &quot;&gt;${t.continueText}&lt;/button&gt;
            `;
            
            // Ajouter des feux d&#x27;artifice
            for(let i = 0; i &lt; 25; i++) {
                const firework = document.createElement(&#x27;div&#x27;);
                firework.className = &#x27;neural-fireworks&#x27;;
                firework.style.left = Math.random() * 100 + &#x27;%&#x27;;
                firework.style.top = Math.random() * 100 + &#x27;%&#x27;;
                firework.style.animationDelay = Math.random() * 4 + &#x27;s&#x27;;
                overlay.appendChild(firework);
            }
            
            overlay.appendChild(content);
            document.body.appendChild(overlay);
        }

        // Afficher la défaite
        function showDefeat() {
            const t = translations[gameState.currentLanguage];
            
            // Créer l&#x27;animation de défaite
            const overlay = document.createElement(&#x27;div&#x27;);
            overlay.className = &#x27;defeat-animation&#x27;;
            
            const content = document.createElement(&#x27;div&#x27;);
            content.className = &#x27;defeat-content&#x27;;
            content.innerHTML = `
                &lt;h2&gt;${t.defeatTitle}&lt;/h2&gt;
                &lt;p style=&quot;margin: 25px 0;&quot;&gt;${t.defeatMessage}&lt;/p&gt;
                &lt;p style=&quot;margin: 15px 0; color: #ef4444;&quot;&gt;Score Final: ${gameState.score}&lt;/p&gt;
                &lt;p style=&quot;margin: 15px 0; color: #fbbf24;&quot;&gt;Niveau Atteint: ${gameState.level}&lt;/p&gt;
                ${gameState.score &gt; gameState.bestScore ? `&lt;p style=&quot;margin: 15px 0; color: #00ff88;&quot;&gt;${t.newRecord}&lt;/p&gt;` : &#x27;&#x27;}
                &lt;button onclick=&quot;resetGame()&quot; style=&quot;
                    margin: 25px 15px 15px 15px;
                    padding: 18px 35px;
                    background: linear-gradient(145deg, #00ff88, #0099ff);
                    color: white;
                    border: none;
                    border-radius: 18px;
                    font-size: 16px;
                    font-weight: bold;
                    cursor: pointer;
                    transition: all 0.3s ease;
                &quot;&gt;${t.tryAgainText}&lt;/button&gt;
            `;
            
            overlay.appendChild(content);
            document.body.appendChild(overlay);
        }

        // Charger le meilleur score
        function loadBestScore() {
            const saved = localStorage.getItem(&#x27;neuralMemoryBest&#x27;);
            if(saved) {
                gameState.bestScore = parseInt(saved);
            }
        }

        // Initialisation
        document.addEventListener(&#x27;DOMContentLoaded&#x27;, function() {
            createQuantumParticles();
            loadBestScore();
            updateDisplay();
            updateProgressText();
            updateCellImages(); // Initialiser les images des cellules
        });
    &lt;/script&gt;
&lt;script&gt;(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement(&#x27;script&#x27;);d.innerHTML=&quot;window.__CF$cv$params={r:&#x27;984a9506f3267781&#x27;,t:&#x27;MTc1ODgwMzk0My4wMDAwMDA=&#x27;};var a=document.createElement(&#x27;script&#x27;);a.nonce=&#x27;&#x27;;a.src=&#x27;/cdn-cgi/challenge-platform/scripts/jsd/main.js&#x27;;document.getElementsByTagName(&#x27;head&#x27;)[0].appendChild(a);&quot;;b.getElementsByTagName(&#x27;head&#x27;)[0].appendChild(d)}}if(document.body){var a=document.createElement(&#x27;iframe&#x27;);a.height=1;a.width=1;a.style.position=&#x27;absolute&#x27;;a.style.top=0;a.style.left=0;a.style.border=&#x27;none&#x27;;a.style.visibility=&#x27;hidden&#x27;;document.body.appendChild(a);if(&#x27;loading&#x27;!==document.readyState)c();else if(window.addEventListener)document.addEventListener(&#x27;DOMContentLoaded&#x27;,c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);&#x27;loading&#x27;!==document.readyState&amp;&amp;(document.onreadystatechange=e,c())}}}})();&lt;/script&gt;&lt;/body&gt;
&lt;/html&gt;
" style="width:100%;height:100%;border:none;"></iframe>
</div>

<script>
function launchGame7() {
  const overlay = document.getElementById("game7Overlay");
  overlay.style.display = "block";
}
function closeGame7() {
  const overlay = document.getElementById("game7Overlay");
  overlay.style.display = "none";
}
document.addEventListener("keydown", function(e) {
  if (e.key === "Escape") {
    const overlay = document.getElementById("game7Overlay");
    if (overlay && overlay.style.display === "block") {
      e.preventDefault();
      e.stopPropagation();
      closeGame7();
    }
  }
}, true);
</script>


<div id="game8Overlay" style="display:none;position:fixed;inset:0;background:#000;z-index:9999;">
  <button onclick="closeGame8()" style="position:absolute;top:10px;right:10px;z-index:10000;
    font-size:24px;background:red;color:white;border:none;border-radius:50%;width:40px;height:40px;
    cursor:pointer;">✖</button>
  <iframe id="iframeGame8" srcdoc="&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;fr&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;🚀 Speed Challenge - IA Futuriste&lt;/title&gt;
    &lt;script src=&quot;https://cdn.tailwindcss.com&quot;&gt;&lt;/script&gt;
    &lt;style&gt;
        body {
            box-sizing: border-box;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: &#x27;Segoe UI&#x27;, Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0a0f 0%, #1a0a2e 30%, #16213e 70%, #0f3460 100%);
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }

        /* Particules cyber d&#x27;arrière-plan */
        .cyber-particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .cyber-particle {
            position: absolute;
            width: 3px;
            height: 3px;
            background: #00ffff;
            border-radius: 50%;
            animation: cyberFloat 12s infinite linear;
            box-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff;
        }

        @keyframes cyberFloat {
            0% {
                transform: translateY(100vh) translateX(0) rotate(0deg) scale(0);
                opacity: 0;
            }
            10% {
                opacity: 1;
                transform: translateY(90vh) translateX(20px) rotate(45deg) scale(1);
            }
            50% {
                transform: translateY(50vh) translateX(-30px) rotate(180deg) scale(1.2);
            }
            90% {
                opacity: 1;
                transform: translateY(10vh) translateX(40px) rotate(315deg) scale(1);
            }
            100% {
                transform: translateY(-10vh) translateX(80px) rotate(360deg) scale(0);
                opacity: 0;
            }
        }

        /* Grille cyber de fond */
        .cyber-grid {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(0, 255, 255, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 255, 0.1) 1px, transparent 1px);
            background-size: 60px 60px;
            animation: cyberGridMove 25s linear infinite;
            z-index: 1;
        }

        @keyframes cyberGridMove {
            0% { transform: translate(0, 0); }
            100% { transform: translate(60px, 60px); }
        }

        /* Container principal */
        .speed-challenge-container {
            position: relative;
            z-index: 10;
            display: grid;
            grid-template-columns: 250px 1fr 250px;
            grid-template-rows: auto 1fr;
            gap: 15px;
            min-height: 100vh;
            padding: 15px;
            max-width: 100%;
            margin: 0;
        }

        .game-panel {
            background: linear-gradient(145deg, 
                rgba(20, 20, 40, 0.95) 0%,
                rgba(30, 15, 80, 0.95) 50%,
                rgba(15, 52, 96, 0.95) 100%);
            backdrop-filter: blur(25px);
            border-radius: 20px;
            padding: 20px;
            width: 100%;
            height: fit-content;
            box-shadow: 
                0 25px 50px rgba(0, 0, 0, 0.8),
                0 0 100px rgba(0, 255, 255, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(0, 255, 255, 0.4);
            animation: cyberPanelGlow 4s ease-in-out infinite alternate;
            grid-column: 2;
        }

        .left-panel, .right-panel {
            background: linear-gradient(145deg, 
                rgba(20, 20, 40, 0.95) 0%,
                rgba(30, 15, 80, 0.95) 50%,
                rgba(15, 52, 96, 0.95) 100%);
            backdrop-filter: blur(25px);
            border-radius: 15px;
            padding: 15px;
            height: fit-content;
            box-shadow: 
                0 15px 30px rgba(0, 0, 0, 0.6),
                0 0 60px rgba(0, 255, 255, 0.15),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(0, 255, 255, 0.3);
        }

        .panel-section {
            margin-bottom: 20px;
        }

        @keyframes cyberPanelGlow {
            from { 
                box-shadow: 
                    0 25px 50px rgba(0, 0, 0, 0.8),
                    0 0 100px rgba(0, 255, 255, 0.2),
                    inset 0 1px 0 rgba(255, 255, 255, 0.1);
            }
            to { 
                box-shadow: 
                    0 30px 60px rgba(0, 0, 0, 0.8),
                    0 0 120px rgba(0, 255, 255, 0.3),
                    inset 0 1px 0 rgba(255, 255, 255, 0.2);
            }
        }

        /* En-tête du jeu */
        .cyber-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 2px solid rgba(0, 255, 255, 0.4);
        }

        .cyber-title {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .cyber-title h1 {
            color: #00ffff;
            margin: 0;
            font-size: 26px;
            font-weight: 700;
            text-shadow: 0 0 30px rgba(0, 255, 255, 0.9);
            animation: cyberTitlePulse 3s infinite alternate;
        }

        @keyframes cyberTitlePulse {
            from { 
                text-shadow: 0 0 30px rgba(0, 255, 255, 0.9);
                transform: scale(1);
            }
            to { 
                text-shadow: 0 0 40px rgba(0, 255, 255, 1);
                transform: scale(1.03);
            }
        }

        .cyber-icon {
            font-size: 32px;
            animation: cyberIconSpin 4s ease-in-out infinite;
            filter: drop-shadow(0 0 20px #00ffff);
        }

        @keyframes cyberIconSpin {
            0%, 100% { transform: scale(1) rotate(0deg); }
            50% { transform: scale(1.15) rotate(10deg); }
        }

        .cyber-badge {
            background: linear-gradient(45deg, #00ffff, #ff00ff, #ffff00, #00ff00);
            background-size: 400% 400%;
            color: white;
            padding: 12px 20px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
            animation: cyberBadgeShine 4s ease-in-out infinite;
            box-shadow: 0 0 25px rgba(0, 255, 255, 0.6);
        }

        @keyframes cyberBadgeShine {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        /* Sélecteur de langue */
        .language-selector {
            background: linear-gradient(145deg, 
                rgba(20, 20, 40, 0.95) 0%,
                rgba(30, 15, 80, 0.95) 30%,
                rgba(15, 52, 96, 0.95) 70%,
                rgba(0, 255, 255, 0.95) 100%);
            color: #00ffff;
            border: 2px solid rgba(0, 255, 255, 0.6);
            border-radius: 15px;
            padding: 12px 18px;
            font-weight: bold;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
            box-shadow: 
                0 0 25px rgba(0, 255, 255, 0.4),
                0 0 40px rgba(255, 0, 255, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(15px);
            min-width: 160px;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
        }

        .language-selector:hover {
            background: linear-gradient(145deg, 
                rgba(0, 255, 255, 0.9) 0%,
                rgba(255, 0, 255, 0.9) 30%,
                rgba(255, 255, 0, 0.9) 70%,
                rgba(0, 255, 0, 0.9) 100%);
            transform: translateY(-2px);
            box-shadow: 
                0 8px 25px rgba(0, 255, 255, 0.6),
                0 0 50px rgba(255, 0, 255, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
            color: white;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.8);
        }

        .language-selector option {
            background: linear-gradient(145deg, 
                rgba(15, 15, 30, 0.98) 0%,
                rgba(25, 10, 70, 0.98) 50%,
                rgba(10, 42, 86, 0.98) 100%);
            color: #00ffff;
            padding: 10px 14px;
            font-weight: bold;
            font-size: 14px;
            border: none;
            text-shadow: 0 0 12px rgba(0, 255, 255, 0.9);
            border-bottom: 1px solid rgba(0, 255, 255, 0.3);
        }

        .language-selector option:hover,
        .language-selector option:focus,
        .language-selector option:checked {
            background: linear-gradient(145deg, 
                rgba(0, 255, 255, 0.9) 0%,
                rgba(255, 0, 255, 0.9) 30%,
                rgba(255, 255, 0, 0.9) 70%,
                rgba(0, 255, 0, 0.9) 100%) !important;
            color: white !important;
            text-shadow: 0 0 18px rgba(255, 255, 255, 1) !important;
        }

        /* Panneau de titre des sections */
        .panel-title {
            color: #00ffff;
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 18px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 15px rgba(0, 255, 255, 0.9);
            border-bottom: 2px solid rgba(0, 255, 255, 0.4);
            padding-bottom: 10px;
        }

        /* Zone de jeu principale */
        .speed-arena {
            background: rgba(0, 0, 0, 0.6);
            border-radius: 20px;
            padding: 20px;
            margin-bottom: 15px;
            border: 3px solid rgba(0, 255, 255, 0.5);
            box-shadow: 
                0 0 40px rgba(0, 255, 255, 0.3),
                inset 0 0 20px rgba(0, 255, 255, 0.1);
            min-height: 75vh;
            height: 75vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        /* Cibles de vitesse */
        .speed-target {
            position: absolute;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
            color: white;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.8);
            border: 3px solid rgba(255, 255, 255, 0.6);
            animation: targetPulse 2s ease-in-out infinite;
        }

        @keyframes targetPulse {
            0%, 100% { 
                transform: scale(1);
                box-shadow: 0 0 20px currentColor;
            }
            50% { 
                transform: scale(1.1);
                box-shadow: 0 0 30px currentColor;
            }
        }

        .speed-target:hover {
            transform: scale(1.2);
            box-shadow: 0 0 40px currentColor;
        }

        .speed-target.hit {
            animation: targetHit 0.5s ease-out;
        }

        @keyframes targetHit {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); }
            100% { transform: scale(0); opacity: 0; }
        }

        .speed-target.miss {
            animation: targetMiss 0.8s ease-out;
        }

        @keyframes targetMiss {
            0%, 100% { transform: scale(1); }
            25% { transform: scale(1.1) rotate(-5deg); }
            75% { transform: scale(1.1) rotate(5deg); }
        }

        /* Types de cibles - 8 VITESSES */
        .target-normal {
            background: linear-gradient(145deg, #00ffff, #0099cc);
        }

        .target-fast {
            background: linear-gradient(145deg, #ff00ff, #cc0099);
        }

        .target-bonus {
            background: linear-gradient(145deg, #ffff00, #cccc00);
        }

        .target-danger {
            background: linear-gradient(145deg, #ff0000, #cc0000);
        }

        .target-lightning {
            background: linear-gradient(145deg, #ffff00, #ff8800, #ffff00);
            background-size: 200% 200%;
            animation: lightningPulse 0.3s ease-in-out infinite alternate;
            box-shadow: 0 0 30px #ffff00, 0 0 50px #ff8800;
        }

        @keyframes lightningPulse {
            0% { 
                background-position: 0% 50%;
                transform: scale(1);
            }
            100% { 
                background-position: 100% 50%;
                transform: scale(1.15);
            }
        }

        .target-mega {
            background: linear-gradient(145deg, #00ffff, #ff00ff, #ffff00, #00ff00);
            background-size: 400% 400%;
            animation: megaShine 0.8s ease-in-out infinite;
            box-shadow: 0 0 40px #00ffff, 0 0 60px #ff00ff;
        }

        @keyframes megaShine {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .target-toxic {
            background: linear-gradient(145deg, #00ff00, #008800, #004400);
            animation: toxicGlow 1s ease-in-out infinite alternate;
            box-shadow: 0 0 25px #00ff00, 0 0 45px #008800;
        }

        @keyframes toxicGlow {
            0% { 
                box-shadow: 0 0 25px #00ff00, 0 0 45px #008800;
                filter: hue-rotate(0deg);
            }
            100% { 
                box-shadow: 0 0 35px #00ff00, 0 0 55px #008800;
                filter: hue-rotate(30deg);
            }
        }

        .target-ultimate {
            background: linear-gradient(145deg, #ffffff, #ffff00, #ff00ff, #00ffff, #ffffff);
            background-size: 500% 500%;
            animation: ultimateBlaze 0.4s ease-in-out infinite;
            box-shadow: 0 0 50px #ffffff, 0 0 80px #ffff00, 0 0 100px #ff00ff;
            border: 3px solid #ffffff;
        }

        @keyframes ultimateBlaze {
            0%, 100% { 
                background-position: 0% 50%;
                transform: scale(1) rotate(0deg);
            }
            50% { 
                background-position: 100% 50%;
                transform: scale(1.2) rotate(5deg);
            }
        }

        /* Contrôles du jeu */
        .game-controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
        }

        .cyber-btn {
            padding: 15px 30px;
            background: linear-gradient(145deg, #00ffff, #0099cc);
            color: white;
            border: none;
            border-radius: 15px;
            font-weight: bold;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 1px;
            min-width: 150px;
        }

        .cyber-btn::before {
            content: &#x27;&#x27;;
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            transition: left 0.5s ease;
        }

        .cyber-btn:hover::before {
            left: 100%;
        }

        .cyber-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0, 255, 255, 0.5);
            background: linear-gradient(145deg, #00ccff, #0077aa);
        }

        .cyber-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .start-btn {
            background: linear-gradient(145deg, #00ff00, #00cc00);
        }

        .start-btn:hover {
            background: linear-gradient(145deg, #00cc00, #009900);
        }

        .reset-btn {
            background: linear-gradient(145deg, #ff0066, #cc0044);
        }

        .reset-btn:hover {
            background: linear-gradient(145deg, #cc0044, #990033);
        }

        /* Statistiques du jeu */
        .game-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 20px;
        }

        .stat-item {
            background: rgba(0, 255, 255, 0.1);
            padding: 12px;
            border-radius: 12px;
            text-align: center;
            border: 2px solid rgba(0, 255, 255, 0.3);
            position: relative;
            overflow: hidden;
        }

        .stat-item::before {
            content: &#x27;&#x27;;
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 255, 0.2), transparent);
            animation: statCyberScan 4s linear infinite;
        }

        @keyframes statCyberScan {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .stat-label {
            display: block;
            color: #9ca3af;
            font-size: 11px;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-value {
            display: block;
            color: #00ffff;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 0 0 15px rgba(0, 255, 255, 0.9);
            position: relative;
            z-index: 1;
        }

        /* Messages de jeu */
        .game-message {
            text-align: center;
            margin-bottom: 20px;
            padding: 18px;
            border-radius: 12px;
            background: rgba(0, 255, 255, 0.1);
            border: 2px solid rgba(0, 255, 255, 0.3);
            color: #00ffff;
            font-weight: bold;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }

        /* Compteur de temps */
        .time-display {
            font-size: 48px;
            font-weight: bold;
            color: #00ffff;
            text-shadow: 0 0 25px rgba(0, 255, 255, 0.9);
            margin-bottom: 20px;
            text-align: center;
            animation: timeGlow 2s ease-in-out infinite alternate;
        }

        @keyframes timeGlow {
            from { 
                text-shadow: 0 0 25px rgba(0, 255, 255, 0.9);
                transform: scale(1);
            }
            to { 
                text-shadow: 0 0 35px rgba(0, 255, 255, 1);
                transform: scale(1.05);
            }
        }

        /* Barre de progression */
        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            margin-bottom: 20px;
            overflow: hidden;
            border: 1px solid rgba(0, 255, 255, 0.3);
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ffff, #ff00ff);
            border-radius: 10px;
            transition: width 0.3s ease;
            box-shadow: 0 0 12px rgba(0, 255, 255, 0.6);
        }

        /* Responsive */
        @media (max-width: 1200px) {
            .speed-challenge-container {
                grid-template-columns: 200px 1fr 200px;
                gap: 10px;
                padding: 10px;
            }
            
            .left-panel, .right-panel {
                padding: 12px;
            }
        }

        @media (max-width: 900px) {
            .speed-challenge-container {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto 1fr;
                gap: 10px;
            }
            
            .left-panel {
                grid-row: 2;
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 15px;
            }
            
            .right-panel {
                grid-row: 3;
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 15px;
            }
        }

        @media (max-width: 768px) {
            .game-panel {
                padding: 15px;
            }
            
            .cyber-title h1 {
                font-size: 18px;
            }
            
            .speed-arena {
                min-height: 65vh;
                height: 65vh;
                padding: 15px;
            }
            
            .speed-target {
                width: 60px;
                height: 60px;
                font-size: 18px;
            }
            
            .game-controls {
                flex-direction: column;
                gap: 10px;
            }
            
            .cyber-btn {
                min-width: 120px;
                padding: 12px 20px;
            }
            
            .left-panel, .right-panel {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 480px) {
            .speed-target {
                width: 50px;
                height: 50px;
                font-size: 16px;
            }
            
            .game-stats {
                grid-template-columns: 1fr 1fr;
            }
            
            .cyber-title {
                flex-direction: column;
                gap: 10px;
            }
            
            .cyber-title h1 {
                font-size: 16px;
            }
            
            .game-controls {
                flex-direction: column;
                gap: 8px;
            }
            
            .cyber-btn {
                min-width: 100px;
                padding: 10px 15px;
                font-size: 12px;
            }
        }

        /* Animations de victoire et défaite */
        .victory-animation, .defeat-animation {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            backdrop-filter: blur(15px);
        }

        .victory-content, .defeat-content {
            background: linear-gradient(145deg, rgba(20, 20, 40, 0.95), rgba(15, 52, 96, 0.95));
            border: 3px solid #00ffff;
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            color: white;
            font-size: 20px;
            font-weight: bold;
            max-width: 500px;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.7);
            animation: victoryPulse 2s ease-in-out infinite alternate;
        }

        .defeat-content {
            border-color: #ff0066;
            box-shadow: 0 0 50px rgba(255, 0, 102, 0.7);
            animation: defeatShake 1s ease-in-out infinite;
        }

        @keyframes victoryPulse {
            from { 
                box-shadow: 0 0 50px rgba(0, 255, 255, 0.7);
                transform: scale(1);
            }
            to { 
                box-shadow: 0 0 70px rgba(0, 255, 255, 1);
                transform: scale(1.03);
            }
        }

        @keyframes defeatShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        /* Effets spéciaux */
        .combo-effect {
            position: absolute;
            font-size: 24px;
            font-weight: bold;
            color: #ffff00;
            text-shadow: 0 0 20px #ffff00;
            animation: comboFloat 2s ease-out forwards;
            pointer-events: none;
        }

        @keyframes comboFloat {
            0% {
                transform: scale(0.5) translateY(0);
                opacity: 1;
            }
            100% {
                transform: scale(1.5) translateY(-100px);
                opacity: 0;
            }
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!-- Particules cyber d&#x27;arrière-plan --&gt;
    &lt;div class=&quot;cyber-particles&quot; id=&quot;cyberParticles&quot;&gt;&lt;/div&gt;
    
    &lt;!-- Grille cyber --&gt;
    &lt;div class=&quot;cyber-grid&quot;&gt;&lt;/div&gt;
    
    &lt;!-- Container principal --&gt;
    &lt;div class=&quot;speed-challenge-container&quot;&gt;
        &lt;!-- Panneau gauche --&gt;
        &lt;div class=&quot;left-panel&quot;&gt;
            &lt;div class=&quot;panel-section&quot;&gt;
                &lt;div class=&quot;panel-title&quot; id=&quot;controlsTitle&quot;&gt;⚡ Contrôles Cyber&lt;/div&gt;
                &lt;div style=&quot;display: grid; gap: 12px;&quot;&gt;
                    &lt;button class=&quot;cyber-btn start-btn&quot; onclick=&quot;startGame()&quot; id=&quot;startBtn&quot;&gt;
                        🚀 &lt;span id=&quot;startText&quot;&gt;Démarrer&lt;/span&gt;
                    &lt;/button&gt;
                    &lt;button class=&quot;cyber-btn reset-btn&quot; onclick=&quot;resetGame()&quot;&gt;
                        🔄 &lt;span id=&quot;resetText&quot;&gt;Réinitialiser&lt;/span&gt;
                    &lt;/button&gt;

                &lt;/div&gt;
            &lt;/div&gt;

            &lt;div class=&quot;panel-section&quot;&gt;
                &lt;div class=&quot;panel-title&quot; id=&quot;statsTitle&quot;&gt;📊 Statistiques&lt;/div&gt;
                &lt;div class=&quot;game-stats&quot;&gt;
                    &lt;div class=&quot;stat-item&quot;&gt;
                        &lt;span class=&quot;stat-label&quot; id=&quot;scoreLabel&quot;&gt;Score&lt;/span&gt;
                        &lt;span class=&quot;stat-value&quot; id=&quot;scoreValue&quot;&gt;0&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;stat-item&quot;&gt;
                        &lt;span class=&quot;stat-label&quot; id=&quot;hitsLabel&quot;&gt;Cibles&lt;/span&gt;
                        &lt;span class=&quot;stat-value&quot; id=&quot;hitsValue&quot;&gt;0&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;stat-item&quot;&gt;
                        &lt;span class=&quot;stat-label&quot; id=&quot;accuracyLabel&quot;&gt;Précision&lt;/span&gt;
                        &lt;span class=&quot;stat-value&quot; id=&quot;accuracyValue&quot;&gt;100%&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;stat-item&quot;&gt;
                        &lt;span class=&quot;stat-label&quot; id=&quot;bestLabel&quot;&gt;Record&lt;/span&gt;
                        &lt;span class=&quot;stat-value&quot; id=&quot;bestValue&quot;&gt;0&lt;/span&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;div class=&quot;panel-section&quot;&gt;
                &lt;div class=&quot;panel-title&quot; id=&quot;progressTitle&quot;&gt;⏱️ Progression&lt;/div&gt;
                &lt;div class=&quot;progress-bar&quot;&gt;
                    &lt;div class=&quot;progress-fill&quot; id=&quot;progressFill&quot; style=&quot;width: 0%;&quot;&gt;&lt;/div&gt;
                &lt;/div&gt;
                &lt;div style=&quot;color: #9ca3af; font-size: 12px; text-align: center;&quot; id=&quot;progressText&quot;&gt;
                    Prêt pour le défi
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;

        &lt;!-- Panneau central --&gt;
        &lt;div class=&quot;game-panel&quot;&gt;
            &lt;!-- En-tête --&gt;
            &lt;div class=&quot;cyber-header&quot;&gt;
                &lt;div class=&quot;cyber-title&quot;&gt;
                    &lt;span class=&quot;cyber-icon&quot;&gt;⚡&lt;/span&gt;
                    &lt;h1 id=&quot;gameTitle&quot;&gt;Speed Challenge&lt;/h1&gt;
                    &lt;span class=&quot;cyber-badge&quot; id=&quot;cyberBadge&quot;&gt;🚀 IA FUTURISTE&lt;/span&gt;
                &lt;/div&gt;
                &lt;div style=&quot;display: flex; align-items: center; gap: 20px;&quot;&gt;
                    &lt;select id=&quot;languageSelector&quot; onchange=&quot;changeLanguage()&quot; class=&quot;language-selector&quot;&gt;
                        &lt;option value=&quot;fr&quot;&gt;🇫🇷 Français&lt;/option&gt;
                        &lt;option value=&quot;en&quot;&gt;🇺🇸 English&lt;/option&gt;
                        &lt;option value=&quot;ar&quot;&gt;🇸🇦 العربية&lt;/option&gt;
                        &lt;option value=&quot;es&quot;&gt;🇪🇸 Español&lt;/option&gt;
                        &lt;option value=&quot;de&quot;&gt;🇩🇪 Deutsch&lt;/option&gt;
                        &lt;option value=&quot;zh&quot;&gt;🇨🇳 中文&lt;/option&gt;
                    &lt;/select&gt;
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;!-- Message de jeu et compteur temps --&gt;
            &lt;div style=&quot;display: flex; gap: 20px; align-items: center; margin-bottom: 20px;&quot;&gt;
                &lt;div class=&quot;game-message&quot; id=&quot;gameMessage&quot; style=&quot;flex: 1; margin-bottom: 0;&quot;&gt;
                    &lt;span id=&quot;welcomeMessage&quot;&gt;Bienvenue dans Speed Challenge ! Cliquez sur les cibles le plus rapidement possible.&lt;/span&gt;
                &lt;/div&gt;
                &lt;div style=&quot;display: flex; gap: 15px; align-items: center;&quot;&gt;
                    &lt;div class=&quot;time-display&quot; style=&quot;font-size: 32px; margin: 0;&quot; id=&quot;timeDisplay&quot;&gt;30.0s&lt;/div&gt;
                    &lt;select id=&quot;timeSelector&quot; onchange=&quot;changeGameDuration()&quot; class=&quot;cyber-btn&quot; style=&quot;background: linear-gradient(145deg, #ffff00, #ff8800); min-width: 140px; cursor: pointer; border: none; color: white; font-weight: bold; appearance: menulist;&quot;&gt;
                        &lt;option value=&quot;30&quot; style=&quot;background: rgba(15, 15, 30, 0.98); color: #00ffff; padding: 10px;&quot;&gt;⏱️ 30.0s&lt;/option&gt;
                        &lt;option value=&quot;45&quot; style=&quot;background: rgba(15, 15, 30, 0.98); color: #00ffff; padding: 10px;&quot;&gt;⏱️ 45.0s&lt;/option&gt;
                        &lt;option value=&quot;60&quot; style=&quot;background: rgba(15, 15, 30, 0.98); color: #00ffff; padding: 10px;&quot;&gt;⏱️ 1 minute&lt;/option&gt;
                    &lt;/select&gt;
                &lt;/div&gt;
            &lt;/div&gt;



            &lt;!-- Zone de jeu --&gt;
            &lt;div class=&quot;speed-arena&quot; id=&quot;speedArena&quot;&gt;
                &lt;div style=&quot;color: #00ffff; font-size: 18px; text-align: center;&quot;&gt;
                    &lt;span id=&quot;readyMessage&quot;&gt;Prêt pour le défi de vitesse ?&lt;/span&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;

        &lt;!-- Panneau droit --&gt;
        &lt;div class=&quot;right-panel&quot;&gt;
            &lt;div class=&quot;panel-section&quot;&gt;
                &lt;div class=&quot;panel-title&quot; id=&quot;instructionsTitle&quot;&gt;📖 Instructions&lt;/div&gt;
                &lt;div style=&quot;color: #9ca3af; font-size: 13px; line-height: 1.7;&quot;&gt;
                    &lt;p id=&quot;instructionsText&quot;&gt;
                        • Cliquez sur les cibles qui apparaissent&lt;br&gt;
                        • Plus vous êtes rapide, plus vous gagnez&lt;br&gt;
                        • Évitez les cibles rouges (danger)&lt;br&gt;
                        • Cibles jaunes = bonus de points&lt;br&gt;
                        • L&#x27;IA analyse votre vitesse de réaction
                    &lt;/p&gt;
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;div class=&quot;panel-section&quot;&gt;
                &lt;div class=&quot;panel-title&quot; id=&quot;targetsTitle&quot;&gt;🎯 8 Types de Cibles&lt;/div&gt;
                &lt;div style=&quot;color: #9ca3af; font-size: 12px; line-height: 1.6;&quot;&gt;
                    &lt;div style=&quot;margin-bottom: 8px;&quot;&gt;
                        &lt;span style=&quot;color: #00ffff;&quot;&gt;🔵&lt;/span&gt; &lt;span id=&quot;normalText&quot;&gt;Normale (+10 pts)&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div style=&quot;margin-bottom: 8px;&quot;&gt;
                        &lt;span style=&quot;color: #ff00ff;&quot;&gt;🟣&lt;/span&gt; &lt;span id=&quot;fastText&quot;&gt;Rapide (+20 pts)&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div style=&quot;margin-bottom: 8px;&quot;&gt;
                        &lt;span style=&quot;color: #ffff00;&quot;&gt;🟡&lt;/span&gt; &lt;span id=&quot;bonusText&quot;&gt;Bonus (+50 pts)&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div style=&quot;margin-bottom: 8px;&quot;&gt;
                        &lt;span style=&quot;color: #ff0000;&quot;&gt;🔴&lt;/span&gt; &lt;span id=&quot;dangerText&quot;&gt;Danger (-30 pts)&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div style=&quot;margin-bottom: 8px;&quot;&gt;
                        &lt;span style=&quot;color: #ffff00;&quot;&gt;⚡&lt;/span&gt; &lt;span id=&quot;lightningText&quot;&gt;Éclair (+75 pts)&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div style=&quot;margin-bottom: 8px;&quot;&gt;
                        &lt;span style=&quot;color: #00ffff;&quot;&gt;💎&lt;/span&gt; &lt;span id=&quot;megaText&quot;&gt;Méga (+100 pts)&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div style=&quot;margin-bottom: 8px;&quot;&gt;
                        &lt;span style=&quot;color: #00ff00;&quot;&gt;☢️&lt;/span&gt; &lt;span id=&quot;toxicText&quot;&gt;Toxique (-50 pts)&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div style=&quot;margin-bottom: 8px;&quot;&gt;
                        &lt;span style=&quot;color: #ffffff;&quot;&gt;🌟&lt;/span&gt; &lt;span id=&quot;ultimateText&quot;&gt;Ultime (+200 pts)&lt;/span&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;div class=&quot;panel-section&quot;&gt;
                &lt;div class=&quot;panel-title&quot; id=&quot;aiStatusTitle&quot;&gt;🤖 Analyse IA&lt;/div&gt;
                &lt;div id=&quot;aiStatus&quot; style=&quot;color: #00ffff; font-size: 13px; text-align: center; padding: 12px;&quot;&gt;
                    &lt;span id=&quot;aiStatusText&quot;&gt;IA Cyber Active&lt;/span&gt;
                &lt;/div&gt;
                &lt;div style=&quot;color: #9ca3af; font-size: 11px; text-align: center; margin-top: 10px;&quot; id=&quot;aiAnalysis&quot;&gt;
                    &lt;span id=&quot;aiAnalysisText&quot;&gt;Analyse des réflexes en cours...&lt;/span&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;script&gt;
        // Traductions multilingues
        const translations = {
            fr: {
                gameTitle: &quot;Speed Challenge - 8 Vitesses&quot;,
                cyberBadge: &quot;🚀 IA FUTURISTE&quot;,
                controlsTitle: &quot;⚡ Contrôles Cyber&quot;,
                statsTitle: &quot;📊 Statistiques&quot;,
                progressTitle: &quot;⏱️ Progression&quot;,
                instructionsTitle: &quot;📖 Instructions&quot;,
                targetsTitle: &quot;🎯 8 Types de Cibles&quot;,
                aiStatusTitle: &quot;🤖 Analyse IA&quot;,
                startText: &quot;Démarrer&quot;,
                resetText: &quot;Réinitialiser&quot;,

                scoreLabel: &quot;Score&quot;,
                hitsLabel: &quot;Cibles&quot;,
                accuracyLabel: &quot;Précision&quot;,
                bestLabel: &quot;Record&quot;,
                welcomeMessage: &quot;Bienvenue dans Speed Challenge ! Cliquez sur les cibles le plus rapidement possible.&quot;,
                readyMessage: &quot;Prêt pour le défi de vitesse ?&quot;,
                instructionsText: &quot;• Cliquez sur les cibles qui apparaissent&lt;br&gt;• Plus vous êtes rapide, plus vous gagnez de points&lt;br&gt;• Évitez les cibles rouges (danger)&lt;br&gt;• Cibles jaunes = bonus de points&lt;br&gt;• L&#x27;IA analyse votre vitesse de réaction en temps réel&quot;,
                normalText: &quot;Normale (+10 pts)&quot;,
                fastText: &quot;Rapide (+20 pts)&quot;,
                bonusText: &quot;Bonus (+50 pts)&quot;,
                dangerText: &quot;Danger (-30 pts)&quot;,
                lightningText: &quot;Éclair (+75 pts)&quot;,
                megaText: &quot;Méga (+100 pts)&quot;,
                toxicText: &quot;Toxique (-50 pts)&quot;,
                ultimateText: &quot;Ultime (+200 pts)&quot;,
                aiStatusText: &quot;IA Cyber Active&quot;,
                aiAnalysisText: &quot;Analyse des réflexes en cours...&quot;,
                progressReady: &quot;Prêt pour le défi&quot;,
                progressActive: &quot;Défi en cours...&quot;,
                progressFinished: &quot;Défi terminé !&quot;,
                gameStarted: &quot;Défi démarré ! Cliquez sur les cibles !&quot;,
                gameOver: &quot;Temps écoulé ! Score final :&quot;,
                newRecord: &quot;Nouveau record !&quot;,
                victoryTitle: &quot;🎉 EXCELLENT ! 🎉&quot;,
                victoryMessage: &quot;Réflexes exceptionnels !&quot;,
                defeatTitle: &quot;⏱️ TEMPS ÉCOULÉ ⏱️&quot;,
                defeatMessage: &quot;Entraînez vos réflexes !&quot;,
                tryAgainText: &quot;Réessayer&quot;,
                continueText: &quot;Continuer&quot;,
                aiExcellent: &quot;IA : Réflexes exceptionnels détectés !&quot;,
                aiGood: &quot;IA : Bonne vitesse de réaction&quot;,
                aiAverage: &quot;IA : Réflexes moyens&quot;,
                aiSlow: &quot;IA : Entraînement recommandé&quot;,
                combo2: &quot;COMBO x2 !&quot;,
                combo3: &quot;COMBO x3 !&quot;,
                combo5: &quot;COMBO x5 !&quot;,
                perfect: &quot;PARFAIT !&quot;
            },
            en: {
                gameTitle: &quot;Speed Challenge - 8 Speeds&quot;,
                cyberBadge: &quot;🚀 FUTURISTIC AI&quot;,
                controlsTitle: &quot;⚡ Cyber Controls&quot;,
                statsTitle: &quot;📊 Statistics&quot;,
                progressTitle: &quot;⏱️ Progress&quot;,
                instructionsTitle: &quot;📖 Instructions&quot;,
                targetsTitle: &quot;🎯 8 Target Types&quot;,
                aiStatusTitle: &quot;🤖 AI Analysis&quot;,
                startText: &quot;Start&quot;,
                resetText: &quot;Reset&quot;,

                scoreLabel: &quot;Score&quot;,
                hitsLabel: &quot;Targets&quot;,
                accuracyLabel: &quot;Accuracy&quot;,
                bestLabel: &quot;Best&quot;,
                welcomeMessage: &quot;Welcome to Speed Challenge! Click targets as fast as possible.&quot;,
                readyMessage: &quot;Ready for the speed challenge?&quot;,
                instructionsText: &quot;• Click on targets that appear&lt;br&gt;• Faster clicks = more points&lt;br&gt;• Avoid red targets (danger)&lt;br&gt;• Yellow targets = bonus points&lt;br&gt;• AI analyzes your reaction speed in real-time&quot;,
                normalText: &quot;Normal (+10 pts)&quot;,
                fastText: &quot;Fast (+20 pts)&quot;,
                bonusText: &quot;Bonus (+50 pts)&quot;,
                dangerText: &quot;Danger (-30 pts)&quot;,
                lightningText: &quot;Lightning (+75 pts)&quot;,
                megaText: &quot;Mega (+100 pts)&quot;,
                toxicText: &quot;Toxic (-50 pts)&quot;,
                ultimateText: &quot;Ultimate (+200 pts)&quot;,
                aiStatusText: &quot;Cyber AI Active&quot;,
                aiAnalysisText: &quot;Reflex analysis in progress...&quot;,
                progressReady: &quot;Ready for challenge&quot;,
                progressActive: &quot;Challenge in progress...&quot;,
                progressFinished: &quot;Challenge completed!&quot;,
                gameStarted: &quot;Challenge started! Click the targets!&quot;,
                gameOver: &quot;Time&#x27;s up! Final score:&quot;,
                newRecord: &quot;New record!&quot;,
                victoryTitle: &quot;🎉 EXCELLENT! 🎉&quot;,
                victoryMessage: &quot;Exceptional reflexes!&quot;,
                defeatTitle: &quot;⏱️ TIME&#x27;S UP ⏱️&quot;,
                defeatMessage: &quot;Train your reflexes!&quot;,
                tryAgainText: &quot;Try Again&quot;,
                continueText: &quot;Continue&quot;,
                aiExcellent: &quot;AI: Exceptional reflexes detected!&quot;,
                aiGood: &quot;AI: Good reaction speed&quot;,
                aiAverage: &quot;AI: Average reflexes&quot;,
                aiSlow: &quot;AI: Training recommended&quot;,
                combo2: &quot;COMBO x2!&quot;,
                combo3: &quot;COMBO x3!&quot;,
                combo5: &quot;COMBO x5!&quot;,
                perfect: &quot;PERFECT!&quot;
            },
            ar: {
                gameTitle: &quot;تحدي السرعة - 8 سرعات&quot;,
                cyberBadge: &quot;🚀 ذكاء مستقبلي&quot;,
                controlsTitle: &quot;⚡ تحكم سيبراني&quot;,
                statsTitle: &quot;📊 إحصائيات&quot;,
                progressTitle: &quot;⏱️ التقدم&quot;,
                instructionsTitle: &quot;📖 التعليمات&quot;,
                targetsTitle: &quot;🎯 8 أنواع أهداف&quot;,
                aiStatusTitle: &quot;🤖 تحليل الذكاء&quot;,
                startText: &quot;ابدأ&quot;,
                resetText: &quot;إعادة تعيين&quot;,

                scoreLabel: &quot;النقاط&quot;,
                hitsLabel: &quot;الأهداف&quot;,
                accuracyLabel: &quot;الدقة&quot;,
                bestLabel: &quot;الأفضل&quot;,
                welcomeMessage: &quot;مرحباً بك في تحدي السرعة! انقر على الأهداف بأسرع ما يمكن.&quot;,
                readyMessage: &quot;جاهز لتحدي السرعة؟&quot;,
                instructionsText: &quot;• انقر على الأهداف التي تظهر&lt;br&gt;• النقر السريع = نقاط أكثر&lt;br&gt;• تجنب الأهداف الحمراء (خطر)&lt;br&gt;• الأهداف الصفراء = نقاط إضافية&lt;br&gt;• الذكاء الاصطناعي يحلل سرعة ردود أفعالك في الوقت الفعلي&quot;,
                normalText: &quot;عادي (+10 نقاط)&quot;,
                fastText: &quot;سريع (+20 نقطة)&quot;,
                bonusText: &quot;مكافأة (+50 نقطة)&quot;,
                dangerText: &quot;خطر (-30 نقطة)&quot;,
                lightningText: &quot;برق (+75 نقطة)&quot;,
                megaText: &quot;ميجا (+100 نقطة)&quot;,
                toxicText: &quot;سام (-50 نقطة)&quot;,
                ultimateText: &quot;نهائي (+200 نقطة)&quot;,
                aiStatusText: &quot;الذكاء السيبراني نشط&quot;,
                aiAnalysisText: &quot;تحليل ردود الأفعال جاري...&quot;,
                progressReady: &quot;جاهز للتحدي&quot;,
                progressActive: &quot;التحدي جاري...&quot;,
                progressFinished: &quot;التحدي مكتمل!&quot;,
                gameStarted: &quot;بدأ التحدي! انقر على الأهداف!&quot;,
                gameOver: &quot;انتهى الوقت! النقاط النهائية:&quot;,
                newRecord: &quot;رقم قياسي جديد!&quot;,
                victoryTitle: &quot;🎉 ممتاز! 🎉&quot;,
                victoryMessage: &quot;ردود أفعال استثنائية!&quot;,
                defeatTitle: &quot;⏱️ انتهى الوقت ⏱️&quot;,
                defeatMessage: &quot;درب ردود أفعالك!&quot;,
                tryAgainText: &quot;حاول مرة أخرى&quot;,
                continueText: &quot;متابعة&quot;,
                aiExcellent: &quot;الذكاء: تم اكتشاف ردود أفعال استثنائية!&quot;,
                aiGood: &quot;الذكاء: سرعة رد فعل جيدة&quot;,
                aiAverage: &quot;الذكاء: ردود أفعال متوسطة&quot;,
                aiSlow: &quot;الذكاء: ينصح بالتدريب&quot;,
                combo2: &quot;كومبو x2!&quot;,
                combo3: &quot;كومبو x3!&quot;,
                combo5: &quot;كومبو x5!&quot;,
                perfect: &quot;مثالي!&quot;
            },
            es: {
                gameTitle: &quot;Desafío de Velocidad - 8 Velocidades&quot;,
                cyberBadge: &quot;🚀 IA FUTURISTA&quot;,
                controlsTitle: &quot;⚡ Controles Cyber&quot;,
                statsTitle: &quot;📊 Estadísticas&quot;,
                progressTitle: &quot;⏱️ Progreso&quot;,
                instructionsTitle: &quot;📖 Instrucciones&quot;,
                targetsTitle: &quot;🎯 8 Tipos de Objetivos&quot;,
                aiStatusTitle: &quot;🤖 Análisis IA&quot;,
                startText: &quot;Iniciar&quot;,
                resetText: &quot;Reiniciar&quot;,

                scoreLabel: &quot;Puntuación&quot;,
                hitsLabel: &quot;Objetivos&quot;,
                accuracyLabel: &quot;Precisión&quot;,
                bestLabel: &quot;Mejor&quot;,
                welcomeMessage: &quot;¡Bienvenido al Desafío de Velocidad! Haz clic en los objetivos lo más rápido posible.&quot;,
                readyMessage: &quot;¿Listo para el desafío de velocidad?&quot;,
                instructionsText: &quot;• Haz clic en los objetivos que aparecen&lt;br&gt;• Clics más rápidos = más puntos&lt;br&gt;• Evita los objetivos rojos (peligro)&lt;br&gt;• Objetivos amarillos = puntos bonus&lt;br&gt;• La IA analiza tu velocidad de reacción en tiempo real&quot;,
                normalText: &quot;Normal (+10 pts)&quot;,
                fastText: &quot;Rápido (+20 pts)&quot;,
                bonusText: &quot;Bonus (+50 pts)&quot;,
                dangerText: &quot;Peligro (-30 pts)&quot;,
                lightningText: &quot;Rayo (+75 pts)&quot;,
                megaText: &quot;Mega (+100 pts)&quot;,
                toxicText: &quot;Tóxico (-50 pts)&quot;,
                ultimateText: &quot;Supremo (+200 pts)&quot;,
                aiStatusText: &quot;IA Cyber Activa&quot;,
                aiAnalysisText: &quot;Análisis de reflejos en progreso...&quot;,
                progressReady: &quot;Listo para el desafío&quot;,
                progressActive: &quot;Desafío en progreso...&quot;,
                progressFinished: &quot;¡Desafío completado!&quot;,
                gameStarted: &quot;¡Desafío iniciado! ¡Haz clic en los objetivos!&quot;,
                gameOver: &quot;¡Se acabó el tiempo! Puntuación final:&quot;,
                newRecord: &quot;¡Nuevo récord!&quot;,
                victoryTitle: &quot;🎉 ¡EXCELENTE! 🎉&quot;,
                victoryMessage: &quot;¡Reflejos excepcionales!&quot;,
                defeatTitle: &quot;⏱️ SE ACABÓ EL TIEMPO ⏱️&quot;,
                defeatMessage: &quot;¡Entrena tus reflejos!&quot;,
                tryAgainText: &quot;Intentar de nuevo&quot;,
                continueText: &quot;Continuar&quot;,
                aiExcellent: &quot;IA: ¡Reflejos excepcionales detectados!&quot;,
                aiGood: &quot;IA: Buena velocidad de reacción&quot;,
                aiAverage: &quot;IA: Reflejos promedio&quot;,
                aiSlow: &quot;IA: Entrenamiento recomendado&quot;,
                combo2: &quot;¡COMBO x2!&quot;,
                combo3: &quot;¡COMBO x3!&quot;,
                combo5: &quot;¡COMBO x5!&quot;,
                perfect: &quot;¡PERFECTO!&quot;
            },
            de: {
                gameTitle: &quot;Geschwindigkeits-Challenge - 8 Geschwindigkeiten&quot;,
                cyberBadge: &quot;🚀 FUTURISTISCHE KI&quot;,
                controlsTitle: &quot;⚡ Cyber-Steuerung&quot;,
                statsTitle: &quot;📊 Statistiken&quot;,
                progressTitle: &quot;⏱️ Fortschritt&quot;,
                instructionsTitle: &quot;📖 Anweisungen&quot;,
                targetsTitle: &quot;🎯 8 Zieltypen&quot;,
                aiStatusTitle: &quot;🤖 KI-Analyse&quot;,
                startText: &quot;Start&quot;,
                resetText: &quot;Zurücksetzen&quot;,

                scoreLabel: &quot;Punkte&quot;,
                hitsLabel: &quot;Ziele&quot;,
                accuracyLabel: &quot;Genauigkeit&quot;,
                bestLabel: &quot;Beste&quot;,
                welcomeMessage: &quot;Willkommen zur Geschwindigkeits-Challenge! Klicke so schnell wie möglich auf die Ziele.&quot;,
                readyMessage: &quot;Bereit für die Geschwindigkeits-Challenge?&quot;,
                instructionsText: &quot;• Klicke auf erscheinende Ziele&lt;br&gt;• Schnellere Klicks = mehr Punkte&lt;br&gt;• Vermeide rote Ziele (Gefahr)&lt;br&gt;• Gelbe Ziele = Bonuspunkte&lt;br&gt;• KI analysiert deine Reaktionsgeschwindigkeit in Echtzeit&quot;,
                normalText: &quot;Normal (+10 Pkt)&quot;,
                fastText: &quot;Schnell (+20 Pkt)&quot;,
                bonusText: &quot;Bonus (+50 Pkt)&quot;,
                dangerText: &quot;Gefahr (-30 Pkt)&quot;,
                lightningText: &quot;Blitz (+75 Pkt)&quot;,
                megaText: &quot;Mega (+100 Pkt)&quot;,
                toxicText: &quot;Giftig (-50 Pkt)&quot;,
                ultimateText: &quot;Ultimativ (+200 Pkt)&quot;,
                aiStatusText: &quot;Cyber-KI Aktiv&quot;,
                aiAnalysisText: &quot;Reflexanalyse läuft...&quot;,
                progressReady: &quot;Bereit für Challenge&quot;,
                progressActive: &quot;Challenge läuft...&quot;,
                progressFinished: &quot;Challenge abgeschlossen!&quot;,
                gameStarted: &quot;Challenge gestartet! Klicke auf die Ziele!&quot;,
                gameOver: &quot;Zeit abgelaufen! Endpunktzahl:&quot;,
                newRecord: &quot;Neuer Rekord!&quot;,
                victoryTitle: &quot;🎉 AUSGEZEICHNET! 🎉&quot;,
                victoryMessage: &quot;Außergewöhnliche Reflexe!&quot;,
                defeatTitle: &quot;⏱️ ZEIT ABGELAUFEN ⏱️&quot;,
                defeatMessage: &quot;Trainiere deine Reflexe!&quot;,
                tryAgainText: &quot;Nochmal versuchen&quot;,
                continueText: &quot;Weiter&quot;,
                aiExcellent: &quot;KI: Außergewöhnliche Reflexe erkannt!&quot;,
                aiGood: &quot;KI: Gute Reaktionsgeschwindigkeit&quot;,
                aiAverage: &quot;KI: Durchschnittliche Reflexe&quot;,
                aiSlow: &quot;KI: Training empfohlen&quot;,
                combo2: &quot;COMBO x2!&quot;,
                combo3: &quot;COMBO x3!&quot;,
                combo5: &quot;COMBO x5!&quot;,
                perfect: &quot;PERFEKT!&quot;
            },
            zh: {
                gameTitle: &quot;速度挑战 - 8种速度&quot;,
                cyberBadge: &quot;🚀 未来人工智能&quot;,
                controlsTitle: &quot;⚡ 网络控制&quot;,
                statsTitle: &quot;📊 统计数据&quot;,
                progressTitle: &quot;⏱️ 进度&quot;,
                instructionsTitle: &quot;📖 说明&quot;,
                targetsTitle: &quot;🎯 8种目标类型&quot;,
                aiStatusTitle: &quot;🤖 AI分析&quot;,
                startText: &quot;开始&quot;,
                resetText: &quot;重置&quot;,

                scoreLabel: &quot;得分&quot;,
                hitsLabel: &quot;目标&quot;,
                accuracyLabel: &quot;准确度&quot;,
                bestLabel: &quot;最佳&quot;,
                welcomeMessage: &quot;欢迎来到速度挑战！尽可能快地点击目标。&quot;,
                readyMessage: &quot;准备好速度挑战了吗？&quot;,
                instructionsText: &quot;• 点击出现的目标&lt;br&gt;• 点击越快得分越多&lt;br&gt;• 避免红色目标（危险）&lt;br&gt;• 黄色目标 = 奖励分数&lt;br&gt;• AI实时分析你的反应速度&quot;,
                normalText: &quot;普通 (+10分)&quot;,
                fastText: &quot;快速 (+20分)&quot;,
                bonusText: &quot;奖励 (+50分)&quot;,
                dangerText: &quot;危险 (-30分)&quot;,
                lightningText: &quot;闪电 (+75分)&quot;,
                megaText: &quot;超级 (+100分)&quot;,
                toxicText: &quot;毒性 (-50分)&quot;,
                ultimateText: &quot;终极 (+200分)&quot;,
                aiStatusText: &quot;网络AI激活&quot;,
                aiAnalysisText: &quot;反射分析进行中...&quot;,
                progressReady: &quot;准备挑战&quot;,
                progressActive: &quot;挑战进行中...&quot;,
                progressFinished: &quot;挑战完成！&quot;,
                gameStarted: &quot;挑战开始！点击目标！&quot;,
                gameOver: &quot;时间到！最终得分：&quot;,
                newRecord: &quot;新记录！&quot;,
                victoryTitle: &quot;🎉 优秀！🎉&quot;,
                victoryMessage: &quot;反应超凡！&quot;,
                defeatTitle: &quot;⏱️ 时间到 ⏱️&quot;,
                defeatMessage: &quot;训练你的反应！&quot;,
                tryAgainText: &quot;再试一次&quot;,
                continueText: &quot;继续&quot;,
                aiExcellent: &quot;AI：检测到超凡反应！&quot;,
                aiGood: &quot;AI：良好的反应速度&quot;,
                aiAverage: &quot;AI：平均反应&quot;,
                aiSlow: &quot;AI：建议训练&quot;,
                combo2: &quot;连击 x2！&quot;,
                combo3: &quot;连击 x3！&quot;,
                combo5: &quot;连击 x5！&quot;,
                perfect: &quot;完美！&quot;
            }
        };

        // État du jeu
    var gameState = {
            currentLanguage: &#x27;fr&#x27;,
            isPlaying: false,
            timeLeft: 30.0,
            gameDuration: 30.0,
            score: 0,
            hits: 0,
            totalClicks: 0,
            bestScore: 0,
            targets: [],
            gameTimer: null,
            spawnTimer: null,
            combo: 0,
            lastHitTime: 0
        };

        // Types de cibles - 8 VITESSES
        const targetTypes = {
            normal: { points: 10, color: &#x27;target-normal&#x27;, icon: &#x27;🔵&#x27;, duration: 2000 },
            fast: { points: 20, color: &#x27;target-fast&#x27;, icon: &#x27;🟣&#x27;, duration: 1200 },
            bonus: { points: 50, color: &#x27;target-bonus&#x27;, icon: &#x27;🟡&#x27;, duration: 1800 },
            danger: { points: -30, color: &#x27;target-danger&#x27;, icon: &#x27;🔴&#x27;, duration: 2500 },
            lightning: { points: 75, color: &#x27;target-lightning&#x27;, icon: &#x27;⚡&#x27;, duration: 800 },
            mega: { points: 100, color: &#x27;target-mega&#x27;, icon: &#x27;💎&#x27;, duration: 1500 },
            toxic: { points: -50, color: &#x27;target-toxic&#x27;, icon: &#x27;☢️&#x27;, duration: 3000 },
            ultimate: { points: 200, color: &#x27;target-ultimate&#x27;, icon: &#x27;🌟&#x27;, duration: 600 }
        };

        // Créer les particules cyber
        function createCyberParticles() {
            const container = document.getElementById(&#x27;cyberParticles&#x27;);
            
            for(let i = 0; i &lt; 35; i++) {
                const particle = document.createElement(&#x27;div&#x27;);
                particle.className = &#x27;cyber-particle&#x27;;
                particle.style.left = Math.random() * 100 + &#x27;%&#x27;;
                particle.style.animationDelay = Math.random() * 12 + &#x27;s&#x27;;
                particle.style.animationDuration = (12 + Math.random() * 6) + &#x27;s&#x27;;
                container.appendChild(particle);
            }
        }

        // Fonction de changement de durée de jeu
        function changeGameDuration() {
            if(gameState.isPlaying) return; // Ne pas changer pendant le jeu
            
            const selector = document.getElementById(&#x27;timeSelector&#x27;);
            const selectedTime = parseInt(selector.value);
            gameState.gameDuration = selectedTime;
            gameState.timeLeft = selectedTime;
            
            // Mettre à jour l&#x27;affichage du temps
            updateTimeDisplay();
            updateProgressText();
            updateProgressBar();
            
            // Afficher un message de confirmation
            const t = translations[gameState.currentLanguage];
            let timeText = &#x27;&#x27;;
            if(selectedTime === 30) timeText = &#x27;30 secondes&#x27;;
            else if(selectedTime === 45) timeText = &#x27;45 secondes&#x27;;
            else if(selectedTime === 60) timeText = &#x27;1 minute&#x27;;
            
            showMessage(`Durée sélectionnée: ${timeText}`, 2000);
            
            console.log(&#x27;Durée changée:&#x27;, selectedTime, &#x27;secondes&#x27;);
        }

        // Fonction de changement de langue
        function changeLanguage() {
            const selector = document.getElementById(&#x27;languageSelector&#x27;);
            const selectedLang = selector.value;
            gameState.currentLanguage = selectedLang;
            
            const t = translations[selectedLang];
            
            // Mettre à jour tous les textes
            document.getElementById(&#x27;gameTitle&#x27;).textContent = t.gameTitle;
            document.getElementById(&#x27;cyberBadge&#x27;).textContent = t.cyberBadge;
            document.getElementById(&#x27;controlsTitle&#x27;).textContent = t.controlsTitle;
            document.getElementById(&#x27;statsTitle&#x27;).textContent = t.statsTitle;
            document.getElementById(&#x27;progressTitle&#x27;).textContent = t.progressTitle;
            document.getElementById(&#x27;instructionsTitle&#x27;).textContent = t.instructionsTitle;
            document.getElementById(&#x27;targetsTitle&#x27;).textContent = t.targetsTitle;
            document.getElementById(&#x27;aiStatusTitle&#x27;).textContent = t.aiStatusTitle;
            
            document.getElementById(&#x27;startText&#x27;).textContent = t.startText;
            document.getElementById(&#x27;resetText&#x27;).textContent = t.resetText;
            
            document.getElementById(&#x27;scoreLabel&#x27;).textContent = t.scoreLabel;
            document.getElementById(&#x27;hitsLabel&#x27;).textContent = t.hitsLabel;
            document.getElementById(&#x27;accuracyLabel&#x27;).textContent = t.accuracyLabel;
            document.getElementById(&#x27;bestLabel&#x27;).textContent = t.bestLabel;
            
            document.getElementById(&#x27;welcomeMessage&#x27;).textContent = t.welcomeMessage;
            document.getElementById(&#x27;readyMessage&#x27;).textContent = t.readyMessage;
            document.getElementById(&#x27;instructionsText&#x27;).innerHTML = t.instructionsText;
            document.getElementById(&#x27;normalText&#x27;).textContent = t.normalText;
            document.getElementById(&#x27;fastText&#x27;).textContent = t.fastText;
            document.getElementById(&#x27;bonusText&#x27;).textContent = t.bonusText;
            document.getElementById(&#x27;dangerText&#x27;).textContent = t.dangerText;
            document.getElementById(&#x27;lightningText&#x27;).textContent = t.lightningText;
            document.getElementById(&#x27;megaText&#x27;).textContent = t.megaText;
            document.getElementById(&#x27;toxicText&#x27;).textContent = t.toxicText;
            document.getElementById(&#x27;ultimateText&#x27;).textContent = t.ultimateText;
            document.getElementById(&#x27;aiStatusText&#x27;).textContent = t.aiStatusText;
            document.getElementById(&#x27;aiAnalysisText&#x27;).textContent = t.aiAnalysisText;
            
            updateProgressText();
        }

        // Démarrer le jeu
        function startGame() {
            if(gameState.isPlaying) return;
            
            gameState.isPlaying = true;
            gameState.timeLeft = gameState.gameDuration;
            gameState.score = 0;
            gameState.hits = 0;
            gameState.totalClicks = 0;
            gameState.combo = 0;
            gameState.targets = [];
            
            // Désactiver le sélecteur de temps pendant le jeu
            document.getElementById(&#x27;timeSelector&#x27;).disabled = true;
            
            const t = translations[gameState.currentLanguage];
            showMessage(t.gameStarted, 2000);
            
            // Vider l&#x27;arène
            const arena = document.getElementById(&#x27;speedArena&#x27;);
            arena.innerHTML = &#x27;&#x27;;
            
            // Démarrer les timers
            startGameTimer();
            startTargetSpawning();
            
            updateDisplay();
            updateProgressText();
        }

        // Timer principal du jeu
        function startGameTimer() {
            gameState.gameTimer = setInterval(() =&gt; {
                gameState.timeLeft -= 0.1;
                
                if(gameState.timeLeft &lt;= 0) {
                    gameState.timeLeft = 0;
                    endGame();
                    return;
                }
                
                updateTimeDisplay();
                updateProgressText();
                updateProgressBar();
            }, 100);
        }

        // Génération des cibles
        function startTargetSpawning() {
            const spawnTarget = () =&gt; {
                if(!gameState.isPlaying) return;
                
                createTarget();
                
                // Intervalle variable selon le temps restant
                const baseInterval = 800;
                const speedMultiplier = Math.max(0.3, gameState.timeLeft / 30);
                const nextSpawn = baseInterval * speedMultiplier + Math.random() * 400;
                
                gameState.spawnTimer = setTimeout(spawnTarget, nextSpawn);
            };
            
            setTimeout(spawnTarget, 1000);
        }

        // Créer une cible
        function createTarget() {
            const arena = document.getElementById(&#x27;speedArena&#x27;);
            const arenaRect = arena.getBoundingClientRect();
            
            // Choisir le type de cible - 8 VITESSES
            const rand = Math.random();
            let type;
            if(rand &lt; 0.35) type = &#x27;normal&#x27;;
            else if(rand &lt; 0.55) type = &#x27;fast&#x27;;
            else if(rand &lt; 0.7) type = &#x27;bonus&#x27;;
            else if(rand &lt; 0.8) type = &#x27;danger&#x27;;
            else if(rand &lt; 0.88) type = &#x27;lightning&#x27;;
            else if(rand &lt; 0.94) type = &#x27;mega&#x27;;
            else if(rand &lt; 0.97) type = &#x27;toxic&#x27;;
            else type = &#x27;ultimate&#x27;;
            
            const targetInfo = targetTypes[type];
            
            // Créer l&#x27;élément cible
            const target = document.createElement(&#x27;div&#x27;);
            target.className = `speed-target ${targetInfo.color}`;
            target.textContent = targetInfo.icon;
            target.dataset.type = type;
            target.dataset.points = targetInfo.points;
            
            // Position aléatoire
            const maxX = arena.clientWidth - 80;
            const maxY = arena.clientHeight - 80;
            target.style.left = Math.random() * maxX + &#x27;px&#x27;;
            target.style.top = Math.random() * maxY + &#x27;px&#x27;;
            
            // Événement de clic
            target.addEventListener(&#x27;click&#x27;, () =&gt; hitTarget(target));
            
            arena.appendChild(target);
            gameState.targets.push(target);
            
            // Supprimer automatiquement après la durée
            setTimeout(() =&gt; {
                if(target.parentNode) {
                    target.classList.add(&#x27;miss&#x27;);
                    setTimeout(() =&gt; {
                        if(target.parentNode) {
                            arena.removeChild(target);
                            const index = gameState.targets.indexOf(target);
                            if(index &gt; -1) gameState.targets.splice(index, 1);
                        }
                    }, 800);
                }
            }, targetInfo.duration);
        }

        // Cible touchée
        function hitTarget(target) {
            if(!gameState.isPlaying) return;
            
            const points = parseInt(target.dataset.points);
            const type = target.dataset.type;
            
            gameState.totalClicks++;
            
            if(points &gt; 0) {
                gameState.hits++;
                gameState.score += points;
                
                // Système de combo
                const now = Date.now();
                if(now - gameState.lastHitTime &lt; 1000) {
                    gameState.combo++;
                } else {
                    gameState.combo = 1;
                }
                gameState.lastHitTime = now;
                
                // Bonus de combo
                if(gameState.combo &gt;= 5) {
                    gameState.score += 25;
                    showComboEffect(target, &#x27;combo5&#x27;);
                } else if(gameState.combo &gt;= 3) {
                    gameState.score += 15;
                    showComboEffect(target, &#x27;combo3&#x27;);
                } else if(gameState.combo &gt;= 2) {
                    gameState.score += 5;
                    showComboEffect(target, &#x27;combo2&#x27;);
                }
                
                target.classList.add(&#x27;hit&#x27;);
            } else {
                gameState.score += points; // Points négatifs
                gameState.combo = 0;
                target.classList.add(&#x27;miss&#x27;);
            }
            
            // Supprimer la cible
            setTimeout(() =&gt; {
                if(target.parentNode) {
                    target.parentNode.removeChild(target);
                    const index = gameState.targets.indexOf(target);
                    if(index &gt; -1) gameState.targets.splice(index, 1);
                }
            }, 500);
            
            updateDisplay();
        }

        // Effet de combo
        function showComboEffect(target, comboType) {
            const t = translations[gameState.currentLanguage];
            const effect = document.createElement(&#x27;div&#x27;);
            effect.className = &#x27;combo-effect&#x27;;
            effect.textContent = t[comboType];
            
            const rect = target.getBoundingClientRect();
            const arena = document.getElementById(&#x27;speedArena&#x27;);
            const arenaRect = arena.getBoundingClientRect();
            
            effect.style.left = (rect.left - arenaRect.left + 40) + &#x27;px&#x27;;
            effect.style.top = (rect.top - arenaRect.top + 40) + &#x27;px&#x27;;
            
            arena.appendChild(effect);
            
            setTimeout(() =&gt; {
                if(effect.parentNode) {
                    arena.removeChild(effect);
                }
            }, 2000);
        }

        // Fin de jeu
        function endGame() {
            gameState.isPlaying = false;
            
            // Réactiver le sélecteur de temps
            document.getElementById(&#x27;timeSelector&#x27;).disabled = false;
            
            // Arrêter les timers
            if(gameState.gameTimer) {
                clearInterval(gameState.gameTimer);
                gameState.gameTimer = null;
            }
            if(gameState.spawnTimer) {
                clearTimeout(gameState.spawnTimer);
                gameState.spawnTimer = null;
            }
            
            // Vérifier le record
            if(gameState.score &gt; gameState.bestScore) {
                gameState.bestScore = gameState.score;
                localStorage.setItem(&#x27;speedChallengeBest&#x27;, gameState.bestScore);
            }
            
            // Nettoyer l&#x27;arène
            const arena = document.getElementById(&#x27;speedArena&#x27;);
            arena.innerHTML = `&lt;div style=&quot;color: #00ffff; font-size: 18px; text-align: center;&quot;&gt;
                &lt;span id=&quot;readyMessage&quot;&gt;${translations[gameState.currentLanguage].readyMessage}&lt;/span&gt;
            &lt;/div&gt;`;
            
            const t = translations[gameState.currentLanguage];
            showMessage(`${t.gameOver} ${gameState.score}`, 5000);
            
            updateDisplay();
            updateAIAnalysis();
            updateProgressText();
            
            // Afficher l&#x27;écran de fin
            setTimeout(() =&gt; {
                if(gameState.score &gt;= 500) {
                    showVictory();
                } else {
                    showDefeat();
                }
            }, 1000);
        }

        // Réinitialiser le jeu
        function resetGame() {
            // Fermer les overlays
            const victoryOverlay = document.querySelector(&#x27;.victory-animation&#x27;);
            const defeatOverlay = document.querySelector(&#x27;.defeat-animation&#x27;);
            if(victoryOverlay) document.body.removeChild(victoryOverlay);
            if(defeatOverlay) document.body.removeChild(defeatOverlay);
            
            gameState.isPlaying = false;
            gameState.timeLeft = gameState.gameDuration;
            gameState.score = 0;
            gameState.hits = 0;
            gameState.totalClicks = 0;
            gameState.combo = 0;
            gameState.targets = [];
            
            // Réactiver le sélecteur de temps
            document.getElementById(&#x27;timeSelector&#x27;).disabled = false;
            
            // Arrêter les timers
            if(gameState.gameTimer) {
                clearInterval(gameState.gameTimer);
                gameState.gameTimer = null;
            }
            if(gameState.spawnTimer) {
                clearTimeout(gameState.spawnTimer);
                gameState.spawnTimer = null;
            }
            
            // Réinitialiser l&#x27;arène
            const arena = document.getElementById(&#x27;speedArena&#x27;);
            arena.innerHTML = `&lt;div style=&quot;color: #00ffff; font-size: 18px; text-align: center;&quot;&gt;
                &lt;span id=&quot;readyMessage&quot;&gt;${translations[gameState.currentLanguage].readyMessage}&lt;/span&gt;
            &lt;/div&gt;`;
            
            const t = translations[gameState.currentLanguage];
            showMessage(t.welcomeMessage);
            
            updateDisplay();
            updateTimeDisplay();
            updateProgressText();
        }

        // Afficher un message
        function showMessage(message, duration = 0) {
            const messageElement = document.getElementById(&#x27;gameMessage&#x27;);
            messageElement.textContent = message;
            
            if(duration &gt; 0) {
                setTimeout(() =&gt; {
                    const t = translations[gameState.currentLanguage];
                    if(!gameState.isPlaying) {
                        messageElement.textContent = t.welcomeMessage;
                    }
                }, duration);
            }
        }

        // Mettre à jour l&#x27;affichage
        function updateDisplay() {
            document.getElementById(&#x27;scoreValue&#x27;).textContent = gameState.score;
            document.getElementById(&#x27;hitsValue&#x27;).textContent = gameState.hits;
            document.getElementById(&#x27;bestValue&#x27;).textContent = gameState.bestScore;
            
            // Calculer la précision
            const accuracy = gameState.totalClicks &gt; 0 ? 
                Math.round((gameState.hits / gameState.totalClicks) * 100) : 100;
            document.getElementById(&#x27;accuracyValue&#x27;).textContent = accuracy + &#x27;%&#x27;;
        }

        // Mettre à jour l&#x27;affichage du temps
        function updateTimeDisplay() {
            const timeDisplay = document.getElementById(&#x27;timeDisplay&#x27;);
            if(gameState.isPlaying) {
                timeDisplay.textContent = gameState.timeLeft.toFixed(1) + &#x27;s&#x27;;
                // Changer la couleur selon le temps restant
                if(gameState.timeLeft &lt;= 5) {
                    timeDisplay.style.color = &#x27;#ff0000&#x27;;
                    timeDisplay.style.textShadow = &#x27;0 0 25px rgba(255, 0, 0, 0.9)&#x27;;
                } else if(gameState.timeLeft &lt;= 10) {
                    timeDisplay.style.color = &#x27;#ffff00&#x27;;
                    timeDisplay.style.textShadow = &#x27;0 0 25px rgba(255, 255, 0, 0.9)&#x27;;
                } else {
                    timeDisplay.style.color = &#x27;#00ffff&#x27;;
                    timeDisplay.style.textShadow = &#x27;0 0 25px rgba(0, 255, 255, 0.9)&#x27;;
                }
            } else {
                timeDisplay.textContent = gameState.timeLeft.toFixed(1) + &#x27;s&#x27;;
                timeDisplay.style.color = &#x27;#00ffff&#x27;;
                timeDisplay.style.textShadow = &#x27;0 0 25px rgba(0, 255, 255, 0.9)&#x27;;
            }
            
            // Mettre à jour aussi le sélecteur
            const selector = document.getElementById(&#x27;timeSelector&#x27;);
            selector.value = gameState.gameDuration.toString();
        }

        // Mettre à jour la barre de progression
        function updateProgressBar() {
            if(gameState.isPlaying) {
                const progress = ((gameState.gameDuration - gameState.timeLeft) / gameState.gameDuration) * 100;
                document.getElementById(&#x27;progressFill&#x27;).style.width = `${progress}%`;
            } else {
                // Réinitialiser la barre quand le jeu n&#x27;est pas en cours
                document.getElementById(&#x27;progressFill&#x27;).style.width = &#x27;0%&#x27;;
            }
        }

        // Mettre à jour le texte de progression
        function updateProgressText() {
            const t = translations[gameState.currentLanguage];
            const progressText = document.getElementById(&#x27;progressText&#x27;);
            
            if(!gameState.isPlaying &amp;&amp; gameState.timeLeft === gameState.gameDuration) {
                // Afficher la durée sélectionnée quand prêt
                let timeText = &#x27;&#x27;;
                if(gameState.gameDuration === 30) timeText = &#x27;30 secondes&#x27;;
                else if(gameState.gameDuration === 45) timeText = &#x27;45 secondes&#x27;;
                else if(gameState.gameDuration === 60) timeText = &#x27;1 minute&#x27;;
                progressText.textContent = `${t.progressReady} - ${timeText}`;
            } else if(gameState.isPlaying) {
                progressText.textContent = `${t.progressActive} ${gameState.timeLeft.toFixed(1)}s`;
            } else {
                progressText.textContent = t.progressFinished;
            }
        }

        // Mettre à jour l&#x27;analyse IA
        function updateAIAnalysis() {
            const t = translations[gameState.currentLanguage];
            const aiAnalysisElement = document.getElementById(&#x27;aiAnalysisText&#x27;);
            
            const accuracy = gameState.totalClicks &gt; 0 ? 
                (gameState.hits / gameState.totalClicks) : 0;
            const avgReactionTime = gameState.hits &gt; 0 ? 
                (30000 - gameState.timeLeft * 1000) / gameState.hits : 1000;
            
            if(accuracy &gt;= 0.9 &amp;&amp; avgReactionTime &lt; 800) {
                aiAnalysisElement.textContent = t.aiExcellent;
            } else if(accuracy &gt;= 0.7 &amp;&amp; avgReactionTime &lt; 1200) {
                aiAnalysisElement.textContent = t.aiGood;
            } else if(accuracy &gt;= 0.5) {
                aiAnalysisElement.textContent = t.aiAverage;
            } else {
                aiAnalysisElement.textContent = t.aiSlow;
            }
        }

        // Afficher la victoire
        function showVictory() {
            const t = translations[gameState.currentLanguage];
            
            const overlay = document.createElement(&#x27;div&#x27;);
            overlay.className = &#x27;victory-animation&#x27;;
            
            const content = document.createElement(&#x27;div&#x27;);
            content.className = &#x27;victory-content&#x27;;
            content.innerHTML = `
                &lt;h2&gt;${t.victoryTitle}&lt;/h2&gt;
                &lt;p style=&quot;margin: 20px 0;&quot;&gt;${t.victoryMessage}&lt;/p&gt;
                &lt;p style=&quot;margin: 15px 0; color: #00ffff;&quot;&gt;Score Final: ${gameState.score}&lt;/p&gt;
                &lt;p style=&quot;margin: 15px 0; color: #ffff00;&quot;&gt;Précision: ${Math.round((gameState.hits / gameState.totalClicks) * 100)}%&lt;/p&gt;
                ${gameState.score &gt; gameState.bestScore ? `&lt;p style=&quot;margin: 15px 0; color: #ff00ff;&quot;&gt;${t.newRecord}&lt;/p&gt;` : &#x27;&#x27;}
                &lt;button onclick=&quot;resetGame()&quot; style=&quot;
                    margin: 20px 10px 10px 10px;
                    padding: 15px 30px;
                    background: linear-gradient(145deg, #00ffff, #0099cc);
                    color: white;
                    border: none;
                    border-radius: 15px;
                    font-size: 16px;
                    font-weight: bold;
                    cursor: pointer;
                    transition: all 0.3s ease;
                &quot;&gt;${t.continueText}&lt;/button&gt;
            `;
            
            overlay.appendChild(content);
            document.body.appendChild(overlay);
        }

        // Afficher la défaite
        function showDefeat() {
            const t = translations[gameState.currentLanguage];
            
            const overlay = document.createElement(&#x27;div&#x27;);
            overlay.className = &#x27;defeat-animation&#x27;;
            
            const content = document.createElement(&#x27;div&#x27;);
            content.className = &#x27;defeat-content&#x27;;
            content.innerHTML = `
                &lt;h2&gt;${t.defeatTitle}&lt;/h2&gt;
                &lt;p style=&quot;margin: 20px 0;&quot;&gt;${t.defeatMessage}&lt;/p&gt;
                &lt;p style=&quot;margin: 15px 0; color: #ff0066;&quot;&gt;Score Final: ${gameState.score}&lt;/p&gt;
                &lt;p style=&quot;margin: 15px 0; color: #ffff00;&quot;&gt;Cibles Touchées: ${gameState.hits}&lt;/p&gt;
                ${gameState.score &gt; gameState.bestScore ? `&lt;p style=&quot;margin: 15px 0; color: #00ffff;&quot;&gt;${t.newRecord}&lt;/p&gt;` : &#x27;&#x27;}
                &lt;button onclick=&quot;resetGame()&quot; style=&quot;
                    margin: 20px 10px 10px 10px;
                    padding: 15px 30px;
                    background: linear-gradient(145deg, #00ffff, #0099cc);
                    color: white;
                    border: none;
                    border-radius: 15px;
                    font-size: 16px;
                    font-weight: bold;
                    cursor: pointer;
                    transition: all 0.3s ease;
                &quot;&gt;${t.tryAgainText}&lt;/button&gt;
            `;
            
            overlay.appendChild(content);
            document.body.appendChild(overlay);
        }

        // Charger le meilleur score
        function loadBestScore() {
            const saved = localStorage.getItem(&#x27;speedChallengeBest&#x27;);
            if(saved) {
                gameState.bestScore = parseInt(saved);
            }
        }

        // Initialisation
        document.addEventListener(&#x27;DOMContentLoaded&#x27;, function() {
            createCyberParticles();
            loadBestScore();
            updateDisplay();
            updateTimeDisplay();
            updateProgressText();
        });
    &lt;/script&gt;
&lt;script&gt;(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement(&#x27;script&#x27;);d.innerHTML=&quot;window.__CF$cv$params={r:&#x27;985188751748e1b2&#x27;,t:&#x27;MTc1ODg3NjgyOS4wMDAwMDA=&#x27;};var a=document.createElement(&#x27;script&#x27;);a.nonce=&#x27;&#x27;;a.src=&#x27;/cdn-cgi/challenge-platform/scripts/jsd/main.js&#x27;;document.getElementsByTagName(&#x27;head&#x27;)[0].appendChild(a);&quot;;b.getElementsByTagName(&#x27;head&#x27;)[0].appendChild(d)}}if(document.body){var a=document.createElement(&#x27;iframe&#x27;);a.height=1;a.width=1;a.style.position=&#x27;absolute&#x27;;a.style.top=0;a.style.left=0;a.style.border=&#x27;none&#x27;;a.style.visibility=&#x27;hidden&#x27;;document.body.appendChild(a);if(&#x27;loading&#x27;!==document.readyState)c();else if(window.addEventListener)document.addEventListener(&#x27;DOMContentLoaded&#x27;,c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);&#x27;loading&#x27;!==document.readyState&amp;&amp;(document.onreadystatechange=e,c())}}}})();&lt;/script&gt;&lt;/body&gt;
&lt;/html&gt;
" style="width:100%;height:100%;border:none;"></iframe>
</div>

<script>
function launchGame8() {
  const overlay = document.getElementById("game8Overlay");
  overlay.style.display = "block";
}
function closeGame8() {
  const overlay = document.getElementById("game8Overlay");
  overlay.style.display = "none";
}
document.addEventListener("keydown", function(e) {
  if (e.key === "Escape") {
    const overlay = document.getElementById("game8Overlay");
    if (overlay && overlay.style.display === "block") {
      e.preventDefault();
      e.stopPropagation();
      closeGame8();
    }
  }
}, true);
</script>


<div id="game9Overlay" style="display:none;position:fixed;inset:0;background:#000;z-index:9999;">
  <button onclick="closeGame9()" style="position:absolute;top:10px;right:10px;z-index:10000;
    font-size:24px;background:red;color:white;border:none;border-radius:50%;width:40px;height:40px;
    cursor:pointer;">✖</button>
  <iframe id="iframeGame9" srcdoc="&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;fr&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;🔮 Cyber Checker - Connexion Quantique&lt;/title&gt;
    &lt;script src=&quot;https://cdn.tailwindcss.com&quot;&gt;&lt;/script&gt;
    &lt;style&gt;
        body {
            box-sizing: border-box;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: &#x27;Segoe UI&#x27;, Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0a1f 0%, #1a0a3e 30%, #2e1065 70%, #4c1d95 100%);
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }

        /* Particules quantiques d&#x27;arrière-plan */
        .quantum-particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .quantum-particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: #8b5cf6;
            border-radius: 50%;
            animation: quantumFloat 15s infinite linear;
            box-shadow: 0 0 15px #8b5cf6, 0 0 30px #a855f7;
        }

        @keyframes quantumFloat {
            0% {
                transform: translateY(100vh) translateX(0) rotate(0deg) scale(0);
                opacity: 0;
            }
            10% {
                opacity: 1;
                transform: translateY(90vh) translateX(30px) rotate(60deg) scale(1);
            }
            50% {
                transform: translateY(50vh) translateX(-40px) rotate(180deg) scale(1.5);
            }
            90% {
                opacity: 1;
                transform: translateY(10vh) translateX(50px) rotate(300deg) scale(1);
            }
            100% {
                transform: translateY(-10vh) translateX(100px) rotate(360deg) scale(0);
                opacity: 0;
            }
        }

        /* Grille quantique de fond */
        .quantum-grid {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(139, 92, 246, 0.15) 1px, transparent 1px),
                linear-gradient(90deg, rgba(139, 92, 246, 0.15) 1px, transparent 1px);
            background-size: 80px 80px;
            animation: quantumGridPulse 20s linear infinite;
            z-index: 1;
        }

        @keyframes quantumGridPulse {
            0%, 100% { 
                transform: translate(0, 0) scale(1);
                opacity: 0.3;
            }
            50% { 
                transform: translate(40px, 40px) scale(1.05);
                opacity: 0.6;
            }
        }

        /* Container principal */
        .cyber-checker-container {
            position: relative;
            z-index: 10;
            display: grid;
            grid-template-columns: 280px 1fr 280px;
            grid-template-rows: 1fr;
            gap: 20px;
            min-height: 100vh;
            padding: 20px;
            max-width: 100%;
            margin: 0;
        }

        .game-panel {
            background: linear-gradient(145deg, 
                rgba(30, 20, 60, 0.95) 0%,
                rgba(50, 25, 100, 0.95) 50%,
                rgba(76, 29, 149, 0.95) 100%);
            backdrop-filter: blur(30px);
            border-radius: 25px;
            padding: 25px;
            width: 100%;
            height: fit-content;
            box-shadow: 
                0 30px 60px rgba(0, 0, 0, 0.8),
                0 0 120px rgba(139, 92, 246, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            border: 3px solid rgba(139, 92, 246, 0.5);
            animation: quantumPanelGlow 5s ease-in-out infinite alternate;
            grid-column: 2;
        }

        .left-panel, .right-panel {
            background: linear-gradient(145deg, 
                rgba(30, 20, 60, 0.95) 0%,
                rgba(50, 25, 100, 0.95) 50%,
                rgba(76, 29, 149, 0.95) 100%);
            backdrop-filter: blur(30px);
            border-radius: 20px;
            padding: 20px;
            height: fit-content;
            box-shadow: 
                0 20px 40px rgba(0, 0, 0, 0.6),
                0 0 80px rgba(139, 92, 246, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            border: 3px solid rgba(139, 92, 246, 0.4);
        }

        .right-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .panel-section {
            margin-bottom: 25px;
        }

        @keyframes quantumPanelGlow {
            from { 
                box-shadow: 
                    0 30px 60px rgba(0, 0, 0, 0.8),
                    0 0 120px rgba(139, 92, 246, 0.3),
                    inset 0 1px 0 rgba(255, 255, 255, 0.1);
            }
            to { 
                box-shadow: 
                    0 35px 70px rgba(0, 0, 0, 0.8),
                    0 0 150px rgba(139, 92, 246, 0.4),
                    inset 0 1px 0 rgba(255, 255, 255, 0.2);
            }
        }

        /* En-tête du jeu */
        .quantum-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 25px;
            border-bottom: 3px solid rgba(139, 92, 246, 0.5);
        }

        .quantum-title {
            display: flex;
            align-items: center;
            gap: 25px;
        }

        .quantum-title h1 {
            color: #8b5cf6;
            margin: 0;
            font-size: 28px;
            font-weight: 700;
            text-shadow: 0 0 40px rgba(139, 92, 246, 0.9);
            animation: quantumTitlePulse 4s infinite alternate;
        }

        @keyframes quantumTitlePulse {
            from { 
                text-shadow: 0 0 40px rgba(139, 92, 246, 0.9);
                transform: scale(1);
            }
            to { 
                text-shadow: 0 0 50px rgba(139, 92, 246, 1);
                transform: scale(1.05);
            }
        }

        .quantum-icon {
            font-size: 36px;
            animation: quantumIconRotate 6s ease-in-out infinite;
            filter: drop-shadow(0 0 25px #8b5cf6);
        }

        @keyframes quantumIconRotate {
            0%, 100% { transform: scale(1) rotate(0deg); }
            25% { transform: scale(1.2) rotate(90deg); }
            50% { transform: scale(1.1) rotate(180deg); }
            75% { transform: scale(1.2) rotate(270deg); }
        }

        .quantum-badge {
            background: linear-gradient(45deg, #8b5cf6, #a855f7, #c084fc, #e879f9);
            background-size: 400% 400%;
            color: white;
            padding: 15px 25px;
            border-radius: 25px;
            font-size: 13px;
            font-weight: bold;
            animation: quantumBadgeShine 5s ease-in-out infinite;
            box-shadow: 0 0 30px rgba(139, 92, 246, 0.7);
        }

        @keyframes quantumBadgeShine {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        /* Sélecteur de langue personnalisé */
        .language-dropdown {
            position: relative;
            display: inline-block;
        }

        .language-selector {
            background: linear-gradient(145deg, 
                rgba(30, 20, 60, 0.95) 0%,
                rgba(50, 25, 100, 0.95) 30%,
                rgba(76, 29, 149, 0.95) 70%,
                rgba(139, 92, 246, 0.95) 100%);
            color: #8b5cf6;
            border: 3px solid rgba(139, 92, 246, 0.6);
            border-radius: 20px;
            padding: 15px 22px;
            font-weight: bold;
            cursor: pointer;
            font-size: 15px;
            transition: all 0.4s ease;
            box-shadow: 
                0 0 30px rgba(139, 92, 246, 0.4),
                0 0 50px rgba(168, 85, 247, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            min-width: 180px;
            text-shadow: 0 0 15px rgba(139, 92, 246, 0.8);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }

        .language-selector:hover {
            background: linear-gradient(145deg, 
                rgba(139, 92, 246, 0.9) 0%,
                rgba(168, 85, 247, 0.9) 30%,
                rgba(192, 132, 252, 0.9) 70%,
                rgba(232, 121, 249, 0.9) 100%);
            transform: translateY(-3px);
            box-shadow: 
                0 10px 30px rgba(139, 92, 246, 0.6),
                0 0 60px rgba(168, 85, 247, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
            color: white;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.8);
        }

        .language-dropdown-arrow {
            font-size: 12px;
            transition: transform 0.3s ease;
        }

        .language-dropdown.open .language-dropdown-arrow {
            transform: rotate(180deg);
        }

        .language-dropdown-menu {
            position: absolute;
            top: 100%;
            right: 0;
            background: linear-gradient(145deg, 
                rgba(30, 20, 60, 0.98) 0%,
                rgba(50, 25, 100, 0.98) 50%,
                rgba(76, 29, 149, 0.98) 100%);
            backdrop-filter: blur(30px);
            border: 3px solid rgba(139, 92, 246, 0.6);
            border-radius: 15px;
            box-shadow: 
                0 20px 40px rgba(0, 0, 0, 0.8),
                0 0 60px rgba(139, 92, 246, 0.4);
            min-width: 200px;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px);
            transition: all 0.3s ease;
            margin-top: 10px;
        }

        .language-dropdown.open .language-dropdown-menu {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .language-option {
            padding: 15px 20px;
            color: #8b5cf6;
            cursor: pointer;
            transition: all 0.3s ease;
            border-bottom: 1px solid rgba(139, 92, 246, 0.2);
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .language-option:last-child {
            border-bottom: none;
            border-radius: 0 0 12px 12px;
        }

        .language-option:first-child {
            border-radius: 12px 12px 0 0;
        }

        .language-option:hover {
            background: rgba(139, 92, 246, 0.3);
            color: white;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.8);
        }

        .language-option.active {
            background: rgba(139, 92, 246, 0.5);
            color: white;
        }

        /* Panneau de titre des sections */
        .panel-title {
            color: #8b5cf6;
            font-size: 17px;
            font-weight: bold;
            margin-bottom: 20px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 20px rgba(139, 92, 246, 0.9);
            border-bottom: 3px solid rgba(139, 92, 246, 0.4);
            padding-bottom: 12px;
        }

        /* Plateau hexagonal */
        .hex-board {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 15px;
            border: 3px solid rgba(139, 92, 246, 0.6);
            box-shadow: 
                0 0 40px rgba(139, 92, 246, 0.4),
                inset 0 0 20px rgba(139, 92, 246, 0.1);
            width: 100%;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
        }

        .hex-row {
            display: flex;
            gap: 4px;
            align-items: center;
        }

        .hex-cell {
            width: 40px;
            height: 40px;
            background: linear-gradient(145deg, #374151, #1f2937);
            clip-path: polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%);
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid transparent;
            font-size: 16px;
        }

        .hex-cell:hover {
            background: linear-gradient(145deg, #6b21a8, #7c3aed);
            box-shadow: 0 0 25px rgba(139, 92, 246, 0.6);
            transform: scale(1.1);
        }

        .hex-cell.player {
            background: linear-gradient(145deg, #3b82f6, #1d4ed8);
            box-shadow: 0 0 25px rgba(59, 130, 246, 0.8);
            color: white;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.8);
        }

        .hex-cell.ai {
            background: linear-gradient(145deg, #ef4444, #dc2626);
            box-shadow: 0 0 25px rgba(239, 68, 68, 0.8);
            color: white;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.8);
        }

        .hex-cell.connected {
            animation: connectionPulse 2s ease-in-out infinite alternate;
        }

        @keyframes connectionPulse {
            from { 
                box-shadow: 0 0 25px rgba(139, 92, 246, 0.8);
                transform: scale(1);
            }
            to { 
                box-shadow: 0 0 35px rgba(139, 92, 246, 1);
                transform: scale(1.05);
            }
        }

        .hex-cell.winning-path {
            background: linear-gradient(145deg, #fbbf24, #f59e0b);
            box-shadow: 0 0 30px rgba(251, 191, 36, 1);
            animation: winningGlow 1s ease-in-out infinite alternate;
        }

        @keyframes winningGlow {
            from { 
                box-shadow: 0 0 30px rgba(251, 191, 36, 1);
            }
            to { 
                box-shadow: 0 0 40px rgba(251, 191, 36, 1.2);
            }
        }

        /* Contrôles du jeu */
        .game-controls {
            display: flex;
            justify-content: center;
            gap: 25px;
            margin-top: 25px;
        }

        .quantum-btn {
            padding: 18px 35px;
            background: linear-gradient(145deg, #8b5cf6, #7c3aed);
            color: white;
            border: none;
            border-radius: 20px;
            font-weight: bold;
            font-size: 15px;
            cursor: pointer;
            transition: all 0.4s ease;
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 1px;
            min-width: 160px;
            box-shadow: 0 0 25px rgba(139, 92, 246, 0.4);
        }

        .compact-btn {
            padding: 12px 20px;
            font-size: 13px;
            min-width: 120px;
            letter-spacing: 0.5px;
        }

        .quantum-btn::before {
            content: &#x27;&#x27;;
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            transition: left 0.6s ease;
        }

        .quantum-btn:hover::before {
            left: 100%;
        }

        .quantum-btn:hover {
            transform: translateY(-4px);
            box-shadow: 0 10px 30px rgba(139, 92, 246, 0.6);
            background: linear-gradient(145deg, #7c3aed, #6b21a8);
        }

        .quantum-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .new-game-btn {
            background: linear-gradient(145deg, #10b981, #059669);
        }

        .new-game-btn:hover {
            background: linear-gradient(145deg, #059669, #047857);
        }

        .hint-btn {
            background: linear-gradient(145deg, #f59e0b, #d97706);
        }

        .hint-btn:hover {
            background: linear-gradient(145deg, #d97706, #b45309);
        }

        /* Statistiques du jeu */
        .game-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 25px;
        }

        .stat-item {
            background: rgba(139, 92, 246, 0.15);
            padding: 15px;
            border-radius: 15px;
            text-align: center;
            border: 3px solid rgba(139, 92, 246, 0.3);
            position: relative;
            overflow: hidden;
        }

        .stat-item::before {
            content: &#x27;&#x27;;
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(139, 92, 246, 0.3), transparent);
            animation: statQuantumScan 5s linear infinite;
        }

        @keyframes statQuantumScan {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .stat-label {
            display: block;
            color: #a1a1aa;
            font-size: 12px;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-value {
            display: block;
            color: #8b5cf6;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 0 0 20px rgba(139, 92, 246, 0.9);
            position: relative;
            z-index: 1;
        }

        /* Messages de jeu */
        .game-message {
            text-align: center;
            margin-bottom: 20px;
            padding: 15px;
            border-radius: 12px;
            background: rgba(139, 92, 246, 0.15);
            border: 2px solid rgba(139, 92, 246, 0.3);
            color: #8b5cf6;
            font-weight: bold;
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }

        /* IA Status */
        .ai-thinking {
            animation: aiThinking 2s ease-in-out infinite;
        }

        @keyframes aiThinking {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Responsive */
        @media (max-width: 1200px) {
            .cyber-checker-container {
                grid-template-columns: 220px 1fr 220px;
                gap: 15px;
                padding: 15px;
            }
        }

        @media (max-width: 900px) {
            .cyber-checker-container {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto auto;
                gap: 15px;
            }
            
            .left-panel {
                grid-row: 2;
            }
            
            .right-panel {
                grid-row: 3;
            }
        }

        @media (max-width: 768px) {
            .game-panel {
                padding: 20px;
            }
            
            .quantum-title h1 {
                font-size: 20px;
            }
            
            .hex-board {
                max-width: 400px;
                padding: 15px;
            }
            
            .hex-cell {
                width: 35px;
                height: 35px;
                font-size: 16px;
            }
            
            .game-controls {
                flex-direction: column;
                gap: 15px;
            }
            
            .quantum-btn {
                min-width: 140px;
                padding: 15px 25px;
            }
        }

        @media (max-width: 480px) {
            .hex-board {
                max-width: 320px;
            }
            
            .hex-cell {
                width: 30px;
                height: 30px;
                font-size: 14px;
            }
            
            .quantum-title {
                flex-direction: column;
                gap: 15px;
            }
            
            .quantum-title h1 {
                font-size: 18px;
            }
        }

        /* Animations de victoire */
        .victory-animation {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            backdrop-filter: blur(20px);
        }

        .victory-content {
            background: linear-gradient(145deg, rgba(30, 20, 60, 0.95), rgba(76, 29, 149, 0.95));
            border: 4px solid #8b5cf6;
            border-radius: 25px;
            padding: 50px;
            text-align: center;
            color: white;
            font-size: 22px;
            font-weight: bold;
            max-width: 600px;
            box-shadow: 0 0 60px rgba(139, 92, 246, 0.8);
            animation: victoryPulse 3s ease-in-out infinite alternate;
        }

        @keyframes victoryPulse {
            from { 
                box-shadow: 0 0 60px rgba(139, 92, 246, 0.8);
                transform: scale(1);
            }
            to { 
                box-shadow: 0 0 80px rgba(139, 92, 246, 1);
                transform: scale(1.05);
            }
        }

        /* Lignes de connexion */
        .connection-line {
            position: absolute;
            height: 3px;
            background: linear-gradient(90deg, #8b5cf6, #a855f7);
            box-shadow: 0 0 10px rgba(139, 92, 246, 0.8);
            z-index: 5;
            animation: connectionGlow 2s ease-in-out infinite alternate;
        }

        @keyframes connectionGlow {
            from { 
                box-shadow: 0 0 10px rgba(139, 92, 246, 0.8);
            }
            to { 
                box-shadow: 0 0 20px rgba(139, 92, 246, 1);
            }
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!-- Particules quantiques d&#x27;arrière-plan --&gt;
    &lt;div class=&quot;quantum-particles&quot; id=&quot;quantumParticles&quot;&gt;&lt;/div&gt;
    
    &lt;!-- Grille quantique --&gt;
    &lt;div class=&quot;quantum-grid&quot;&gt;&lt;/div&gt;
    
    &lt;!-- Container principal --&gt;
    &lt;div class=&quot;cyber-checker-container&quot;&gt;
        &lt;!-- Panneau gauche --&gt;
        &lt;div class=&quot;left-panel&quot;&gt;
            &lt;div class=&quot;panel-section&quot;&gt;
                &lt;div class=&quot;panel-title&quot; id=&quot;controlsTitle&quot;&gt;⚡ Contrôles Quantiques&lt;/div&gt;
                &lt;div style=&quot;display: grid; gap: 15px;&quot;&gt;
                    &lt;button class=&quot;quantum-btn new-game-btn compact-btn&quot; onclick=&quot;newGame()&quot;&gt;
                        🎮 &lt;span id=&quot;newGameText&quot;&gt;Nouvelle Partie&lt;/span&gt;
                    &lt;/button&gt;
                    &lt;button class=&quot;quantum-btn hint-btn compact-btn&quot; onclick=&quot;getHint()&quot; id=&quot;hintBtn&quot;&gt;
                        💡 &lt;span id=&quot;hintText&quot;&gt;Conseil&lt;/span&gt;
                    &lt;/button&gt;
                    &lt;button class=&quot;quantum-btn compact-btn&quot; onclick=&quot;undoMove()&quot; id=&quot;undoBtn&quot;&gt;
                        ↶ &lt;span id=&quot;undoText&quot;&gt;Annuler&lt;/span&gt;
                    &lt;/button&gt;
                    &lt;button class=&quot;quantum-btn compact-btn&quot; onclick=&quot;surrenderGame()&quot; id=&quot;surrenderBtn&quot;&gt;
                        🏳️ &lt;span id=&quot;surrenderText&quot;&gt;Abandonner&lt;/span&gt;
                    &lt;/button&gt;
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;div class=&quot;panel-section&quot;&gt;
                &lt;div class=&quot;panel-title&quot; id=&quot;gameModeTitle&quot;&gt;🎮 Mode de Jeu&lt;/div&gt;
                &lt;select id=&quot;gameModeSelector&quot; onchange=&quot;changeGameMode()&quot; class=&quot;language-selector&quot; style=&quot;width: 100%; text-align: center; margin-bottom: 15px;&quot;&gt;
                    &lt;option value=&quot;ai&quot; selected&gt;🤖 Contre IA&lt;/option&gt;
                    &lt;option value=&quot;human&quot;&gt;👥 2 Joueurs&lt;/option&gt;
                &lt;/select&gt;
            &lt;/div&gt;

            &lt;div class=&quot;panel-section&quot;&gt;
                &lt;div class=&quot;panel-title&quot; id=&quot;statsTitle&quot;&gt;📊 Statistiques&lt;/div&gt;
                &lt;div class=&quot;game-stats&quot;&gt;
                    &lt;div class=&quot;stat-item&quot;&gt;
                        &lt;span class=&quot;stat-label&quot; id=&quot;playerNodesLabel&quot;&gt;Vos Nœuds&lt;/span&gt;
                        &lt;span class=&quot;stat-value&quot; id=&quot;playerNodesValue&quot;&gt;0&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;stat-item&quot;&gt;
                        &lt;span class=&quot;stat-label&quot; id=&quot;aiNodesLabel&quot;&gt;Nœuds IA&lt;/span&gt;
                        &lt;span class=&quot;stat-value&quot; id=&quot;aiNodesValue&quot;&gt;0&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;stat-item&quot;&gt;
                        &lt;span class=&quot;stat-label&quot; id=&quot;playerConnectionsLabel&quot;&gt;Connexions&lt;/span&gt;
                        &lt;span class=&quot;stat-value&quot; id=&quot;playerConnectionsValue&quot;&gt;0&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;stat-item&quot;&gt;
                        &lt;span class=&quot;stat-label&quot; id=&quot;aiConnectionsLabel&quot;&gt;IA Connexions&lt;/span&gt;
                        &lt;span class=&quot;stat-value&quot; id=&quot;aiConnectionsValue&quot;&gt;0&lt;/span&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;div class=&quot;panel-section&quot; id=&quot;difficultySection&quot;&gt;
                &lt;div class=&quot;panel-title&quot; id=&quot;difficultyTitle&quot;&gt;🎯 Niveau IA&lt;/div&gt;
                &lt;select id=&quot;difficultySelector&quot; onchange=&quot;changeDifficulty()&quot; class=&quot;language-selector&quot; style=&quot;width: 100%; text-align: center;&quot;&gt;
                    &lt;option value=&quot;easy&quot;&gt;🟢 Débutant&lt;/option&gt;
                    &lt;option value=&quot;medium&quot; selected&gt;🟡 Intermédiaire&lt;/option&gt;
                    &lt;option value=&quot;hard&quot;&gt;🔴 Expert&lt;/option&gt;
                    &lt;option value=&quot;quantum&quot;&gt;🔮 Quantique&lt;/option&gt;
                &lt;/select&gt;
            &lt;/div&gt;
        &lt;/div&gt;

        &lt;!-- Panneau central --&gt;
        &lt;div class=&quot;game-panel&quot;&gt;
            &lt;!-- En-tête --&gt;
            &lt;div class=&quot;quantum-header&quot;&gt;
                &lt;div class=&quot;quantum-title&quot;&gt;
                    &lt;span class=&quot;quantum-icon&quot;&gt;🔮&lt;/span&gt;
                    &lt;h1 id=&quot;gameTitle&quot;&gt;Cyber Checker&lt;/h1&gt;
                    &lt;span class=&quot;quantum-badge&quot; id=&quot;quantumBadge&quot;&gt;🤖 IA QUANTIQUE&lt;/span&gt;
                &lt;/div&gt;
                &lt;div style=&quot;display: flex; align-items: center; gap: 25px;&quot;&gt;
                    &lt;div class=&quot;language-dropdown&quot; id=&quot;languageDropdown&quot;&gt;
                        &lt;div class=&quot;language-selector&quot; onclick=&quot;toggleLanguageDropdown()&quot;&gt;
                            &lt;span id=&quot;selectedLanguage&quot;&gt;🇫🇷 Français&lt;/span&gt;
                            &lt;span class=&quot;language-dropdown-arrow&quot;&gt;▼&lt;/span&gt;
                        &lt;/div&gt;
                        &lt;div class=&quot;language-dropdown-menu&quot; id=&quot;languageMenu&quot;&gt;
                            &lt;div class=&quot;language-option active&quot; onclick=&quot;selectLanguage(&#x27;fr&#x27;, &#x27;🇫🇷 Français&#x27;)&quot;&gt;🇫🇷 Français&lt;/div&gt;
                            &lt;div class=&quot;language-option&quot; onclick=&quot;selectLanguage(&#x27;en&#x27;, &#x27;🇺🇸 English&#x27;)&quot;&gt;🇺🇸 English&lt;/div&gt;
                            &lt;div class=&quot;language-option&quot; onclick=&quot;selectLanguage(&#x27;ar&#x27;, &#x27;🇸🇦 العربية&#x27;)&quot;&gt;🇸🇦 العربية&lt;/div&gt;
                            &lt;div class=&quot;language-option&quot; onclick=&quot;selectLanguage(&#x27;es&#x27;, &#x27;🇪🇸 Español&#x27;)&quot;&gt;🇪🇸 Español&lt;/div&gt;
                            &lt;div class=&quot;language-option&quot; onclick=&quot;selectLanguage(&#x27;de&#x27;, &#x27;🇩🇪 Deutsch&#x27;)&quot;&gt;🇩🇪 Deutsch&lt;/div&gt;
                            &lt;div class=&quot;language-option&quot; onclick=&quot;selectLanguage(&#x27;zh&#x27;, &#x27;🇨🇳 中文&#x27;)&quot;&gt;🇨🇳 中文&lt;/div&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;!-- Message de jeu --&gt;
            &lt;div class=&quot;game-message&quot; id=&quot;gameMessage&quot;&gt;
                &lt;span id=&quot;welcomeMessage&quot;&gt;🔵 À votre tour - Placez un nœud quantique&lt;/span&gt;
            &lt;/div&gt;

            &lt;!-- Plateau hexagonal --&gt;
            &lt;div class=&quot;hex-board&quot; id=&quot;hexBoard&quot;&gt;
                &lt;!-- Les hexagones seront générés par JavaScript --&gt;
            &lt;/div&gt;
        &lt;/div&gt;

        &lt;!-- Panneau droit --&gt;
        &lt;div class=&quot;right-panel&quot;&gt;
            &lt;div class=&quot;panel-section&quot;&gt;
                &lt;div class=&quot;panel-title&quot; id=&quot;rulesTitle&quot;&gt;📖 Règles Quantiques&lt;/div&gt;
                &lt;div style=&quot;color: #a1a1aa; font-size: 14px; line-height: 1.8;&quot;&gt;
                    &lt;p id=&quot;rulesText&quot;&gt;
                        • Placez vos nœuds sur les hexagones&lt;br&gt;
                        • Créez une chaîne continue de bord à bord&lt;br&gt;
                        • Bleu: connexion horizontale&lt;br&gt;
                        • Rouge: connexion verticale&lt;br&gt;
                        • L&#x27;IA quantique prédit vos mouvements
                    &lt;/p&gt;
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;div class=&quot;panel-section&quot;&gt;
                &lt;div class=&quot;panel-title&quot; id=&quot;objectiveTitle&quot;&gt;🎯 Objectifs&lt;/div&gt;
                &lt;div style=&quot;color: #a1a1aa; font-size: 13px; line-height: 1.7;&quot;&gt;
                    &lt;div style=&quot;margin-bottom: 10px;&quot;&gt;
                        &lt;span style=&quot;color: #3b82f6;&quot;&gt;🔵&lt;/span&gt; &lt;span id=&quot;playerObjectiveText&quot;&gt;Connectez gauche-droite&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div style=&quot;margin-bottom: 10px;&quot;&gt;
                        &lt;span style=&quot;color: #ef4444;&quot;&gt;🔴&lt;/span&gt; &lt;span id=&quot;aiObjectiveText&quot;&gt;IA connecte haut-bas&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div style=&quot;margin-bottom: 10px;&quot;&gt;
                        &lt;span style=&quot;color: #10b981;&quot;&gt;⚡&lt;/span&gt; &lt;span id=&quot;strategyText&quot;&gt;Bloquez l&#x27;adversaire&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div style=&quot;margin-bottom: 10px;&quot;&gt;
                        &lt;span style=&quot;color: #fbbf24;&quot;&gt;🧠&lt;/span&gt; &lt;span id=&quot;tacticsText&quot;&gt;Anticipez les coups&lt;/span&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;div class=&quot;panel-section&quot;&gt;
                &lt;div class=&quot;panel-title&quot; id=&quot;aiStatusTitle&quot;&gt;🤖 État IA&lt;/div&gt;
                &lt;div id=&quot;aiStatus&quot; style=&quot;color: #8b5cf6; font-size: 14px; text-align: center; padding: 15px;&quot;&gt;
                    &lt;span id=&quot;aiStatusText&quot;&gt;IA Quantique Prête&lt;/span&gt;
                &lt;/div&gt;
                &lt;div style=&quot;color: #a1a1aa; font-size: 12px; text-align: center; margin-top: 12px;&quot; id=&quot;aiAnalysis&quot;&gt;
                    &lt;span id=&quot;aiAnalysisText&quot;&gt;Analyse des connexions...&lt;/span&gt;
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;div class=&quot;panel-section&quot;&gt;
                &lt;div class=&quot;panel-title&quot; id=&quot;historyTitle&quot;&gt;📜 Historique&lt;/div&gt;
                &lt;div id=&quot;moveHistory&quot; style=&quot;color: #a1a1aa; font-size: 11px; max-height: 120px; overflow-y: auto; line-height: 1.4;&quot;&gt;
                    &lt;div id=&quot;historyContent&quot;&gt;Aucun coup joué&lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;script&gt;
        // Traductions multilingues
        const translations = {
            fr: {
                gameTitle: &quot;Cyber Checker&quot;,
                quantumBadge: &quot;🤖 IA QUANTIQUE&quot;,
                controlsTitle: &quot;⚡ Contrôles&quot;,
                statsTitle: &quot;📊 Statistiques&quot;,
                gameModeTitle: &quot;🎮 Mode de Jeu&quot;,
                difficultyTitle: &quot;🎯 Niveau IA&quot;,
                rulesTitle: &quot;📖 Règles&quot;,
                objectiveTitle: &quot;🎯 Objectifs&quot;,
                aiStatusTitle: &quot;🤖 État IA&quot;,
                historyTitle: &quot;📜 Historique&quot;,
                newGameText: &quot;Nouvelle Partie&quot;,
                hintText: &quot;Conseil&quot;,
                undoText: &quot;Annuler&quot;,
                surrenderText: &quot;Abandonner&quot;,
                playerNodesLabel: &quot;Vos Nœuds&quot;,
                aiNodesLabel: &quot;Nœuds IA&quot;,
                playerConnectionsLabel: &quot;Vos Liens&quot;,
                aiConnectionsLabel: &quot;Liens IA&quot;,
                welcomeMessage: &quot;🔵 À votre tour - Placez un nœud quantique&quot;,
                rulesText: &quot;• Placez nœuds sur hexagones&lt;br&gt;• Créez chaîne bord à bord&lt;br&gt;• Bleu: horizontal&lt;br&gt;• Rouge: vertical&lt;br&gt;• IA prédit mouvements&quot;,
                playerObjectiveText: &quot;Connectez gauche-droite&quot;,
                aiObjectiveText: &quot;IA connecte haut-bas&quot;,
                strategyText: &quot;Bloquez adversaire&quot;,
                tacticsText: &quot;Anticipez coups&quot;,
                aiStatusText: &quot;IA Prête&quot;,
                aiAnalysisText: &quot;Analyse...&quot;,
                yourTurn: &quot;🔵 À votre tour - Placez un nœud quantique&quot;,
                aiTurn: &quot;🔴 L&#x27;IA calcule sa stratégie optimale...&quot;,
                aiThinking: &quot;🤖 IA en analyse stratégique profonde...&quot;,
                playerWins: &quot;🎉 VICTOIRE QUANTIQUE ! Vous avez créé une connexion complète !&quot;,
                aiWins: &quot;🤖 DÉFAITE ! L&#x27;IA a établi sa connexion stratégique !&quot;,
                draw: &quot;🤝 ÉGALITÉ QUANTIQUE ! Plateau saturé sans vainqueur !&quot;,
                easyLevel: &quot;🟢 Novice&quot;,
                mediumLevel: &quot;🟡 Stratège&quot;,
                hardLevel: &quot;🔴 Maître&quot;,
                quantumLevel: &quot;🔮 Quantique&quot;,
                hintMessage: &quot;💡 Conseil Stratégique: Position optimale&quot;,
                noHint: &quot;❌ Aucun conseil disponible actuellement&quot;,
                historyEmpty: &quot;Aucun mouvement&quot;,
                boardFull: &quot;⚡ Plateau saturé - Égalité quantique !&quot;,
                goodMove: &quot;✨ Placement stratégique excellent !&quot;,
                blockingMove: &quot;🛡️ Mouvement défensif efficace !&quot;,
                connectingMove: &quot;🔗 Connexion quantique en formation...&quot;,
                undoFunction: &quot;Fonction d&#x27;annulation en développement&quot;,
                surrenderConfirm: &quot;Êtes-vous sûr de vouloir abandonner ?&quot;,
                victoryTitle: &quot;🎉 VICTOIRE ! 🎉&quot;,
                defeatTitle: &quot;🤖 DÉFAITE 🤖&quot;,
                drawTitle: &quot;🤝 MATCH NUL 🤝&quot;,
                victoryMessage: &quot;Félicitations ! Vous avez créé une connexion complète !&quot;,
                defeatMessage: &quot;L&#x27;IA quantique a créé sa connexion en premier !&quot;,
                drawMessage: &quot;Le plateau est plein sans connexion complète !&quot;,
                nodesPlaced: &quot;Nœuds placés: Vous&quot;,
                newGameButton: &quot;🎮 Nouvelle Partie&quot;,
                difficultyChanged: &quot;Niveau IA:&quot;,
                gameModeAI: &quot;🤖 Contre IA&quot;,
                gameModeHuman: &quot;👥 2 Joueurs&quot;,
                player1Turn: &quot;🔵 Joueur 1 - Placez un nœud quantique&quot;,
                player2Turn: &quot;🔴 Joueur 2 - Placez un nœud quantique&quot;,
                player1Wins: &quot;🎉 VICTOIRE JOUEUR 1 ! Connexion complète créée !&quot;,
                player2Wins: &quot;🎉 VICTOIRE JOUEUR 2 ! Connexion complète créée !&quot;,
                player1Nodes: &quot;Joueur 1&quot;,
                player2Nodes: &quot;Joueur 2&quot;
            },
            en: {
                gameTitle: &quot;Cyber Checker&quot;,
                quantumBadge: &quot;🤖 QUANTUM AI&quot;,
                controlsTitle: &quot;⚡ Controls&quot;,
                statsTitle: &quot;📊 Statistics&quot;,
                gameModeTitle: &quot;🎮 Game Mode&quot;,
                difficultyTitle: &quot;🎯 AI Level&quot;,
                rulesTitle: &quot;📖 Rules&quot;,
                objectiveTitle: &quot;🎯 Objectives&quot;,
                aiStatusTitle: &quot;🤖 AI Status&quot;,
                historyTitle: &quot;📜 History&quot;,
                newGameText: &quot;New Game&quot;,
                hintText: &quot;Hint&quot;,
                undoText: &quot;Undo&quot;,
                surrenderText: &quot;Surrender&quot;,
                playerNodesLabel: &quot;Your Nodes&quot;,
                aiNodesLabel: &quot;AI Nodes&quot;,
                playerConnectionsLabel: &quot;Your Links&quot;,
                aiConnectionsLabel: &quot;AI Links&quot;,
                welcomeMessage: &quot;🔵 Your turn - Place a quantum node&quot;,
                rulesText: &quot;• Place nodes on hexagons&lt;br&gt;• Create chain edge to edge&lt;br&gt;• Blue: horizontal&lt;br&gt;• Red: vertical&lt;br&gt;• AI predicts moves&quot;,
                playerObjectiveText: &quot;Connect left-right&quot;,
                aiObjectiveText: &quot;AI connects top-bottom&quot;,
                strategyText: &quot;Block opponent&quot;,
                tacticsText: &quot;Anticipate moves&quot;,
                aiStatusText: &quot;AI Ready&quot;,
                aiAnalysisText: &quot;Analyzing...&quot;,
                yourTurn: &quot;🔵 Your turn - Place a quantum node&quot;,
                aiTurn: &quot;🔴 AI calculating optimal strategy...&quot;,
                aiThinking: &quot;🤖 AI in deep strategic analysis...&quot;,
                playerWins: &quot;🎉 QUANTUM VICTORY! You created a complete connection!&quot;,
                aiWins: &quot;🤖 DEFEAT! AI established its strategic connection!&quot;,
                draw: &quot;🤝 QUANTUM DRAW! Board saturated with no winner!&quot;,
                easyLevel: &quot;🟢 Novice&quot;,
                mediumLevel: &quot;🟡 Strategist&quot;,
                hardLevel: &quot;🔴 Master&quot;,
                quantumLevel: &quot;🔮 Quantum&quot;,
                hintMessage: &quot;💡 Strategic Hint: Optimal position&quot;,
                noHint: &quot;❌ No hint currently available&quot;,
                historyEmpty: &quot;📜 No moves recorded&quot;,
                boardFull: &quot;⚡ Board saturated - Quantum draw!&quot;,
                goodMove: &quot;✨ Excellent strategic placement!&quot;,
                blockingMove: &quot;🛡️ Effective defensive move!&quot;,
                connectingMove: &quot;🔗 Quantum connection forming...&quot;,
                undoFunction: &quot;Undo function in development&quot;,
                surrenderConfirm: &quot;Are you sure you want to surrender?&quot;,
                victoryTitle: &quot;🎉 VICTORY! 🎉&quot;,
                defeatTitle: &quot;🤖 DEFEAT 🤖&quot;,
                drawTitle: &quot;🤝 DRAW 🤝&quot;,
                victoryMessage: &quot;Congratulations! You created a complete connection!&quot;,
                defeatMessage: &quot;The quantum AI created its connection first!&quot;,
                drawMessage: &quot;The board is full with no complete connection!&quot;,
                nodesPlaced: &quot;Nodes placed: You&quot;,
                newGameButton: &quot;🎮 New Game&quot;,
                difficultyChanged: &quot;AI Level:&quot;,
                gameModeAI: &quot;🤖 vs AI&quot;,
                gameModeHuman: &quot;👥 2 Players&quot;,
                player1Turn: &quot;🔵 Player 1 - Place a quantum node&quot;,
                player2Turn: &quot;🔴 Player 2 - Place a quantum node&quot;,
                player1Wins: &quot;🎉 PLAYER 1 VICTORY! Complete connection created!&quot;,
                player2Wins: &quot;🎉 PLAYER 2 VICTORY! Complete connection created!&quot;,
                player1Nodes: &quot;Player 1&quot;,
                player2Nodes: &quot;Player 2&quot;
            },
            ar: {
                gameTitle: &quot;سايبر تشيكر&quot;,
                quantumBadge: &quot;🤖 ذكاء كمي&quot;,
                controlsTitle: &quot;⚡ تحكم&quot;,
                statsTitle: &quot;📊 إحصائيات&quot;,
                difficultyTitle: &quot;🎯 مستوى ذكاء&quot;,
                rulesTitle: &quot;📖 قواعد&quot;,
                objectiveTitle: &quot;🎯 أهداف&quot;,
                aiStatusTitle: &quot;🤖 حالة ذكاء&quot;,
                historyTitle: &quot;📜 تاريخ&quot;,
                newGameText: &quot;لعبة جديدة&quot;,
                hintText: &quot;تلميح&quot;,
                undoText: &quot;تراجع&quot;,
                surrenderText: &quot;استسلام&quot;,
                playerNodesLabel: &quot;عقدك&quot;,
                aiNodesLabel: &quot;عقد ذكاء&quot;,
                playerConnectionsLabel: &quot;روابطك&quot;,
                aiConnectionsLabel: &quot;روابط ذكاء&quot;,
                welcomeMessage: &quot;🔵 دورك - ضع عقدة كمية&quot;,
                rulesText: &quot;• ضع عقد على سداسيات&lt;br&gt;• أنشئ سلسلة حافة لحافة&lt;br&gt;• أزرق: أفقي&lt;br&gt;• أحمر: عمودي&lt;br&gt;• ذكاء يتنبأ حركات&quot;,
                playerObjectiveText: &quot;اربط يسار-يمين&quot;,
                aiObjectiveText: &quot;ذكاء يربط أعلى-أسفل&quot;,
                strategyText: &quot;احجب خصم&quot;,
                tacticsText: &quot;توقع حركات&quot;,
                aiStatusText: &quot;ذكاء جاهز&quot;,
                aiAnalysisText: &quot;تحليل...&quot;,
                yourTurn: &quot;🔵 دورك - ضع عقدة كمية&quot;,
                aiTurn: &quot;🔴 الذكاء يحسب الاستراتيجية المثلى...&quot;,
                aiThinking: &quot;🤖 الذكاء في تحليل استراتيجي عميق...&quot;,
                playerWins: &quot;🎉 نصر كمي! لقد أنشأت اتصالاً كاملاً!&quot;,
                aiWins: &quot;🤖 هزيمة! الذكاء أنشأ اتصاله الاستراتيجي!&quot;,
                draw: &quot;🤝 تعادل كمي! اللوحة مشبعة بدون فائز!&quot;,
                easyLevel: &quot;🟢 مبتدئ&quot;,
                mediumLevel: &quot;🟡 استراتيجي&quot;,
                hardLevel: &quot;🔴 خبير&quot;,
                quantumLevel: &quot;🔮 كمي&quot;,
                hintMessage: &quot;💡 تلميح استراتيجي: موضع مثالي&quot;,
                noHint: &quot;❌ لا يوجد تلميح متاح حالياً&quot;,
                historyEmpty: &quot;📜 لم يتم تسجيل حركات&quot;,
                boardFull: &quot;⚡ اللوحة مشبعة - تعادل كمي!&quot;,
                goodMove: &quot;✨ وضع استراتيجي ممتاز!&quot;,
                blockingMove: &quot;🛡️ حركة دفاعية فعالة!&quot;,
                connectingMove: &quot;🔗 اتصال كمي في التكوين...&quot;,
                undoFunction: &quot;وظيفة التراجع قيد التطوير&quot;,
                surrenderConfirm: &quot;هل أنت متأكد من الاستسلام؟&quot;,
                victoryTitle: &quot;🎉 نصر! 🎉&quot;,
                defeatTitle: &quot;🤖 هزيمة 🤖&quot;,
                drawTitle: &quot;🤝 تعادل 🤝&quot;,
                victoryMessage: &quot;تهانينا! لقد أنشأت اتصالاً كاملاً!&quot;,
                defeatMessage: &quot;الذكاء الكمي أنشأ اتصاله أولاً!&quot;,
                drawMessage: &quot;اللوحة ممتلئة بدون اتصال كامل!&quot;,
                nodesPlaced: &quot;العقد الموضوعة: أنت&quot;,
                newGameButton: &quot;🎮 لعبة جديدة&quot;,
                difficultyChanged: &quot;مستوى الذكاء:&quot;
            },
            es: {
                gameTitle: &quot;Cyber Checker&quot;,
                quantumBadge: &quot;🤖 IA CUÁNTICA&quot;,
                controlsTitle: &quot;⚡ Controles&quot;,
                statsTitle: &quot;📊 Estadísticas&quot;,
                difficultyTitle: &quot;🎯 Nivel IA&quot;,
                rulesTitle: &quot;📖 Reglas&quot;,
                objectiveTitle: &quot;🎯 Objetivos&quot;,
                aiStatusTitle: &quot;🤖 Estado IA&quot;,
                historyTitle: &quot;📜 Historial&quot;,
                newGameText: &quot;Nuevo Juego&quot;,
                hintText: &quot;Pista&quot;,
                undoText: &quot;Deshacer&quot;,
                surrenderText: &quot;Rendirse&quot;,
                playerNodesLabel: &quot;Tus Nodos&quot;,
                aiNodesLabel: &quot;Nodos IA&quot;,
                playerConnectionsLabel: &quot;Tus Enlaces&quot;,
                aiConnectionsLabel: &quot;Enlaces IA&quot;,
                welcomeMessage: &quot;🔵 Tu turno - Coloca un nodo cuántico&quot;,
                rulesText: &quot;• Coloca nodos en hexágonos&lt;br&gt;• Crea cadena borde a borde&lt;br&gt;• Azul: horizontal&lt;br&gt;• Rojo: vertical&lt;br&gt;• IA predice movimientos&quot;,
                playerObjectiveText: &quot;Conecta izquierda-derecha&quot;,
                aiObjectiveText: &quot;IA conecta arriba-abajo&quot;,
                strategyText: &quot;Bloquea oponente&quot;,
                tacticsText: &quot;Anticipa movimientos&quot;,
                aiStatusText: &quot;IA Lista&quot;,
                aiAnalysisText: &quot;Analizando...&quot;,
                yourTurn: &quot;🔵 Tu turno - Coloca un nodo cuántico&quot;,
                aiTurn: &quot;🔴 IA calculando estrategia óptima...&quot;,
                aiThinking: &quot;🤖 IA en análisis estratégico profundo...&quot;,
                playerWins: &quot;🎉 ¡VICTORIA CUÁNTICA! ¡Creaste una conexión completa!&quot;,
                aiWins: &quot;🤖 ¡DERROTA! ¡La IA estableció su conexión estratégica!&quot;,
                draw: &quot;🤝 ¡EMPATE CUÁNTICO! ¡Tablero saturado sin ganador!&quot;,
                easyLevel: &quot;🟢 Novato&quot;,
                mediumLevel: &quot;🟡 Estratega&quot;,
                hardLevel: &quot;🔴 Maestro&quot;,
                quantumLevel: &quot;🔮 Cuántico&quot;,
                hintMessage: &quot;💡 Pista Estratégica: Posición óptima&quot;,
                noHint: &quot;❌ No hay pista disponible actualmente&quot;,
                historyEmpty: &quot;📜 No hay movimientos registrados&quot;,
                boardFull: &quot;⚡ Tablero saturado - ¡Empate cuántico!&quot;,
                goodMove: &quot;✨ ¡Colocación estratégica excelente!&quot;,
                blockingMove: &quot;🛡️ ¡Movimiento defensivo efectivo!&quot;,
                connectingMove: &quot;🔗 Conexión cuántica formándose...&quot;,
                undoFunction: &quot;Función de deshacer en desarrollo&quot;,
                surrenderConfirm: &quot;¿Estás seguro de que quieres rendirte?&quot;,
                victoryTitle: &quot;🎉 ¡VICTORIA! 🎉&quot;,
                defeatTitle: &quot;🤖 DERROTA 🤖&quot;,
                drawTitle: &quot;🤝 EMPATE 🤝&quot;,
                victoryMessage: &quot;¡Felicidades! ¡Creaste una conexión completa!&quot;,
                defeatMessage: &quot;¡La IA cuántica creó su conexión primero!&quot;,
                drawMessage: &quot;¡El tablero está lleno sin conexión completa!&quot;,
                nodesPlaced: &quot;Nodos colocados: Tú&quot;,
                newGameButton: &quot;🎮 Nuevo Juego&quot;,
                difficultyChanged: &quot;Nivel IA:&quot;
            },
            de: {
                gameTitle: &quot;Cyber Checker&quot;,
                quantumBadge: &quot;🤖 QUANTEN-KI&quot;,
                controlsTitle: &quot;⚡ Steuerung&quot;,
                statsTitle: &quot;📊 Statistiken&quot;,
                difficultyTitle: &quot;🎯 KI-Level&quot;,
                rulesTitle: &quot;📖 Regeln&quot;,
                objectiveTitle: &quot;🎯 Ziele&quot;,
                aiStatusTitle: &quot;🤖 KI-Status&quot;,
                historyTitle: &quot;📜 Historie&quot;,
                newGameText: &quot;Neues Spiel&quot;,
                hintText: &quot;Hinweis&quot;,
                undoText: &quot;Rückgängig&quot;,
                surrenderText: &quot;Aufgeben&quot;,
                playerNodesLabel: &quot;Deine Knoten&quot;,
                aiNodesLabel: &quot;KI-Knoten&quot;,
                playerConnectionsLabel: &quot;Deine Verbindungen&quot;,
                aiConnectionsLabel: &quot;KI-Verbindungen&quot;,
                welcomeMessage: &quot;🔵 Dein Zug - Platziere einen Quanten-Knoten&quot;,
                rulesText: &quot;• Platziere Knoten auf Hexagonen&lt;br&gt;• Erstelle Kette Rand zu Rand&lt;br&gt;• Blau: horizontal&lt;br&gt;• Rot: vertikal&lt;br&gt;• KI sagt Züge voraus&quot;,
                playerObjectiveText: &quot;Verbinde links-rechts&quot;,
                aiObjectiveText: &quot;KI verbindet oben-unten&quot;,
                strategyText: &quot;Blockiere Gegner&quot;,
                tacticsText: &quot;Antizipiere Züge&quot;,
                aiStatusText: &quot;KI Bereit&quot;,
                aiAnalysisText: &quot;Analysiere...&quot;,
                yourTurn: &quot;🔵 Dein Zug - Platziere einen Quanten-Knoten&quot;,
                aiTurn: &quot;🔴 KI berechnet optimale Strategie...&quot;,
                aiThinking: &quot;🤖 KI in tiefer strategischer Analyse...&quot;,
                playerWins: &quot;🎉 QUANTEN-SIEG! Du hast eine vollständige Verbindung erstellt!&quot;,
                aiWins: &quot;🤖 NIEDERLAGE! KI hat ihre strategische Verbindung etabliert!&quot;,
                draw: &quot;🤝 QUANTEN-UNENTSCHIEDEN! Brett gesättigt ohne Gewinner!&quot;,
                easyLevel: &quot;🟢 Anfänger&quot;,
                mediumLevel: &quot;🟡 Stratege&quot;,
                hardLevel: &quot;🔴 Meister&quot;,
                quantumLevel: &quot;🔮 Quanten&quot;,
                hintMessage: &quot;💡 Strategischer Hinweis: Optimale Position&quot;,
                noHint: &quot;❌ Derzeit kein Hinweis verfügbar&quot;,
                historyEmpty: &quot;📜 Keine Züge aufgezeichnet&quot;,
                boardFull: &quot;⚡ Brett gesättigt - Quanten-Unentschieden!&quot;,
                goodMove: &quot;✨ Ausgezeichnete strategische Platzierung!&quot;,
                blockingMove: &quot;🛡️ Effektiver Verteidigungszug!&quot;,
                connectingMove: &quot;🔗 Quanten-Verbindung bildet sich...&quot;,
                undoFunction: &quot;Rückgängig-Funktion in Entwicklung&quot;,
                surrenderConfirm: &quot;Bist du sicher, dass du aufgeben möchtest?&quot;,
                victoryTitle: &quot;🎉 SIEG! 🎉&quot;,
                defeatTitle: &quot;🤖 NIEDERLAGE 🤖&quot;,
                drawTitle: &quot;🤝 UNENTSCHIEDEN 🤝&quot;,
                victoryMessage: &quot;Glückwunsch! Du hast eine vollständige Verbindung erstellt!&quot;,
                defeatMessage: &quot;Die Quanten-KI hat ihre Verbindung zuerst erstellt!&quot;,
                drawMessage: &quot;Das Brett ist voll ohne vollständige Verbindung!&quot;,
                nodesPlaced: &quot;Knoten platziert: Du&quot;,
                newGameButton: &quot;🎮 Neues Spiel&quot;,
                difficultyChanged: &quot;KI-Level:&quot;
            },
            zh: {
                gameTitle: &quot;网络跳棋&quot;,
                quantumBadge: &quot;🤖 量子人工智能&quot;,
                controlsTitle: &quot;⚡ 控制&quot;,
                statsTitle: &quot;📊 统计&quot;,
                difficultyTitle: &quot;🎯 AI等级&quot;,
                rulesTitle: &quot;📖 规则&quot;,
                objectiveTitle: &quot;🎯 目标&quot;,
                aiStatusTitle: &quot;🤖 AI状态&quot;,
                historyTitle: &quot;📜 历史&quot;,
                newGameText: &quot;新游戏&quot;,
                hintText: &quot;提示&quot;,
                undoText: &quot;撤销&quot;,
                surrenderText: &quot;投降&quot;,
                playerNodesLabel: &quot;你的节点&quot;,
                aiNodesLabel: &quot;AI节点&quot;,
                playerConnectionsLabel: &quot;你的连接&quot;,
                aiConnectionsLabel: &quot;AI连接&quot;,
                welcomeMessage: &quot;🔵 你的回合 - 放置量子节点&quot;,
                rulesText: &quot;• 在六角形上放置节点&lt;br&gt;• 创建链边到边&lt;br&gt;• 蓝色：水平&lt;br&gt;• 红色：垂直&lt;br&gt;• AI预测移动&quot;,
                playerObjectiveText: &quot;连接左右&quot;,
                aiObjectiveText: &quot;AI连接上下&quot;,
                strategyText: &quot;阻止对手&quot;,
                tacticsText: &quot;预测移动&quot;,
                aiStatusText: &quot;AI准备就绪&quot;,
                aiAnalysisText: &quot;分析中...&quot;,
                yourTurn: &quot;🔵 你的回合 - 放置量子节点&quot;,
                aiTurn: &quot;🔴 AI计算最优策略...&quot;,
                aiThinking: &quot;🤖 AI深度战略分析中...&quot;,
                playerWins: &quot;🎉 量子胜利！你创建了完整连接！&quot;,
                aiWins: &quot;🤖 失败！AI建立了战略连接！&quot;,
                draw: &quot;🤝 量子平局！棋盘饱和无获胜者！&quot;,
                easyLevel: &quot;🟢 新手&quot;,
                mediumLevel: &quot;🟡 策略家&quot;,
                hardLevel: &quot;🔴 大师&quot;,
                quantumLevel: &quot;🔮 量子&quot;,
                hintMessage: &quot;💡 战略提示：最优位置&quot;,
                noHint: &quot;❌ 当前无可用提示&quot;,
                historyEmpty: &quot;📜 无移动记录&quot;,
                boardFull: &quot;⚡ 棋盘饱和 - 量子平局！&quot;,
                goodMove: &quot;✨ 优秀的战略放置！&quot;,
                blockingMove: &quot;🛡️ 有效的防御移动！&quot;,
                connectingMove: &quot;🔗 量子连接形成中...&quot;,
                undoFunction: &quot;撤销功能开发中&quot;,
                surrenderConfirm: &quot;你确定要投降吗？&quot;,
                victoryTitle: &quot;🎉 胜利！🎉&quot;,
                defeatTitle: &quot;🤖 失败 🤖&quot;,
                drawTitle: &quot;🤝 平局 🤝&quot;,
                victoryMessage: &quot;恭喜！你创建了完整连接！&quot;,
                defeatMessage: &quot;量子AI首先创建了连接！&quot;,
                drawMessage: &quot;棋盘已满但无完整连接！&quot;,
                nodesPlaced: &quot;已放置节点：你&quot;,
                newGameButton: &quot;🎮 新游戏&quot;,
                difficultyChanged: &quot;AI等级：&quot;
            }
        };

        // État du jeu
    var gameState = {
            currentLanguage: &#x27;fr&#x27;,
            board: [],
            boardSize: 10,
            currentPlayer: &#x27;player&#x27;, // &#x27;player&#x27; ou &#x27;ai&#x27; ou &#x27;player1&#x27; ou &#x27;player2&#x27;
            gameMode: &#x27;ai&#x27;, // &#x27;ai&#x27; ou &#x27;human&#x27;
            playerNodes: 0,
            aiNodes: 0,
            playerConnections: 0,
            aiConnections: 0,
            difficulty: &#x27;medium&#x27;,
            gameOver: false,
            moveHistory: [],
            winningPath: []
        };

        // Créer les particules quantiques
        function createQuantumParticles() {
            const container = document.getElementById(&#x27;quantumParticles&#x27;);
            
            for(let i = 0; i &lt; 40; i++) {
                const particle = document.createElement(&#x27;div&#x27;);
                particle.className = &#x27;quantum-particle&#x27;;
                particle.style.left = Math.random() * 100 + &#x27;%&#x27;;
                particle.style.animationDelay = Math.random() * 15 + &#x27;s&#x27;;
                particle.style.animationDuration = (15 + Math.random() * 8) + &#x27;s&#x27;;
                container.appendChild(particle);
            }
        }

        // Fonctions du sélecteur de langue personnalisé
        function toggleLanguageDropdown() {
            const dropdown = document.getElementById(&#x27;languageDropdown&#x27;);
            dropdown.classList.toggle(&#x27;open&#x27;);
        }

        function selectLanguage(langCode, langText) {
            gameState.currentLanguage = langCode;
            document.getElementById(&#x27;selectedLanguage&#x27;).textContent = langText;
            
            // Mettre à jour les options actives
            const options = document.querySelectorAll(&#x27;.language-option&#x27;);
            options.forEach(option =&gt; option.classList.remove(&#x27;active&#x27;));
            event.target.classList.add(&#x27;active&#x27;);
            
            // Fermer le dropdown
            document.getElementById(&#x27;languageDropdown&#x27;).classList.remove(&#x27;open&#x27;);
            
            // Appliquer les traductions
            changeLanguage();
        }

        // Fermer le dropdown si on clique ailleurs
        document.addEventListener(&#x27;click&#x27;, function(event) {
            const dropdown = document.getElementById(&#x27;languageDropdown&#x27;);
            if (dropdown &amp;&amp; !dropdown.contains(event.target)) {
                dropdown.classList.remove(&#x27;open&#x27;);
            }
        });

        // Fonction de changement de langue
        function changeLanguage() {
            const selectedLang = gameState.currentLanguage;
            
            const t = translations[selectedLang];
            
            // Mettre à jour tous les textes
            document.getElementById(&#x27;gameTitle&#x27;).textContent = t.gameTitle;
            document.getElementById(&#x27;quantumBadge&#x27;).textContent = t.quantumBadge;
            document.getElementById(&#x27;controlsTitle&#x27;).textContent = t.controlsTitle;
            document.getElementById(&#x27;statsTitle&#x27;).textContent = t.statsTitle;
            document.getElementById(&#x27;gameModeTitle&#x27;).textContent = t.gameModeTitle;
            document.getElementById(&#x27;difficultyTitle&#x27;).textContent = t.difficultyTitle;
            document.getElementById(&#x27;rulesTitle&#x27;).textContent = t.rulesTitle;
            document.getElementById(&#x27;objectiveTitle&#x27;).textContent = t.objectiveTitle;
            document.getElementById(&#x27;aiStatusTitle&#x27;).textContent = t.aiStatusTitle;
            document.getElementById(&#x27;historyTitle&#x27;).textContent = t.historyTitle;
            
            document.getElementById(&#x27;newGameText&#x27;).textContent = t.newGameText;
            document.getElementById(&#x27;hintText&#x27;).textContent = t.hintText;
            document.getElementById(&#x27;undoText&#x27;).textContent = t.undoText;
            document.getElementById(&#x27;surrenderText&#x27;).textContent = t.surrenderText;
            
            document.getElementById(&#x27;playerNodesLabel&#x27;).textContent = t.playerNodesLabel;
            document.getElementById(&#x27;aiNodesLabel&#x27;).textContent = t.aiNodesLabel;
            document.getElementById(&#x27;playerConnectionsLabel&#x27;).textContent = t.playerConnectionsLabel;
            document.getElementById(&#x27;aiConnectionsLabel&#x27;).textContent = t.aiConnectionsLabel;
            
            document.getElementById(&#x27;welcomeMessage&#x27;).textContent = t.welcomeMessage;
            document.getElementById(&#x27;rulesText&#x27;).innerHTML = t.rulesText;
            document.getElementById(&#x27;playerObjectiveText&#x27;).textContent = t.playerObjectiveText;
            document.getElementById(&#x27;aiObjectiveText&#x27;).textContent = t.aiObjectiveText;
            document.getElementById(&#x27;strategyText&#x27;).textContent = t.strategyText;
            document.getElementById(&#x27;tacticsText&#x27;).textContent = t.tacticsText;
            document.getElementById(&#x27;aiStatusText&#x27;).textContent = t.aiStatusText;
            document.getElementById(&#x27;aiAnalysisText&#x27;).textContent = t.aiAnalysisText;
            
            // Mettre à jour les sélecteurs
            updateGameModeSelector();
            updateDifficultySelector();
            
            // Mettre à jour le message de jeu
            updateGameMessage();
        }

        // Mettre à jour le sélecteur de difficulté
        function updateDifficultySelector() {
            const t = translations[gameState.currentLanguage];
            const selector = document.getElementById(&#x27;difficultySelector&#x27;);
            selector.innerHTML = `
                &lt;option value=&quot;easy&quot;&gt;${t.easyLevel}&lt;/option&gt;
                &lt;option value=&quot;medium&quot;&gt;${t.mediumLevel}&lt;/option&gt;
                &lt;option value=&quot;hard&quot;&gt;${t.hardLevel}&lt;/option&gt;
                &lt;option value=&quot;quantum&quot;&gt;${t.quantumLevel}&lt;/option&gt;
            `;
            selector.value = gameState.difficulty;
        }

        // Mettre à jour le sélecteur de mode de jeu
        function updateGameModeSelector() {
            const t = translations[gameState.currentLanguage];
            const selector = document.getElementById(&#x27;gameModeSelector&#x27;);
            selector.innerHTML = `
                &lt;option value=&quot;ai&quot;&gt;${t.gameModeAI}&lt;/option&gt;
                &lt;option value=&quot;human&quot;&gt;${t.gameModeHuman}&lt;/option&gt;
            `;
            selector.value = gameState.gameMode;
        }

        // Changer le mode de jeu
        function changeGameMode() {
            const selector = document.getElementById(&#x27;gameModeSelector&#x27;);
            gameState.gameMode = selector.value;
            
            // Afficher/masquer la section difficulté selon le mode
            const difficultySection = document.getElementById(&#x27;difficultySection&#x27;);
            if (gameState.gameMode === &#x27;ai&#x27;) {
                difficultySection.style.display = &#x27;block&#x27;;
            } else {
                difficultySection.style.display = &#x27;none&#x27;;
            }
            
            // Redémarrer la partie avec le nouveau mode
            newGame();
        }

        // Changer la difficulté
        function changeDifficulty() {
            const selector = document.getElementById(&#x27;difficultySelector&#x27;);
            gameState.difficulty = selector.value;
            
            const t = translations[gameState.currentLanguage];
            showMessage(`${t.difficultyChanged} ${selector.options[selector.selectedIndex].text}`, 2000);
        }

        // Initialiser le plateau hexagonal
        function initializeBoard() {
            gameState.board = [];
            const size = gameState.boardSize;
            
            // Créer un plateau hexagonal
            for(let row = 0; row &lt; size; row++) {
                gameState.board[row] = [];
                for(let col = 0; col &lt; size; col++) {
                    gameState.board[row][col] = null;
                }
            }
        }

        // Créer le plateau visuel hexagonal
        function createHexBoard() {
            const boardElement = document.getElementById(&#x27;hexBoard&#x27;);
            boardElement.innerHTML = &#x27;&#x27;;
            const size = gameState.boardSize;
            
            for(let row = 0; row &lt; size; row++) {
                const hexRow = document.createElement(&#x27;div&#x27;);
                hexRow.className = &#x27;hex-row&#x27;;
                
                // Décalage pour créer la forme hexagonale
                const offset = Math.abs(Math.floor(size/2) - row);
                hexRow.style.marginLeft = offset * 22 + &#x27;px&#x27;;
                
                const cellsInRow = size - offset;
                
                for(let col = 0; col &lt; cellsInRow; col++) {
                    const actualCol = col + Math.floor(offset/2);
                    const cell = document.createElement(&#x27;div&#x27;);
                    cell.className = &#x27;hex-cell&#x27;;
                    cell.dataset.row = row;
                    cell.dataset.col = actualCol;
                    
                    cell.addEventListener(&#x27;click&#x27;, () =&gt; handleCellClick(row, actualCol));
                    
                    // Ajouter le contenu de la cellule
                    const piece = gameState.board[row] &amp;&amp; gameState.board[row][actualCol];
                    if(piece) {
                        if(gameState.gameMode === &#x27;ai&#x27;) {
                            cell.classList.add(piece);
                            cell.textContent = piece === &#x27;player&#x27; ? &#x27;🔵&#x27; : &#x27;🔴&#x27;;
                        } else {
                            // Mode 2 joueurs
                            cell.classList.add(piece === &#x27;player1&#x27; ? &#x27;player&#x27; : &#x27;ai&#x27;);
                            cell.textContent = piece === &#x27;player1&#x27; ? &#x27;🔵&#x27; : &#x27;🔴&#x27;;
                        }
                    }
                    
                    hexRow.appendChild(cell);
                }
                
                boardElement.appendChild(hexRow);
            }
        }

        // Gérer le clic sur une cellule
        function handleCellClick(row, col) {
            if(gameState.gameOver) return;
            
            // Vérifier si c&#x27;est le bon tour selon le mode de jeu
            if(gameState.gameMode === &#x27;ai&#x27; &amp;&amp; gameState.currentPlayer !== &#x27;player&#x27;) return;
            if(gameState.gameMode === &#x27;human&#x27; &amp;&amp; (gameState.currentPlayer !== &#x27;player1&#x27; &amp;&amp; gameState.currentPlayer !== &#x27;player2&#x27;)) return;
            
            // Vérifier si la cellule est valide et vide
            if(!gameState.board[row] || gameState.board[row][col] !== null) return;
            
            // Placer le nœud selon le mode de jeu
            if(gameState.gameMode === &#x27;ai&#x27;) {
                makeMove(row, col, &#x27;player&#x27;);
            } else {
                makeMove(row, col, gameState.currentPlayer);
            }
        }

        // Effectuer un mouvement
        function makeMove(row, col, player) {
            gameState.board[row][col] = player;
            
            // Mettre à jour les compteurs selon le mode de jeu
            if(gameState.gameMode === &#x27;ai&#x27;) {
                if(player === &#x27;player&#x27;) {
                    gameState.playerNodes++;
                } else {
                    gameState.aiNodes++;
                }
            } else {
                // Mode 2 joueurs
                if(player === &#x27;player1&#x27;) {
                    gameState.playerNodes++;
                } else {
                    gameState.aiNodes++;
                }
            }
            
            // Ajouter à l&#x27;historique
            addToHistory(row, col, player);
            
            // Mettre à jour l&#x27;affichage
            createHexBoard();
            updateStats();
            
            // Vérifier la victoire
            if(checkWin(player)) {
                endGame(player);
                return;
            }
            
            // Vérifier si le plateau est plein
            if(isBoardFull()) {
                endGame(&#x27;draw&#x27;);
                return;
            }
            
            // Changer de joueur selon le mode
            if(gameState.gameMode === &#x27;ai&#x27;) {
                gameState.currentPlayer = player === &#x27;player&#x27; ? &#x27;ai&#x27; : &#x27;player&#x27;;
            } else {
                gameState.currentPlayer = player === &#x27;player1&#x27; ? &#x27;player2&#x27; : &#x27;player1&#x27;;
            }
            
            updateGameMessage();
            
            // Tour de l&#x27;IA si mode IA
            if(gameState.gameMode === &#x27;ai&#x27; &amp;&amp; gameState.currentPlayer === &#x27;ai&#x27;) {
                setTimeout(() =&gt; {
                    aiMove();
                }, 1000);
            }
        }

        // Mouvement de l&#x27;IA
        function aiMove() {
            const t = translations[gameState.currentLanguage];
            showMessage(t.aiThinking);
            document.getElementById(&#x27;aiStatus&#x27;).classList.add(&#x27;ai-thinking&#x27;);
            
            setTimeout(() =&gt; {
                const bestMove = getBestAIMove();
                if(bestMove) {
                    makeMove(bestMove.row, bestMove.col, &#x27;ai&#x27;);
                }
                
                document.getElementById(&#x27;aiStatus&#x27;).classList.remove(&#x27;ai-thinking&#x27;);
            }, 1500);
        }

        // Obtenir le meilleur coup pour l&#x27;IA
        function getBestAIMove() {
            const emptyCells = [];
            const size = gameState.boardSize;
            
            // Trouver toutes les cellules vides
            for(let row = 0; row &lt; size; row++) {
                if(!gameState.board[row]) continue;
                for(let col = 0; col &lt; size; col++) {
                    if(gameState.board[row][col] === null) {
                        emptyCells.push({row, col});
                    }
                }
            }
            
            if(emptyCells.length === 0) return null;
            
            // Stratégie selon la difficulté
            switch(gameState.difficulty) {
                case &#x27;easy&#x27;:
                    return emptyCells[Math.floor(Math.random() * emptyCells.length)];
                
                case &#x27;medium&#x27;:
                    return getMediumAIMove(emptyCells);
                
                case &#x27;hard&#x27;:
                case &#x27;quantum&#x27;:
                    return getAdvancedAIMove(emptyCells);
            }
        }

        // IA niveau moyen
        function getMediumAIMove(emptyCells) {
            // Préférer les positions centrales
            const centerRow = Math.floor(gameState.boardSize / 2);
            const centerCells = emptyCells.filter(cell =&gt; 
                Math.abs(cell.row - centerRow) &lt;= 2
            );
            
            if(centerCells.length &gt; 0) {
                return centerCells[Math.floor(Math.random() * centerCells.length)];
            }
            
            return emptyCells[Math.floor(Math.random() * emptyCells.length)];
        }

        // IA avancée
        function getAdvancedAIMove(emptyCells) {
            let bestMove = null;
            let bestScore = -Infinity;
            
            for(const cell of emptyCells) {
                let score = evaluatePosition(cell.row, cell.col, &#x27;ai&#x27;);
                
                // Bonus pour bloquer le joueur
                const blockScore = evaluatePosition(cell.row, cell.col, &#x27;player&#x27;);
                score += blockScore * 0.8;
                
                // Ajouter de l&#x27;aléatoire
                score += Math.random() * 10;
                
                if(score &gt; bestScore) {
                    bestScore = score;
                    bestMove = cell;
                }
            }
            
            return bestMove || emptyCells[0];
        }

        // Évaluer une position
        function evaluatePosition(row, col, player) {
            let score = 0;
            
            // Bonus pour les positions qui créent des connexions
            const neighbors = getNeighbors(row, col);
            const friendlyNeighbors = neighbors.filter(n =&gt; 
                gameState.board[n.row] &amp;&amp; gameState.board[n.row][n.col] === player
            ).length;
            
            score += friendlyNeighbors * 20;
            
            // Bonus pour les positions stratégiques
            if(player === &#x27;ai&#x27;) {
                // IA veut connecter haut-bas
                if(row === 0 || row === gameState.boardSize - 1) {
                    score += 30;
                }
            } else {
                // Joueur veut connecter gauche-droite
                if(col === 0 || col === gameState.boardSize - 1) {
                    score += 30;
                }
            }
            
            return score;
        }

        // Obtenir les voisins d&#x27;une cellule hexagonale
        function getNeighbors(row, col) {
            const neighbors = [];
            const directions = [
                [-1, -1], [-1, 0], [0, -1], [0, 1], [1, 0], [1, 1]
            ];
            
            for(const [dRow, dCol] of directions) {
                const newRow = row + dRow;
                const newCol = col + dCol;
                
                if(newRow &gt;= 0 &amp;&amp; newRow &lt; gameState.boardSize &amp;&amp; 
                   newCol &gt;= 0 &amp;&amp; newCol &lt; gameState.boardSize &amp;&amp;
                   gameState.board[newRow]) {
                    neighbors.push({row: newRow, col: newCol});
                }
            }
            
            return neighbors;
        }

        // Vérifier la victoire
        function checkWin(player) {
            if(gameState.gameMode === &#x27;ai&#x27;) {
                if(player === &#x27;player&#x27;) {
                    // Le joueur doit connecter gauche-droite
                    return hasPath(player, &#x27;horizontal&#x27;);
                } else {
                    // L&#x27;IA doit connecter haut-bas
                    return hasPath(player, &#x27;vertical&#x27;);
                }
            } else {
                // Mode 2 joueurs
                if(player === &#x27;player1&#x27;) {
                    // Joueur 1 (bleu) doit connecter gauche-droite
                    return hasPath(player, &#x27;horizontal&#x27;);
                } else {
                    // Joueur 2 (rouge) doit connecter haut-bas
                    return hasPath(player, &#x27;vertical&#x27;);
                }
            }
        }

        // Vérifier s&#x27;il y a un chemin
        function hasPath(player, direction) {
            const visited = new Set();
            const size = gameState.boardSize;
            
            // Points de départ selon la direction
            const startPoints = [];
            if(direction === &#x27;horizontal&#x27;) {
                // Chercher sur le bord gauche
                for(let row = 0; row &lt; size; row++) {
                    if(gameState.board[row] &amp;&amp; gameState.board[row][0] === player) {
                        startPoints.push({row, col: 0});
                    }
                }
            } else {
                // Chercher sur le bord haut
                for(let col = 0; col &lt; size; col++) {
                    if(gameState.board[0] &amp;&amp; gameState.board[0][col] === player) {
                        startPoints.push({row: 0, col});
                    }
                }
            }
            
            // DFS pour chaque point de départ
            for(const start of startPoints) {
                const path = [];
                if(dfsPath(start.row, start.col, player, direction, visited, path)) {
                    gameState.winningPath = path;
                    return true;
                }
            }
            
            return false;
        }

        // DFS pour trouver un chemin
        function dfsPath(row, col, player, direction, visited, path) {
            const key = `${row},${col}`;
            if(visited.has(key)) return false;
            
            if(!gameState.board[row] || gameState.board[row][col] !== player) {
                return false;
            }
            
            visited.add(key);
            path.push({row, col});
            
            // Vérifier si on a atteint le bord opposé
            const size = gameState.boardSize;
            if(direction === &#x27;horizontal&#x27; &amp;&amp; col === size - 1) {
                return true;
            }
            if(direction === &#x27;vertical&#x27; &amp;&amp; row === size - 1) {
                return true;
            }
            
            // Explorer les voisins
            const neighbors = getNeighbors(row, col);
            for(const neighbor of neighbors) {
                if(dfsPath(neighbor.row, neighbor.col, player, direction, visited, path)) {
                    return true;
                }
            }
            
            path.pop();
            return false;
        }

        // Vérifier si le plateau est plein
        function isBoardFull() {
            const size = gameState.boardSize;
            for(let row = 0; row &lt; size; row++) {
                if(!gameState.board[row]) continue;
                for(let col = 0; col &lt; size; col++) {
                    if(gameState.board[row][col] === null) {
                        return false;
                    }
                }
            }
            return true;
        }

        // Fin de partie
        function endGame(winner) {
            gameState.gameOver = true;
            const t = translations[gameState.currentLanguage];
            
            let message;
            if(gameState.gameMode === &#x27;ai&#x27;) {
                if(winner === &#x27;player&#x27;) {
                    message = t.playerWins;
                    highlightWinningPath();
                } else if(winner === &#x27;ai&#x27;) {
                    message = t.aiWins;
                    highlightWinningPath();
                } else {
                    message = t.boardFull;
                }
            } else {
                // Mode 2 joueurs
                if(winner === &#x27;player1&#x27;) {
                    message = t.player1Wins;
                    highlightWinningPath();
                } else if(winner === &#x27;player2&#x27;) {
                    message = t.player2Wins;
                    highlightWinningPath();
                } else {
                    message = t.boardFull;
                }
            }
            
            showMessage(message);
            
            // Afficher l&#x27;écran de victoire après un délai
            setTimeout(() =&gt; {
                showVictoryScreen(winner);
            }, 2000);
        }

        // Mettre en évidence le chemin gagnant
        function highlightWinningPath() {
            const cells = document.querySelectorAll(&#x27;.hex-cell&#x27;);
            cells.forEach(cell =&gt; {
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                
                const isInPath = gameState.winningPath.some(p =&gt; p.row === row &amp;&amp; p.col === col);
                if(isInPath) {
                    cell.classList.add(&#x27;winning-path&#x27;);
                }
            });
        }

        // Afficher l&#x27;écran de victoire
        function showVictoryScreen(winner) {
            const t = translations[gameState.currentLanguage];
            
            const overlay = document.createElement(&#x27;div&#x27;);
            overlay.className = &#x27;victory-animation&#x27;;
            
            const content = document.createElement(&#x27;div&#x27;);
            content.className = &#x27;victory-content&#x27;;
            
            let title, message, scoreText;
            
            if(gameState.gameMode === &#x27;ai&#x27;) {
                if(winner === &#x27;player&#x27;) {
                    title = t.victoryTitle;
                    message = t.victoryMessage;
                } else if(winner === &#x27;ai&#x27;) {
                    title = t.defeatTitle;
                    message = t.defeatMessage;
                } else {
                    title = t.drawTitle;
                    message = t.drawMessage;
                }
                scoreText = `${t.nodesPlaced} ${gameState.playerNodes} - IA ${gameState.aiNodes}`;
            } else {
                // Mode 2 joueurs
                if(winner === &#x27;player1&#x27;) {
                    title = t.victoryTitle;
                    message = t.player1Wins;
                } else if(winner === &#x27;player2&#x27;) {
                    title = t.victoryTitle;
                    message = t.player2Wins;
                } else {
                    title = t.drawTitle;
                    message = t.drawMessage;
                }
                scoreText = `${t.player1Nodes}: ${gameState.playerNodes} - ${t.player2Nodes}: ${gameState.aiNodes}`;
            }
            
            content.innerHTML = `
                &lt;h2&gt;${title}&lt;/h2&gt;
                &lt;p style=&quot;margin: 25px 0;&quot;&gt;${message}&lt;/p&gt;
                &lt;p style=&quot;margin: 20px 0; color: #8b5cf6;&quot;&gt;${scoreText}&lt;/p&gt;
                &lt;button onclick=&quot;newGame(); document.body.removeChild(document.querySelector(&#x27;.victory-animation&#x27;))&quot; style=&quot;
                    margin: 25px 15px 15px 15px;
                    padding: 18px 35px;
                    background: linear-gradient(145deg, #8b5cf6, #7c3aed);
                    color: white;
                    border: none;
                    border-radius: 20px;
                    font-size: 16px;
                    font-weight: bold;
                    cursor: pointer;
                    transition: all 0.3s ease;
                &quot;&gt;${t.newGameButton}&lt;/button&gt;
            `;
            
            overlay.appendChild(content);
            document.body.appendChild(overlay);
        }

        // Nouvelle partie
        function newGame() {
            // Fermer l&#x27;overlay de victoire s&#x27;il existe
            const overlay = document.querySelector(&#x27;.victory-animation&#x27;);
            if(overlay) {
                document.body.removeChild(overlay);
            }
            
            // Réinitialiser l&#x27;état du jeu selon le mode
            if(gameState.gameMode === &#x27;ai&#x27;) {
                gameState.currentPlayer = &#x27;player&#x27;;
            } else {
                gameState.currentPlayer = &#x27;player1&#x27;;
            }
            
            gameState.playerNodes = 0;
            gameState.aiNodes = 0;
            gameState.playerConnections = 0;
            gameState.aiConnections = 0;
            gameState.gameOver = false;
            gameState.moveHistory = [];
            gameState.winningPath = [];
            
            // Réinitialiser le plateau
            initializeBoard();
            createHexBoard();
            updateStats();
            updateHistoryDisplay();
            updateGameMessage();
            
            const t = translations[gameState.currentLanguage];
            if(gameState.gameMode === &#x27;ai&#x27;) {
                showMessage(t.welcomeMessage);
            } else {
                showMessage(t.player1Turn);
            }
        }

        // Obtenir un indice
        function getHint() {
            if(gameState.currentPlayer !== &#x27;player&#x27; || gameState.gameOver) return;
            
            const t = translations[gameState.currentLanguage];
            const bestMove = getBestAIMove();
            
            if(!bestMove) {
                showMessage(t.noHint);
                return;
            }
            
            showMessage(`${t.hintMessage} (${bestMove.row}, ${bestMove.col})`, 4000);
            
            // Mettre en évidence la position suggérée
            const cells = document.querySelectorAll(&#x27;.hex-cell&#x27;);
            cells.forEach(cell =&gt; {
                if(parseInt(cell.dataset.row) === bestMove.row &amp;&amp; 
                   parseInt(cell.dataset.col) === bestMove.col) {
                    cell.style.border = &#x27;3px solid #fbbf24&#x27;;
                    cell.style.boxShadow = &#x27;0 0 25px rgba(251, 191, 36, 0.8)&#x27;;
                    
                    setTimeout(() =&gt; {
                        cell.style.border = &#x27;2px solid transparent&#x27;;
                        cell.style.boxShadow = &#x27;&#x27;;
                    }, 3000);
                }
            });
        }

        // Annuler le dernier coup
        function undoMove() {
            const t = translations[gameState.currentLanguage];
            showMessage(t.undoFunction, 2000);
        }

        // Abandonner la partie
        function surrenderGame() {
            if(gameState.gameOver) return;
            
            const t = translations[gameState.currentLanguage];
            if(confirm(t.surrenderConfirm)) {
                endGame(&#x27;ai&#x27;);
            }
        }

        // Ajouter à l&#x27;historique
        function addToHistory(row, col, player) {
            const playerName = player === &#x27;player&#x27; ? &#x27;Joueur&#x27; : &#x27;IA&#x27;;
            const position = `(${row}, ${col})`;
            
            gameState.moveHistory.push(`${playerName} → ${position}`);
            
            // Limiter l&#x27;historique à 10 coups
            if(gameState.moveHistory.length &gt; 10) {
                gameState.moveHistory.shift();
            }
            
            updateHistoryDisplay();
        }

        // Mettre à jour l&#x27;affichage de l&#x27;historique
        function updateHistoryDisplay() {
            const historyElement = document.getElementById(&#x27;historyContent&#x27;);
            const t = translations[gameState.currentLanguage];
            
            if(gameState.moveHistory.length === 0) {
                historyElement.textContent = t.historyEmpty;
            } else {
                historyElement.innerHTML = gameState.moveHistory
                    .slice(-5) // Afficher les 5 derniers coups
                    .map(move =&gt; `&lt;div style=&quot;margin-bottom: 5px;&quot;&gt;${move}&lt;/div&gt;`)
                    .join(&#x27;&#x27;);
            }
        }

        // Mettre à jour les statistiques
        function updateStats() {
            document.getElementById(&#x27;playerNodesValue&#x27;).textContent = gameState.playerNodes;
            document.getElementById(&#x27;aiNodesValue&#x27;).textContent = gameState.aiNodes;
            document.getElementById(&#x27;playerConnectionsValue&#x27;).textContent = gameState.playerConnections;
            document.getElementById(&#x27;aiConnectionsValue&#x27;).textContent = gameState.aiConnections;
        }

        // Mettre à jour le message de jeu
        function updateGameMessage() {
            const t = translations[gameState.currentLanguage];
            const messageElement = document.getElementById(&#x27;gameMessage&#x27;);
            
            if(gameState.gameOver) return;
            
            if(gameState.gameMode === &#x27;ai&#x27;) {
                if(gameState.currentPlayer === &#x27;player&#x27;) {
                    messageElement.innerHTML = `&lt;span&gt;${t.yourTurn}&lt;/span&gt;`;
                } else {
                    messageElement.innerHTML = `&lt;span&gt;${t.aiTurn}&lt;/span&gt;`;
                }
            } else {
                // Mode 2 joueurs
                if(gameState.currentPlayer === &#x27;player1&#x27;) {
                    messageElement.innerHTML = `&lt;span&gt;${t.player1Turn}&lt;/span&gt;`;
                } else {
                    messageElement.innerHTML = `&lt;span&gt;${t.player2Turn}&lt;/span&gt;`;
                }
            }
        }

        // Afficher un message temporaire
        function showMessage(message, duration = 0) {
            const messageElement = document.getElementById(&#x27;gameMessage&#x27;);
            messageElement.innerHTML = `&lt;span&gt;${message}&lt;/span&gt;`;
            
            if(duration &gt; 0) {
                setTimeout(() =&gt; {
                    updateGameMessage();
                }, duration);
            }
        }

        // Initialisation
        document.addEventListener(&#x27;DOMContentLoaded&#x27;, function() {
            createQuantumParticles();
            initializeBoard();
            createHexBoard();
            updateStats();
            updateHistoryDisplay();
            updateDifficultySelector();
            updateGameModeSelector();
            updateGameMessage();
        });
    &lt;/script&gt;
&lt;script&gt;(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement(&#x27;script&#x27;);d.innerHTML=&quot;window.__CF$cv$params={r:&#x27;985230952519e246&#x27;,t:&#x27;MTc1ODg4MzcxNS4wMDAwMDA=&#x27;};var a=document.createElement(&#x27;script&#x27;);a.nonce=&#x27;&#x27;;a.src=&#x27;/cdn-cgi/challenge-platform/scripts/jsd/main.js&#x27;;document.getElementsByTagName(&#x27;head&#x27;)[0].appendChild(a);&quot;;b.getElementsByTagName(&#x27;head&#x27;)[0].appendChild(d)}}if(document.body){var a=document.createElement(&#x27;iframe&#x27;);a.height=1;a.width=1;a.style.position=&#x27;absolute&#x27;;a.style.top=0;a.style.left=0;a.style.border=&#x27;none&#x27;;a.style.visibility=&#x27;hidden&#x27;;document.body.appendChild(a);if(&#x27;loading&#x27;!==document.readyState)c();else if(window.addEventListener)document.addEventListener(&#x27;DOMContentLoaded&#x27;,c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);&#x27;loading&#x27;!==document.readyState&amp;&amp;(document.onreadystatechange=e,c())}}}})();&lt;/script&gt;&lt;/body&gt;
&lt;/html&gt;
" style="width:100%;height:100%;border:none;"></iframe>
</div>

<script>
function launchGame9() {
  const overlay = document.getElementById("game9Overlay");
  overlay.style.display = "block";
}
function closeGame9() {
  const overlay = document.getElementById("game9Overlay");
  overlay.style.display = "none";
}
document.addEventListener("keydown", function(e) {
  if (e.key === "Escape") {
    const overlay = document.getElementById("game9Overlay");
    if (overlay && overlay.style.display === "block") {
      e.preventDefault();
      e.stopPropagation();
      closeGame9();
    }
  }
}, true);
</script>


<!-- === Overlay pour Jeu 10 === -->
<div id="game10Overlay" style="display:none;position:fixed;inset:0;background:#000;z-index:9999;">
  <button onclick="closeGame10()" style="position:absolute;top:10px;right:10px;z-index:10000;
    font-size:24px;background:red;color:white;border:none;border-radius:50%;width:40px;height:40px;
    cursor:pointer;">✖</button>
  <iframe id="iframeGame10" srcdoc="&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;fr&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;🚀 DEMO PLAYGROUND - Terrain d&#x27;Entraînement Futuriste&lt;/title&gt;
    &lt;script src=&quot;https://cdn.tailwindcss.com&quot;&gt;&lt;/script&gt;
    &lt;style&gt;
        body {
            box-sizing: border-box;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: &#x27;Segoe UI&#x27;, Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a3e 30%, #2d1b69 70%, #4c1d95 100%);
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }

        /* Particules futuristes d&#x27;arrière-plan */
        .cyber-particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .cyber-particle {
            position: absolute;
            width: 3px;
            height: 3px;
            background: #00ffff;
            border-radius: 50%;
            animation: cyberFloat 20s infinite linear;
            box-shadow: 0 0 20px #00ffff, 0 0 40px #0080ff;
        }

        @keyframes cyberFloat {
            0% {
                transform: translateY(100vh) translateX(0) rotate(0deg) scale(0);
                opacity: 0;
            }
            10% {
                opacity: 1;
                transform: translateY(90vh) translateX(50px) rotate(90deg) scale(1);
            }
            50% {
                transform: translateY(50vh) translateX(-60px) rotate(180deg) scale(1.8);
            }
            90% {
                opacity: 1;
                transform: translateY(10vh) translateX(80px) rotate(270deg) scale(1);
            }
            100% {
                transform: translateY(-10vh) translateX(120px) rotate(360deg) scale(0);
                opacity: 0;
            }
        }

        /* Grille cyber de fond */
        .cyber-grid {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(0, 255, 255, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 255, 0.1) 1px, transparent 1px);
            background-size: 100px 100px;
            animation: cyberGridPulse 25s linear infinite;
            z-index: 1;
        }

        @keyframes cyberGridPulse {
            0%, 100% { 
                transform: translate(0, 0) scale(1);
                opacity: 0.2;
            }
            50% { 
                transform: translate(50px, 50px) scale(1.1);
                opacity: 0.4;
            }
        }

        /* Container principal */
        .playground-container {
            position: relative;
            z-index: 10;
            display: grid;
            grid-template-columns: 200px 1fr 200px;
            grid-template-rows: 1fr;
            gap: 20px;
            min-height: 100vh;
            padding: 20px;
            max-width: 100%;
            margin: 0;
        }

        .game-panel {
            background: linear-gradient(145deg, 
                rgba(15, 15, 35, 0.95) 0%,
                rgba(26, 26, 62, 0.95) 30%,
                rgba(45, 27, 105, 0.95) 70%,
                rgba(76, 29, 149, 0.95) 100%);
            backdrop-filter: blur(40px);
            border-radius: 30px;
            padding: 30px;
            width: 100%;
            height: fit-content;
            box-shadow: 
                0 40px 80px rgba(0, 0, 0, 0.9),
                0 0 150px rgba(0, 255, 255, 0.3),
                inset 0 2px 0 rgba(255, 255, 255, 0.1);
            border: 4px solid rgba(0, 255, 255, 0.5);
            animation: cyberPanelGlow 6s ease-in-out infinite alternate;
            grid-column: 2;
        }

        .left-panel, .right-panel {
            background: linear-gradient(145deg, 
                rgba(15, 15, 35, 0.95) 0%,
                rgba(26, 26, 62, 0.95) 30%,
                rgba(45, 27, 105, 0.95) 70%,
                rgba(76, 29, 149, 0.95) 100%);
            backdrop-filter: blur(40px);
            border-radius: 20px;
            padding: 18px;
            height: fit-content;
            box-shadow: 
                0 20px 40px rgba(0, 0, 0, 0.7),
                0 0 80px rgba(0, 255, 255, 0.2),
                inset 0 2px 0 rgba(255, 255, 255, 0.1);
            border: 3px solid rgba(0, 255, 255, 0.4);
        }

        .right-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .panel-section {
            margin-bottom: 18px;
        }

        @keyframes cyberPanelGlow {
            from { 
                box-shadow: 
                    0 40px 80px rgba(0, 0, 0, 0.9),
                    0 0 150px rgba(0, 255, 255, 0.3),
                    inset 0 2px 0 rgba(255, 255, 255, 0.1);
            }
            to { 
                box-shadow: 
                    0 45px 90px rgba(0, 0, 0, 0.9),
                    0 0 200px rgba(0, 255, 255, 0.4),
                    inset 0 2px 0 rgba(255, 255, 255, 0.2);
            }
        }

        /* En-tête du jeu */
        .cyber-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 18px;
            padding-bottom: 15px;
            border-bottom: 3px solid rgba(0, 255, 255, 0.5);
        }

        .cyber-title {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .cyber-title h1 {
            color: #00ffff;
            margin: 0;
            font-size: 20px;
            font-weight: 700;
            text-shadow: 0 0 30px rgba(0, 255, 255, 0.9);
            animation: cyberTitlePulse 5s infinite alternate;
        }

        @keyframes cyberTitlePulse {
            from { 
                text-shadow: 0 0 50px rgba(0, 255, 255, 0.9);
                transform: scale(1);
            }
            to { 
                text-shadow: 0 0 70px rgba(0, 255, 255, 1);
                transform: scale(1.08);
            }
        }

        .cyber-icon {
            font-size: 24px;
            animation: cyberIconRotate 8s ease-in-out infinite;
            filter: drop-shadow(0 0 20px #00ffff);
        }

        @keyframes cyberIconRotate {
            0%, 100% { transform: scale(1) rotate(0deg); }
            25% { transform: scale(1.2) rotate(90deg); }
            50% { transform: scale(1.1) rotate(180deg); }
            75% { transform: scale(1.2) rotate(270deg); }
        }

        .cyber-badge {
            background: linear-gradient(45deg, #00ffff, #0080ff, #4040ff, #8000ff);
            background-size: 400% 400%;
            color: white;
            padding: 10px 18px;
            border-radius: 20px;
            font-size: 11px;
            font-weight: bold;
            animation: cyberBadgeShine 6s ease-in-out infinite;
            box-shadow: 0 0 25px rgba(0, 255, 255, 0.6);
        }

        @keyframes cyberBadgeShine {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        /* Sélecteur de langue personnalisé */
        .language-dropdown {
            position: relative;
            display: inline-block;
        }

        .language-selector {
            background: linear-gradient(145deg, 
                rgba(15, 15, 35, 0.95) 0%,
                rgba(26, 26, 62, 0.95) 30%,
                rgba(45, 27, 105, 0.95) 70%,
                rgba(0, 255, 255, 0.95) 100%);
            color: #00ffff;
            border: 4px solid rgba(0, 255, 255, 0.6);
            border-radius: 25px;
            padding: 18px 25px;
            font-weight: bold;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.4s ease;
            box-shadow: 
                0 0 40px rgba(0, 255, 255, 0.4),
                0 0 60px rgba(0, 128, 255, 0.2),
                inset 0 2px 0 rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(25px);
            min-width: 200px;
            text-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        .language-selector:hover {
            background: linear-gradient(145deg, 
                rgba(0, 255, 255, 0.9) 0%,
                rgba(0, 128, 255, 0.9) 30%,
                rgba(64, 64, 255, 0.9) 70%,
                rgba(128, 0, 255, 0.9) 100%);
            transform: translateY(-4px);
            box-shadow: 
                0 15px 40px rgba(0, 255, 255, 0.6),
                0 0 80px rgba(0, 128, 255, 0.4),
                inset 0 2px 0 rgba(255, 255, 255, 0.2);
            color: white;
            text-shadow: 0 0 25px rgba(255, 255, 255, 0.8);
        }

        .language-dropdown-arrow {
            font-size: 14px;
            transition: transform 0.3s ease;
        }

        .language-dropdown.open .language-dropdown-arrow {
            transform: rotate(180deg);
        }

        .language-dropdown-menu {
            position: absolute;
            top: 100%;
            right: 0;
            background: linear-gradient(145deg, 
                rgba(15, 15, 35, 0.98) 0%,
                rgba(26, 26, 62, 0.98) 50%,
                rgba(45, 27, 105, 0.98) 100%);
            backdrop-filter: blur(40px);
            border: 4px solid rgba(0, 255, 255, 0.6);
            border-radius: 20px;
            box-shadow: 
                0 25px 50px rgba(0, 0, 0, 0.9),
                0 0 80px rgba(0, 255, 255, 0.4);
            min-width: 220px;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-15px);
            transition: all 0.3s ease;
            margin-top: 12px;
        }

        .language-dropdown.open .language-dropdown-menu {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .language-option {
            padding: 18px 25px;
            color: #00ffff;
            cursor: pointer;
            transition: all 0.3s ease;
            border-bottom: 1px solid rgba(0, 255, 255, 0.2);
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .language-option:last-child {
            border-bottom: none;
            border-radius: 0 0 16px 16px;
        }

        .language-option:first-child {
            border-radius: 16px 16px 0 0;
        }

        .language-option:hover {
            background: rgba(0, 255, 255, 0.3);
            color: white;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.8);
        }

        .language-option.active {
            background: rgba(0, 255, 255, 0.5);
            color: white;
        }

        /* Sélecteur compact pour la difficulté */
        .compact-selector {
            background: linear-gradient(145deg, 
                rgba(15, 15, 35, 0.95) 0%,
                rgba(26, 26, 62, 0.95) 30%,
                rgba(45, 27, 105, 0.95) 70%,
                rgba(0, 255, 255, 0.95) 100%);
            color: #00ffff;
            border: 3px solid rgba(0, 255, 255, 0.6);
            border-radius: 15px;
            padding: 12px 18px;
            font-weight: bold;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.4s ease;
            box-shadow: 
                0 0 25px rgba(0, 255, 255, 0.3),
                0 0 40px rgba(0, 128, 255, 0.1),
                inset 0 2px 0 rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            text-shadow: 0 0 15px rgba(0, 255, 255, 0.6);
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
        }

        .compact-selector option {
            background: rgba(15, 15, 35, 0.98);
            color: #00ffff;
            padding: 10px;
            font-weight: bold;
        }

        .compact-selector:hover {
            background: linear-gradient(145deg, 
                rgba(0, 255, 255, 0.8) 0%,
                rgba(0, 128, 255, 0.8) 30%,
                rgba(64, 64, 255, 0.8) 70%,
                rgba(128, 0, 255, 0.8) 100%);
            transform: translateY(-2px);
            box-shadow: 
                0 8px 25px rgba(0, 255, 255, 0.5),
                0 0 50px rgba(0, 128, 255, 0.3),
                inset 0 2px 0 rgba(255, 255, 255, 0.2);
            color: white;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.8);
        }

        /* Panneau de titre des sections */
        .panel-title {
            color: #00ffff;
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 15px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 20px rgba(0, 255, 255, 0.9);
            border-bottom: 3px solid rgba(0, 255, 255, 0.4);
            padding-bottom: 10px;
        }

        /* Zone de jeu principale */
        .playground-arena {
            background: rgba(0, 0, 0, 0.9);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 20px;
            border: 4px solid rgba(0, 255, 255, 0.6);
            box-shadow: 
                0 0 50px rgba(0, 255, 255, 0.4),
                inset 0 0 30px rgba(0, 255, 255, 0.1);
            width: 100%;
            max-width: 700px;
            margin-left: auto;
            margin-right: auto;
            min-height: 400px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .game-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            gap: 3px;
            background: rgba(0, 255, 255, 0.1);
            padding: 15px;
            border-radius: 15px;
            border: 2px solid rgba(0, 255, 255, 0.3);
        }

        .grid-cell {
            width: 50px;
            height: 50px;
            background: linear-gradient(145deg, #1a1a3e, #0f0f23);
            border: 2px solid rgba(0, 255, 255, 0.3);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: bold;
        }

        .grid-cell:hover {
            background: linear-gradient(145deg, #00ffff, #0080ff);
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.8);
            transform: scale(1.1);
            border-color: #00ffff;
        }

        .grid-cell.player {
            background: linear-gradient(145deg, #00ff00, #008000);
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.8);
            color: white;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.8);
        }

        .grid-cell.ai {
            background: linear-gradient(145deg, #ff0080, #800040);
            box-shadow: 0 0 30px rgba(255, 0, 128, 0.8);
            color: white;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.8);
        }

        .grid-cell.target {
            background: linear-gradient(145deg, #ffff00, #ff8000);
            box-shadow: 0 0 30px rgba(255, 255, 0, 0.8);
            animation: targetPulse 2s ease-in-out infinite alternate;
        }

        @keyframes targetPulse {
            from { 
                box-shadow: 0 0 30px rgba(255, 255, 0, 0.8);
                transform: scale(1);
            }
            to { 
                box-shadow: 0 0 40px rgba(255, 255, 0, 1);
                transform: scale(1.05);
            }
        }

        /* Contrôles du jeu */
        .game-controls {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 30px;
            flex-wrap: wrap;
        }

        .cyber-btn {
            padding: 20px 40px;
            background: linear-gradient(145deg, #00ffff, #0080ff);
            color: white;
            border: none;
            border-radius: 25px;
            font-weight: bold;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.4s ease;
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 2px;
            min-width: 180px;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.4);
        }

        .compact-btn {
            padding: 12px 20px;
            font-size: 12px;
            min-width: 120px;
            letter-spacing: 1px;
        }

        .cyber-btn::before {
            content: &#x27;&#x27;;
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            transition: left 0.6s ease;
        }

        .cyber-btn:hover::before {
            left: 100%;
        }

        .cyber-btn:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(0, 255, 255, 0.6);
            background: linear-gradient(145deg, #0080ff, #4040ff);
        }

        .cyber-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .start-btn {
            background: linear-gradient(145deg, #00ff00, #008000);
        }

        .start-btn:hover {
            background: linear-gradient(145deg, #008000, #004000);
        }

        .reset-btn {
            background: linear-gradient(145deg, #ff4040, #800020);
        }

        .reset-btn:hover {
            background: linear-gradient(145deg, #800020, #400010);
        }

        /* Statistiques du jeu */
        .game-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 20px;
        }

        .stat-item {
            background: rgba(0, 255, 255, 0.15);
            padding: 12px;
            border-radius: 15px;
            text-align: center;
            border: 3px solid rgba(0, 255, 255, 0.3);
            position: relative;
            overflow: hidden;
        }

        .stat-item::before {
            content: &#x27;&#x27;;
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 255, 0.3), transparent);
            animation: statCyberScan 6s linear infinite;
        }

        @keyframes statCyberScan {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .stat-label {
            display: block;
            color: #a1a1aa;
            font-size: 10px;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-value {
            display: block;
            color: #00ffff;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 0 0 20px rgba(0, 255, 255, 0.9);
            position: relative;
            z-index: 1;
        }

        /* Messages de jeu */
        .game-message {
            text-align: center;
            margin-bottom: 25px;
            padding: 20px;
            border-radius: 15px;
            background: rgba(0, 255, 255, 0.15);
            border: 3px solid rgba(0, 255, 255, 0.3);
            color: #00ffff;
            font-weight: bold;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
        }

        /* IA Status */
        .ai-thinking {
            animation: aiThinking 2.5s ease-in-out infinite;
        }

        @keyframes aiThinking {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        /* Niveaux de difficulté */
        .difficulty-indicator {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin: 15px 0;
        }

        .difficulty-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: rgba(0, 255, 255, 0.3);
            transition: all 0.3s ease;
        }

        .difficulty-dot.active {
            background: #00ffff;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.8);
        }

        /* Responsive */
        @media (max-width: 1200px) {
            .playground-container {
                grid-template-columns: 180px 1fr 180px;
                gap: 15px;
                padding: 15px;
            }
        }

        @media (max-width: 900px) {
            .playground-container {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto auto;
                gap: 20px;
            }
            
            .left-panel {
                grid-row: 2;
            }
            
            .right-panel {
                grid-row: 3;
            }
        }

        @media (max-width: 768px) {
            .game-panel {
                padding: 25px;
            }
            
            .cyber-title h1 {
                font-size: 24px;
            }
            
            .playground-arena {
                max-width: 450px;
                padding: 20px;
            }
            
            .game-grid {
                grid-template-columns: repeat(6, 1fr);
                grid-template-rows: repeat(6, 1fr);
            }
            
            .grid-cell {
                width: 40px;
                height: 40px;
                font-size: 18px;
            }
            
            .game-controls {
                flex-direction: column;
                gap: 20px;
            }
            
            .cyber-btn {
                min-width: 160px;
                padding: 18px 30px;
            }
        }

        @media (max-width: 480px) {
            .playground-arena {
                max-width: 350px;
            }
            
            .grid-cell {
                width: 35px;
                height: 35px;
                font-size: 16px;
            }
            
            .cyber-title {
                flex-direction: column;
                gap: 20px;
            }
            
            .cyber-title h1 {
                font-size: 20px;
            }
        }

        /* Animations de victoire */
        .victory-animation {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            backdrop-filter: blur(25px);
        }

        .victory-content {
            background: linear-gradient(145deg, rgba(15, 15, 35, 0.95), rgba(45, 27, 105, 0.95));
            border: 5px solid #00ffff;
            border-radius: 30px;
            padding: 60px;
            text-align: center;
            color: white;
            font-size: 26px;
            font-weight: bold;
            max-width: 700px;
            box-shadow: 0 0 80px rgba(0, 255, 255, 0.8);
            animation: victoryPulse 4s ease-in-out infinite alternate;
        }

        @keyframes victoryPulse {
            from { 
                box-shadow: 0 0 80px rgba(0, 255, 255, 0.8);
                transform: scale(1);
            }
            to { 
                box-shadow: 0 0 120px rgba(0, 255, 255, 1);
                transform: scale(1.08);
            }
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!-- Particules cyber d&#x27;arrière-plan --&gt;
    &lt;div class=&quot;cyber-particles&quot; id=&quot;cyberParticles&quot;&gt;&lt;/div&gt;
    
    &lt;!-- Grille cyber --&gt;
    &lt;div class=&quot;cyber-grid&quot;&gt;&lt;/div&gt;
    
    &lt;!-- Container principal --&gt;
    &lt;div class=&quot;playground-container&quot;&gt;
        &lt;!-- Panneau gauche --&gt;
        &lt;div class=&quot;left-panel&quot;&gt;
            &lt;div class=&quot;panel-section&quot;&gt;
                &lt;div class=&quot;panel-title&quot; id=&quot;statsTitle&quot;&gt;📊 Statistiques&lt;/div&gt;
                &lt;div class=&quot;game-stats&quot;&gt;
                    &lt;div class=&quot;stat-item&quot;&gt;
                        &lt;span class=&quot;stat-label&quot; id=&quot;scoreLabel&quot;&gt;Score&lt;/span&gt;
                        &lt;span class=&quot;stat-value&quot; id=&quot;scoreValue&quot;&gt;0&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;stat-item&quot;&gt;
                        &lt;span class=&quot;stat-label&quot; id=&quot;levelLabel&quot;&gt;Niveau&lt;/span&gt;
                        &lt;span class=&quot;stat-value&quot; id=&quot;levelValue&quot;&gt;1&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;stat-item&quot;&gt;
                        &lt;span class=&quot;stat-label&quot; id=&quot;movesLabel&quot;&gt;Mouvements&lt;/span&gt;
                        &lt;span class=&quot;stat-value&quot; id=&quot;movesValue&quot;&gt;0&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;stat-item&quot;&gt;
                        &lt;span class=&quot;stat-label&quot; id=&quot;timeLabel&quot;&gt;Temps&lt;/span&gt;
                        &lt;span class=&quot;stat-value&quot; id=&quot;timeValue&quot;&gt;00:00&lt;/span&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;div class=&quot;panel-section&quot;&gt;
                &lt;div class=&quot;panel-title&quot; id=&quot;controlsTitle&quot;&gt;⚡ Contrôles Cyber&lt;/div&gt;
                &lt;div style=&quot;display: grid; gap: 18px;&quot;&gt;
                    &lt;button class=&quot;cyber-btn start-btn compact-btn&quot; onclick=&quot;startGame()&quot;&gt;
                        🚀 &lt;span id=&quot;startGameText&quot;&gt;Démarrer Mission&lt;/span&gt;
                    &lt;/button&gt;
                    &lt;button class=&quot;cyber-btn reset-btn compact-btn&quot; onclick=&quot;resetGame()&quot; id=&quot;resetBtn&quot;&gt;
                        🔄 &lt;span id=&quot;resetText&quot;&gt;Reset Arena&lt;/span&gt;
                    &lt;/button&gt;
                    &lt;button class=&quot;cyber-btn compact-btn&quot; onclick=&quot;getHint()&quot; id=&quot;hintBtn&quot;&gt;
                        🧠 &lt;span id=&quot;hintText&quot;&gt;Analyse IA&lt;/span&gt;
                    &lt;/button&gt;
                    &lt;button class=&quot;cyber-btn compact-btn&quot; onclick=&quot;pauseGame()&quot; id=&quot;pauseBtn&quot;&gt;
                        &lt;span id=&quot;pauseIcon&quot;&gt;⏸️&lt;/span&gt; &lt;span id=&quot;pauseText&quot;&gt;Pause&lt;/span&gt;
                    &lt;/button&gt;
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;div class=&quot;panel-section&quot;&gt;
                &lt;div class=&quot;panel-title&quot; id=&quot;difficultyTitle&quot;&gt;🎯 Niveau Mission&lt;/div&gt;
                &lt;select id=&quot;difficultySelector&quot; onchange=&quot;changeDifficulty()&quot; class=&quot;compact-selector&quot; style=&quot;width: 100%; text-align: center; margin-bottom: 15px;&quot;&gt;
                    &lt;option value=&quot;1&quot;&gt;🟢 Recrue&lt;/option&gt;
                    &lt;option value=&quot;2&quot;&gt;🟡 Soldat&lt;/option&gt;
                    &lt;option value=&quot;3&quot; selected&gt;🟠 Vétéran&lt;/option&gt;
                    &lt;option value=&quot;4&quot;&gt;🔴 Elite&lt;/option&gt;
                    &lt;option value=&quot;5&quot;&gt;🟣 Légende&lt;/option&gt;
                &lt;/select&gt;
                &lt;div class=&quot;difficulty-indicator&quot; id=&quot;difficultyIndicator&quot;&gt;
                    &lt;div class=&quot;difficulty-dot&quot;&gt;&lt;/div&gt;
                    &lt;div class=&quot;difficulty-dot&quot;&gt;&lt;/div&gt;
                    &lt;div class=&quot;difficulty-dot active&quot;&gt;&lt;/div&gt;
                    &lt;div class=&quot;difficulty-dot&quot;&gt;&lt;/div&gt;
                    &lt;div class=&quot;difficulty-dot&quot;&gt;&lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;

        &lt;!-- Panneau central --&gt;
        &lt;div class=&quot;game-panel&quot;&gt;
            &lt;!-- En-tête --&gt;
            &lt;div class=&quot;cyber-header&quot;&gt;
                &lt;div class=&quot;cyber-title&quot;&gt;
                    &lt;span class=&quot;cyber-icon&quot;&gt;🚀&lt;/span&gt;
                    &lt;h1 id=&quot;gameTitle&quot;&gt;DEMO PLAYGROUND&lt;/h1&gt;
                    &lt;span class=&quot;cyber-badge&quot; id=&quot;cyberBadge&quot;&gt;🤖 IA FUTURISTE&lt;/span&gt;
                &lt;/div&gt;
                &lt;div style=&quot;display: flex; align-items: center; gap: 30px;&quot;&gt;
                    &lt;div class=&quot;language-dropdown&quot; id=&quot;languageDropdown&quot;&gt;
                        &lt;div class=&quot;language-selector&quot; onclick=&quot;toggleLanguageDropdown()&quot;&gt;
                            &lt;span id=&quot;selectedLanguage&quot;&gt;🇫🇷 Français&lt;/span&gt;
                            &lt;span class=&quot;language-dropdown-arrow&quot;&gt;▼&lt;/span&gt;
                        &lt;/div&gt;
                        &lt;div class=&quot;language-dropdown-menu&quot; id=&quot;languageMenu&quot;&gt;
                            &lt;div class=&quot;language-option active&quot; onclick=&quot;selectLanguage(&#x27;fr&#x27;, &#x27;🇫🇷 Français&#x27;)&quot;&gt;🇫🇷 Français&lt;/div&gt;
                            &lt;div class=&quot;language-option&quot; onclick=&quot;selectLanguage(&#x27;en&#x27;, &#x27;🇺🇸 English&#x27;)&quot;&gt;🇺🇸 English&lt;/div&gt;
                            &lt;div class=&quot;language-option&quot; onclick=&quot;selectLanguage(&#x27;ar&#x27;, &#x27;🇸🇦 العربية&#x27;)&quot;&gt;🇸🇦 العربية&lt;/div&gt;
                            &lt;div class=&quot;language-option&quot; onclick=&quot;selectLanguage(&#x27;es&#x27;, &#x27;🇪🇸 Español&#x27;)&quot;&gt;🇪🇸 Español&lt;/div&gt;
                            &lt;div class=&quot;language-option&quot; onclick=&quot;selectLanguage(&#x27;de&#x27;, &#x27;🇩🇪 Deutsch&#x27;)&quot;&gt;🇩🇪 Deutsch&lt;/div&gt;
                            &lt;div class=&quot;language-option&quot; onclick=&quot;selectLanguage(&#x27;zh&#x27;, &#x27;🇨🇳 中文&#x27;)&quot;&gt;🇨🇳 中文&lt;/div&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;!-- Message de jeu --&gt;
            &lt;div class=&quot;game-message&quot; id=&quot;gameMessage&quot;&gt;
                &lt;span id=&quot;welcomeMessage&quot;&gt;🚀 Bienvenue dans le Terrain d&#x27;Entraînement Futuriste&lt;/span&gt;
            &lt;/div&gt;

            &lt;!-- Zone de jeu principale --&gt;
            &lt;div class=&quot;playground-arena&quot; id=&quot;playgroundArena&quot;&gt;
                &lt;div class=&quot;game-grid&quot; id=&quot;gameGrid&quot;&gt;
                    &lt;!-- Les cellules seront générées par JavaScript --&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;

        &lt;!-- Panneau droit --&gt;
        &lt;div class=&quot;right-panel&quot;&gt;
            &lt;div class=&quot;panel-section&quot;&gt;
                &lt;div class=&quot;panel-title&quot; id=&quot;missionTitle&quot;&gt;🎯 Objectif Mission&lt;/div&gt;
                &lt;div style=&quot;color: #a1a1aa; font-size: 15px; line-height: 2;&quot;&gt;
                    &lt;p id=&quot;missionText&quot;&gt;
                        • Collectez tous les orbes d&#x27;énergie&lt;br&gt;
                        • Évitez les sentinelles IA&lt;br&gt;
                        • Atteignez la zone d&#x27;extraction&lt;br&gt;
                        • Optimisez votre score temporel&lt;br&gt;
                        • Maîtrisez chaque niveau progressif
                    &lt;/p&gt;
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;div class=&quot;panel-section&quot;&gt;
                &lt;div class=&quot;panel-title&quot; id=&quot;strategiesTitle&quot;&gt;🧠 Stratégies&lt;/div&gt;
                &lt;div style=&quot;color: #a1a1aa; font-size: 14px; line-height: 1.8;&quot;&gt;
                    &lt;div style=&quot;margin-bottom: 12px;&quot;&gt;
                        &lt;span style=&quot;color: #00ff00;&quot;&gt;🟢&lt;/span&gt; &lt;span id=&quot;strategy1Text&quot;&gt;Planifiez vos mouvements&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div style=&quot;margin-bottom: 12px;&quot;&gt;
                        &lt;span style=&quot;color: #00ffff;&quot;&gt;🔵&lt;/span&gt; &lt;span id=&quot;strategy2Text&quot;&gt;Analysez les patterns IA&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div style=&quot;margin-bottom: 12px;&quot;&gt;
                        &lt;span style=&quot;color: #ffff00;&quot;&gt;🟡&lt;/span&gt; &lt;span id=&quot;strategy3Text&quot;&gt;Optimisez le temps&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div style=&quot;margin-bottom: 12px;&quot;&gt;
                        &lt;span style=&quot;color: #ff0080;&quot;&gt;🟣&lt;/span&gt; &lt;span id=&quot;strategy4Text&quot;&gt;Adaptez-vous aux niveaux&lt;/span&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;div class=&quot;panel-section&quot;&gt;
                &lt;div class=&quot;panel-title&quot; id=&quot;aiStatusTitle&quot;&gt;🤖 État IA&lt;/div&gt;
                &lt;div id=&quot;aiStatus&quot; style=&quot;color: #00ffff; font-size: 15px; text-align: center; padding: 18px;&quot;&gt;
                    &lt;span id=&quot;aiStatusText&quot;&gt;Système IA Initialisé&lt;/span&gt;
                &lt;/div&gt;
                &lt;div style=&quot;color: #a1a1aa; font-size: 13px; text-align: center; margin-top: 15px;&quot; id=&quot;aiAnalysis&quot;&gt;
                    &lt;span id=&quot;aiAnalysisText&quot;&gt;Analyse comportementale en cours...&lt;/span&gt;
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;div class=&quot;panel-section&quot;&gt;
                &lt;div class=&quot;panel-title&quot; id=&quot;achievementsTitle&quot;&gt;🏆 Succès&lt;/div&gt;
                &lt;div id=&quot;achievementsList&quot; style=&quot;color: #a1a1aa; font-size: 12px; max-height: 140px; overflow-y: auto; line-height: 1.6;&quot;&gt;
                    &lt;div id=&quot;achievementsContent&quot;&gt;Aucun succès débloqué&lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;script&gt;
        // Traductions multilingues
        const translations = {
            fr: {
                gameTitle: &quot;DEMO PLAYGROUND&quot;,
                cyberBadge: &quot;🤖 IA FUTURISTE&quot;,
                controlsTitle: &quot;⚡ Contrôles Cyber&quot;,
                statsTitle: &quot;📊 Statistiques&quot;,
                difficultyTitle: &quot;🎯 Niveau Mission&quot;,
                missionTitle: &quot;🎯 Objectif Mission&quot;,
                strategiesTitle: &quot;🧠 Stratégies&quot;,
                aiStatusTitle: &quot;🤖 État IA&quot;,
                achievementsTitle: &quot;🏆 Succès&quot;,
                startGameText: &quot;Démarrer Mission&quot;,
                resetText: &quot;Reset Arena&quot;,
                hintText: &quot;Analyse IA&quot;,
                pauseText: &quot;Pause&quot;,
                resumeText: &quot;Reprendre&quot;,
                scoreLabel: &quot;Score&quot;,
                levelLabel: &quot;Niveau&quot;,
                movesLabel: &quot;Mouvements&quot;,
                timeLabel: &quot;Temps&quot;,
                welcomeMessage: &quot;🚀 Bienvenue dans le Terrain d&#x27;Entraînement Futuriste&quot;,
                missionText: &quot;• Collectez tous les orbes d&#x27;énergie&lt;br&gt;• Évitez les sentinelles IA&lt;br&gt;• Atteignez la zone d&#x27;extraction&lt;br&gt;• Optimisez votre score temporel&lt;br&gt;• Maîtrisez chaque niveau progressif&quot;,
                strategy1Text: &quot;Planifiez vos mouvements&quot;,
                strategy2Text: &quot;Analysez les patterns IA&quot;,
                strategy3Text: &quot;Optimisez le temps&quot;,
                strategy4Text: &quot;Adaptez-vous aux niveaux&quot;,
                aiStatusText: &quot;Système IA Initialisé&quot;,
                aiAnalysisText: &quot;Analyse comportementale en cours...&quot;,
                achievementsContent: &quot;Aucun succès débloqué&quot;,
                gameStarted: &quot;🚀 Mission commencée - Collectez les orbes !&quot;,
                gameWon: &quot;🎉 Mission accomplie ! Niveau suivant débloqué !&quot;,
                gameLost: &quot;💥 Mission échouée ! Réessayez pour améliorer votre score !&quot;,
                gamePaused: &quot;⏸️ Mission en pause - Cliquez pour reprendre&quot;,
                hintMessage: &quot;💡 Conseil Tactique: Analysez les mouvements IA&quot;,
                levelUp: &quot;⬆️ Niveau supérieur ! Difficulté augmentée !&quot;,
                perfectScore: &quot;⭐ Score parfait ! Maîtrise totale !&quot;,
                speedBonus: &quot;⚡ Bonus vitesse ! Exécution rapide !&quot;,
                energyBoostMessage: &quot;⚡ BOOST D&#x27;ÉNERGIE ACTIVÉ! Sentinelles ralenties! ⚡&quot;,
                difficultyLevels: {
                    1: &quot;🟢 Recrue&quot;,
                    2: &quot;🟡 Soldat&quot;, 
                    3: &quot;🟠 Vétéran&quot;,
                    4: &quot;🔴 Elite&quot;,
                    5: &quot;🟣 Légende&quot;
                }
            },
            en: {
                gameTitle: &quot;DEMO PLAYGROUND&quot;,
                cyberBadge: &quot;🤖 FUTURISTIC AI&quot;,
                controlsTitle: &quot;⚡ Cyber Controls&quot;,
                statsTitle: &quot;📊 Statistics&quot;,
                difficultyTitle: &quot;🎯 Mission Level&quot;,
                missionTitle: &quot;🎯 Mission Objective&quot;,
                strategiesTitle: &quot;🧠 Strategies&quot;,
                aiStatusTitle: &quot;🤖 AI Status&quot;,
                achievementsTitle: &quot;🏆 Achievements&quot;,
                startGameText: &quot;Start Mission&quot;,
                resetText: &quot;Reset Arena&quot;,
                hintText: &quot;AI Analysis&quot;,
                pauseText: &quot;Pause&quot;,
                resumeText: &quot;Resume&quot;,
                scoreLabel: &quot;Score&quot;,
                levelLabel: &quot;Level&quot;,
                movesLabel: &quot;Moves&quot;,
                timeLabel: &quot;Time&quot;,
                welcomeMessage: &quot;🚀 Welcome to the Futuristic Training Ground&quot;,
                missionText: &quot;• Collect all energy orbs&lt;br&gt;• Avoid AI sentinels&lt;br&gt;• Reach extraction zone&lt;br&gt;• Optimize time score&lt;br&gt;• Master each progressive level&quot;,
                strategy1Text: &quot;Plan your movements&quot;,
                strategy2Text: &quot;Analyze AI patterns&quot;,
                strategy3Text: &quot;Optimize timing&quot;,
                strategy4Text: &quot;Adapt to levels&quot;,
                aiStatusText: &quot;AI System Initialized&quot;,
                aiAnalysisText: &quot;Behavioral analysis in progress...&quot;,
                achievementsContent: &quot;No achievements unlocked&quot;,
                gameStarted: &quot;🚀 Mission started - Collect the orbs!&quot;,
                gameWon: &quot;🎉 Mission accomplished! Next level unlocked!&quot;,
                gameLost: &quot;💥 Mission failed! Try again to improve your score!&quot;,
                gamePaused: &quot;⏸️ Mission paused - Click to resume&quot;,
                hintMessage: &quot;💡 Tactical Advice: Analyze AI movements&quot;,
                levelUp: &quot;⬆️ Level up! Difficulty increased!&quot;,
                perfectScore: &quot;⭐ Perfect score! Total mastery!&quot;,
                speedBonus: &quot;⚡ Speed bonus! Fast execution!&quot;,
                energyBoostMessage: &quot;⚡ ENERGY BOOST ACTIVATED! Sentinels slowed! ⚡&quot;,
                difficultyLevels: {
                    1: &quot;🟢 Recruit&quot;,
                    2: &quot;🟡 Soldier&quot;,
                    3: &quot;🟠 Veteran&quot;, 
                    4: &quot;🔴 Elite&quot;,
                    5: &quot;🟣 Legend&quot;
                }
            },
            ar: {
                gameTitle: &quot;ساحة التدريب التجريبية&quot;,
                cyberBadge: &quot;🤖 ذكاء مستقبلي&quot;,
                controlsTitle: &quot;⚡ تحكم سايبر&quot;,
                statsTitle: &quot;📊 إحصائيات&quot;,
                difficultyTitle: &quot;🎯 مستوى المهمة&quot;,
                missionTitle: &quot;🎯 هدف المهمة&quot;,
                strategiesTitle: &quot;🧠 استراتيجيات&quot;,
                aiStatusTitle: &quot;🤖 حالة الذكاء&quot;,
                achievementsTitle: &quot;🏆 إنجازات&quot;,
                startGameText: &quot;بدء المهمة&quot;,
                resetText: &quot;إعادة تعيين الساحة&quot;,
                hintText: &quot;تحليل ذكاء&quot;,
                pauseText: &quot;إيقاف مؤقت&quot;,
                resumeText: &quot;استئناف&quot;,
                scoreLabel: &quot;النقاط&quot;,
                levelLabel: &quot;المستوى&quot;,
                movesLabel: &quot;الحركات&quot;,
                timeLabel: &quot;الوقت&quot;,
                welcomeMessage: &quot;🚀 مرحباً في ساحة التدريب المستقبلية&quot;,
                missionText: &quot;• اجمع جميع كرات الطاقة&lt;br&gt;• تجنب حراس الذكاء&lt;br&gt;• اوصل لمنطقة الإخلاء&lt;br&gt;• حسن نقاط الوقت&lt;br&gt;• أتقن كل مستوى تدريجي&quot;,
                strategy1Text: &quot;خطط لحركاتك&quot;,
                strategy2Text: &quot;حلل أنماط الذكاء&quot;,
                strategy3Text: &quot;حسن التوقيت&quot;,
                strategy4Text: &quot;تكيف مع المستويات&quot;,
                aiStatusText: &quot;نظام الذكاء مهيأ&quot;,
                aiAnalysisText: &quot;تحليل سلوكي جاري...&quot;,
                achievementsContent: &quot;لا توجد إنجازات مفتوحة&quot;,
                gameStarted: &quot;🚀 بدأت المهمة - اجمع الكرات!&quot;,
                gameWon: &quot;🎉 تمت المهمة! المستوى التالي مفتوح!&quot;,
                gameLost: &quot;💥 فشلت المهمة! حاول مرة أخرى لتحسين نقاطك!&quot;,
                gamePaused: &quot;⏸️ المهمة متوقفة - اضغط للمتابعة&quot;,
                hintMessage: &quot;💡 نصيحة تكتيكية: حلل حركات الذكاء&quot;,
                levelUp: &quot;⬆️ مستوى أعلى! زادت الصعوبة!&quot;,
                perfectScore: &quot;⭐ نقاط مثالية! إتقان تام!&quot;,
                speedBonus: &quot;⚡ مكافأة سرعة! تنفيذ سريع!&quot;,
                energyBoostMessage: &quot;⚡ تم تفعيل دفعة الطاقة! تباطأ الحراس! ⚡&quot;,
                difficultyLevels: {
                    1: &quot;🟢 مجند&quot;,
                    2: &quot;🟡 جندي&quot;,
                    3: &quot;🟠 محارب قديم&quot;,
                    4: &quot;🔴 نخبة&quot;, 
                    5: &quot;🟣 أسطورة&quot;
                }
            },
            es: {
                gameTitle: &quot;DEMO PLAYGROUND&quot;,
                cyberBadge: &quot;🤖 IA FUTURISTA&quot;,
                controlsTitle: &quot;⚡ Controles Cyber&quot;,
                statsTitle: &quot;📊 Estadísticas&quot;,
                difficultyTitle: &quot;🎯 Nivel Misión&quot;,
                missionTitle: &quot;🎯 Objetivo Misión&quot;,
                strategiesTitle: &quot;🧠 Estrategias&quot;,
                aiStatusTitle: &quot;🤖 Estado IA&quot;,
                achievementsTitle: &quot;🏆 Logros&quot;,
                startGameText: &quot;Iniciar Misión&quot;,
                resetText: &quot;Reset Arena&quot;,
                hintText: &quot;Análisis IA&quot;,
                pauseText: &quot;Pausa&quot;,
                resumeText: &quot;Reanudar&quot;,
                scoreLabel: &quot;Puntuación&quot;,
                levelLabel: &quot;Nivel&quot;,
                movesLabel: &quot;Movimientos&quot;,
                timeLabel: &quot;Tiempo&quot;,
                welcomeMessage: &quot;🚀 Bienvenido al Campo de Entrenamiento Futurista&quot;,
                missionText: &quot;• Recolecta todos los orbes de energía&lt;br&gt;• Evita los centinelas IA&lt;br&gt;• Alcanza la zona de extracción&lt;br&gt;• Optimiza tu puntuación temporal&lt;br&gt;• Domina cada nivel progresivo&quot;,
                strategy1Text: &quot;Planifica tus movimientos&quot;,
                strategy2Text: &quot;Analiza patrones IA&quot;,
                strategy3Text: &quot;Optimiza el tiempo&quot;,
                strategy4Text: &quot;Adáptate a los niveles&quot;,
                aiStatusText: &quot;Sistema IA Inicializado&quot;,
                aiAnalysisText: &quot;Análisis comportamental en curso...&quot;,
                achievementsContent: &quot;Ningún logro desbloqueado&quot;,
                gameStarted: &quot;🚀 Misión iniciada - ¡Recolecta los orbes!&quot;,
                gameWon: &quot;🎉 ¡Misión cumplida! ¡Siguiente nivel desbloqueado!&quot;,
                gameLost: &quot;💥 ¡Misión fallida! ¡Inténtalo de nuevo para mejorar tu puntuación!&quot;,
                gamePaused: &quot;⏸️ Misión pausada - Haz clic para reanudar&quot;,
                hintMessage: &quot;💡 Consejo Táctico: Analiza movimientos IA&quot;,
                levelUp: &quot;⬆️ ¡Subir nivel! ¡Dificultad aumentada!&quot;,
                perfectScore: &quot;⭐ ¡Puntuación perfecta! ¡Dominio total!&quot;,
                speedBonus: &quot;⚡ ¡Bonus velocidad! ¡Ejecución rápida!&quot;,
                energyBoostMessage: &quot;⚡ ¡IMPULSO DE ENERGÍA ACTIVADO! ¡Centinelas ralentizados! ⚡&quot;,
                difficultyLevels: {
                    1: &quot;🟢 Recluta&quot;,
                    2: &quot;🟡 Soldado&quot;,
                    3: &quot;🟠 Veterano&quot;,
                    4: &quot;🔴 Elite&quot;,
                    5: &quot;🟣 Leyenda&quot;
                }
            },
            de: {
                gameTitle: &quot;DEMO PLAYGROUND&quot;,
                cyberBadge: &quot;🤖 FUTURISTISCHE KI&quot;,
                controlsTitle: &quot;⚡ Cyber Steuerung&quot;,
                statsTitle: &quot;📊 Statistiken&quot;,
                difficultyTitle: &quot;🎯 Missions Level&quot;,
                missionTitle: &quot;🎯 Missions Ziel&quot;,
                strategiesTitle: &quot;🧠 Strategien&quot;,
                aiStatusTitle: &quot;🤖 KI Status&quot;,
                achievementsTitle: &quot;🏆 Erfolge&quot;,
                startGameText: &quot;Mission Starten&quot;,
                resetText: &quot;Arena Reset&quot;,
                hintText: &quot;KI Analyse&quot;,
                pauseText: &quot;Pause&quot;,
                resumeText: &quot;Fortsetzen&quot;,
                scoreLabel: &quot;Punkte&quot;,
                levelLabel: &quot;Level&quot;,
                movesLabel: &quot;Züge&quot;,
                timeLabel: &quot;Zeit&quot;,
                welcomeMessage: &quot;🚀 Willkommen im Futuristischen Trainingsgelände&quot;,
                missionText: &quot;• Sammle alle Energie-Orbs&lt;br&gt;• Vermeide KI-Wächter&lt;br&gt;• Erreiche die Extraktionszone&lt;br&gt;• Optimiere deine Zeitpunkte&lt;br&gt;• Meistere jedes progressive Level&quot;,
                strategy1Text: &quot;Plane deine Bewegungen&quot;,
                strategy2Text: &quot;Analysiere KI-Muster&quot;,
                strategy3Text: &quot;Optimiere das Timing&quot;,
                strategy4Text: &quot;Passe dich an Level an&quot;,
                aiStatusText: &quot;KI-System Initialisiert&quot;,
                aiAnalysisText: &quot;Verhaltensanalyse läuft...&quot;,
                achievementsContent: &quot;Keine Erfolge freigeschaltet&quot;,
                gameStarted: &quot;🚀 Mission gestartet - Sammle die Orbs!&quot;,
                gameWon: &quot;🎉 Mission erfüllt! Nächstes Level freigeschaltet!&quot;,
                gameLost: &quot;💥 Mission fehlgeschlagen! Versuche es erneut für bessere Punkte!&quot;,
                gamePaused: &quot;⏸️ Mission pausiert - Klicken zum Fortsetzen&quot;,
                hintMessage: &quot;💡 Taktischer Rat: Analysiere KI-Bewegungen&quot;,
                levelUp: &quot;⬆️ Level up! Schwierigkeit erhöht!&quot;,
                perfectScore: &quot;⭐ Perfekte Punkte! Totale Meisterschaft!&quot;,
                speedBonus: &quot;⚡ Geschwindigkeitsbonus! Schnelle Ausführung!&quot;,
                energyBoostMessage: &quot;⚡ ENERGIE-BOOST AKTIVIERT! Wächter verlangsamt! ⚡&quot;,
                difficultyLevels: {
                    1: &quot;🟢 Rekrut&quot;,
                    2: &quot;🟡 Soldat&quot;,
                    3: &quot;🟠 Veteran&quot;,
                    4: &quot;🔴 Elite&quot;,
                    5: &quot;🟣 Legende&quot;
                }
            },
            zh: {
                gameTitle: &quot;演示游乐场&quot;,
                cyberBadge: &quot;🤖 未来人工智能&quot;,
                controlsTitle: &quot;⚡ 网络控制&quot;,
                statsTitle: &quot;📊 统计&quot;,
                difficultyTitle: &quot;🎯 任务等级&quot;,
                missionTitle: &quot;🎯 任务目标&quot;,
                strategiesTitle: &quot;🧠 策略&quot;,
                aiStatusTitle: &quot;🤖 AI状态&quot;,
                achievementsTitle: &quot;🏆 成就&quot;,
                startGameText: &quot;开始任务&quot;,
                resetText: &quot;重置竞技场&quot;,
                hintText: &quot;AI分析&quot;,
                pauseText: &quot;暂停&quot;,
                resumeText: &quot;继续&quot;,
                scoreLabel: &quot;分数&quot;,
                levelLabel: &quot;等级&quot;,
                movesLabel: &quot;移动&quot;,
                timeLabel: &quot;时间&quot;,
                welcomeMessage: &quot;🚀 欢迎来到未来训练场&quot;,
                missionText: &quot;• 收集所有能量球&lt;br&gt;• 避开AI哨兵&lt;br&gt;• 到达撤离区&lt;br&gt;• 优化时间分数&lt;br&gt;• 掌握每个渐进级别&quot;,
                strategy1Text: &quot;规划你的移动&quot;,
                strategy2Text: &quot;分析AI模式&quot;,
                strategy3Text: &quot;优化时机&quot;,
                strategy4Text: &quot;适应级别&quot;,
                aiStatusText: &quot;AI系统已初始化&quot;,
                aiAnalysisText: &quot;行为分析进行中...&quot;,
                achievementsContent: &quot;没有解锁成就&quot;,
                gameStarted: &quot;🚀 任务开始 - 收集能量球！&quot;,
                gameWon: &quot;🎉 任务完成！下一级别解锁！&quot;,
                gameLost: &quot;💥 任务失败！再试一次提高分数！&quot;,
                gamePaused: &quot;⏸️ 任务暂停 - 点击继续&quot;,
                hintMessage: &quot;💡 战术建议：分析AI移动&quot;,
                levelUp: &quot;⬆️ 升级！难度增加！&quot;,
                perfectScore: &quot;⭐ 完美分数！完全掌握！&quot;,
                speedBonus: &quot;⚡ 速度奖励！快速执行！&quot;,
                energyBoostMessage: &quot;⚡ 能量提升激活！哨兵减速！⚡&quot;,
                difficultyLevels: {
                    1: &quot;🟢 新兵&quot;,
                    2: &quot;🟡 士兵&quot;,
                    3: &quot;🟠 老兵&quot;,
                    4: &quot;🔴 精英&quot;,
                    5: &quot;🟣 传奇&quot;
                }
            }
        };

        // État du jeu
    var gameState = {
            currentLanguage: &#x27;fr&#x27;,
            isPlaying: false,
            isPaused: false,
            score: 0,
            level: 1,
            moves: 0,
            startTime: null,
            elapsedTime: 0,
            difficulty: 3,
            gridSize: 8,
            playerPos: {x: 0, y: 0},
            targets: [],
            obstacles: [],
            aiEntities: [],
            gameTimer: null,
            achievements: [],
            energyBoostTurns: 0, // Tours restants du boost d&#x27;énergie
            levelAttempts: {}, // Compteur de tentatives par niveau
            speedBoosts: {} // Bonus de vitesse accumulés par niveau
        };

        // Créer les particules cyber
        function createCyberParticles() {
            const container = document.getElementById(&#x27;cyberParticles&#x27;);
            
            for(let i = 0; i &lt; 50; i++) {
                const particle = document.createElement(&#x27;div&#x27;);
                particle.className = &#x27;cyber-particle&#x27;;
                particle.style.left = Math.random() * 100 + &#x27;%&#x27;;
                particle.style.animationDelay = Math.random() * 20 + &#x27;s&#x27;;
                particle.style.animationDuration = (20 + Math.random() * 10) + &#x27;s&#x27;;
                container.appendChild(particle);
            }
        }

        // Fonctions du sélecteur de langue
        function toggleLanguageDropdown() {
            const dropdown = document.getElementById(&#x27;languageDropdown&#x27;);
            dropdown.classList.toggle(&#x27;open&#x27;);
        }

        function selectLanguage(langCode, langText) {
            gameState.currentLanguage = langCode;
            document.getElementById(&#x27;selectedLanguage&#x27;).textContent = langText;
            
            const options = document.querySelectorAll(&#x27;.language-option&#x27;);
            options.forEach(option =&gt; option.classList.remove(&#x27;active&#x27;));
            event.target.classList.add(&#x27;active&#x27;);
            
            document.getElementById(&#x27;languageDropdown&#x27;).classList.remove(&#x27;open&#x27;);
            changeLanguage();
        }

        // Fermer le dropdown si on clique ailleurs
        document.addEventListener(&#x27;click&#x27;, function(event) {
            const dropdown = document.getElementById(&#x27;languageDropdown&#x27;);
            if (dropdown &amp;&amp; !dropdown.contains(event.target)) {
                dropdown.classList.remove(&#x27;open&#x27;);
            }
        });

        // Fonction de changement de langue
        function changeLanguage() {
            const selectedLang = gameState.currentLanguage;
            const t = translations[selectedLang];
            
            // Mettre à jour tous les textes
            document.getElementById(&#x27;gameTitle&#x27;).textContent = t.gameTitle;
            document.getElementById(&#x27;cyberBadge&#x27;).textContent = t.cyberBadge;
            document.getElementById(&#x27;controlsTitle&#x27;).textContent = t.controlsTitle;
            document.getElementById(&#x27;statsTitle&#x27;).textContent = t.statsTitle;
            document.getElementById(&#x27;difficultyTitle&#x27;).textContent = t.difficultyTitle;
            document.getElementById(&#x27;missionTitle&#x27;).textContent = t.missionTitle;
            document.getElementById(&#x27;strategiesTitle&#x27;).textContent = t.strategiesTitle;
            document.getElementById(&#x27;aiStatusTitle&#x27;).textContent = t.aiStatusTitle;
            document.getElementById(&#x27;achievementsTitle&#x27;).textContent = t.achievementsTitle;
            
            document.getElementById(&#x27;startGameText&#x27;).textContent = t.startGameText;
            document.getElementById(&#x27;resetText&#x27;).textContent = t.resetText;
            document.getElementById(&#x27;hintText&#x27;).textContent = t.hintText;
            
            document.getElementById(&#x27;scoreLabel&#x27;).textContent = t.scoreLabel;
            document.getElementById(&#x27;levelLabel&#x27;).textContent = t.levelLabel;
            document.getElementById(&#x27;movesLabel&#x27;).textContent = t.movesLabel;
            document.getElementById(&#x27;timeLabel&#x27;).textContent = t.timeLabel;
            
            // Mettre à jour le message selon l&#x27;état du jeu
            if (!gameState.isPlaying) {
                document.getElementById(&#x27;welcomeMessage&#x27;).textContent = t.welcomeMessage;
            }
            
            document.getElementById(&#x27;missionText&#x27;).innerHTML = t.missionText;
            document.getElementById(&#x27;strategy1Text&#x27;).textContent = t.strategy1Text;
            document.getElementById(&#x27;strategy2Text&#x27;).textContent = t.strategy2Text;
            document.getElementById(&#x27;strategy3Text&#x27;).textContent = t.strategy3Text;
            document.getElementById(&#x27;strategy4Text&#x27;).textContent = t.strategy4Text;
            document.getElementById(&#x27;achievementsContent&#x27;).textContent = t.achievementsContent;
            
            // Mettre à jour le sélecteur de difficulté
            updateDifficultySelector();
            
            // Mettre à jour le bouton pause selon l&#x27;état actuel
            updatePauseButton();
            
            // Mettre à jour le statut IA avec la nouvelle langue
            updateAIStatus();
        }

        // Mettre à jour le sélecteur de difficulté
        function updateDifficultySelector() {
            const t = translations[gameState.currentLanguage];
            const selector = document.getElementById(&#x27;difficultySelector&#x27;);
            const currentValue = selector.value || gameState.difficulty;
            selector.innerHTML = `
                &lt;option value=&quot;1&quot;&gt;${t.difficultyLevels[1]}&lt;/option&gt;
                &lt;option value=&quot;2&quot;&gt;${t.difficultyLevels[2]}&lt;/option&gt;
                &lt;option value=&quot;3&quot;&gt;${t.difficultyLevels[3]}&lt;/option&gt;
                &lt;option value=&quot;4&quot;&gt;${t.difficultyLevels[4]}&lt;/option&gt;
                &lt;option value=&quot;5&quot;&gt;${t.difficultyLevels[5]}&lt;/option&gt;
            `;
            selector.value = currentValue;
        }

        // Changer la difficulté
        function changeDifficulty() {
            const selector = document.getElementById(&#x27;difficultySelector&#x27;);
            gameState.difficulty = parseInt(selector.value);
            updateDifficultyIndicator();
            
            if (gameState.isPlaying) {
                resetGame();
            }
        }

        // Mettre à jour l&#x27;indicateur de difficulté
        function updateDifficultyIndicator() {
            const dots = document.querySelectorAll(&#x27;.difficulty-dot&#x27;);
            dots.forEach((dot, index) =&gt; {
                if (index &lt; gameState.difficulty) {
                    dot.classList.add(&#x27;active&#x27;);
                } else {
                    dot.classList.remove(&#x27;active&#x27;);
                }
            });
        }

        // Initialiser la grille de jeu
        function initializeGrid() {
            const grid = document.getElementById(&#x27;gameGrid&#x27;);
            grid.innerHTML = &#x27;&#x27;;
            
            // Ajuster la taille de la grille selon la difficulté
            const size = Math.max(6, Math.min(10, 6 + gameState.difficulty));
            gameState.gridSize = size;
            
            grid.style.gridTemplateColumns = `repeat(${size}, 1fr)`;
            grid.style.gridTemplateRows = `repeat(${size}, 1fr)`;
            
            // Créer les cellules
            for(let row = 0; row &lt; size; row++) {
                for(let col = 0; col &lt; size; col++) {
                    const cell = document.createElement(&#x27;div&#x27;);
                    cell.className = &#x27;grid-cell&#x27;;
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    cell.addEventListener(&#x27;click&#x27;, () =&gt; handleCellClick(row, col));
                    grid.appendChild(cell);
                }
            }
        }

        // Démarrer le jeu
        function startGame() {
            if (gameState.isPaused) {
                resumeGame();
                return;
            }
            
            gameState.isPlaying = true;
            gameState.isPaused = false;
            gameState.score = 0;
            gameState.moves = 0;
            gameState.startTime = Date.now();
            
            // Incrémenter le compteur de tentatives pour ce niveau
            const currentLevelKey = `${gameState.difficulty}_${gameState.level}`;
            if (!gameState.levelAttempts[currentLevelKey]) {
                gameState.levelAttempts[currentLevelKey] = 0;
            }
            gameState.levelAttempts[currentLevelKey]++;
            
            // Calculer le bonus de vitesse après 2 tentatives
            if (gameState.levelAttempts[currentLevelKey] &gt;= 2) {
                const extraAttempts = gameState.levelAttempts[currentLevelKey] - 1;
                gameState.speedBoosts[currentLevelKey] = extraAttempts * 0.08; // +8% par tentative supplémentaire
            }
            
            initializeGrid();
            generateLevel();
            startGameTimer();
            
            const t = translations[gameState.currentLanguage];
            showMessage(t.gameStarted);
            
            updateStats();
            updatePauseButton(); // Mettre à jour le bouton pause
            updateAIStatus(); // Mettre à jour le statut IA avec les infos de vitesse
        }

        // Générer un niveau
        function generateLevel() {
            const size = gameState.gridSize;
            
            // Position du joueur (coin supérieur gauche)
            gameState.playerPos = {x: 0, y: 0};
            
            // Générer des cibles selon la difficulté
            gameState.targets = [];
            const numTargets = Math.min(gameState.difficulty + 2, size * size / 4);
            
            for(let i = 0; i &lt; numTargets; i++) {
                let pos;
                do {
                    pos = {
                        x: Math.floor(Math.random() * size),
                        y: Math.floor(Math.random() * size)
                    };
                } while ((pos.x === 0 &amp;&amp; pos.y === 0) || 
                         gameState.targets.some(t =&gt; t.x === pos.x &amp;&amp; t.y === pos.y));
                
                gameState.targets.push(pos);
            }
            
            // Générer des entités IA selon la difficulté
            gameState.aiEntities = [];
            const numAI = Math.max(1, Math.floor(gameState.difficulty / 2));
            
            for(let i = 0; i &lt; numAI; i++) {
                let pos;
                do {
                    pos = {
                        x: Math.floor(Math.random() * size),
                        y: Math.floor(Math.random() * size)
                    };
                } while ((pos.x === 0 &amp;&amp; pos.y === 0) || 
                         gameState.targets.some(t =&gt; t.x === pos.x &amp;&amp; t.y === pos.y) ||
                         gameState.aiEntities.some(ai =&gt; ai.x === pos.x &amp;&amp; ai.y === pos.y));
                
                gameState.aiEntities.push(pos);
            }
            
            updateGridDisplay();
        }

        // Mettre à jour l&#x27;affichage de la grille
        function updateGridDisplay() {
            const cells = document.querySelectorAll(&#x27;.grid-cell&#x27;);
            
            cells.forEach(cell =&gt; {
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                
                // Réinitialiser la cellule
                cell.className = &#x27;grid-cell&#x27;;
                cell.textContent = &#x27;&#x27;;
                
                // Position du joueur
                if (row === gameState.playerPos.y &amp;&amp; col === gameState.playerPos.x) {
                    cell.classList.add(&#x27;player&#x27;);
                    cell.textContent = &#x27;🚀&#x27;;
                }
                
                // Cibles
                else if (gameState.targets.some(t =&gt; t.x === col &amp;&amp; t.y === row)) {
                    cell.classList.add(&#x27;target&#x27;);
                    cell.textContent = &#x27;⚡&#x27;;
                }
                
                // Entités IA
                else if (gameState.aiEntities.some(ai =&gt; ai.x === col &amp;&amp; ai.y === row)) {
                    cell.classList.add(&#x27;ai&#x27;);
                    cell.textContent = &#x27;🤖&#x27;;
                }
            });
        }

        // Gérer le clic sur une cellule
        function handleCellClick(row, col) {
            if (!gameState.isPlaying || gameState.isPaused) return;
            
            // Vérifier si le mouvement est valide (adjacent)
            const dx = Math.abs(col - gameState.playerPos.x);
            const dy = Math.abs(row - gameState.playerPos.y);
            
            if (dx + dy !== 1) return; // Mouvement non adjacent
            
            // Déplacer le joueur
            gameState.playerPos.x = col;
            gameState.playerPos.y = row;
            gameState.moves++;
            
            // Vérifier collision avec cible (orbe d&#x27;énergie)
            const targetIndex = gameState.targets.findIndex(t =&gt; t.x === col &amp;&amp; t.y === row);
            if (targetIndex !== -1) {
                gameState.targets.splice(targetIndex, 1);
                gameState.score += 100 * gameState.difficulty;
                
                // Bonus orbe d&#x27;énergie : ralentir temporairement les sentinelles
                gameState.energyBoostTurns = 3; // 3 tours de ralentissement
                
                // Mettre à jour l&#x27;affichage immédiatement pour faire disparaître l&#x27;orbe
                updateGridDisplay();
                
                // Effet visuel pour indiquer le bonus
                showEnergyBoostEffect();
                
                // Vérifier victoire après un petit délai pour voir l&#x27;orbe disparaître
                if (gameState.targets.length === 0) {
                    setTimeout(() =&gt; {
                        winLevel();
                    }, 100);
                    return;
                }
            }
            
            // Vérifier collision avec IA
            if (gameState.aiEntities.some(ai =&gt; ai.x === col &amp;&amp; ai.y === row)) {
                loseGame();
                return;
            }
            
            // Déplacer les entités IA
            moveAIEntities();
            
            updateGridDisplay();
            updateStats();
        }

        // Déplacer les entités IA
        function moveAIEntities() {
            // Décrémenter le boost d&#x27;énergie
            if (gameState.energyBoostTurns &gt; 0) {
                gameState.energyBoostTurns--;
            }
            
            gameState.aiEntities.forEach((ai, index) =&gt; {
                // Calculer la probabilité de mouvement basée sur le niveau
                // Niveau 1: 55%, Niveau 2: 65%, Niveau 3: 75%, etc.
                let baseMoveChance = 0.55; // 55% de base (vitesse plus rapide)
                const levelBonus = (gameState.level - 1) * 0.10; // +10% par niveau
                
                // Ajouter le bonus de vitesse progressif après plusieurs tentatives
                const currentLevelKey = `${gameState.difficulty}_${gameState.level}`;
                const speedBoost = gameState.speedBoosts[currentLevelKey] || 0;
                
                let moveChance = Math.min(0.95, baseMoveChance + levelBonus + speedBoost); // Maximum 95%
                
                // Appliquer le ralentissement du boost d&#x27;énergie
                if (gameState.energyBoostTurns &gt; 0) {
                    moveChance *= 0.25; // Réduire la vitesse de 75% pendant le boost
                }
                
                // Chaque sentinelle a sa propre chance de bouger
                if (Math.random() &gt; moveChance) {
                    return; // Cette sentinelle ne bouge pas ce tour
                }
                
                // IA simple : se rapprocher du joueur
                const dx = gameState.playerPos.x - ai.x;
                const dy = gameState.playerPos.y - ai.y;
                
                // Probabilité de mouvement intelligent vs aléatoire (aussi augmentée par les tentatives)
                const baseSmartChance = 0.70 + (gameState.level - 1) * 0.08;
                const smartMoveChance = Math.min(0.90, baseSmartChance + speedBoost * 0.5); // Intelligence aussi améliorée
                
                if (Math.random() &lt; smartMoveChance) {
                    // Mouvement intelligent : se rapprocher du joueur
                    if (Math.abs(dx) &gt; Math.abs(dy)) {
                        ai.x += dx &gt; 0 ? 1 : -1;
                    } else {
                        ai.y += dy &gt; 0 ? 1 : -1;
                    }
                } else {
                    // Mouvement aléatoire
                    const moves = [{x: 0, y: 1}, {x: 0, y: -1}, {x: 1, y: 0}, {x: -1, y: 0}];
                    const move = moves[Math.floor(Math.random() * moves.length)];
                    ai.x += move.x;
                    ai.y += move.y;
                }
                
                // Garder dans les limites
                ai.x = Math.max(0, Math.min(gameState.gridSize - 1, ai.x));
                ai.y = Math.max(0, Math.min(gameState.gridSize - 1, ai.y));
            });
            
            // Vérifier collision après mouvement IA
            if (gameState.aiEntities.some(ai =&gt; ai.x === gameState.playerPos.x &amp;&amp; ai.y === gameState.playerPos.y)) {
                loseGame();
            }
        }

        // Gagner le niveau
        function winLevel() {
            gameState.level++;
            gameState.score += 500 * gameState.difficulty;
            
            const t = translations[gameState.currentLanguage];
            showMessage(t.gameWon);
            
            // Générer le niveau suivant après un délai
            setTimeout(() =&gt; {
                generateLevel();
                const currentT = translations[gameState.currentLanguage]; // Récupérer les traductions actuelles
                showMessage(currentT.levelUp);
            }, 2000);
        }

        // Perdre le jeu
        function loseGame() {
            gameState.isPlaying = false;
            clearInterval(gameState.gameTimer);
            
            // Faire disparaître la fusée mais garder les sentinelles
            gameState.playerPos = {x: -1, y: -1}; // Position hors grille pour faire disparaître la fusée
            updateGridDisplay(); // Mettre à jour l&#x27;affichage immédiatement
            
            const t = translations[gameState.currentLanguage];
            showMessage(t.gameLost);
            
            // Mettre à jour le statut IA après la défaite
            updateAIStatus();
            
            setTimeout(() =&gt; {
                showVictoryScreen(false);
            }, 2000);
        }

        // Réinitialiser le jeu
        function resetGame() {
            gameState.isPlaying = false;
            gameState.isPaused = false;
            gameState.score = 0;
            gameState.level = 1;
            gameState.moves = 0;
            gameState.elapsedTime = 0;
            gameState.energyBoostTurns = 0;
            
            if (gameState.gameTimer) {
                clearInterval(gameState.gameTimer);
            }
            
            initializeGrid();
            updateStats();
            updatePauseButton();
            updateAIStatus();
            
            const t = translations[gameState.currentLanguage];
            showMessage(t.welcomeMessage);
        }

        // Mettre à jour le statut IA avec les informations de vitesse
        function updateAIStatus() {
            const currentLevelKey = `${gameState.difficulty}_${gameState.level}`;
            const attempts = gameState.levelAttempts[currentLevelKey] || 0;
            const speedBoost = gameState.speedBoosts[currentLevelKey] || 0;
            
            const t = translations[gameState.currentLanguage];
            
            let statusText = t.aiStatusText;
            let analysisText = t.aiAnalysisText;
            
            if (attempts &gt; 0) {
                const baseSpeed = 55 + (gameState.level - 1) * 10;
                const currentSpeed = Math.min(95, baseSpeed + speedBoost * 100);
                
                if (gameState.currentLanguage === &#x27;fr&#x27;) {
                    statusText = `Sentinelles: ${Math.round(currentSpeed)}% vitesse`;
                    analysisText = attempts === 1 ? 
                        &quot;Première tentative - Vitesse normale&quot; : 
                        `Tentative ${attempts} - Vitesse augmentée (+${Math.round(speedBoost * 100)}%)`;
                } else if (gameState.currentLanguage === &#x27;en&#x27;) {
                    statusText = `Sentinels: ${Math.round(currentSpeed)}% speed`;
                    analysisText = attempts === 1 ? 
                        &quot;First attempt - Normal speed&quot; : 
                        `Attempt ${attempts} - Increased speed (+${Math.round(speedBoost * 100)}%)`;
                } else if (gameState.currentLanguage === &#x27;ar&#x27;) {
                    statusText = `الحراس: ${Math.round(currentSpeed)}% سرعة`;
                    analysisText = attempts === 1 ? 
                        &quot;المحاولة الأولى - سرعة عادية&quot; : 
                        `المحاولة ${attempts} - سرعة متزايدة (+${Math.round(speedBoost * 100)}%)`;
                } else if (gameState.currentLanguage === &#x27;es&#x27;) {
                    statusText = `Centinelas: ${Math.round(currentSpeed)}% velocidad`;
                    analysisText = attempts === 1 ? 
                        &quot;Primer intento - Velocidad normal&quot; : 
                        `Intento ${attempts} - Velocidad aumentada (+${Math.round(speedBoost * 100)}%)`;
                } else if (gameState.currentLanguage === &#x27;de&#x27;) {
                    statusText = `Wächter: ${Math.round(currentSpeed)}% Geschwindigkeit`;
                    analysisText = attempts === 1 ? 
                        &quot;Erster Versuch - Normale Geschwindigkeit&quot; : 
                        `Versuch ${attempts} - Erhöhte Geschwindigkeit (+${Math.round(speedBoost * 100)}%)`;
                } else if (gameState.currentLanguage === &#x27;zh&#x27;) {
                    statusText = `哨兵: ${Math.round(currentSpeed)}% 速度`;
                    analysisText = attempts === 1 ? 
                        &quot;第一次尝试 - 正常速度&quot; : 
                        `第${attempts}次尝试 - 速度提升 (+${Math.round(speedBoost * 100)}%)`;
                }
            }
            
            document.getElementById(&#x27;aiStatusText&#x27;).textContent = statusText;
            document.getElementById(&#x27;aiAnalysisText&#x27;).textContent = analysisText;
        }

        // Mettre à jour le bouton pause selon l&#x27;état et la langue
        function updatePauseButton() {
            const t = translations[gameState.currentLanguage];
            
            if (gameState.isPaused) {
                document.getElementById(&#x27;pauseIcon&#x27;).textContent = &#x27;▶️&#x27;;
                document.getElementById(&#x27;pauseText&#x27;).textContent = t.resumeText;
            } else {
                document.getElementById(&#x27;pauseIcon&#x27;).textContent = &#x27;⏸️&#x27;;
                document.getElementById(&#x27;pauseText&#x27;).textContent = t.pauseText;
            }
        }

        // Mettre en pause
        function pauseGame() {
            if (!gameState.isPlaying) return;
            
            gameState.isPaused = !gameState.isPaused;
            const t = translations[gameState.currentLanguage];
            
            if (gameState.isPaused) {
                clearInterval(gameState.gameTimer);
                showMessage(t.gamePaused);
            } else {
                startGameTimer();
                showMessage(t.gameStarted);
            }
            
            updatePauseButton();
        }

        // Reprendre le jeu
        function resumeGame() {
            gameState.isPaused = false;
            startGameTimer();
            
            const t = translations[gameState.currentLanguage];
            showMessage(t.gameStarted);
            updatePauseButton();
        }

        // Obtenir un indice
        function getHint() {
            if (!gameState.isPlaying || gameState.isPaused) return;
            
            const t = translations[gameState.currentLanguage];
            showMessage(t.hintMessage, 3000);
            
            // Mettre en évidence la cible la plus proche
            if (gameState.targets.length &gt; 0) {
                let closestTarget = gameState.targets[0];
                let minDistance = Math.abs(closestTarget.x - gameState.playerPos.x) + 
                                Math.abs(closestTarget.y - gameState.playerPos.y);
                
                gameState.targets.forEach(target =&gt; {
                    const distance = Math.abs(target.x - gameState.playerPos.x) + 
                                   Math.abs(target.y - gameState.playerPos.y);
                    if (distance &lt; minDistance) {
                        minDistance = distance;
                        closestTarget = target;
                    }
                });
                
                // Mettre en évidence la cible
                const cells = document.querySelectorAll(&#x27;.grid-cell&#x27;);
                cells.forEach(cell =&gt; {
                    const row = parseInt(cell.dataset.row);
                    const col = parseInt(cell.dataset.col);
                    
                    if (row === closestTarget.y &amp;&amp; col === closestTarget.x) {
                        cell.style.border = &#x27;4px solid #ffff00&#x27;;
                        cell.style.boxShadow = &#x27;0 0 30px rgba(255, 255, 0, 1)&#x27;;
                        
                        setTimeout(() =&gt; {
                            cell.style.border = &#x27;2px solid rgba(0, 255, 255, 0.3)&#x27;;
                            cell.style.boxShadow = &#x27;&#x27;;
                        }, 2500);
                    }
                });
            }
        }

        // Démarrer le timer du jeu
        function startGameTimer() {
            gameState.gameTimer = setInterval(() =&gt; {
                if (!gameState.isPaused) {
                    gameState.elapsedTime = Date.now() - gameState.startTime;
                    updateTimeDisplay();
                }
            }, 1000);
        }

        // Mettre à jour l&#x27;affichage du temps
        function updateTimeDisplay() {
            const seconds = Math.floor(gameState.elapsedTime / 1000);
            const minutes = Math.floor(seconds / 60);
            const displaySeconds = seconds % 60;
            
            const timeString = `${minutes.toString().padStart(2, &#x27;0&#x27;)}:${displaySeconds.toString().padStart(2, &#x27;0&#x27;)}`;
            document.getElementById(&#x27;timeValue&#x27;).textContent = timeString;
        }

        // Mettre à jour les statistiques
        function updateStats() {
            document.getElementById(&#x27;scoreValue&#x27;).textContent = gameState.score;
            document.getElementById(&#x27;levelValue&#x27;).textContent = gameState.level;
            document.getElementById(&#x27;movesValue&#x27;).textContent = gameState.moves;
        }

        // Afficher un message
        function showMessage(message, duration = 0) {
            const messageElement = document.getElementById(&#x27;gameMessage&#x27;);
            messageElement.innerHTML = `&lt;span&gt;${message}&lt;/span&gt;`;
            
            if (duration &gt; 0) {
                setTimeout(() =&gt; {
                    if (!gameState.isPlaying) {
                        const currentT = translations[gameState.currentLanguage]; // Toujours récupérer la langue actuelle
                        messageElement.innerHTML = `&lt;span&gt;${currentT.welcomeMessage}&lt;/span&gt;`;
                    }
                }, duration);
            }
        }

        // Effet visuel du boost d&#x27;énergie
        function showEnergyBoostEffect() {
            const currentT = translations[gameState.currentLanguage]; // Toujours récupérer la langue actuelle
            const boostMessage = currentT.energyBoostMessage;
            showMessage(boostMessage, 2000);
            
            // Effet visuel sur toute la grille
            const grid = document.getElementById(&#x27;gameGrid&#x27;);
            grid.style.boxShadow = &#x27;0 0 50px rgba(0, 255, 0, 0.8), inset 0 0 30px rgba(0, 255, 0, 0.3)&#x27;;
            grid.style.border = &#x27;4px solid rgba(0, 255, 0, 0.8)&#x27;;
            
            setTimeout(() =&gt; {
                grid.style.boxShadow = &#x27;0 0 50px rgba(0, 255, 255, 0.4), inset 0 0 30px rgba(0, 255, 255, 0.1)&#x27;;
                grid.style.border = &#x27;2px solid rgba(0, 255, 255, 0.3)&#x27;;
            }, 2000);
        }

        // Afficher l&#x27;écran de victoire/défaite
        function showVictoryScreen(won) {
            const currentT = translations[gameState.currentLanguage]; // Toujours récupérer la langue actuelle
            
            const overlay = document.createElement(&#x27;div&#x27;);
            overlay.className = &#x27;victory-animation&#x27;;
            
            const content = document.createElement(&#x27;div&#x27;);
            content.className = &#x27;victory-content&#x27;;
            
            const title = won ? currentT.gameWon : currentT.gameLost;
            const scoreText = `Score Final: ${gameState.score}`;
            const levelText = `Niveau Atteint: ${gameState.level}`;
            const timeText = `Temps: ${document.getElementById(&#x27;timeValue&#x27;).textContent}`;
            
            content.innerHTML = `
                &lt;h2&gt;${title}&lt;/h2&gt;
                &lt;p style=&quot;margin: 30px 0;&quot;&gt;${scoreText}&lt;/p&gt;
                &lt;p style=&quot;margin: 20px 0; color: #00ffff;&quot;&gt;${levelText}&lt;/p&gt;
                &lt;p style=&quot;margin: 20px 0; color: #00ffff;&quot;&gt;${timeText}&lt;/p&gt;
                &lt;button onclick=&quot;resetGame(); document.body.removeChild(document.querySelector(&#x27;.victory-animation&#x27;))&quot; style=&quot;
                    margin: 30px 20px 20px 20px;
                    padding: 20px 40px;
                    background: linear-gradient(145deg, #00ffff, #0080ff);
                    color: white;
                    border: none;
                    border-radius: 25px;
                    font-size: 18px;
                    font-weight: bold;
                    cursor: pointer;
                    transition: all 0.3s ease;
                &quot;&gt;${currentT.startGameText}&lt;/button&gt;
            `;
            
            overlay.appendChild(content);
            document.body.appendChild(overlay);
        }

        // Initialisation
        document.addEventListener(&#x27;DOMContentLoaded&#x27;, function() {
            createCyberParticles();
            initializeGrid();
            updateStats();
            updateDifficultyIndicator();
            updateDifficultySelector();
        });
    &lt;/script&gt;
&lt;script&gt;(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement(&#x27;script&#x27;);d.innerHTML=&quot;window.__CF$cv$params={r:&#x27;98536a8af288ae33&#x27;,t:&#x27;MTc1ODg5NjU3NS4wMDAwMDA=&#x27;};var a=document.createElement(&#x27;script&#x27;);a.nonce=&#x27;&#x27;;a.src=&#x27;/cdn-cgi/challenge-platform/scripts/jsd/main.js&#x27;;document.getElementsByTagName(&#x27;head&#x27;)[0].appendChild(a);&quot;;b.getElementsByTagName(&#x27;head&#x27;)[0].appendChild(d)}}if(document.body){var a=document.createElement(&#x27;iframe&#x27;);a.height=1;a.width=1;a.style.position=&#x27;absolute&#x27;;a.style.top=0;a.style.left=0;a.style.border=&#x27;none&#x27;;a.style.visibility=&#x27;hidden&#x27;;document.body.appendChild(a);if(&#x27;loading&#x27;!==document.readyState)c();else if(window.addEventListener)document.addEventListener(&#x27;DOMContentLoaded&#x27;,c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);&#x27;loading&#x27;!==document.readyState&amp;&amp;(document.onreadystatechange=e,c())}}}})();&lt;/script&gt;&lt;/body&gt;
&lt;/html&gt;
" style="width:100%;height:100%;border:none;"></iframe>
</div>

<script>
function launchGame10() {
  document.getElementById("game10Overlay").style.display = "block";
}
function closeGame10() {
  document.getElementById("game10Overlay").style.display = "none";
}
document.addEventListener("keydown", function(e) {
  if (e.key === "Escape") {
    const overlay = document.getElementById("game10Overlay");
    if (overlay && overlay.style.display === "block") {
      e.preventDefault();
      e.stopPropagation();
      closeGame10();
    }
  }
}, true);
</script>


<!-- === Overlay pour Jeu 11 (procédure jeu4) === -->
<div id="game11Overlay" style="display:none;position:fixed;inset:0;background:#000;z-index:99999;">
  <button id="closeGame11Btn" style="position:absolute;top:12px;right:12px;z-index:100000;
    font-size:20px;background:red;color:white;border:none;border-radius:6px;padding:8px 10px;cursor:pointer;">✖</button>
  <iframe id="iframeGame11" srcdoc="&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;fr&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Quantum Monopoly - Jeu de Plateau Futuriste&lt;/title&gt;
    &lt;style&gt;
        body {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: &#x27;Segoe UI&#x27;, Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%);
            color: #ffffff;
            min-height: 100vh;
            overflow-x: auto;
        }

        .quantum-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            background: radial-gradient(circle at 20% 80%, rgba(120, 119, 198, 0.3) 0%, transparent 50%),
                        radial-gradient(circle at 80% 20%, rgba(255, 119, 198, 0.3) 0%, transparent 50%),
                        radial-gradient(circle at 40% 40%, rgba(120, 219, 255, 0.2) 0%, transparent 50%);
        }

        .quantum-particle {
            position: absolute;
            width: 2px;
            height: 2px;
            background: #00ffff;
            border-radius: 50%;
            animation: float 6s ease-in-out infinite;
            box-shadow: 0 0 6px #00ffff;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px) rotate(0deg); opacity: 0.7; }
            50% { transform: translateY(-20px) rotate(180deg); opacity: 1; }
        }

        .game-header {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin: 10px auto;
            max-width: 800px;
            align-items: center;
        }

        .header-top {
            background: linear-gradient(135deg, rgba(15, 15, 35, 0.95) 0%, rgba(30, 30, 60, 0.95) 100%);
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 12px;
            padding: 8px 20px;
            backdrop-filter: blur(15px);
            box-shadow: 0 8px 32px rgba(0, 255, 255, 0.2);
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            min-height: 50px;
        }

        .header-center {
            background: linear-gradient(135deg, rgba(15, 15, 35, 0.95) 0%, rgba(30, 30, 60, 0.95) 100%);
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 12px;
            padding: 8px 20px;
            backdrop-filter: blur(15px);
            box-shadow: 0 8px 32px rgba(0, 255, 255, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            flex-wrap: wrap;
            width: 100%;
            min-height: 50px;
        }

        .header-bottom {
            background: linear-gradient(135deg, rgba(15, 15, 35, 0.95) 0%, rgba(30, 30, 60, 0.95) 100%);
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 12px;
            padding: 8px 20px;
            backdrop-filter: blur(15px);
            box-shadow: 0 8px 32px rgba(0, 255, 255, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            min-height: 40px;
        }

        .game-title {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .game-title h1 {
            font-size: 18px;
            font-weight: bold;
            background: linear-gradient(135deg, #00ffff, #ff00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin: 0;
            text-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
            letter-spacing: 1px;
            display: flex;
            align-items: center;
            gap: 8px;
            justify-content: center;
        }

        .ai-quantum-btn {
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 50%, #f39c12 100%);
            border: 2px solid rgba(255, 215, 0, 0.8);
            border-radius: 20px;
            padding: 8px 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.4);
            backdrop-filter: blur(10px);
            position: relative;
            overflow: hidden;
        }

        .ai-quantum-btn:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 6px 25px rgba(255, 215, 0, 0.6);
            border-color: rgba(255, 215, 0, 1);
        }

        .ai-quantum-btn:active {
            transform: translateY(0) scale(0.98);
        }

        .ai-quantum-btn::before {
            content: &#x27;&#x27;;
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transition: left 0.5s ease;
        }

        .ai-quantum-btn:hover::before {
            left: 100%;
        }

        .ai-quantum-btn span {
            font-size: 11px;
            font-weight: bold;
            color: #1a1a2e;
            text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.3);
            letter-spacing: 0.5px;
            position: relative;
            z-index: 1;
        }

        .game-logo {
            font-size: 24px;
            filter: drop-shadow(0 0 20px #00ffff);
            animation: pulse 3s ease-in-out infinite;
            flex-shrink: 0;
        }

        .subtitle {
            font-size: 10px;
            color: #00ffff;
            text-align: center;
            margin-top: 2px;
            font-weight: bold;
            letter-spacing: 1px;
        }

        .header-controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        .main-container {
            max-width: 1400px;
            margin: 0 auto;
            position: relative;
            background: linear-gradient(135deg, rgba(15, 15, 35, 0.95) 0%, rgba(30, 30, 60, 0.95) 100%);
            border: 3px solid rgba(0, 255, 255, 0.4);
            border-radius: 25px;
            backdrop-filter: blur(20px);
            box-shadow: 
                0 0 50px rgba(0, 255, 255, 0.3),
                inset 0 0 50px rgba(0, 255, 255, 0.1);
            padding: 20px;
            margin: 20px auto;
            position: relative;
            overflow: hidden;
        }

        .main-container::before {
            content: &#x27;&#x27;;
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, #00ffff, #ff00ff, #ffff00, #00ffff);
            border-radius: 25px;
            z-index: -1;
            animation: borderGlow 3s linear infinite;
        }

        @keyframes borderGlow {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .game-container {
            display: grid;
            grid-template-columns: 200px 1fr 200px;
            gap: 20px;
            padding: 0 20px 20px 20px;
            min-height: calc(100vh - 200px);
            position: relative;
            z-index: 1;
            margin-top: 10px;
        }

        .sidebar {
            background: linear-gradient(135deg, rgba(15, 15, 35, 0.95) 0%, rgba(30, 30, 60, 0.95) 100%);
            border: 3px solid rgba(0, 255, 255, 0.4);
            border-radius: 20px;
            padding: 20px;
            backdrop-filter: blur(15px);
            box-shadow: 
                0 10px 40px rgba(0, 255, 255, 0.2),
                inset 0 0 30px rgba(0, 255, 255, 0.05);
            margin-top: 0px;
            height: fit-content;
            position: relative;
            overflow: hidden;
        }

        .sidebar::before {
            content: &#x27;&#x27;;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, #00ffff, #ff00ff, #00ffff, transparent);
            animation: scanLine 2s linear infinite;
        }

        .sidebar::after {
            content: &#x27;&#x27;;
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(0, 255, 255, 0.1) 0%, transparent 70%);
            animation: rotate 10s linear infinite;
            pointer-events: none;
        }

        @keyframes scanLine {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        @keyframes rotate {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .main-board {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .board-container {
            width: 800px;
            height: 800px;
            position: relative;
            background: linear-gradient(135deg, rgba(15, 15, 35, 0.98) 0%, rgba(30, 30, 60, 0.98) 100%);
            border: 4px solid rgba(0, 255, 255, 0.6);
            border-radius: 25px;
            box-shadow: 
                0 0 60px rgba(0, 255, 255, 0.4),
                inset 0 0 40px rgba(0, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            position: relative;
            overflow: hidden;
        }



        .board-surface {
            width: 100%;
            height: 100%;
            display: grid;
            grid-template-columns: repeat(11, 1fr);
            grid-template-rows: repeat(11, 1fr);
            gap: 1px;
            padding: 10px;
            box-sizing: border-box;
        }

        .board-cell {
            background: rgba(30, 30, 60, 0.8);
            border: 1px solid rgba(0, 255, 255, 0.2);
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            font-size: 11px;
            text-align: center;
            overflow: hidden;
            transition: all 0.3s ease;
            min-height: 70px;
        }

        .board-cell:hover {
            background: rgba(0, 255, 255, 0.1);
            border-color: rgba(0, 255, 255, 0.5);
            transform: scale(1.05);
        }

        .cell-corner {
            background: linear-gradient(135deg, #ff6b6b, #ee5a24) !important;
            font-weight: bold;
            font-size: 9px;
        }

        .cell-property {
            background: linear-gradient(135deg, #4834d4, #686de0) !important;
        }

        .cell-railroad {
            background: linear-gradient(135deg, #2c2c54, #40407a) !important;
        }

        .cell-utility {
            background: linear-gradient(135deg, #ff9ff3, #f368e0) !important;
        }

        .cell-chance {
            background: linear-gradient(135deg, #ff9500, #ff6348) !important;
        }

        .cell-communityChest {
            background: linear-gradient(135deg, #0abde3, #006ba6) !important;
        }

        .cell-tax {
            background: linear-gradient(135deg, #c44569, #f8b500) !important;
        }

        .player-token {
            position: absolute;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 900;
            font-size: 12px;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,1), 0 0 8px rgba(0,0,0,0.8);
            border: 3px solid rgba(255,255,255,1);
            z-index: 10;
            animation: pulse 2s ease-in-out infinite;
            box-shadow: 0 0 15px rgba(0,0,0,0.5), inset 0 0 10px rgba(255,255,255,0.2);
        }

        .player-1 { background: linear-gradient(135deg, #ff4757, #ff3742); border: 3px solid #ffffff; font-weight: 900; }
        .player-2 { background: linear-gradient(135deg, #2ed573, #1dd1a1); border: 3px solid #ffffff; font-weight: 900; }
        .player-3 { background: linear-gradient(135deg, #3742fa, #2f3542); border: 3px solid #ffffff; font-weight: 900; }
        .player-4 { background: linear-gradient(135deg, #ff6348, #ff4757); border: 3px solid #ffffff; font-weight: 900; }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
            margin-top: 20px;
        }

        .quantum-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            color: white;
            padding: 6px 12px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            font-size: 11px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .quantum-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
            background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
        }

        .quantum-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .quantum-dice {
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, #00ffff, #ff00ff);
            border: 3px solid rgba(255,255,255,0.8);
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 0 20px rgba(0,255,255,0.6);
        }

        .quantum-dice:hover {
            transform: scale(1.1) rotate(5deg);
            box-shadow: 0 0 30px rgba(0,255,255,0.8);
        }

        .quantum-dice.rolling {
            animation: roll 1s ease-in-out;
        }

        @keyframes roll {
            0% { transform: rotate(0deg); }
            25% { transform: rotate(90deg) scale(1.2); }
            50% { transform: rotate(180deg) scale(0.8); }
            75% { transform: rotate(270deg) scale(1.2); }
            100% { transform: rotate(360deg); }
        }

        .player-info {
            background: rgba(30, 30, 60, 0.8);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            backdrop-filter: blur(5px);
            transition: all 0.3s ease;
            position: relative;
            z-index: 10;
        }

        .player-info:hover {
            border-color: rgba(0, 255, 255, 0.6);
            background: rgba(30, 30, 60, 0.9);
        }

        .player-info.current-player {
            border-color: #00ffff;
            background: rgba(0, 255, 255, 0.1);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }

        .player-name {
            font-size: 16px;
            font-weight: bold;
            color: #00ffff;
            margin-bottom: 8px;
        }

        .player-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            font-size: 12px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .stat-value {
            font-weight: bold;
            color: #ffffff;
        }

        .section-title {
            font-size: 18px;
            font-weight: bold;
            color: #00ffff;
            margin-bottom: 15px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 2px;
            position: relative;
            z-index: 10;
        }

        .game-message {
            background: rgba(15, 15, 35, 0.9);
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            font-size: 16px;
            font-weight: bold;
            color: #00ffff;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            margin-bottom: 20px;
        }

        .language-selector {
            position: relative;
            display: inline-block;
        }

        .language-dropdown {
            background: linear-gradient(135deg, rgba(15, 15, 35, 0.95) 0%, rgba(30, 30, 60, 0.95) 100%);
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 12px;
            color: #00ffff;
            padding: 6px 12px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 255, 255, 0.2);
            display: flex;
            align-items: center;
            gap: 6px;
            font-weight: bold;
            min-width: 120px;
            justify-content: space-between;
        }

        .language-dropdown:hover {
            border-color: rgba(0, 255, 255, 0.8);
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.1) 0%, rgba(255, 0, 255, 0.1) 100%);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 255, 255, 0.3);
        }

        .language-options {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: linear-gradient(135deg, rgba(15, 15, 35, 0.98) 0%, rgba(30, 30, 60, 0.98) 100%);
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 15px;
            backdrop-filter: blur(15px);
            box-shadow: 0 8px 32px rgba(0, 255, 255, 0.3);
            z-index: 999999;
            margin-top: 5px;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px);
            transition: all 0.3s ease;
        }

        .language-options.show {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .language-option {
            padding: 12px 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            color: #ffffff;
            font-weight: bold;
            border-bottom: 1px solid rgba(0, 255, 255, 0.1);
        }

        .language-option:last-child {
            border-bottom: none;
            border-radius: 0 0 13px 13px;
        }

        .language-option:first-child {
            border-radius: 13px 13px 0 0;
        }

        .language-option:hover {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.2) 0%, rgba(255, 0, 255, 0.2) 100%);
            color: #00ffff;
            transform: translateX(5px);
        }

        .language-option.active {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.3) 0%, rgba(255, 0, 255, 0.3) 100%);
            color: #00ffff;
        }

        @media (max-width: 1200px) {
            .game-container {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .board-container {
                width: 500px;
                height: 500px;
            }
            
            .sidebar {
                order: 2;
            }
        }

        .player-count-selector {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 15px;
        }

        .count-btn {
            background: rgba(30, 30, 60, 0.8);
            border: 2px solid rgba(0, 255, 255, 0.3);
            color: #ffffff;
            padding: 8px 16px;
            border-radius: 15px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            min-width: 40px;
        }

        .count-btn:hover {
            border-color: rgba(0, 255, 255, 0.6);
            background: rgba(0, 255, 255, 0.1);
        }

        .count-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-color: #00ffff;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.4);
        }

        .quick-actions {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .action-btn {
            background: rgba(30, 30, 60, 0.8);
            border: 2px solid rgba(0, 255, 255, 0.3);
            color: #ffffff;
            padding: 8px 12px;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            font-size: 12px;
            transition: all 0.3s ease;
            text-align: center;
        }

        .action-btn:hover:not(:disabled) {
            border-color: rgba(0, 255, 255, 0.6);
            background: rgba(0, 255, 255, 0.1);
            transform: translateY(-1px);
        }

        .action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        @media (max-width: 1200px) {
            .game-container {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .board-container {
                width: 600px;
                height: 600px;
            }
            
            .sidebar {
                order: 2;
            }

            .game-header {
                flex-direction: column;
                gap: 10px;
            }

            .header-left, .header-center, .header-right {
                min-width: auto;
            }

            .game-title h1 {
                font-size: 22px;
            }
        }

        @media (max-width: 600px) {
            .board-container {
                width: 450px;
                height: 450px;
            }
            
            .quantum-dice {
                width: 40px;
                height: 40px;
                font-size: 20px;
            }
            
            .header-bottom {
                gap: 8px;
            }
            
            .quantum-btn {
                padding: 8px 16px;
                font-size: 12px;
            }

            .game-title h1 {
                font-size: 24px;
            }

            .game-header {
                margin: 10px;
            }

            .header-left, .header-center, .header-right {
                padding: 15px;
            }
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;quantum-bg&quot;&gt;&lt;/div&gt;
    
    &lt;div class=&quot;main-container&quot;&gt;
    &lt;!-- En-tête du jeu --&gt;
    &lt;div class=&quot;game-header&quot;&gt;
        &lt;div class=&quot;header-top&quot;&gt;
            &lt;div class=&quot;game-title&quot;&gt;
                &lt;h1&gt;&lt;span id=&quot;gameTitle&quot;&gt;QUANTUM MONOPOLY&lt;/span&gt;&lt;/h1&gt;
            &lt;/div&gt;
            &lt;div class=&quot;ai-quantum-btn&quot; onclick=&quot;showAIInfo()&quot;&gt;
                &lt;span id=&quot;aiQuantumBtnText&quot;&gt;🤖 IA QUANTIQUE&lt;/span&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class=&quot;header-center&quot;&gt;
            &lt;button class=&quot;quantum-btn&quot; id=&quot;startBtn&quot; onclick=&quot;startGame()&quot;&gt;🚀 &lt;span id=&quot;startBtnText&quot;&gt;Démarrer&lt;/span&gt;&lt;/button&gt;
            &lt;button class=&quot;quantum-btn&quot; id=&quot;endTurnBtn&quot; onclick=&quot;endTurn()&quot; disabled&gt;⏭️ &lt;span id=&quot;endTurnBtnText&quot;&gt;Fin Tour&lt;/span&gt;&lt;/button&gt;
            &lt;button class=&quot;quantum-btn&quot; onclick=&quot;resetGame()&quot;&gt;🔄 &lt;span id=&quot;newGameBtnText&quot;&gt;Nouvelle Partie&lt;/span&gt;&lt;/button&gt;
            &lt;button class=&quot;quantum-btn&quot; onclick=&quot;showRules()&quot;&gt;📋 &lt;span id=&quot;rulesBtnText&quot;&gt;Règles Quantiques&lt;/span&gt;&lt;/button&gt;
        &lt;/div&gt;

    &lt;/div&gt;

    &lt;div class=&quot;game-container&quot;&gt;
        &lt;!-- Sidebar gauche - Joueurs --&gt;
        &lt;div class=&quot;sidebar&quot;&gt;
            &lt;div class=&quot;section-title&quot; id=&quot;playersTitle&quot;&gt;🎮 Joueurs Quantiques&lt;/div&gt;
            &lt;div id=&quot;playersContainer&quot;&gt;&lt;/div&gt;
            
            &lt;div class=&quot;section-title&quot; id=&quot;statsTitle&quot; style=&quot;margin-top: 30px;&quot;&gt;📊 Statistiques&lt;/div&gt;
            &lt;div class=&quot;player-info&quot;&gt;
                &lt;div class=&quot;player-stats&quot;&gt;
                    &lt;div class=&quot;stat-item&quot;&gt;
                        &lt;span id=&quot;turnLabel&quot;&gt;Tour:&lt;/span&gt;
                        &lt;span class=&quot;stat-value&quot; id=&quot;turnValue&quot;&gt;1&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;stat-item&quot;&gt;
                        &lt;span id=&quot;roundLabel&quot;&gt;Manche:&lt;/span&gt;
                        &lt;span class=&quot;stat-value&quot; id=&quot;roundValue&quot;&gt;1&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;stat-item&quot;&gt;
                        &lt;span id=&quot;timeLabel&quot;&gt;Temps:&lt;/span&gt;
                        &lt;span class=&quot;stat-value&quot; id=&quot;timeValue&quot;&gt;00:00&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;stat-item&quot;&gt;
                        &lt;span id=&quot;bankLabel&quot;&gt;Banque:&lt;/span&gt;
                        &lt;span class=&quot;stat-value&quot;&gt;∞&lt;/span&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;

        &lt;!-- Plateau principal --&gt;
        &lt;div class=&quot;main-board&quot;&gt;
            &lt;div class=&quot;game-message&quot; id=&quot;gameMessage&quot;&gt;
                &lt;span&gt;Bienvenue dans Quantum Monopoly! Cliquez sur &quot;Démarrer&quot; pour commencer.&lt;/span&gt;
            &lt;/div&gt;

            &lt;div class=&quot;board-container&quot;&gt;
                &lt;div class=&quot;board-surface&quot; id=&quot;boardSurface&quot;&gt;&lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;

        &lt;!-- Sidebar droite - Propriétés et Actions --&gt;
        &lt;div class=&quot;sidebar&quot;&gt;
            &lt;div class=&quot;language-selector&quot; style=&quot;margin-bottom: 20px;&quot;&gt;
                &lt;div class=&quot;language-dropdown&quot; onclick=&quot;toggleLanguageDropdown()&quot;&gt;
                    &lt;span id=&quot;currentLanguage&quot;&gt;🇫🇷 Français&lt;/span&gt;
                    &lt;span style=&quot;font-size: 10px;&quot;&gt;▼&lt;/span&gt;
                &lt;/div&gt;
                &lt;div class=&quot;language-options&quot; id=&quot;languageOptions&quot;&gt;
                    &lt;div class=&quot;language-option active&quot; onclick=&quot;selectLanguage(&#x27;fr&#x27;, &#x27;🇫🇷 Français&#x27;)&quot;&gt;🇫🇷 Français&lt;/div&gt;
                    &lt;div class=&quot;language-option&quot; onclick=&quot;selectLanguage(&#x27;en&#x27;, &#x27;🇬🇧 English&#x27;)&quot;&gt;🇬🇧 English&lt;/div&gt;
                    &lt;div class=&quot;language-option&quot; onclick=&quot;selectLanguage(&#x27;es&#x27;, &#x27;🇪🇸 Español&#x27;)&quot;&gt;🇪🇸 Español&lt;/div&gt;
                    &lt;div class=&quot;language-option&quot; onclick=&quot;selectLanguage(&#x27;ar&#x27;, &#x27;🇸🇦 العربية&#x27;)&quot;&gt;🇸🇦 العربية&lt;/div&gt;
                    &lt;div class=&quot;language-option&quot; onclick=&quot;selectLanguage(&#x27;de&#x27;, &#x27;🇩🇪 Deutsch&#x27;)&quot;&gt;🇩🇪 Deutsch&lt;/div&gt;
                    &lt;div class=&quot;language-option&quot; onclick=&quot;selectLanguage(&#x27;zh&#x27;, &#x27;🇨🇳 中文&#x27;)&quot;&gt;🇨🇳 中文&lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            
            &lt;div class=&quot;section-title&quot; id=&quot;propertiesTitle&quot;&gt;🏢 Propriétés Galactiques&lt;/div&gt;
            &lt;div id=&quot;propertiesContainer&quot;&gt;
                &lt;div style=&quot;color: #a1a1aa; text-align: center; padding: 20px;&quot; id=&quot;noPropertiesText&quot;&gt;Aucune propriété&lt;/div&gt;
            &lt;/div&gt;
            
            &lt;div class=&quot;section-title&quot; id=&quot;aiTitle&quot; style=&quot;margin-top: 30px;&quot;&gt;🤖 IA Quantique&lt;/div&gt;
            &lt;div class=&quot;player-info&quot;&gt;
                &lt;div style=&quot;color: #00ffff; font-size: 12px; text-align: center; line-height: 1.4;&quot; id=&quot;aiStatusText&quot;&gt;
                    Système IA initialisé&lt;br&gt;
                    Analyse des stratégies en cours...
                &lt;/div&gt;
            &lt;/div&gt;
            
            &lt;div class=&quot;section-title&quot; id=&quot;playerCountTitle&quot; style=&quot;margin-top: 30px;&quot;&gt;👥 Nombre de Joueurs&lt;/div&gt;
            &lt;div class=&quot;player-count-selector&quot;&gt;
                &lt;button class=&quot;count-btn&quot; onclick=&quot;setPlayerCount(2)&quot;&gt;2&lt;/button&gt;
                &lt;button class=&quot;count-btn&quot; onclick=&quot;setPlayerCount(3)&quot;&gt;3&lt;/button&gt;
                &lt;button class=&quot;count-btn active&quot; onclick=&quot;setPlayerCount(4)&quot;&gt;4&lt;/button&gt;
            &lt;/div&gt;
            
            &lt;div class=&quot;section-title&quot; id=&quot;diceTitle&quot; style=&quot;margin-top: 30px;&quot;&gt;🎲 Dés Quantiques&lt;/div&gt;
            &lt;div style=&quot;display: flex; justify-content: center; gap: 15px; margin-bottom: 20px;&quot;&gt;
                &lt;div class=&quot;quantum-dice&quot; id=&quot;sidebarDice1&quot; onclick=&quot;rollDice()&quot; style=&quot;width: 50px; height: 50px; font-size: 24px;&quot;&gt;1&lt;/div&gt;
                &lt;div class=&quot;quantum-dice&quot; id=&quot;sidebarDice2&quot; onclick=&quot;rollDice()&quot; style=&quot;width: 50px; height: 50px; font-size: 24px;&quot;&gt;1&lt;/div&gt;
            &lt;/div&gt;
            
            &lt;div class=&quot;section-title&quot; id=&quot;actionsTitle&quot; style=&quot;margin-top: 30px;&quot;&gt;⚡ Actions Rapides&lt;/div&gt;
            &lt;div class=&quot;quick-actions&quot;&gt;
                &lt;button class=&quot;action-btn&quot; id=&quot;buyBtn&quot; onclick=&quot;buyProperty()&quot; disabled&gt;💰 &lt;span id=&quot;buyBtnText&quot;&gt;Acheter&lt;/span&gt;&lt;/button&gt;
                &lt;button class=&quot;action-btn&quot; onclick=&quot;buildHouse()&quot;&gt;🏗️ &lt;span id=&quot;buildBtnText&quot;&gt;Construire&lt;/span&gt;&lt;/button&gt;
                &lt;button class=&quot;action-btn&quot; onclick=&quot;tradeProperty()&quot;&gt;🔄 &lt;span id=&quot;tradeBtnText&quot;&gt;Échanger&lt;/span&gt;&lt;/button&gt;
                &lt;button class=&quot;action-btn&quot; onclick=&quot;mortgage()&quot;&gt;🏦 &lt;span id=&quot;mortgageBtnText&quot;&gt;Hypothèque&lt;/span&gt;&lt;/button&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;/div&gt;

    &lt;script&gt;
        // État du jeu
    var gameState = {
            isPlaying: false,
            currentPlayer: 0,
            playerCount: 4,
            players: [],
            turn: 1,
            round: 1,
            dice1: 1,
            dice2: 1,
            lastRoll: 2,
            canRoll: true,
            startTime: 0,
            elapsedTime: 0,
            gameTimer: null,
            currentLanguage: &#x27;fr&#x27;
        };

        // Traductions
        const translations = {
            fr: {
                gameTitle: &#x27;QUANTUM MONOPOLY&#x27;,
                playersTitle: &#x27;🎮 Joueurs Quantiques&#x27;,
                propertiesTitle: &#x27;🏢 Propriétés Galactiques&#x27;,
                statsTitle: &#x27;📊 Statistiques&#x27;,
                aiTitle: &#x27;🤖 IA Quantique&#x27;,
                playerCountTitle: &#x27;👥 Nombre de Joueurs&#x27;,
                diceTitle: &#x27;🎲 Dés Quantiques&#x27;,
                actionsTitle: &#x27;⚡ Actions Rapides&#x27;,
                welcomeMessage: &#x27;Bienvenue dans Quantum Monopoly! Cliquez sur &quot;Démarrer&quot; pour commencer.&#x27;,
                gameStarted: &#x27;Jeu commencé! Tour de&#x27;,
                playerTurn: &#x27;Tour de&#x27;,
                diceRolled: &#x27;a lancé&#x27;,
                propertyBought: &#x27;a acheté&#x27;,
                rentPaid: &#x27;paie un loyer de&#x27;,
                aiThinking: &#x27;IA réfléchit...&#x27;,
                moneyLabel: &#x27;Argent&#x27;,
                propertiesLabel: &#x27;Propriétés&#x27;,
                positionLabel: &#x27;Position&#x27;,
                statusLabel: &#x27;Statut&#x27;,
                turnLabel: &#x27;Tour&#x27;,
                roundLabel: &#x27;Manche&#x27;,
                timeLabel: &#x27;Temps&#x27;,
                priceLabel: &#x27;Prix&#x27;,
                typeLabel: &#x27;Type&#x27;,
                noPropertiesText: &#x27;Aucune propriété&#x27;,
                rulesText: &#x27;Règles Quantiques&#x27;,
                startBtn: &#x27;Démarrer&#x27;,
                endTurnBtn: &#x27;Fin Tour&#x27;,
                newGameBtn: &#x27;Nouvelle Partie&#x27;,
                rulesBtn: &#x27;Règles Quantiques&#x27;,
                buyBtn: &#x27;Acheter&#x27;,
                buildBtn: &#x27;Construire&#x27;,
                tradeBtn: &#x27;Échanger&#x27;,
                mortgageBtn: &#x27;Hypothèque&#x27;,
                aiStatus: &#x27;Système IA initialisé\nAnalyse des stratégies en cours...&#x27;,
                bankLabel: &#x27;Banque&#x27;,
                properties: {
                    go: &#x27;DÉPART&#x27;,
                    jail: &#x27;PRISON&#x27;,
                    freeParking: &#x27;PARC GRATUIT&#x27;,
                    goToJail: &#x27;ALLEZ EN PRISON&#x27;,
                    chance: &#x27;CHANCE&#x27;,
                    communityChest: &#x27;CAISSE COMM.&#x27;
                }
            },
            en: {
                gameTitle: &#x27;QUANTUM MONOPOLY&#x27;,
                playersTitle: &#x27;🎮 Quantum Players&#x27;,
                propertiesTitle: &#x27;🏢 Galactic Properties&#x27;,
                statsTitle: &#x27;📊 Statistics&#x27;,
                aiTitle: &#x27;🤖 Quantum AI&#x27;,
                playerCountTitle: &#x27;👥 Player Count&#x27;,
                diceTitle: &#x27;🎲 Quantum Dice&#x27;,
                actionsTitle: &#x27;⚡ Quick Actions&#x27;,
                welcomeMessage: &#x27;Welcome to Quantum Monopoly! Click &quot;Start&quot; to begin.&#x27;,
                gameStarted: &#x27;Game started! Turn of&#x27;,
                playerTurn: &#x27;Turn of&#x27;,
                diceRolled: &#x27;rolled&#x27;,
                propertyBought: &#x27;bought&#x27;,
                rentPaid: &#x27;pays rent of&#x27;,
                aiThinking: &#x27;AI thinking...&#x27;,
                moneyLabel: &#x27;Money&#x27;,
                propertiesLabel: &#x27;Properties&#x27;,
                positionLabel: &#x27;Position&#x27;,
                statusLabel: &#x27;Status&#x27;,
                turnLabel: &#x27;Turn&#x27;,
                roundLabel: &#x27;Round&#x27;,
                timeLabel: &#x27;Time&#x27;,
                priceLabel: &#x27;Price&#x27;,
                typeLabel: &#x27;Type&#x27;,
                noPropertiesText: &#x27;No properties&#x27;,
                rulesText: &#x27;Quantum Rules&#x27;,
                startBtn: &#x27;Start&#x27;,
                endTurnBtn: &#x27;End Turn&#x27;,
                newGameBtn: &#x27;New Game&#x27;,
                rulesBtn: &#x27;Quantum Rules&#x27;,
                buyBtn: &#x27;Buy&#x27;,
                buildBtn: &#x27;Build&#x27;,
                tradeBtn: &#x27;Trade&#x27;,
                mortgageBtn: &#x27;Mortgage&#x27;,
                aiStatus: &#x27;AI System initialized\nStrategy analysis in progress...&#x27;,
                bankLabel: &#x27;Bank&#x27;,
                properties: {
                    go: &#x27;GO&#x27;,
                    jail: &#x27;JAIL&#x27;,
                    freeParking: &#x27;FREE PARKING&#x27;,
                    goToJail: &#x27;GO TO JAIL&#x27;,
                    chance: &#x27;CHANCE&#x27;,
                    communityChest: &#x27;COMMUNITY CHEST&#x27;
                }
            },
            es: {
                gameTitle: &#x27;QUANTUM MONOPOLY&#x27;,
                playersTitle: &#x27;🎮 Jugadores Cuánticos&#x27;,
                propertiesTitle: &#x27;🏢 Propiedades Galácticas&#x27;,
                statsTitle: &#x27;📊 Estadísticas&#x27;,
                aiTitle: &#x27;🤖 IA Cuántica&#x27;,
                playerCountTitle: &#x27;👥 Número de Jugadores&#x27;,
                diceTitle: &#x27;🎲 Dados Cuánticos&#x27;,
                actionsTitle: &#x27;⚡ Acciones Rápidas&#x27;,
                welcomeMessage: &#x27;¡Bienvenido a Quantum Monopoly! Haz clic en &quot;Empezar&quot; para comenzar.&#x27;,
                gameStarted: &#x27;¡Juego iniciado! Turno de&#x27;,
                playerTurn: &#x27;Turno de&#x27;,
                diceRolled: &#x27;lanzó&#x27;,
                propertyBought: &#x27;compró&#x27;,
                rentPaid: &#x27;paga alquiler de&#x27;,
                aiThinking: &#x27;IA pensando...&#x27;,
                moneyLabel: &#x27;Dinero&#x27;,
                propertiesLabel: &#x27;Propiedades&#x27;,
                positionLabel: &#x27;Posición&#x27;,
                statusLabel: &#x27;Estado&#x27;,
                turnLabel: &#x27;Turno&#x27;,
                roundLabel: &#x27;Ronda&#x27;,
                timeLabel: &#x27;Tiempo&#x27;,
                priceLabel: &#x27;Precio&#x27;,
                typeLabel: &#x27;Tipo&#x27;,
                noPropertiesText: &#x27;Sin propiedades&#x27;,
                rulesText: &#x27;Reglas Cuánticas&#x27;,
                startBtn: &#x27;Empezar&#x27;,
                endTurnBtn: &#x27;Fin Turno&#x27;,
                newGameBtn: &#x27;Nueva Partida&#x27;,
                rulesBtn: &#x27;Reglas Cuánticas&#x27;,
                buyBtn: &#x27;Comprar&#x27;,
                buildBtn: &#x27;Construir&#x27;,
                tradeBtn: &#x27;Intercambiar&#x27;,
                mortgageBtn: &#x27;Hipoteca&#x27;,
                aiStatus: &#x27;Sistema IA inicializado\nAnálisis de estrategias en curso...&#x27;,
                bankLabel: &#x27;Banco&#x27;,
                properties: {
                    go: &#x27;SALIDA&#x27;,
                    jail: &#x27;CÁRCEL&#x27;,
                    freeParking: &#x27;PARKING GRATIS&#x27;,
                    goToJail: &#x27;VE A LA CÁRCEL&#x27;,
                    chance: &#x27;SUERTE&#x27;,
                    communityChest: &#x27;CAJA COMÚN&#x27;
                }
            },
            ar: {
                gameTitle: &#x27;مونوبولي كمومي&#x27;,
                playersTitle: &#x27;🎮 اللاعبون الكموميون&#x27;,
                propertiesTitle: &#x27;🏢 الممتلكات المجرية&#x27;,
                statsTitle: &#x27;📊 الإحصائيات&#x27;,
                aiTitle: &#x27;🤖 الذكاء الكمومي&#x27;,
                playerCountTitle: &#x27;👥 عدد اللاعبين&#x27;,
                diceTitle: &#x27;🎲 النرد الكمومي&#x27;,
                actionsTitle: &#x27;⚡ الإجراءات السريعة&#x27;,
                welcomeMessage: &#x27;مرحباً بك في مونوبولي الكمومي! اضغط على &quot;ابدأ&quot; للبدء.&#x27;,
                gameStarted: &#x27;بدأت اللعبة! دور&#x27;,
                playerTurn: &#x27;دور&#x27;,
                diceRolled: &#x27;رمى&#x27;,
                propertyBought: &#x27;اشترى&#x27;,
                rentPaid: &#x27;يدفع إيجار&#x27;,
                aiThinking: &#x27;الذكاء الاصطناعي يفكر...&#x27;,
                moneyLabel: &#x27;المال&#x27;,
                propertiesLabel: &#x27;الممتلكات&#x27;,
                positionLabel: &#x27;الموقع&#x27;,
                statusLabel: &#x27;الحالة&#x27;,
                turnLabel: &#x27;الدور&#x27;,
                roundLabel: &#x27;الجولة&#x27;,
                timeLabel: &#x27;الوقت&#x27;,
                priceLabel: &#x27;السعر&#x27;,
                typeLabel: &#x27;النوع&#x27;,
                noPropertiesText: &#x27;لا توجد ممتلكات&#x27;,
                rulesText: &#x27;القواعد الكمومية&#x27;,
                startBtn: &#x27;ابدأ&#x27;,
                endTurnBtn: &#x27;إنهاء الدور&#x27;,
                newGameBtn: &#x27;لعبة جديدة&#x27;,
                rulesBtn: &#x27;القواعد الكمومية&#x27;,
                buyBtn: &#x27;شراء&#x27;,
                buildBtn: &#x27;بناء&#x27;,
                tradeBtn: &#x27;تبادل&#x27;,
                mortgageBtn: &#x27;رهن&#x27;,
                aiStatus: &#x27;تم تهيئة نظام الذكاء الاصطناعي\nتحليل الاستراتيجيات جاري...&#x27;,
                bankLabel: &#x27;البنك&#x27;,
                properties: {
                    go: &#x27;البداية&#x27;,
                    jail: &#x27;السجن&#x27;,
                    freeParking: &#x27;موقف مجاني&#x27;,
                    goToJail: &#x27;اذهب للسجن&#x27;,
                    chance: &#x27;فرصة&#x27;,
                    communityChest: &#x27;صندوق المجتمع&#x27;
                }
            },
            de: {
                gameTitle: &#x27;QUANTUM MONOPOLY&#x27;,
                playersTitle: &#x27;🎮 Quantenspieler&#x27;,
                propertiesTitle: &#x27;🏢 Galaktische Eigenschaften&#x27;,
                statsTitle: &#x27;📊 Statistiken&#x27;,
                aiTitle: &#x27;🤖 Quanten-KI&#x27;,
                playerCountTitle: &#x27;👥 Spieleranzahl&#x27;,
                diceTitle: &#x27;🎲 Quantenwürfel&#x27;,
                actionsTitle: &#x27;⚡ Schnellaktionen&#x27;,
                welcomeMessage: &#x27;Willkommen bei Quantum Monopoly! Klicken Sie auf &quot;Start&quot; um zu beginnen.&#x27;,
                gameStarted: &#x27;Spiel gestartet! Zug von&#x27;,
                playerTurn: &#x27;Zug von&#x27;,
                diceRolled: &#x27;würfelte&#x27;,
                propertyBought: &#x27;kaufte&#x27;,
                rentPaid: &#x27;zahlt Miete von&#x27;,
                aiThinking: &#x27;KI denkt nach...&#x27;,
                moneyLabel: &#x27;Geld&#x27;,
                propertiesLabel: &#x27;Eigenschaften&#x27;,
                positionLabel: &#x27;Position&#x27;,
                statusLabel: &#x27;Status&#x27;,
                turnLabel: &#x27;Zug&#x27;,
                roundLabel: &#x27;Runde&#x27;,
                timeLabel: &#x27;Zeit&#x27;,
                priceLabel: &#x27;Preis&#x27;,
                typeLabel: &#x27;Typ&#x27;,
                noPropertiesText: &#x27;Keine Eigenschaften&#x27;,
                rulesText: &#x27;Quantenregeln&#x27;,
                startBtn: &#x27;Start&#x27;,
                endTurnBtn: &#x27;Zug beenden&#x27;,
                newGameBtn: &#x27;Neues Spiel&#x27;,
                rulesBtn: &#x27;Quantenregeln&#x27;,
                buyBtn: &#x27;Kaufen&#x27;,
                buildBtn: &#x27;Bauen&#x27;,
                tradeBtn: &#x27;Handeln&#x27;,
                mortgageBtn: &#x27;Hypothek&#x27;,
                aiStatus: &#x27;KI-System initialisiert\nStrategieanalyse läuft...&#x27;,
                bankLabel: &#x27;Bank&#x27;,
                properties: {
                    go: &#x27;START&#x27;,
                    jail: &#x27;GEFÄNGNIS&#x27;,
                    freeParking: &#x27;FREIES PARKEN&#x27;,
                    goToJail: &#x27;GEHE INS GEFÄNGNIS&#x27;,
                    chance: &#x27;EREIGNIS&#x27;,
                    communityChest: &#x27;GEMEINSCHAFTSKASSE&#x27;
                }
            },
            zh: {
                gameTitle: &#x27;量子大富翁&#x27;,
                playersTitle: &#x27;🎮 量子玩家&#x27;,
                propertiesTitle: &#x27;🏢 银河属性&#x27;,
                statsTitle: &#x27;📊 统计数据&#x27;,
                aiTitle: &#x27;🤖 量子AI&#x27;,
                playerCountTitle: &#x27;👥 玩家数量&#x27;,
                diceTitle: &#x27;🎲 量子骰子&#x27;,
                actionsTitle: &#x27;⚡ 快速操作&#x27;,
                welcomeMessage: &#x27;欢迎来到量子大富翁！点击&quot;开始&quot;开始游戏。&#x27;,
                gameStarted: &#x27;游戏开始！轮到&#x27;,
                playerTurn: &#x27;轮到&#x27;,
                diceRolled: &#x27;掷出&#x27;,
                propertyBought: &#x27;购买了&#x27;,
                rentPaid: &#x27;支付租金&#x27;,
                aiThinking: &#x27;AI思考中...&#x27;,
                moneyLabel: &#x27;金钱&#x27;,
                propertiesLabel: &#x27;属性&#x27;,
                positionLabel: &#x27;位置&#x27;,
                statusLabel: &#x27;状态&#x27;,
                turnLabel: &#x27;回合&#x27;,
                roundLabel: &#x27;轮次&#x27;,
                timeLabel: &#x27;时间&#x27;,
                priceLabel: &#x27;价格&#x27;,
                typeLabel: &#x27;类型&#x27;,
                noPropertiesText: &#x27;无属性&#x27;,
                rulesText: &#x27;量子规则&#x27;,
                startBtn: &#x27;开始&#x27;,
                endTurnBtn: &#x27;结束回合&#x27;,
                newGameBtn: &#x27;新游戏&#x27;,
                rulesBtn: &#x27;量子规则&#x27;,
                buyBtn: &#x27;购买&#x27;,
                buildBtn: &#x27;建造&#x27;,
                tradeBtn: &#x27;交易&#x27;,
                mortgageBtn: &#x27;抵押&#x27;,
                aiStatus: &#x27;AI系统已初始化\n策略分析进行中...&#x27;,
                bankLabel: &#x27;银行&#x27;,
                properties: {
                    go: &#x27;起点&#x27;,
                    jail: &#x27;监狱&#x27;,
                    freeParking: &#x27;免费停车&#x27;,
                    goToJail: &#x27;进监狱&#x27;,
                    chance: &#x27;机会&#x27;,
                    communityChest: &#x27;公共基金&#x27;
                }
            }
        };

        // Propriétés du plateau
        let boardProperties = [];

        function getTranslatedProperties() {
            const t = translations[gameState.currentLanguage];
            return [
                // Case 0 - Départ
                { name: t.properties.go, type: &#x27;corner&#x27;, price: 0, color: &#x27;#ff6b6b&#x27; },
                
                // Cases 1-9 (côté bas)
                { name: &#x27;Rue de la Paix&#x27;, type: &#x27;property&#x27;, price: 60, color: &#x27;#8B4513&#x27;, rent: 6 },
                { name: &#x27;Caisse Communauté&#x27;, type: &#x27;communityChest&#x27;, price: 0, color: &#x27;#0088ff&#x27; },
                { name: &#x27;Rue Lecourbe&#x27;, type: &#x27;property&#x27;, price: 60, color: &#x27;#8B4513&#x27;, rent: 6 },
                { name: &#x27;Impôt sur le Revenu&#x27;, type: &#x27;tax&#x27;, price: 200, color: &#x27;#ff4444&#x27; },
                { name: &#x27;Gare Montparnasse&#x27;, type: &#x27;railroad&#x27;, price: 200, color: &#x27;#2c2c54&#x27; },
                { name: &#x27;Rue de Vaugirard&#x27;, type: &#x27;property&#x27;, price: 100, color: &#x27;#87CEEB&#x27;, rent: 8 },
                { name: &#x27;Chance&#x27;, type: &#x27;chance&#x27;, price: 0, color: &#x27;#ff9500&#x27; },
                { name: &#x27;Rue de Courcelles&#x27;, type: &#x27;property&#x27;, price: 100, color: &#x27;#87CEEB&#x27;, rent: 8 },
                { name: &#x27;Avenue de la République&#x27;, type: &#x27;property&#x27;, price: 120, color: &#x27;#87CEEB&#x27;, rent: 10 },
                
                // Case 10 - Prison
                { name: t.properties.jail, type: &#x27;corner&#x27;, price: 0, color: &#x27;#ff6b6b&#x27; },
                
                // Cases 11-19 (côté gauche)
                { name: &#x27;Boulevard de Belleville&#x27;, type: &#x27;property&#x27;, price: 140, color: &#x27;#FF69B4&#x27;, rent: 12 },
                { name: &#x27;Compagnie Électrique&#x27;, type: &#x27;utility&#x27;, price: 150, color: &#x27;#ff9ff3&#x27; },
                { name: &#x27;Rue Oberkampf&#x27;, type: &#x27;property&#x27;, price: 140, color: &#x27;#FF69B4&#x27;, rent: 12 },
                { name: &#x27;Rue Ménilmontant&#x27;, type: &#x27;property&#x27;, price: 160, color: &#x27;#FF69B4&#x27;, rent: 14 },
                { name: &#x27;Gare du Nord&#x27;, type: &#x27;railroad&#x27;, price: 200, color: &#x27;#2c2c54&#x27; },
                { name: &#x27;Avenue de Neuilly&#x27;, type: &#x27;property&#x27;, price: 180, color: &#x27;#FFA500&#x27;, rent: 16 },
                { name: &#x27;Caisse Communauté&#x27;, type: &#x27;communityChest&#x27;, price: 0, color: &#x27;#0088ff&#x27; },
                { name: &#x27;Avenue Henri-Martin&#x27;, type: &#x27;property&#x27;, price: 180, color: &#x27;#FFA500&#x27;, rent: 16 },
                { name: &#x27;Place Pigalle&#x27;, type: &#x27;property&#x27;, price: 200, color: &#x27;#FFA500&#x27;, rent: 18 },
                
                // Case 20 - Parc Gratuit
                { name: t.properties.freeParking, type: &#x27;corner&#x27;, price: 0, color: &#x27;#ff6b6b&#x27; },
                
                // Cases 21-29 (côté haut)
                { name: &#x27;Avenue Matignon&#x27;, type: &#x27;property&#x27;, price: 220, color: &#x27;#FF0000&#x27;, rent: 20 },
                { name: &#x27;Chance&#x27;, type: &#x27;chance&#x27;, price: 0, color: &#x27;#ff9500&#x27; },
                { name: &#x27;Boulevard Malesherbes&#x27;, type: &#x27;property&#x27;, price: 220, color: &#x27;#FF0000&#x27;, rent: 20 },
                { name: &#x27;Avenue des Champs-Élysées&#x27;, type: &#x27;property&#x27;, price: 240, color: &#x27;#FF0000&#x27;, rent: 22 },
                { name: &#x27;Gare de Lyon&#x27;, type: &#x27;railroad&#x27;, price: 200, color: &#x27;#2c2c54&#x27; },
                { name: &#x27;Avenue de Breteuil&#x27;, type: &#x27;property&#x27;, price: 260, color: &#x27;#FFFF00&#x27;, rent: 24 },
                { name: &#x27;Avenue Foch&#x27;, type: &#x27;property&#x27;, price: 260, color: &#x27;#FFFF00&#x27;, rent: 24 },
                { name: &#x27;Compagnie des Eaux&#x27;, type: &#x27;utility&#x27;, price: 150, color: &#x27;#ff9ff3&#x27; },
                { name: &#x27;Boulevard des Capucines&#x27;, type: &#x27;property&#x27;, price: 280, color: &#x27;#FFFF00&#x27;, rent: 26 },
                
                // Case 30 - Allez en Prison
                { name: t.properties.goToJail, type: &#x27;corner&#x27;, price: 0, color: &#x27;#ff6b6b&#x27; },
                
                // Cases 31-39 (côté droit)
                { name: &#x27;Avenue des Champs-Élysées&#x27;, type: &#x27;property&#x27;, price: 300, color: &#x27;#00FF00&#x27;, rent: 28 },
                { name: &#x27;Place de la Concorde&#x27;, type: &#x27;property&#x27;, price: 300, color: &#x27;#00FF00&#x27;, rent: 28 },
                { name: &#x27;Caisse Communauté&#x27;, type: &#x27;communityChest&#x27;, price: 0, color: &#x27;#0088ff&#x27; },
                { name: &#x27;Avenue de la Grande-Armée&#x27;, type: &#x27;property&#x27;, price: 320, color: &#x27;#00FF00&#x27;, rent: 30 },
                { name: &#x27;Gare Saint-Lazare&#x27;, type: &#x27;railroad&#x27;, price: 200, color: &#x27;#2c2c54&#x27; },
                { name: &#x27;Chance&#x27;, type: &#x27;chance&#x27;, price: 0, color: &#x27;#ff9500&#x27; },
                { name: &#x27;Rue de la Paix&#x27;, type: &#x27;property&#x27;, price: 350, color: &#x27;#0000FF&#x27;, rent: 35 },
                { name: &#x27;Taxe de Luxe&#x27;, type: &#x27;tax&#x27;, price: 100, color: &#x27;#ff4444&#x27; },
                { name: &#x27;Place Vendôme&#x27;, type: &#x27;property&#x27;, price: 400, color: &#x27;#0000FF&#x27;, rent: 40 }
            ];
        }

        // Basculer le dropdown de langue
        function toggleLanguageDropdown() {
            const options = document.getElementById(&#x27;languageOptions&#x27;);
            options.classList.toggle(&#x27;show&#x27;);
            
            // Fermer le dropdown si on clique ailleurs
            document.addEventListener(&#x27;click&#x27;, function closeDropdown(e) {
                if (!e.target.closest(&#x27;.language-selector&#x27;)) {
                    options.classList.remove(&#x27;show&#x27;);
                    document.removeEventListener(&#x27;click&#x27;, closeDropdown);
                }
            });
        }

        // Sélectionner une langue
        function selectLanguage(langCode, langText) {
            gameState.currentLanguage = langCode;
            
            // Mettre à jour l&#x27;affichage du sélecteur
            document.getElementById(&#x27;currentLanguage&#x27;).textContent = langText;
            
            // Mettre à jour les classes actives
            document.querySelectorAll(&#x27;.language-option&#x27;).forEach(option =&gt; {
                option.classList.remove(&#x27;active&#x27;);
            });
            event.target.classList.add(&#x27;active&#x27;);
            
            // Fermer le dropdown
            document.getElementById(&#x27;languageOptions&#x27;).classList.remove(&#x27;show&#x27;);
            
            // Mettre à jour les propriétés traduites
            boardProperties = getTranslatedProperties();
            
            // Mettre à jour l&#x27;interface
            updateLanguageInterface();
            
            // Réinitialiser le plateau avec les nouvelles traductions
            if (gameState.isPlaying) {
                initializeBoard();
                updatePlayersDisplay();
                updatePropertiesDisplay();
            }
        }

        // Mettre à jour l&#x27;interface selon la langue
        function updateLanguageInterface() {
            const t = translations[gameState.currentLanguage];
            
            // Mettre à jour le titre du jeu
            document.getElementById(&#x27;gameTitle&#x27;).textContent = t.gameTitle;
            document.getElementById(&#x27;aiQuantumBtnText&#x27;).textContent = &#x27;🤖 &#x27; + t.aiTitle.replace(&#x27;🤖 &#x27;, &#x27;&#x27;);
            
            // Mettre à jour les titres des sections
            document.getElementById(&#x27;playersTitle&#x27;).textContent = t.playersTitle;
            document.getElementById(&#x27;statsTitle&#x27;).textContent = t.statsTitle;
            document.getElementById(&#x27;propertiesTitle&#x27;).textContent = t.propertiesTitle;
            document.getElementById(&#x27;aiTitle&#x27;).textContent = t.aiTitle;
            document.getElementById(&#x27;playerCountTitle&#x27;).textContent = t.playerCountTitle;
            document.getElementById(&#x27;diceTitle&#x27;).textContent = t.diceTitle;
            document.getElementById(&#x27;actionsTitle&#x27;).textContent = t.actionsTitle;
            
            // Mettre à jour les boutons
            document.getElementById(&#x27;startBtnText&#x27;).textContent = t.startBtn;
            document.getElementById(&#x27;endTurnBtnText&#x27;).textContent = t.endTurnBtn;
            document.getElementById(&#x27;newGameBtnText&#x27;).textContent = t.newGameBtn;
            document.getElementById(&#x27;rulesBtnText&#x27;).textContent = t.rulesBtn;
            
            // Mettre à jour les boutons d&#x27;action
            document.getElementById(&#x27;buyBtnText&#x27;).textContent = t.buyBtn;
            document.getElementById(&#x27;buildBtnText&#x27;).textContent = t.buildBtn;
            document.getElementById(&#x27;tradeBtnText&#x27;).textContent = t.tradeBtn;
            document.getElementById(&#x27;mortgageBtnText&#x27;).textContent = t.mortgageBtn;
            
            // Mettre à jour les labels
            document.getElementById(&#x27;turnLabel&#x27;).textContent = t.turnLabel + &#x27;:&#x27;;
            document.getElementById(&#x27;roundLabel&#x27;).textContent = t.roundLabel + &#x27;:&#x27;;
            document.getElementById(&#x27;timeLabel&#x27;).textContent = t.timeLabel + &#x27;:&#x27;;
            document.getElementById(&#x27;bankLabel&#x27;).textContent = t.bankLabel + &#x27;:&#x27;;
            
            // Mettre à jour le statut IA
            document.getElementById(&#x27;aiStatusText&#x27;).innerHTML = t.aiStatus.replace(&#x27;\n&#x27;, &#x27;&lt;br&gt;&#x27;);
            
            // Mettre à jour le texte &quot;aucune propriété&quot;
            document.getElementById(&#x27;noPropertiesText&#x27;).textContent = t.noPropertiesText;
            
            if (!gameState.isPlaying) {
                document.getElementById(&#x27;gameMessage&#x27;).innerHTML = `&lt;span&gt;${t.welcomeMessage}&lt;/span&gt;`;
            }
        }

        // Créer les particules quantiques
        function createQuantumParticles() {
            const bg = document.querySelector(&#x27;.quantum-bg&#x27;);
            for (let i = 0; i &lt; 50; i++) {
                const particle = document.createElement(&#x27;div&#x27;);
                particle.className = &#x27;quantum-particle&#x27;;
                particle.style.left = Math.random() * 100 + &#x27;%&#x27;;
                particle.style.top = Math.random() * 100 + &#x27;%&#x27;;
                particle.style.animationDelay = Math.random() * 6 + &#x27;s&#x27;;
                particle.style.animationDuration = (Math.random() * 4 + 4) + &#x27;s&#x27;;
                bg.appendChild(particle);
            }
        }

        // Initialiser les joueurs
        function initializePlayers() {
            const playerNames = [
                { name: &#x27;Commandant Alpha&#x27;, icon: &#x27;👤&#x27;, isAI: false },
                { name: &#x27;Capitaine Beta&#x27;, icon: &#x27;🤖&#x27;, isAI: false },
                { name: &#x27;Major Gamma&#x27;, icon: &#x27;🤖&#x27;, isAI: true },
                { name: &#x27;Colonel Delta&#x27;, icon: &#x27;🤖&#x27;, isAI: true }
            ];

            gameState.players = [];
            for (let i = 0; i &lt; gameState.playerCount; i++) {
                gameState.players.push({
                    id: i,
                    name: playerNames[i].name,
                    icon: playerNames[i].icon,
                    money: 1500,
                    properties: [],
                    position: 0,
                    isAI: playerNames[i].isAI,
                    isBankrupt: false,
                    inJail: false,
                    jailTurns: 0
                });
            }
        }

        // Mettre à jour l&#x27;affichage des joueurs
        function updatePlayersDisplay() {
            const container = document.getElementById(&#x27;playersContainer&#x27;);
            container.innerHTML = &#x27;&#x27;;
            
            const t = translations[gameState.currentLanguage];
            
            gameState.players.forEach((player, index) =&gt; {
                const playerDiv = document.createElement(&#x27;div&#x27;);
                playerDiv.className = `player-info ${index === gameState.currentPlayer ? &#x27;current-player&#x27; : &#x27;&#x27;}`;
                
                playerDiv.innerHTML = `
                    &lt;div class=&quot;player-name&quot;&gt;${index + 1}${player.name} ${player.icon}&lt;/div&gt;
                    &lt;div class=&quot;player-stats&quot;&gt;
                        &lt;div class=&quot;stat-item&quot;&gt;
                            &lt;span&gt;${t.moneyLabel || &#x27;Argent&#x27;}:&lt;/span&gt;
                            &lt;span class=&quot;stat-value&quot;&gt;₹${player.money}&lt;/span&gt;
                        &lt;/div&gt;
                        &lt;div class=&quot;stat-item&quot;&gt;
                            &lt;span&gt;${t.propertiesLabel || &#x27;Propriétés&#x27;}:&lt;/span&gt;
                            &lt;span class=&quot;stat-value&quot;&gt;${player.properties.length}&lt;/span&gt;
                        &lt;/div&gt;
                        &lt;div class=&quot;stat-item&quot;&gt;
                            &lt;span&gt;${t.positionLabel || &#x27;Position&#x27;}:&lt;/span&gt;
                            &lt;span class=&quot;stat-value&quot;&gt;${player.position}&lt;/span&gt;
                        &lt;/div&gt;
                        &lt;div class=&quot;stat-item&quot;&gt;
                            &lt;span&gt;${t.statusLabel || &#x27;Statut&#x27;}:&lt;/span&gt;
                            &lt;span class=&quot;stat-value&quot;&gt;${player.isBankrupt ? &#x27;💸&#x27; : player.inJail ? &#x27;🔒&#x27; : &#x27;✅&#x27;}&lt;/span&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                `;
                container.appendChild(playerDiv);
            });
        }

        // Initialiser le plateau
        function initializeBoard() {
            const boardSurface = document.getElementById(&#x27;boardSurface&#x27;);
            boardSurface.innerHTML = &#x27;&#x27;;
            
            // Créer les 40 cases du plateau en disposition Monopoly
            const positions = [
                // Bas (0-10)
                [10, 10], [9, 10], [8, 10], [7, 10], [6, 10], [5, 10], [4, 10], [3, 10], [2, 10], [1, 10], [0, 10],
                // Gauche (11-19)
                [0, 9], [0, 8], [0, 7], [0, 6], [0, 5], [0, 4], [0, 3], [0, 2], [0, 1],
                // Haut (20-30)
                [0, 0], [1, 0], [2, 0], [3, 0], [4, 0], [5, 0], [6, 0], [7, 0], [8, 0], [9, 0], [10, 0],
                // Droite (31-39)
                [10, 1], [10, 2], [10, 3], [10, 4], [10, 5], [10, 6], [10, 7], [10, 8], [10, 9]
            ];
            
            // Créer toutes les cellules de la grille 11x11
            for(let row = 0; row &lt; 11; row++) {
                for(let col = 0; col &lt; 11; col++) {
                    const cell = document.createElement(&#x27;div&#x27;);
                    cell.className = &#x27;board-cell&#x27;;
                    
                    // Vérifier si cette position correspond à une case du plateau
                    const propertyIndex = positions.findIndex(pos =&gt; pos[0] === col &amp;&amp; pos[1] === row);
                    
                    if (propertyIndex !== -1) {
                        const property = boardProperties[propertyIndex];
                        cell.classList.add(`cell-${property.type}`);
                        cell.dataset.propertyId = propertyIndex;
                        
                        // Affichage selon le type de case
                        let cellContent = &#x27;&#x27;;
                        if (property.type === &#x27;corner&#x27;) {
                            cellContent = `&lt;div style=&quot;font-size: 13px; font-weight: bold; text-align: center; padding: 6px; line-height: 1.2; color: white; text-shadow: 2px 2px 4px rgba(0,0,0,0.8); display: flex; align-items: center; justify-content: center; height: 100%; word-break: break-word; hyphens: auto;&quot;&gt;${property.name}&lt;/div&gt;`;
                        } else if (property.type === &#x27;property&#x27;) {
                            cellContent = `
                                &lt;div style=&quot;background: ${property.color}; height: 26px; width: 100%; border-radius: 8px; border: 1px solid rgba(255,255,255,0.7); flex-shrink: 0; display: flex; align-items: center; justify-content: center; font-size: 12px; font-weight: bold; color: #00ff00; text-shadow: 1px 1px 2px rgba(0,0,0,0.9);&quot;&gt;₹${property.price}&lt;/div&gt;
                                &lt;div style=&quot;font-size: 13px; text-align: center; line-height: 1.1; color: white; font-weight: bold; text-shadow: 1px 1px 3px rgba(0,0,0,1); padding: 5px; flex-grow: 1; display: flex; align-items: center; justify-content: center; word-break: break-word; hyphens: auto;&quot;&gt;${property.name}&lt;/div&gt;
                            `;
                        } else if (property.type === &#x27;railroad&#x27;) {
                            cellContent = `
                                &lt;div style=&quot;font-size: 22px; text-align: center; flex-shrink: 0;&quot;&gt;🚂&lt;/div&gt;
                                &lt;div style=&quot;font-size: 12px; text-align: center; line-height: 1.1; color: white; font-weight: bold; text-shadow: 1px 1px 3px rgba(0,0,0,1); padding: 4px; flex-grow: 1; display: flex; align-items: center; justify-content: center; word-break: break-word; hyphens: auto;&quot;&gt;${property.name}&lt;/div&gt;
                                &lt;div style=&quot;font-size: 13px; text-align: center; color: #00ff00; font-weight: bold; background: rgba(0,0,0,0.8); padding: 4px 8px; border-radius: 10px; text-shadow: 1px 1px 2px rgba(0,0,0,1); border: 1px solid rgba(0,255,0,0.3); flex-shrink: 0;&quot;&gt;₹${property.price}&lt;/div&gt;
                            `;
                        } else if (property.type === &#x27;utility&#x27;) {
                            cellContent = `
                                &lt;div style=&quot;font-size: 22px; text-align: center; flex-shrink: 0;&quot;&gt;⚡&lt;/div&gt;
                                &lt;div style=&quot;font-size: 12px; text-align: center; line-height: 1.1; color: white; font-weight: bold; text-shadow: 1px 1px 3px rgba(0,0,0,1); padding: 4px; flex-grow: 1; display: flex; align-items: center; justify-content: center; word-break: break-word; hyphens: auto;&quot;&gt;${property.name}&lt;/div&gt;
                                &lt;div style=&quot;font-size: 13px; text-align: center; color: #00ff00; font-weight: bold; background: rgba(0,0,0,0.8); padding: 4px 8px; border-radius: 10px; text-shadow: 1px 1px 2px rgba(0,0,0,1); border: 1px solid rgba(0,255,0,0.3); flex-shrink: 0;&quot;&gt;₹${property.price}&lt;/div&gt;
                            `;
                        } else if (property.type === &#x27;chance&#x27;) {
                            const t = translations[gameState.currentLanguage];
                            cellContent = `
                                &lt;div style=&quot;font-size: 22px; text-align: center; flex-shrink: 0;&quot;&gt;🎲&lt;/div&gt;
                                &lt;div style=&quot;font-size: 12px; text-align: center; font-weight: bold; color: #ff8800; text-shadow: 2px 2px 4px rgba(0,0,0,0.8); flex-grow: 1; display: flex; align-items: center; justify-content: center;&quot;&gt;${t.properties.chance}&lt;/div&gt;
                            `;
                        } else if (property.type === &#x27;communityChest&#x27;) {
                            const t = translations[gameState.currentLanguage];
                            cellContent = `
                                &lt;div style=&quot;font-size: 22px; text-align: center; flex-shrink: 0;&quot;&gt;📦&lt;/div&gt;
                                &lt;div style=&quot;font-size: 11px; text-align: center; font-weight: bold; color: #0088ff; text-shadow: 2px 2px 4px rgba(0,0,0,0.8); flex-grow: 1; display: flex; align-items: center; justify-content: center; line-height: 1.1;&quot;&gt;${t.properties.communityChest}&lt;/div&gt;
                            `;
                        } else if (property.type === &#x27;tax&#x27;) {
                            cellContent = `
                                &lt;div style=&quot;font-size: 22px; text-align: center; flex-shrink: 0;&quot;&gt;💰&lt;/div&gt;
                                &lt;div style=&quot;font-size: 12px; text-align: center; line-height: 1.1; color: white; font-weight: bold; text-shadow: 1px 1px 3px rgba(0,0,0,1); padding: 4px; flex-grow: 1; display: flex; align-items: center; justify-content: center; word-break: break-word; hyphens: auto;&quot;&gt;${property.name}&lt;/div&gt;
                                &lt;div style=&quot;font-size: 13px; text-align: center; color: #ffff00; font-weight: bold; background: rgba(0,0,0,0.8); padding: 4px 8px; border-radius: 10px; text-shadow: 1px 1px 2px rgba(0,0,0,1); border: 1px solid rgba(255,255,0,0.3); flex-shrink: 0;&quot;&gt;₹${property.price}&lt;/div&gt;
                            `;
                        }
                        
                        cell.innerHTML = cellContent;
                        
                        // Ajouter les pions des joueurs sur la case départ
                        if (propertyIndex === 0) {
                            gameState.players.forEach((player, index) =&gt; {
                                if (player.position === 0) {
                                    const token = document.createElement(&#x27;div&#x27;);
                                    token.className = `player-token player-${index + 1}`;
                                    token.textContent = index + 1;
                                    token.style.top = `${(index % 2) * 25}px`;
                                    token.style.left = `${Math.floor(index / 2) * 25}px`;
                                    cell.appendChild(token);
                                }
                            });
                        }
                    } else {
                        // Cellule du centre (vide)
                        cell.style.background = &#x27;transparent&#x27;;
                        cell.style.border = &#x27;none&#x27;;
                        if (row === 5 &amp;&amp; col === 5) {
                            cell.innerHTML = `
                                &lt;div style=&quot;display: flex; flex-direction: column; align-items: center; gap: 8px; padding: 6px; height: 100%; justify-content: center;&quot;&gt;
                                    &lt;div style=&quot;font-size: 48px; filter: drop-shadow(0 0 15px #00ffff); animation: pulse 2s ease-in-out infinite;&quot;&gt;🌌&lt;/div&gt;
                                &lt;/div&gt;
                            `;
                        }
                    }
                    
                    boardSurface.appendChild(cell);
                }
            }
        }

        // Lancer les dés
        function rollDice() {
            if (!gameState.isPlaying || !gameState.canRoll) return;
            
            const dice1 = document.getElementById(&#x27;sidebarDice1&#x27;);
            const dice2 = document.getElementById(&#x27;sidebarDice2&#x27;);
            
            // Animation de lancement
            dice1.classList.add(&#x27;rolling&#x27;);
            dice2.classList.add(&#x27;rolling&#x27;);
            
            setTimeout(() =&gt; {
                gameState.dice1 = Math.floor(Math.random() * 6) + 1;
                gameState.dice2 = Math.floor(Math.random() * 6) + 1;
                gameState.lastRoll = gameState.dice1 + gameState.dice2;
                
                dice1.textContent = gameState.dice1;
                dice2.textContent = gameState.dice2;
                
                dice1.classList.remove(&#x27;rolling&#x27;);
                dice2.classList.remove(&#x27;rolling&#x27;);
                
                gameState.canRoll = false;
                document.getElementById(&#x27;endTurnBtn&#x27;).disabled = false;
                
                // Déplacer le joueur
                movePlayer(gameState.currentPlayer, gameState.lastRoll);
                
                const t = translations[gameState.currentLanguage];
                const currentPlayer = gameState.players[gameState.currentPlayer];
                showMessage(`${currentPlayer.name} ${t.diceRolled} ${gameState.lastRoll}`);
                
            }, 1000);
        }

        // Déplacer un joueur
        function movePlayer(playerIndex, steps) {
            const player = gameState.players[playerIndex];
            const oldPosition = player.position;
            
            player.position = (player.position + steps) % 40;
            
            // Vérifier si le joueur passe par la case départ
            if (player.position &lt; oldPosition) {
                player.money += 200;
                const t = translations[gameState.currentLanguage];
                showMessage(`${player.name} passe par ${t.properties.go} et reçoit ₹200!`);
            }
            
            updatePlayersDisplay();
            updateBoardDisplay();
            
            // Traiter l&#x27;action de la case
            handlePropertyAction(playerIndex, player.position);
        }

        // Gérer l&#x27;action d&#x27;une propriété
        function handlePropertyAction(playerIndex, position) {
            const player = gameState.players[playerIndex];
            const property = boardProperties[position];
            const t = translations[gameState.currentLanguage];
            
            if (property.type === &#x27;property&#x27; || property.type === &#x27;railroad&#x27; || property.type === &#x27;utility&#x27;) {
                // Vérifier si la propriété appartient à quelqu&#x27;un
                const owner = gameState.players.find(p =&gt; p.properties.includes(position));
                
                if (!owner) {
                    // Propriété libre - proposer l&#x27;achat
                    if (player.money &gt;= property.price) {
                        if (player.isAI) {
                            // IA décide d&#x27;acheter (logique simple)
                            if (Math.random() &gt; 0.3) {
                                buyPropertyForPlayer(playerIndex, position);
                            }
                        } else {
                            // Proposer l&#x27;achat au joueur humain
                            document.getElementById(&#x27;buyBtn&#x27;).disabled = false;
                            showMessage(`Voulez-vous acheter ${property.name} pour ₹${property.price}?`);
                        }
                    }
                } else if (owner.id !== playerIndex) {
                    // Payer un loyer
                    const rent = calculateRent(property, owner);
                    player.money -= rent;
                    owner.money += rent;
                    showMessage(`${player.name} ${t.rentPaid} ₹${rent} à ${owner.name} pour ${property.name}`);
                    updatePlayersDisplay();
                }
            } else if (property.type === &#x27;tax&#x27;) {
                // Payer une taxe
                player.money -= property.price;
                showMessage(`${player.name} paie ${property.name}: ₹${property.price}`);
                updatePlayersDisplay();
            } else if (property.type === &#x27;chance&#x27;) {
                // Carte Chance
                handleChanceCard(playerIndex);
            } else if (property.type === &#x27;communityChest&#x27;) {
                // Carte Caisse de Communauté
                handleCommunityChestCard(playerIndex);
            } else if (property.type === &#x27;corner&#x27;) {
                if (position === 30) { // Allez en Prison
                    player.position = 10;
                    player.inJail = true;
                    player.jailTurns = 0;
                    showMessage(`${player.name} va en prison!`);
                    updateBoardDisplay();
                } else if (position === 0) { // Départ
                    showMessage(`${player.name} est sur la case Départ!`);
                } else if (position === 10) { // Prison (visite)
                    showMessage(`${player.name} visite la prison`);
                } else if (position === 20) { // Parc Gratuit
                    showMessage(`${player.name} se repose au Parc Gratuit`);
                }
            }
        }

        // Gérer les cartes Chance
        function handleChanceCard(playerIndex) {
            const player = gameState.players[playerIndex];
            const chanceCards = [
                { text: &quot;Avancez jusqu&#x27;à la case Départ&quot;, action: () =&gt; { player.position = 0; player.money += 200; } },
                { text: &quot;Allez en prison&quot;, action: () =&gt; { player.position = 10; player.inJail = true; player.jailTurns = 0; } },
                { text: &quot;Recevez ₹200&quot;, action: () =&gt; { player.money += 200; } },
                { text: &quot;Payez ₹50&quot;, action: () =&gt; { player.money -= 50; } },
                { text: &quot;Avancez de 3 cases&quot;, action: () =&gt; { movePlayer(playerIndex, 3); } }
            ];
            
            const card = chanceCards[Math.floor(Math.random() * chanceCards.length)];
            card.action();
            showMessage(`${player.name} - Chance: ${card.text}`);
            updatePlayersDisplay();
            updateBoardDisplay();
        }

        // Gérer les cartes Caisse de Communauté
        function handleCommunityChestCard(playerIndex) {
            const player = gameState.players[playerIndex];
            const communityCards = [
                { text: &quot;Recevez ₹100&quot;, action: () =&gt; { player.money += 100; } },
                { text: &quot;Payez ₹100&quot;, action: () =&gt; { player.money -= 100; } },
                { text: &quot;Recevez ₹50 de chaque joueur&quot;, action: () =&gt; { 
                    gameState.players.forEach(p =&gt; {
                        if (p.id !== player.id) {
                            p.money -= 50;
                            player.money += 50;
                        }
                    });
                }},
                { text: &quot;Allez en prison&quot;, action: () =&gt; { player.position = 10; player.inJail = true; player.jailTurns = 0; } },
                { text: &quot;Sortez de prison gratuitement&quot;, action: () =&gt; { /* Carte à garder */ } }
            ];
            
            const card = communityCards[Math.floor(Math.random() * communityCards.length)];
            card.action();
            showMessage(`${player.name} - Caisse: ${card.text}`);
            updatePlayersDisplay();
            updateBoardDisplay();
        }

        // Calculer le loyer
        function calculateRent(property, owner) {
            let baseRent = property.rent || Math.floor(property.price * 0.1);
            
            if (property.type === &#x27;railroad&#x27;) {
                const railroadCount = owner.properties.filter(p =&gt; boardProperties[p].type === &#x27;railroad&#x27;).length;
                baseRent = 25 * Math.pow(2, railroadCount - 1);
            } else if (property.type === &#x27;utility&#x27;) {
                const utilityCount = owner.properties.filter(p =&gt; boardProperties[p].type === &#x27;utility&#x27;).length;
                baseRent = utilityCount === 1 ? gameState.lastRoll * 4 : gameState.lastRoll * 10;
            } else if (property.type === &#x27;property&#x27;) {
                // Vérifier si le joueur possède toutes les propriétés de cette couleur
                const sameColorProperties = boardProperties.filter(p =&gt; p.color === property.color &amp;&amp; p.type === &#x27;property&#x27;);
                const ownedSameColor = owner.properties.filter(p =&gt; {
                    const prop = boardProperties[p];
                    return prop.color === property.color &amp;&amp; prop.type === &#x27;property&#x27;;
                });
                
                if (ownedSameColor.length === sameColorProperties.length) {
                    baseRent *= 2; // Double le loyer si monopole
                }
            }
            
            return baseRent;
        }

        // Acheter une propriété pour un joueur
        function buyPropertyForPlayer(playerIndex, propertyIndex) {
            const player = gameState.players[playerIndex];
            const property = boardProperties[propertyIndex];
            const t = translations[gameState.currentLanguage];
            
            if (player.money &gt;= property.price) {
                player.money -= property.price;
                player.properties.push(propertyIndex);
                
                showMessage(`${player.name} ${t.propertyBought} ${property.name} pour ₹${property.price}`);
                updatePlayersDisplay();
                updatePropertiesDisplay();
                
                document.getElementById(&#x27;buyBtn&#x27;).disabled = true;
            }
        }

        // Acheter une propriété (bouton)
        function buyProperty() {
            const currentPlayer = gameState.players[gameState.currentPlayer];
            buyPropertyForPlayer(gameState.currentPlayer, currentPlayer.position);
        }

        // Mettre à jour l&#x27;affichage du plateau
        function updateBoardDisplay() {
            // Supprimer tous les pions existants
            document.querySelectorAll(&#x27;.player-token&#x27;).forEach(token =&gt; token.remove());
            
            // Replacer les pions selon les positions actuelles
            gameState.players.forEach((player, index) =&gt; {
                if (!player.isBankrupt) {
                    const cell = document.querySelector(`[data-property-id=&quot;${player.position}&quot;]`);
                    if (cell) {
                        const token = document.createElement(&#x27;div&#x27;);
                        token.className = `player-token player-${index + 1}`;
                        token.textContent = index + 1;
                        
                        // Positionner les pions pour éviter les chevauchements
                        const playersOnSameCell = gameState.players.filter(p =&gt; p.position === player.position &amp;&amp; !p.isBankrupt);
                        const tokenIndex = playersOnSameCell.findIndex(p =&gt; p.id === player.id);
                        
                        token.style.top = `${(tokenIndex % 2) * 25}px`;
                        token.style.left = `${Math.floor(tokenIndex / 2) * 25}px`;
                        
                        cell.appendChild(token);
                    }
                }
            });
        }

        // Mettre à jour l&#x27;affichage des propriétés
        function updatePropertiesDisplay() {
            const container = document.getElementById(&#x27;propertiesContainer&#x27;);
            container.innerHTML = &#x27;&#x27;;
            
            const currentPlayer = gameState.players[gameState.currentPlayer];
            
            const t = translations[gameState.currentLanguage];
            if (currentPlayer.properties.length === 0) {
                container.innerHTML = `&lt;div style=&quot;color: #a1a1aa; text-align: center; padding: 20px;&quot;&gt;${t.noPropertiesText || &#x27;Aucune propriété&#x27;}&lt;/div&gt;`;
                return;
            }
            
            currentPlayer.properties.forEach(propertyIndex =&gt; {
                const property = boardProperties[propertyIndex];
                const propertyDiv = document.createElement(&#x27;div&#x27;);
                propertyDiv.className = &#x27;player-info&#x27;;
                propertyDiv.style.marginBottom = &#x27;8px&#x27;;
                propertyDiv.innerHTML = `
                    &lt;div style=&quot;font-weight: bold; color: #00ffff; font-size: 12px;&quot;&gt;
                        ${property.name} #${propertyIndex}
                    &lt;/div&gt;
                    &lt;div style=&quot;font-size: 10px; color: #a1a1aa;&quot;&gt;
                        ${t.priceLabel || &#x27;Prix&#x27;}: ₹${property.price} | ${t.typeLabel || &#x27;Type&#x27;}: ${property.type}
                    &lt;/div&gt;
                `;
                container.appendChild(propertyDiv);
            });
        }

        // Finir le tour
        function endTurn() {
            if (!gameState.isPlaying) return;
            
            gameState.canRoll = true;
            document.getElementById(&#x27;endTurnBtn&#x27;).disabled = true;
            document.getElementById(&#x27;buyBtn&#x27;).disabled = true;
            
            // Passer au joueur suivant
            do {
                gameState.currentPlayer = (gameState.currentPlayer + 1) % gameState.playerCount;
                if (gameState.currentPlayer === 0) {
                    gameState.turn++;
                    if (gameState.turn % gameState.playerCount === 1) {
                        gameState.round++;
                    }
                }
            } while (gameState.players[gameState.currentPlayer].isBankrupt);
            
            updatePlayersDisplay();
            updatePropertiesDisplay();
            updateStats();
            
            const t = translations[gameState.currentLanguage];
            const currentPlayer = gameState.players[gameState.currentPlayer];
            showMessage(`${t.playerTurn} ${currentPlayer.name}`);
            
            // Si c&#x27;est un joueur IA, jouer automatiquement
            if (currentPlayer.isAI) {
                setTimeout(() =&gt; {
                    playAITurn();
                }, 2000);
            }
        }

        // Jouer le tour de l&#x27;IA
        function playAITurn() {
            const t = translations[gameState.currentLanguage];
            showMessage(`${t.aiThinking}`);
            
            setTimeout(() =&gt; {
                rollDice();
                
                setTimeout(() =&gt; {
                    endTurn();
                }, 3000);
            }, 1500);
        }

        // Démarrer le jeu
        function startGame() {
            gameState.isPlaying = true;
            gameState.currentPlayer = 0;
            gameState.turn = 1;
            gameState.round = 1;
            gameState.startTime = Date.now();
            gameState.canRoll = true;
            
            initializePlayers();
            initializeBoard();
            updatePlayersDisplay();
            updatePropertiesDisplay();
            startGameTimer();
            
            document.getElementById(&#x27;startBtn&#x27;).disabled = true;
            document.getElementById(&#x27;endTurnBtn&#x27;).disabled = true;
            
            const t = translations[gameState.currentLanguage];
            const currentPlayer = gameState.players[gameState.currentPlayer];
            showMessage(`${t.gameStarted} ${currentPlayer.name}!`);
        }

        // Réinitialiser le jeu
        function resetGame() {
            gameState.isPlaying = false;
            gameState.currentPlayer = 0;
            gameState.turn = 1;
            gameState.round = 1;
            gameState.elapsedTime = 0;
            gameState.canRoll = true;
            
            if (gameState.gameTimer) {
                clearInterval(gameState.gameTimer);
            }
            
            document.getElementById(&#x27;startBtn&#x27;).disabled = false;
            document.getElementById(&#x27;endTurnBtn&#x27;).disabled = true;
            document.getElementById(&#x27;buyBtn&#x27;).disabled = true;
            
            initializePlayers();
            initializeBoard();
            updatePlayersDisplay();
            updatePropertiesDisplay();
            updateStats();
            
            const t = translations[gameState.currentLanguage];
            showMessage(t.welcomeMessage);
        }

        // Démarrer le timer du jeu
        function startGameTimer() {
            gameState.gameTimer = setInterval(() =&gt; {
                gameState.elapsedTime = Date.now() - gameState.startTime;
                updateTimeDisplay();
            }, 1000);
        }

        // Mettre à jour l&#x27;affichage du temps
        function updateTimeDisplay() {
            const seconds = Math.floor(gameState.elapsedTime / 1000);
            const minutes = Math.floor(seconds / 60);
            const displaySeconds = seconds % 60;
            
            const timeString = `${minutes.toString().padStart(2, &#x27;0&#x27;)}:${displaySeconds.toString().padStart(2, &#x27;0&#x27;)}`;
            document.getElementById(&#x27;timeValue&#x27;).textContent = timeString;
        }

        // Mettre à jour les statistiques
        function updateStats() {
            document.getElementById(&#x27;turnValue&#x27;).textContent = gameState.turn;
            document.getElementById(&#x27;roundValue&#x27;).textContent = gameState.round;
        }

        // Afficher un message
        function showMessage(message, duration = 0) {
            const messageElement = document.getElementById(&#x27;gameMessage&#x27;);
            messageElement.innerHTML = `&lt;span&gt;${message}&lt;/span&gt;`;
            
            if (duration &gt; 0) {
                setTimeout(() =&gt; {
                    const t = translations[gameState.currentLanguage];
                    messageElement.innerHTML = `&lt;span&gt;${t.welcomeMessage}&lt;/span&gt;`;
                }, duration);
            }
        }

        // Afficher les règles
        function showRules() {
            const t = translations[gameState.currentLanguage];
            alert(`${t.rulesText}:\n\n1. Lancez les dés pour vous déplacer\n2. Achetez des propriétés\n3. Collectez des loyers\n4. Construisez des maisons et hôtels\n5. Le dernier joueur non-ruiné gagne!`);
        }

        // Fonctions pour les autres actions (simplifiées)
        function buildHouse() {
            showMessage(&quot;Fonction de construction en développement...&quot;);
        }

        function tradeProperty() {
            showMessage(&quot;Fonction d&#x27;échange en développement...&quot;);
        }

        function mortgage() {
            showMessage(&quot;Fonction d&#x27;hypothèque en développement...&quot;);
        }

        // Changer le nombre de joueurs
        function setPlayerCount(count) {
            if (gameState.isPlaying) return; // Ne pas changer pendant le jeu
            
            gameState.playerCount = count;
            
            // Mettre à jour les boutons
            document.querySelectorAll(&#x27;.count-btn&#x27;).forEach(btn =&gt; {
                btn.classList.remove(&#x27;active&#x27;);
            });
            event.target.classList.add(&#x27;active&#x27;);
            
            // Réinitialiser les joueurs
            initializePlayers();
            updatePlayersDisplay();
        }

        // Afficher les informations de l&#x27;IA
        function showAIInfo() {
            const t = translations[gameState.currentLanguage];
            alert(`🤖 IA QUANTIQUE\n\nSystème d&#x27;intelligence artificielle avancé intégré au jeu.\n\n• Analyse des stratégies en temps réel\n• Prise de décision automatique\n• Adaptation au style de jeu\n• Calculs probabilistes quantiques\n\nStatut: ${gameState.isPlaying ? &#x27;ACTIF&#x27; : &#x27;EN ATTENTE&#x27;}`);
        }

        // Initialisation
        document.addEventListener(&#x27;DOMContentLoaded&#x27;, function() {
            // Initialiser les propriétés traduites
            boardProperties = getTranslatedProperties();
            
            createQuantumParticles();
            initializePlayers();
            initializeBoard();
            updatePlayersDisplay();
            updatePropertiesDisplay();
            updateStats();
        });
    &lt;/script&gt;
&lt;script&gt;(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement(&#x27;script&#x27;);d.innerHTML=&quot;window.__CF$cv$params={r:&#x27;985aaedea1985014&#x27;,t:&#x27;MTc1ODk3Mjc3NC4wMDAwMDA=&#x27;};var a=document.createElement(&#x27;script&#x27;);a.nonce=&#x27;&#x27;;a.src=&#x27;/cdn-cgi/challenge-platform/scripts/jsd/main.js&#x27;;document.getElementsByTagName(&#x27;head&#x27;)[0].appendChild(a);&quot;;b.getElementsByTagName(&#x27;head&#x27;)[0].appendChild(d)}}if(document.body){var a=document.createElement(&#x27;iframe&#x27;);a.height=1;a.width=1;a.style.position=&#x27;absolute&#x27;;a.style.top=0;a.style.left=0;a.style.border=&#x27;none&#x27;;a.style.visibility=&#x27;hidden&#x27;;document.body.appendChild(a);if(&#x27;loading&#x27;!==document.readyState)c();else if(window.addEventListener)document.addEventListener(&#x27;DOMContentLoaded&#x27;,c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);&#x27;loading&#x27;!==document.readyState&amp;&amp;(document.onreadystatechange=e,c())}}}})();&lt;/script&gt;&lt;/body&gt;
&lt;/html&gt;
" style="width:100%;height:100%;border:none;"></iframe>
</div>

<script>
function launchGame11() {
  var o=document.getElementById('game11Overlay');
  if(o) o.style.display='block';
}
function closeGame11() {
  var o=document.getElementById('game11Overlay');
  if(o) o.style.display='none';
}
document.getElementById('closeGame11Btn') && document.getElementById('closeGame11Btn').addEventListener('click', closeGame11);
document.addEventListener('keydown', function(e) {
  if(e.key==='Escape'){ var o=document.getElementById('game11Overlay'); if(o && o.style.display==='block') closeGame11(); }
}, true);
</script>


<!-- Overlay for Game 12 (injected like jeu4) -->
<div id="game12Overlay" style="display:none;position:fixed;inset:0;background:#000;z-index:99999;">
  <button onclick="closeGame12()" style="position:fixed;top:12px;right:12px;z-index:100000;background:red;color:#fff;border:none;border-radius:8px;padding:10px 12px;font-size:18px;cursor:pointer;">✖</button>
  <iframe id="iframeGame12" srcdoc="&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;fr&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Quantum Poker - Jeu de Poker Futuriste&lt;/title&gt;
    &lt;style&gt;
        body {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: &#x27;Segoe UI&#x27;, Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            color: #ffffff;
            min-height: 100vh;
            overflow-x: auto;
        }

        .quantum-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            background: radial-gradient(circle at 20% 80%, rgba(0, 255, 255, 0.3) 0%, transparent 50%),
                        radial-gradient(circle at 80% 20%, rgba(255, 0, 255, 0.3) 0%, transparent 50%),
                        radial-gradient(circle at 40% 40%, rgba(255, 215, 0, 0.2) 0%, transparent 50%);
        }

        .quantum-particle {
            position: absolute;
            width: 2px;
            height: 2px;
            background: #00ffff;
            border-radius: 50%;
            animation: float 6s ease-in-out infinite;
            box-shadow: 0 0 6px #00ffff;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px) rotate(0deg); opacity: 0.7; }
            50% { transform: translateY(-20px) rotate(180deg); opacity: 1; }
        }

        .main-container {
            max-width: 1400px;
            margin: 0 auto;
            position: relative;
            background: linear-gradient(135deg, rgba(15, 15, 35, 0.95) 0%, rgba(30, 30, 60, 0.95) 100%);
            border: 3px solid rgba(0, 255, 255, 0.4);
            border-radius: 25px;
            backdrop-filter: blur(20px);
            box-shadow: 
                0 0 50px rgba(0, 255, 255, 0.3),
                inset 0 0 50px rgba(0, 255, 255, 0.1);
            padding: 20px;
            margin: 20px auto;
            position: relative;
            overflow: hidden;
        }

        .main-container::before {
            content: &#x27;&#x27;;
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, #00ffff, #ff00ff, #ffff00, #00ffff);
            border-radius: 25px;
            z-index: -1;
            animation: borderGlow 3s linear infinite;
        }

        @keyframes borderGlow {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            background: linear-gradient(135deg, rgba(15, 15, 35, 0.95) 0%, rgba(30, 30, 60, 0.95) 100%);
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 15px;
            padding: 20px 25px;
            backdrop-filter: blur(15px);
            box-shadow: 0 8px 32px rgba(0, 255, 255, 0.2);
            position: relative;
            z-index: 10;
        }

        .game-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            background: linear-gradient(135deg, rgba(15, 15, 35, 0.95) 0%, rgba(30, 30, 60, 0.95) 100%);
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 15px;
            padding: 20px 25px;
            backdrop-filter: blur(15px);
            box-shadow: 0 8px 32px rgba(0, 255, 255, 0.2);
            position: relative;
            z-index: 1;
        }

        .game-mode-selector {
            display: flex;
            gap: 15px;
        }

        .mode-btn {
            background: linear-gradient(135deg, rgba(30, 30, 60, 0.8) 0%, rgba(60, 60, 90, 0.8) 100%);
            border: 2px solid rgba(0, 255, 255, 0.3);
            transition: all 0.3s ease;
        }

        .mode-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-color: rgba(0, 255, 255, 0.8);
            box-shadow: 0 0 20px rgba(102, 126, 234, 0.5);
        }

        .mode-btn:hover:not(.active) {
            border-color: rgba(0, 255, 255, 0.6);
            background: linear-gradient(135deg, rgba(60, 60, 90, 0.9) 0%, rgba(90, 90, 120, 0.9) 100%);
        }

        .action-controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        .game-title {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .game-title h1 {
            font-size: 28px;
            font-weight: bold;
            background: linear-gradient(135deg, #00ffff, #ff00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin: 0;
            text-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
            letter-spacing: 2px;
        }

        .game-logo {
            font-size: 32px;
            filter: drop-shadow(0 0 20px #00ffff);
            animation: pulse 3s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .language-selector {
            position: relative;
            display: inline-block;
        }

        .language-dropdown {
            background: linear-gradient(135deg, rgba(15, 15, 35, 0.95) 0%, rgba(30, 30, 60, 0.95) 100%);
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 8px;
            color: #00ffff;
            padding: 6px 10px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 255, 255, 0.2);
            display: flex;
            align-items: center;
            gap: 5px;
            font-weight: bold;
            min-width: 70px;
            justify-content: space-between;
        }

        .language-dropdown:hover {
            border-color: rgba(0, 255, 255, 0.8);
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.1) 0%, rgba(255, 0, 255, 0.1) 100%);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 255, 255, 0.3);
        }

        .language-options {
            position: absolute;
            top: 100%;
            right: 0;
            left: auto;
            min-width: 160px;
            background: linear-gradient(135deg, rgba(15, 15, 35, 0.98) 0%, rgba(30, 30, 60, 0.98) 100%);
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 15px;
            backdrop-filter: blur(15px);
            box-shadow: 0 8px 32px rgba(0, 255, 255, 0.3);
            z-index: 99999999;
            margin-top: 8px;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px);
            transition: all 0.3s ease;
        }

        .language-options.show {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .language-option {
            padding: 12px 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            color: #ffffff;
            font-weight: bold;
            border-bottom: 1px solid rgba(0, 255, 255, 0.1);
        }

        .language-option:last-child {
            border-bottom: none;
            border-radius: 0 0 13px 13px;
        }

        .language-option:first-child {
            border-radius: 13px 13px 0 0;
        }

        .language-option:hover {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.2) 0%, rgba(255, 0, 255, 0.2) 100%);
            color: #00ffff;
            transform: translateX(5px);
        }

        .language-option.active {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.3) 0%, rgba(255, 0, 255, 0.3) 100%);
            color: #00ffff;
        }

        .game-container {
            display: grid;
            grid-template-columns: 250px 1fr 250px;
            gap: 25px;
            min-height: 650px;
            margin-top: 20px;
        }

        .sidebar {
            background: linear-gradient(135deg, rgba(15, 15, 35, 0.95) 0%, rgba(30, 30, 60, 0.95) 100%);
            border: 3px solid rgba(0, 255, 255, 0.4);
            border-radius: 20px;
            padding: 20px;
            backdrop-filter: blur(15px);
            box-shadow: 
                0 10px 40px rgba(0, 255, 255, 0.2),
                inset 0 0 30px rgba(0, 255, 255, 0.05);
            height: fit-content;
            position: relative;
            overflow: hidden;
        }

        .sidebar::before {
            content: &#x27;&#x27;;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, #00ffff, #ff00ff, #00ffff, transparent);
            animation: scanLine 2s linear infinite;
        }

        @keyframes scanLine {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .poker-table {
            background: linear-gradient(135deg, rgba(15, 15, 35, 0.98) 0%, rgba(30, 30, 60, 0.98) 100%);
            border: 4px solid rgba(0, 255, 255, 0.6);
            border-radius: 50%;
            width: 600px;
            height: 400px;
            margin: 0 auto;
            position: relative;
            box-shadow: 
                0 0 60px rgba(0, 255, 255, 0.4),
                inset 0 0 40px rgba(0, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .table-center {
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.8) 0%, rgba(30, 30, 60, 0.8) 100%);
            border: 2px solid rgba(255, 215, 0, 0.5);
            border-radius: 20px;
            width: 300px;
            height: 200px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 15px;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.3);
        }

        .community-cards {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .card {
            width: 45px;
            height: 65px;
            background: linear-gradient(135deg, #ffffff 0%, #f0f0f0 100%);
            border: 2px solid #333;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            padding: 5px;
            font-weight: bold;
            font-size: 12px;
            color: #333;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
        }

        .card:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 8px 25px rgba(0, 255, 255, 0.4);
        }

        .card.red {
            color: #d63031;
        }

        .card.black {
            color: #2d3436;
        }

        .card-back {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
        }

        .pot-info {
            text-align: center;
            color: #ffd700;
            font-weight: bold;
        }

        .pot-amount {
            font-size: 24px;
            text-shadow: 0 0 10px #ffd700;
        }

        .player-seat {
            position: absolute;
            width: 120px;
            height: 80px;
            background: linear-gradient(135deg, rgba(15, 15, 35, 0.95) 0%, rgba(30, 30, 60, 0.95) 100%);
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 15px;
            padding: 10px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px rgba(0, 255, 255, 0.2);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            text-align: center;
        }

        .player-seat.active {
            border-color: #ffd700;
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.5);
        }

        .player-seat.ai {
            border-color: #ff00ff;
            box-shadow: 0 0 25px rgba(255, 0, 255, 0.3);
        }

        .player-name {
            font-weight: bold;
            color: #00ffff;
            margin-bottom: 5px;
        }

        .player-chips {
            color: #ffd700;
            font-weight: bold;
        }

        .player-cards {
            display: flex;
            gap: 5px;
            margin-top: 5px;
        }

        .player-cards .card {
            width: 25px;
            height: 35px;
            font-size: 8px;
            padding: 2px;
        }

        .seat-1 { top: -40px; left: 50%; transform: translateX(-50%); }
        .seat-2 { top: 20px; right: -60px; }
        .seat-3 { bottom: 20px; right: -60px; }
        .seat-4 { bottom: -40px; left: 50%; transform: translateX(-50%); }
        .seat-5 { bottom: 20px; left: -60px; }
        .seat-6 { top: 20px; left: -60px; }

        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 30px;
            flex-wrap: wrap;
        }

        .quantum-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            color: white;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
        }

        .quantum-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
            background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
        }

        .quantum-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .quantum-btn::before {
            content: &#x27;&#x27;;
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transition: left 0.5s ease;
        }

        .quantum-btn:hover::before {
            left: 100%;
        }

        .action-btn {
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
            color: #1a1a2e;
        }

        .action-btn:hover:not(:disabled) {
            background: linear-gradient(135deg, #ffed4e 0%, #ffd700 100%);
            box-shadow: 0 6px 20px rgba(255, 215, 0, 0.6);
        }

        .danger-btn {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
        }

        .danger-btn:hover:not(:disabled) {
            background: linear-gradient(135deg, #ee5a24 0%, #ff6b6b 100%);
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.6);
        }

        .section-title {
            font-size: 18px;
            font-weight: bold;
            color: #00ffff;
            margin-bottom: 15px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 2px;
            position: relative;
            z-index: 10;
        }

        .player-info {
            background: rgba(30, 30, 60, 0.8);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            backdrop-filter: blur(5px);
            transition: all 0.3s ease;
            position: relative;
            z-index: 10;
        }

        .player-info:hover {
            border-color: rgba(0, 255, 255, 0.6);
            background: rgba(30, 30, 60, 0.9);
        }

        .player-info.current-player {
            border-color: #ffd700;
            background: rgba(255, 215, 0, 0.1);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .stat-value {
            font-weight: bold;
            color: #ffffff;
        }

        .bet-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 20px;
        }

        .bet-slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
        }

        .bet-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #00ffff, #ff00ff);
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        .bet-amount {
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            color: #ffd700;
            margin: 10px 0;
        }

        .game-message {
            background: rgba(15, 15, 35, 0.9);
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 15px;
            padding: 15px;
            text-align: center;
            font-size: 16px;
            font-weight: bold;
            color: #00ffff;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            margin-bottom: 20px;
        }

        .hand-strength {
            background: linear-gradient(135deg, rgba(0, 255, 0, 0.2) 0%, rgba(255, 215, 0, 0.2) 100%);
            border: 1px solid rgba(0, 255, 0, 0.5);
            border-radius: 10px;
            padding: 10px;
            text-align: center;
            margin-top: 15px;
        }

        .ai-thinking {
            animation: thinking 2s ease-in-out infinite;
        }

        @keyframes thinking {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }

        @media (max-width: 1200px) {
            .game-container {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .poker-table {
                width: 500px;
                height: 350px;
            }
            
            .sidebar {
                order: 2;
            }
        }

        @media (max-width: 600px) {
            .poker-table {
                width: 400px;
                height: 300px;
            }
            
            .game-title h1 {
                font-size: 20px;
            }
            
            .controls {
                gap: 10px;
            }
            
            .quantum-btn {
                padding: 10px 20px;
                font-size: 12px;
            }
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;quantum-bg&quot;&gt;&lt;/div&gt;
    
    &lt;div class=&quot;main-container&quot;&gt;
        &lt;!-- En-tête du jeu --&gt;
        &lt;div class=&quot;game-header&quot;&gt;
            &lt;div class=&quot;game-title&quot;&gt;
                &lt;div class=&quot;game-logo&quot;&gt;🃏&lt;/div&gt;
                &lt;h1 id=&quot;gameTitle&quot;&gt;QUANTUM POKER&lt;/h1&gt;
            &lt;/div&gt;
            
            &lt;div class=&quot;language-selector&quot;&gt;
                &lt;div class=&quot;language-dropdown&quot; onclick=&quot;toggleLanguageDropdown()&quot;&gt;
                    &lt;span id=&quot;currentLanguage&quot;&gt;🇫🇷 FR&lt;/span&gt;
                    &lt;span style=&quot;font-size: 10px;&quot;&gt;▼&lt;/span&gt;
                &lt;/div&gt;
                &lt;div class=&quot;language-options&quot; id=&quot;languageOptions&quot;&gt;
                    &lt;div class=&quot;language-option active&quot; onclick=&quot;selectLanguage(&#x27;fr&#x27;, &#x27;🇫🇷 FR&#x27;)&quot;&gt;🇫🇷 Français&lt;/div&gt;
                    &lt;div class=&quot;language-option&quot; onclick=&quot;selectLanguage(&#x27;en&#x27;, &#x27;🇬🇧 EN&#x27;)&quot;&gt;🇬🇧 English&lt;/div&gt;
                    &lt;div class=&quot;language-option&quot; onclick=&quot;selectLanguage(&#x27;es&#x27;, &#x27;🇪🇸 ES&#x27;)&quot;&gt;🇪🇸 Español&lt;/div&gt;
                    &lt;div class=&quot;language-option&quot; onclick=&quot;selectLanguage(&#x27;ar&#x27;, &#x27;🇸🇦 AR&#x27;)&quot;&gt;🇸🇦 العربية&lt;/div&gt;
                    &lt;div class=&quot;language-option&quot; onclick=&quot;selectLanguage(&#x27;de&#x27;, &#x27;🇩🇪 DE&#x27;)&quot;&gt;🇩🇪 Deutsch&lt;/div&gt;
                    &lt;div class=&quot;language-option&quot; onclick=&quot;selectLanguage(&#x27;zh&#x27;, &#x27;🇨🇳 ZH&#x27;)&quot;&gt;🇨🇳 中文&lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;

        &lt;/div&gt;

        &lt;!-- Bloc de contrôles de jeu --&gt;
        &lt;div class=&quot;game-controls&quot;&gt;
            &lt;div class=&quot;action-controls&quot;&gt;
                &lt;button class=&quot;quantum-btn&quot; onclick=&quot;newGame()&quot;&gt;🚀 &lt;span id=&quot;newGameBtn&quot;&gt;Nouvelle Partie&lt;/span&gt;&lt;/button&gt;
                &lt;button class=&quot;quantum-btn action-btn&quot; id=&quot;callBtn&quot; onclick=&quot;callBet()&quot; disabled&gt;📞 &lt;span id=&quot;callBtnText&quot;&gt;Suivre&lt;/span&gt;&lt;/button&gt;
                &lt;button class=&quot;quantum-btn action-btn&quot; id=&quot;raiseBtn&quot; onclick=&quot;raiseBet()&quot; disabled&gt;⬆️ &lt;span id=&quot;raiseBtnText&quot;&gt;Relancer&lt;/span&gt;&lt;/button&gt;
                &lt;button class=&quot;quantum-btn danger-btn&quot; id=&quot;foldBtn&quot; onclick=&quot;foldHand()&quot; disabled&gt;❌ &lt;span id=&quot;foldBtnText&quot;&gt;Se Coucher&lt;/span&gt;&lt;/button&gt;
                &lt;button class=&quot;quantum-btn&quot; onclick=&quot;showRules()&quot;&gt;📋 &lt;span id=&quot;rulesBtn&quot;&gt;Règles&lt;/span&gt;&lt;/button&gt;
            &lt;/div&gt;
        &lt;/div&gt;

        &lt;div class=&quot;game-container&quot;&gt;
            &lt;!-- Sidebar gauche - Joueurs --&gt;
            &lt;div class=&quot;sidebar&quot;&gt;
                &lt;div class=&quot;section-title&quot; id=&quot;gameModeTitle&quot;&gt;🎮 Mode de Jeu&lt;/div&gt;
                &lt;div class=&quot;game-mode-selector&quot; style=&quot;margin-bottom: 20px; justify-content: center;&quot;&gt;
                    &lt;button class=&quot;quantum-btn mode-btn active&quot; id=&quot;aiModeBtn&quot; onclick=&quot;selectGameMode(&#x27;ai&#x27;)&quot; style=&quot;font-size: 12px; padding: 8px 16px;&quot;&gt;
                        🤖 &lt;span id=&quot;aiModeText&quot;&gt;IA&lt;/span&gt;
                    &lt;/button&gt;
                    &lt;button class=&quot;quantum-btn mode-btn&quot; id=&quot;humanModeBtn&quot; onclick=&quot;selectGameMode(&#x27;human&#x27;)&quot; style=&quot;font-size: 12px; padding: 8px 16px;&quot;&gt;
                        👥 &lt;span id=&quot;humanModeText&quot;&gt;4J&lt;/span&gt;
                    &lt;/button&gt;
                &lt;/div&gt;
                
                &lt;div class=&quot;section-title&quot; id=&quot;playersTitle&quot;&gt;👥 Joueurs&lt;/div&gt;
                &lt;div id=&quot;playersContainer&quot;&gt;&lt;/div&gt;
                
                &lt;div class=&quot;section-title&quot; id=&quot;gameStatsTitle&quot; style=&quot;margin-top: 30px;&quot;&gt;📊 Statistiques&lt;/div&gt;
                &lt;div class=&quot;player-info&quot;&gt;
                    &lt;div class=&quot;stat-item&quot;&gt;
                        &lt;span id=&quot;handLabel&quot;&gt;Main:&lt;/span&gt;
                        &lt;span class=&quot;stat-value&quot; id=&quot;handValue&quot;&gt;1&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;stat-item&quot;&gt;
                        &lt;span id=&quot;roundLabel&quot;&gt;Manche:&lt;/span&gt;
                        &lt;span class=&quot;stat-value&quot; id=&quot;roundValue&quot;&gt;Pré-Flop&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;stat-item&quot;&gt;
                        &lt;span id=&quot;potLabel&quot;&gt;Pot:&lt;/span&gt;
                        &lt;span class=&quot;stat-value&quot; id=&quot;potValue&quot;&gt;₹0&lt;/span&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;!-- Table de poker principale --&gt;
            &lt;div class=&quot;main-board&quot;&gt;
                &lt;div class=&quot;game-message&quot; id=&quot;gameMessage&quot;&gt;
                    &lt;span&gt;Bienvenue au Quantum Poker! Cliquez sur &quot;Nouvelle Partie&quot; pour commencer.&lt;/span&gt;
                &lt;/div&gt;

                &lt;div class=&quot;poker-table&quot;&gt;
                    &lt;div class=&quot;table-center&quot;&gt;
                        &lt;div class=&quot;community-cards&quot; id=&quot;communityCards&quot;&gt;
                            &lt;div class=&quot;card card-back&quot;&gt;🃏&lt;/div&gt;
                            &lt;div class=&quot;card card-back&quot;&gt;🃏&lt;/div&gt;
                            &lt;div class=&quot;card card-back&quot;&gt;🃏&lt;/div&gt;
                            &lt;div class=&quot;card card-back&quot;&gt;🃏&lt;/div&gt;
                            &lt;div class=&quot;card card-back&quot;&gt;🃏&lt;/div&gt;
                        &lt;/div&gt;
                        &lt;div class=&quot;pot-info&quot;&gt;
                            &lt;div id=&quot;potLabel2&quot;&gt;POT&lt;/div&gt;
                            &lt;div class=&quot;pot-amount&quot; id=&quot;potAmount&quot;&gt;₹0&lt;/div&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                    
                    &lt;!-- Sièges des joueurs --&gt;
                    &lt;div class=&quot;player-seat seat-1&quot; id=&quot;seat1&quot;&gt;
                        &lt;div class=&quot;player-name&quot;&gt;Joueur 1&lt;/div&gt;
                        &lt;div class=&quot;player-chips&quot;&gt;₹1000&lt;/div&gt;
                        &lt;div class=&quot;player-cards&quot;&gt;
                            &lt;div class=&quot;card card-back&quot;&gt;🃏&lt;/div&gt;
                            &lt;div class=&quot;card card-back&quot;&gt;🃏&lt;/div&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                    
                    &lt;div class=&quot;player-seat seat-2 ai&quot; id=&quot;seat2&quot;&gt;
                        &lt;div class=&quot;player-name&quot;&gt;IA Alpha 🤖&lt;/div&gt;
                        &lt;div class=&quot;player-chips&quot;&gt;₹1000&lt;/div&gt;
                        &lt;div class=&quot;player-cards&quot;&gt;
                            &lt;div class=&quot;card card-back&quot;&gt;🃏&lt;/div&gt;
                            &lt;div class=&quot;card card-back&quot;&gt;🃏&lt;/div&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                    
                    &lt;div class=&quot;player-seat seat-3&quot; id=&quot;seat3&quot; style=&quot;display: none;&quot;&gt;
                        &lt;div class=&quot;player-name&quot;&gt;Joueur 3&lt;/div&gt;
                        &lt;div class=&quot;player-chips&quot;&gt;₹1000&lt;/div&gt;
                        &lt;div class=&quot;player-cards&quot;&gt;
                            &lt;div class=&quot;card card-back&quot;&gt;🃏&lt;/div&gt;
                            &lt;div class=&quot;card card-back&quot;&gt;🃏&lt;/div&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                    
                    &lt;div class=&quot;player-seat seat-4&quot; id=&quot;seat4&quot; style=&quot;display: none;&quot;&gt;
                        &lt;div class=&quot;player-name&quot;&gt;Joueur 4&lt;/div&gt;
                        &lt;div class=&quot;player-chips&quot;&gt;₹1000&lt;/div&gt;
                        &lt;div class=&quot;player-cards&quot;&gt;
                            &lt;div class=&quot;card card-back&quot;&gt;🃏&lt;/div&gt;
                            &lt;div class=&quot;card card-back&quot;&gt;🃏&lt;/div&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                &lt;/div&gt;


            &lt;/div&gt;

            &lt;!-- Sidebar droite - Actions et IA --&gt;
            &lt;div class=&quot;sidebar&quot;&gt;
                &lt;div class=&quot;section-title&quot; id=&quot;aiTitle&quot;&gt;🤖 IA Quantique&lt;/div&gt;
                &lt;div class=&quot;player-info&quot;&gt;
                    &lt;div style=&quot;color: #00ffff; font-size: 12px; text-align: center; line-height: 1.4;&quot; id=&quot;aiStatusText&quot;&gt;
                        Système IA initialisé&lt;br&gt;
                        Analyse des probabilités...
                    &lt;/div&gt;
                &lt;/div&gt;
                
                &lt;div class=&quot;section-title&quot; id=&quot;yourCardsTitle&quot; style=&quot;margin-top: 30px;&quot;&gt;🃏 Vos Cartes&lt;/div&gt;
                &lt;div style=&quot;display: flex; justify-content: center; gap: 10px; margin-bottom: 20px;&quot; id=&quot;playerCards&quot;&gt;
                    &lt;div class=&quot;card card-back&quot;&gt;🃏&lt;/div&gt;
                    &lt;div class=&quot;card card-back&quot;&gt;🃏&lt;/div&gt;
                &lt;/div&gt;
                
                &lt;div class=&quot;hand-strength&quot; id=&quot;handStrength&quot;&gt;
                    &lt;div style=&quot;font-weight: bold; color: #00ff00;&quot;&gt;Force de la main&lt;/div&gt;
                    &lt;div id=&quot;handStrengthValue&quot;&gt;En attente...&lt;/div&gt;
                &lt;/div&gt;
                
                &lt;div class=&quot;section-title&quot; id=&quot;betTitle&quot; style=&quot;margin-top: 30px;&quot;&gt;💰 Mise&lt;/div&gt;
                &lt;div class=&quot;bet-controls&quot;&gt;
                    &lt;input type=&quot;range&quot; class=&quot;bet-slider&quot; id=&quot;betSlider&quot; min=&quot;0&quot; max=&quot;1000&quot; value=&quot;0&quot; oninput=&quot;updateBetAmount()&quot;&gt;
                    &lt;div class=&quot;bet-amount&quot; id=&quot;betAmount&quot;&gt;₹0&lt;/div&gt;
                    &lt;button class=&quot;quantum-btn action-btn&quot; id=&quot;betBtn&quot; onclick=&quot;placeBet()&quot; disabled&gt;💰 &lt;span id=&quot;betBtnText&quot;&gt;Miser&lt;/span&gt;&lt;/button&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;script&gt;
        // État du jeu
    var gameState = {
            isPlaying: false,
            currentPlayer: 0,
            players: [],
            deck: [],
            communityCards: [],
            pot: 0,
            currentBet: 0,
            round: &#x27;preflop&#x27;, // preflop, flop, turn, river
            handNumber: 1,
            currentLanguage: &#x27;fr&#x27;,
            playerCards: [],
            betAmount: 0,
            gameMode: &#x27;ai&#x27; // &#x27;ai&#x27; ou &#x27;human&#x27;
        };

        // Traductions
        const translations = {
            fr: {
                gameTitle: &#x27;QUANTUM POKER&#x27;,
                gameModeTitle: &#x27;🎮 Mode de Jeu&#x27;,
                playersTitle: &#x27;👥 Joueurs&#x27;,
                gameStatsTitle: &#x27;📊 Statistiques&#x27;,
                aiTitle: &#x27;🤖 IA Quantique&#x27;,
                yourCardsTitle: &#x27;🃏 Vos Cartes&#x27;,
                betTitle: &#x27;💰 Mise&#x27;,
                welcomeMessage: &#x27;Bienvenue au Quantum Poker! Cliquez sur &quot;Nouvelle Partie&quot; pour commencer.&#x27;,
                gameStarted: &#x27;Nouvelle partie commencée! À vous de jouer.&#x27;,
                handLabel: &#x27;Main&#x27;,
                roundLabel: &#x27;Manche&#x27;,
                potLabel: &#x27;Pot&#x27;,
                newGameBtn: &#x27;Nouvelle Partie&#x27;,
                callBtnText: &#x27;Suivre&#x27;,
                raiseBtnText: &#x27;Relancer&#x27;,
                foldBtnText: &#x27;Se Coucher&#x27;,
                rulesBtn: &#x27;Règles&#x27;,
                betBtnText: &#x27;Miser&#x27;,
                aiModeText: &#x27;IA&#x27;,
                humanModeText: &#x27;4J&#x27;,
                aiStatus: &#x27;Système IA initialisé\nAnalyse des probabilités...&#x27;,
                handStrengthWaiting: &#x27;En attente...&#x27;,
                chipsLabel: &#x27;Jetons&#x27;,
                betLabel: &#x27;Mise&#x27;,
                statusLabel: &#x27;Statut&#x27;,
                playerName: &#x27;Joueur&#x27;,
                aiName: &#x27;IA Alpha 🤖&#x27;,
                rounds: {
                    preflop: &#x27;Pré-Flop&#x27;,
                    flop: &#x27;Flop&#x27;,
                    turn: &#x27;Turn&#x27;,
                    river: &#x27;River&#x27;
                },
                actions: {
                    call: &#x27;suit&#x27;,
                    raise: &#x27;relance&#x27;,
                    fold: &#x27;se couche&#x27;,
                    bet: &#x27;mise&#x27;
                }
            },
            en: {
                gameTitle: &#x27;QUANTUM POKER&#x27;,
                gameModeTitle: &#x27;🎮 Game Mode&#x27;,
                playersTitle: &#x27;👥 Players&#x27;,
                gameStatsTitle: &#x27;📊 Statistics&#x27;,
                aiTitle: &#x27;🤖 Quantum AI&#x27;,
                yourCardsTitle: &#x27;🃏 Your Cards&#x27;,
                betTitle: &#x27;💰 Bet&#x27;,
                welcomeMessage: &#x27;Welcome to Quantum Poker! Click &quot;New Game&quot; to start.&#x27;,
                gameStarted: &#x27;New game started! Your turn to play.&#x27;,
                handLabel: &#x27;Hand&#x27;,
                roundLabel: &#x27;Round&#x27;,
                potLabel: &#x27;Pot&#x27;,
                newGameBtn: &#x27;New Game&#x27;,
                callBtnText: &#x27;Call&#x27;,
                raiseBtnText: &#x27;Raise&#x27;,
                foldBtnText: &#x27;Fold&#x27;,
                rulesBtn: &#x27;Rules&#x27;,
                betBtnText: &#x27;Bet&#x27;,
                aiModeText: &#x27;AI&#x27;,
                humanModeText: &#x27;4P&#x27;,
                aiStatus: &#x27;AI System initialized\nProbability analysis...&#x27;,
                handStrengthWaiting: &#x27;Waiting...&#x27;,
                chipsLabel: &#x27;Chips&#x27;,
                betLabel: &#x27;Bet&#x27;,
                statusLabel: &#x27;Status&#x27;,
                playerName: &#x27;Player&#x27;,
                aiName: &#x27;AI Alpha 🤖&#x27;,
                rounds: {
                    preflop: &#x27;Pre-Flop&#x27;,
                    flop: &#x27;Flop&#x27;,
                    turn: &#x27;Turn&#x27;,
                    river: &#x27;River&#x27;
                },
                actions: {
                    call: &#x27;calls&#x27;,
                    raise: &#x27;raises&#x27;,
                    fold: &#x27;folds&#x27;,
                    bet: &#x27;bets&#x27;
                }
            },
            es: {
                gameTitle: &#x27;QUANTUM POKER&#x27;,
                gameModeTitle: &#x27;🎮 Modo de Juego&#x27;,
                playersTitle: &#x27;👥 Jugadores&#x27;,
                gameStatsTitle: &#x27;📊 Estadísticas&#x27;,
                aiTitle: &#x27;🤖 IA Cuántica&#x27;,
                yourCardsTitle: &#x27;🃏 Tus Cartas&#x27;,
                betTitle: &#x27;💰 Apuesta&#x27;,
                welcomeMessage: &#x27;¡Bienvenido al Quantum Poker! Haz clic en &quot;Nueva Partida&quot; para empezar.&#x27;,
                gameStarted: &#x27;¡Nueva partida iniciada! Tu turno para jugar.&#x27;,
                handLabel: &#x27;Mano&#x27;,
                roundLabel: &#x27;Ronda&#x27;,
                potLabel: &#x27;Bote&#x27;,
                newGameBtn: &#x27;Nueva Partida&#x27;,
                callBtnText: &#x27;Igualar&#x27;,
                raiseBtnText: &#x27;Subir&#x27;,
                foldBtnText: &#x27;Retirarse&#x27;,
                rulesBtn: &#x27;Reglas&#x27;,
                betBtnText: &#x27;Apostar&#x27;,
                aiModeText: &#x27;IA&#x27;,
                humanModeText: &#x27;4J&#x27;,
                aiStatus: &#x27;Sistema IA inicializado\nAnálisis de probabilidades...&#x27;,
                handStrengthWaiting: &#x27;Esperando...&#x27;,
                chipsLabel: &#x27;Fichas&#x27;,
                betLabel: &#x27;Apuesta&#x27;,
                statusLabel: &#x27;Estado&#x27;,
                playerName: &#x27;Jugador&#x27;,
                aiName: &#x27;IA Alpha 🤖&#x27;,
                rounds: {
                    preflop: &#x27;Pre-Flop&#x27;,
                    flop: &#x27;Flop&#x27;,
                    turn: &#x27;Turn&#x27;,
                    river: &#x27;River&#x27;
                },
                actions: {
                    call: &#x27;iguala&#x27;,
                    raise: &#x27;sube&#x27;,
                    fold: &#x27;se retira&#x27;,
                    bet: &#x27;apuesta&#x27;
                }
            },
            ar: {
                gameTitle: &#x27;بوكر كمومي&#x27;,
                gameModeTitle: &#x27;🎮 نمط اللعب&#x27;,
                playersTitle: &#x27;👥 اللاعبون&#x27;,
                gameStatsTitle: &#x27;📊 الإحصائيات&#x27;,
                aiTitle: &#x27;🤖 الذكاء الكمومي&#x27;,
                yourCardsTitle: &#x27;🃏 أوراقك&#x27;,
                betTitle: &#x27;💰 الرهان&#x27;,
                welcomeMessage: &#x27;مرحباً بك في البوكر الكمومي! اضغط على &quot;لعبة جديدة&quot; للبدء.&#x27;,
                gameStarted: &#x27;بدأت لعبة جديدة! دورك للعب.&#x27;,
                handLabel: &#x27;اليد&#x27;,
                roundLabel: &#x27;الجولة&#x27;,
                potLabel: &#x27;الوعاء&#x27;,
                newGameBtn: &#x27;لعبة جديدة&#x27;,
                callBtnText: &#x27;متابعة&#x27;,
                raiseBtnText: &#x27;رفع&#x27;,
                foldBtnText: &#x27;انسحاب&#x27;,
                rulesBtn: &#x27;القواعد&#x27;,
                betBtnText: &#x27;رهان&#x27;,
                aiModeText: &#x27;ذكي&#x27;,
                humanModeText: &#x27;4ل&#x27;,
                aiStatus: &#x27;تم تهيئة نظام الذكاء الاصطناعي\nتحليل الاحتماليات...&#x27;,
                handStrengthWaiting: &#x27;في الانتظار...&#x27;,
                chipsLabel: &#x27;رقائق&#x27;,
                betLabel: &#x27;رهان&#x27;,
                statusLabel: &#x27;الحالة&#x27;,
                playerName: &#x27;لاعب&#x27;,
                aiName: &#x27;ذكاء ألفا 🤖&#x27;,
                rounds: {
                    preflop: &#x27;ما قبل الفلوب&#x27;,
                    flop: &#x27;الفلوب&#x27;,
                    turn: &#x27;التيرن&#x27;,
                    river: &#x27;الريفر&#x27;
                },
                actions: {
                    call: &#x27;يتابع&#x27;,
                    raise: &#x27;يرفع&#x27;,
                    fold: &#x27;ينسحب&#x27;,
                    bet: &#x27;يراهن&#x27;
                }
            },
            de: {
                gameTitle: &#x27;QUANTUM POKER&#x27;,
                gameModeTitle: &#x27;🎮 Spielmodus&#x27;,
                playersTitle: &#x27;👥 Spieler&#x27;,
                gameStatsTitle: &#x27;📊 Statistiken&#x27;,
                aiTitle: &#x27;🤖 Quanten-KI&#x27;,
                yourCardsTitle: &#x27;🃏 Ihre Karten&#x27;,
                betTitle: &#x27;💰 Einsatz&#x27;,
                welcomeMessage: &#x27;Willkommen bei Quantum Poker! Klicken Sie auf &quot;Neues Spiel&quot; um zu beginnen.&#x27;,
                gameStarted: &#x27;Neues Spiel gestartet! Sie sind dran.&#x27;,
                handLabel: &#x27;Hand&#x27;,
                roundLabel: &#x27;Runde&#x27;,
                potLabel: &#x27;Pot&#x27;,
                newGameBtn: &#x27;Neues Spiel&#x27;,
                callBtnText: &#x27;Mitgehen&#x27;,
                raiseBtnText: &#x27;Erhöhen&#x27;,
                foldBtnText: &#x27;Passen&#x27;,
                rulesBtn: &#x27;Regeln&#x27;,
                betBtnText: &#x27;Setzen&#x27;,
                aiModeText: &#x27;KI&#x27;,
                humanModeText: &#x27;4S&#x27;,
                aiStatus: &#x27;KI-System initialisiert\nWahrscheinlichkeitsanalyse...&#x27;,
                handStrengthWaiting: &#x27;Warten...&#x27;,
                chipsLabel: &#x27;Chips&#x27;,
                betLabel: &#x27;Einsatz&#x27;,
                statusLabel: &#x27;Status&#x27;,
                playerName: &#x27;Spieler&#x27;,
                aiName: &#x27;KI Alpha 🤖&#x27;,
                rounds: {
                    preflop: &#x27;Pre-Flop&#x27;,
                    flop: &#x27;Flop&#x27;,
                    turn: &#x27;Turn&#x27;,
                    river: &#x27;River&#x27;
                },
                actions: {
                    call: &#x27;geht mit&#x27;,
                    raise: &#x27;erhöht&#x27;,
                    fold: &#x27;passt&#x27;,
                    bet: &#x27;setzt&#x27;
                }
            },
            zh: {
                gameTitle: &#x27;量子扑克&#x27;,
                gameModeTitle: &#x27;🎮 游戏模式&#x27;,
                playersTitle: &#x27;👥 玩家&#x27;,
                gameStatsTitle: &#x27;📊 统计&#x27;,
                aiTitle: &#x27;🤖 量子AI&#x27;,
                yourCardsTitle: &#x27;🃏 您的牌&#x27;,
                betTitle: &#x27;💰 下注&#x27;,
                welcomeMessage: &#x27;欢迎来到量子扑克！点击&quot;新游戏&quot;开始。&#x27;,
                gameStarted: &#x27;新游戏开始！轮到您了。&#x27;,
                handLabel: &#x27;手牌&#x27;,
                roundLabel: &#x27;回合&#x27;,
                potLabel: &#x27;底池&#x27;,
                newGameBtn: &#x27;新游戏&#x27;,
                callBtnText: &#x27;跟注&#x27;,
                raiseBtnText: &#x27;加注&#x27;,
                foldBtnText: &#x27;弃牌&#x27;,
                rulesBtn: &#x27;规则&#x27;,
                betBtnText: &#x27;下注&#x27;,
                aiModeText: &#x27;AI&#x27;,
                humanModeText: &#x27;4人&#x27;,
                aiStatus: &#x27;AI系统已初始化\n概率分析中...&#x27;,
                handStrengthWaiting: &#x27;等待中...&#x27;,
                chipsLabel: &#x27;筹码&#x27;,
                betLabel: &#x27;下注&#x27;,
                statusLabel: &#x27;状态&#x27;,
                playerName: &#x27;玩家&#x27;,
                aiName: &#x27;AI阿尔法 🤖&#x27;,
                rounds: {
                    preflop: &#x27;翻牌前&#x27;,
                    flop: &#x27;翻牌&#x27;,
                    turn: &#x27;转牌&#x27;,
                    river: &#x27;河牌&#x27;
                },
                actions: {
                    call: &#x27;跟注&#x27;,
                    raise: &#x27;加注&#x27;,
                    fold: &#x27;弃牌&#x27;,
                    bet: &#x27;下注&#x27;
                }
            }
        };

        // Créer un jeu de cartes
        function createDeck() {
            const suits = [&#x27;♠&#x27;, &#x27;♥&#x27;, &#x27;♦&#x27;, &#x27;♣&#x27;];
            const ranks = [&#x27;A&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;10&#x27;, &#x27;J&#x27;, &#x27;Q&#x27;, &#x27;K&#x27;];
            const deck = [];
            
            for (let suit of suits) {
                for (let rank of ranks) {
                    deck.push({
                        rank: rank,
                        suit: suit,
                        color: (suit === &#x27;♥&#x27; || suit === &#x27;♦&#x27;) ? &#x27;red&#x27; : &#x27;black&#x27;
                    });
                }
            }
            
            return shuffleDeck(deck);
        }

        // Mélanger le jeu
        function shuffleDeck(deck) {
            for (let i = deck.length - 1; i &gt; 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
            return deck;
        }

        // Créer les particules quantiques
        function createQuantumParticles() {
            const bg = document.querySelector(&#x27;.quantum-bg&#x27;);
            for (let i = 0; i &lt; 50; i++) {
                const particle = document.createElement(&#x27;div&#x27;);
                particle.className = &#x27;quantum-particle&#x27;;
                particle.style.left = Math.random() * 100 + &#x27;%&#x27;;
                particle.style.top = Math.random() * 100 + &#x27;%&#x27;;
                particle.style.animationDelay = Math.random() * 6 + &#x27;s&#x27;;
                particle.style.animationDuration = (Math.random() * 4 + 4) + &#x27;s&#x27;;
                bg.appendChild(particle);
            }
        }

        // Basculer le dropdown de langue
        function toggleLanguageDropdown() {
            const options = document.getElementById(&#x27;languageOptions&#x27;);
            options.classList.toggle(&#x27;show&#x27;);
            
            document.addEventListener(&#x27;click&#x27;, function closeDropdown(e) {
                if (!e.target.closest(&#x27;.language-selector&#x27;)) {
                    options.classList.remove(&#x27;show&#x27;);
                    document.removeEventListener(&#x27;click&#x27;, closeDropdown);
                }
            });
        }

        // Sélectionner une langue
        function selectLanguage(langCode, langText) {
            gameState.currentLanguage = langCode;
            
            document.getElementById(&#x27;currentLanguage&#x27;).textContent = langText;
            
            document.querySelectorAll(&#x27;.language-option&#x27;).forEach(option =&gt; {
                option.classList.remove(&#x27;active&#x27;);
            });
            event.target.classList.add(&#x27;active&#x27;);
            
            document.getElementById(&#x27;languageOptions&#x27;).classList.remove(&#x27;show&#x27;);
            
            updateLanguageInterface();
        }

        // Sélectionner le mode de jeu
        function selectGameMode(mode) {
            gameState.gameMode = mode;
            
            // Mettre à jour les boutons
            document.querySelectorAll(&#x27;.mode-btn&#x27;).forEach(btn =&gt; btn.classList.remove(&#x27;active&#x27;));
            if (mode === &#x27;ai&#x27;) {
                document.getElementById(&#x27;aiModeBtn&#x27;).classList.add(&#x27;active&#x27;);
            } else {
                document.getElementById(&#x27;humanModeBtn&#x27;).classList.add(&#x27;active&#x27;);
            }
            
            // Afficher/masquer les sièges selon le mode
            if (mode === &#x27;ai&#x27;) {
                // Mode IA : 1 joueur humain + 1 IA
                document.getElementById(&#x27;seat1&#x27;).style.display = &#x27;block&#x27;;
                document.getElementById(&#x27;seat2&#x27;).style.display = &#x27;block&#x27;;
                document.getElementById(&#x27;seat3&#x27;).style.display = &#x27;none&#x27;;
                document.getElementById(&#x27;seat4&#x27;).style.display = &#x27;none&#x27;;
                
                // Mettre à jour les noms
                document.querySelector(&#x27;#seat2 .player-name&#x27;).textContent = &#x27;IA Alpha 🤖&#x27;;
                document.getElementById(&#x27;seat2&#x27;).classList.add(&#x27;ai&#x27;);
            } else {
                // Mode 4 joueurs humains
                document.getElementById(&#x27;seat1&#x27;).style.display = &#x27;block&#x27;;
                document.getElementById(&#x27;seat2&#x27;).style.display = &#x27;block&#x27;;
                document.getElementById(&#x27;seat3&#x27;).style.display = &#x27;block&#x27;;
                document.getElementById(&#x27;seat4&#x27;).style.display = &#x27;block&#x27;;
                
                // Mettre à jour les noms
                document.querySelector(&#x27;#seat2 .player-name&#x27;).textContent = &#x27;Joueur 2&#x27;;
                document.getElementById(&#x27;seat2&#x27;).classList.remove(&#x27;ai&#x27;);
            }
            
            // Réinitialiser le jeu si en cours
            if (gameState.isPlaying) {
                newGame();
            }
        }

        // Mettre à jour l&#x27;interface selon la langue
        function updateLanguageInterface() {
            const t = translations[gameState.currentLanguage];
            
            document.getElementById(&#x27;gameTitle&#x27;).textContent = t.gameTitle;
            document.getElementById(&#x27;gameModeTitle&#x27;).textContent = t.gameModeTitle;
            document.getElementById(&#x27;playersTitle&#x27;).textContent = t.playersTitle;
            document.getElementById(&#x27;gameStatsTitle&#x27;).textContent = t.gameStatsTitle;
            document.getElementById(&#x27;aiTitle&#x27;).textContent = t.aiTitle;
            document.getElementById(&#x27;yourCardsTitle&#x27;).textContent = t.yourCardsTitle;
            document.getElementById(&#x27;betTitle&#x27;).textContent = t.betTitle;
            
            document.getElementById(&#x27;handLabel&#x27;).textContent = t.handLabel + &#x27;:&#x27;;
            document.getElementById(&#x27;roundLabel&#x27;).textContent = t.roundLabel + &#x27;:&#x27;;
            document.getElementById(&#x27;potLabel&#x27;).textContent = t.potLabel + &#x27;:&#x27;;
            
            document.getElementById(&#x27;newGameBtn&#x27;).textContent = t.newGameBtn;
            document.getElementById(&#x27;callBtnText&#x27;).textContent = t.callBtnText;
            document.getElementById(&#x27;raiseBtnText&#x27;).textContent = t.raiseBtnText;
            document.getElementById(&#x27;foldBtnText&#x27;).textContent = t.foldBtnText;
            document.getElementById(&#x27;rulesBtn&#x27;).textContent = t.rulesBtn;
            document.getElementById(&#x27;betBtnText&#x27;).textContent = t.betBtnText;
            document.getElementById(&#x27;aiModeText&#x27;).textContent = t.aiModeText;
            document.getElementById(&#x27;humanModeText&#x27;).textContent = t.humanModeText;
            
            document.getElementById(&#x27;aiStatusText&#x27;).innerHTML = t.aiStatus.replace(&#x27;\n&#x27;, &#x27;&lt;br&gt;&#x27;);
            document.getElementById(&#x27;handStrengthValue&#x27;).textContent = t.handStrengthWaiting;
            
            if (!gameState.isPlaying) {
                document.getElementById(&#x27;gameMessage&#x27;).innerHTML = `&lt;span&gt;${t.welcomeMessage}&lt;/span&gt;`;
            }
            
            updateRoundDisplay();
        }

        // Initialiser les joueurs
        function initializePlayers() {
            const t = translations[gameState.currentLanguage];
            
            if (gameState.gameMode === &#x27;ai&#x27;) {
                // Mode IA : 1 joueur humain + 1 IA
                gameState.players = [
                    { id: 0, name: `${t.playerName} 1`, chips: 1000, cards: [], isAI: false, folded: false, currentBet: 0 },
                    { id: 1, name: t.aiName, chips: 1000, cards: [], isAI: true, folded: false, currentBet: 0 }
                ];
            } else {
                // Mode 4 joueurs humains
                gameState.players = [
                    { id: 0, name: `${t.playerName} 1`, chips: 1000, cards: [], isAI: false, folded: false, currentBet: 0 },
                    { id: 1, name: `${t.playerName} 2`, chips: 1000, cards: [], isAI: false, folded: false, currentBet: 0 },
                    { id: 2, name: `${t.playerName} 3`, chips: 1000, cards: [], isAI: false, folded: false, currentBet: 0 },
                    { id: 3, name: `${t.playerName} 4`, chips: 1000, cards: [], isAI: false, folded: false, currentBet: 0 }
                ];
            }
        }

        // Nouvelle partie
        function newGame() {
            gameState.isPlaying = true;
            gameState.currentPlayer = 0;
            gameState.pot = 0;
            gameState.currentBet = 0;
            gameState.round = &#x27;preflop&#x27;;
            gameState.handNumber = 1;
            gameState.communityCards = [];
            gameState.betAmount = 0;
            
            initializePlayers();
            gameState.deck = createDeck();
            
            // Distribuer les cartes
            dealCards();
            
            // Activer les boutons
            document.getElementById(&#x27;callBtn&#x27;).disabled = false;
            document.getElementById(&#x27;raiseBtn&#x27;).disabled = false;
            document.getElementById(&#x27;foldBtn&#x27;).disabled = false;
            document.getElementById(&#x27;betBtn&#x27;).disabled = false;
            
            updateDisplay();
            
            const t = translations[gameState.currentLanguage];
            showMessage(t.gameStarted);
        }

        // Distribuer les cartes
        function dealCards() {
            // Donner 2 cartes à chaque joueur
            for (let i = 0; i &lt; 2; i++) {
                for (let player of gameState.players) {
                    player.cards.push(gameState.deck.pop());
                }
            }
            
            // Afficher les cartes du joueur humain
            displayPlayerCards();
        }

        // Afficher les cartes du joueur
        function displayPlayerCards() {
            const playerCardsContainer = document.getElementById(&#x27;playerCards&#x27;);
            playerCardsContainer.innerHTML = &#x27;&#x27;;
            
            const humanPlayer = gameState.players[0];
            humanPlayer.cards.forEach(card =&gt; {
                const cardElement = document.createElement(&#x27;div&#x27;);
                cardElement.className = `card ${card.color}`;
                cardElement.innerHTML = `
                    &lt;div&gt;${card.rank}&lt;/div&gt;
                    &lt;div style=&quot;font-size: 20px;&quot;&gt;${card.suit}&lt;/div&gt;
                    &lt;div style=&quot;transform: rotate(180deg);&quot;&gt;${card.rank}&lt;/div&gt;
                `;
                playerCardsContainer.appendChild(cardElement);
            });
            
            // Évaluer la force de la main
            evaluateHandStrength();
        }

        // Évaluer la force de la main
        function evaluateHandStrength() {
            const humanPlayer = gameState.players[0];
            const allCards = [...humanPlayer.cards, ...gameState.communityCards];
            
            if (allCards.length &lt; 2) return;
            
            // Logique simplifiée d&#x27;évaluation
            let strength = &#x27;Carte haute&#x27;;
            
            if (humanPlayer.cards[0].rank === humanPlayer.cards[1].rank) {
                strength = &#x27;Paire&#x27;;
            } else if (humanPlayer.cards[0].suit === humanPlayer.cards[1].suit) {
                strength = &#x27;Couleur possible&#x27;;
            } else if (Math.abs(getCardValue(humanPlayer.cards[0]) - getCardValue(humanPlayer.cards[1])) === 1) {
                strength = &#x27;Suite possible&#x27;;
            }
            
            document.getElementById(&#x27;handStrengthValue&#x27;).textContent = strength;
        }

        // Obtenir la valeur numérique d&#x27;une carte
        function getCardValue(card) {
            if (card.rank === &#x27;A&#x27;) return 14;
            if (card.rank === &#x27;K&#x27;) return 13;
            if (card.rank === &#x27;Q&#x27;) return 12;
            if (card.rank === &#x27;J&#x27;) return 11;
            return parseInt(card.rank);
        }

        // Suivre la mise
        function callBet() {
            const player = gameState.players[gameState.currentPlayer];
            const callAmount = gameState.currentBet - player.currentBet;
            
            if (player.chips &gt;= callAmount) {
                player.chips -= callAmount;
                player.currentBet = gameState.currentBet;
                gameState.pot += callAmount;
                
                const t = translations[gameState.currentLanguage];
                showMessage(`${player.name} ${t.actions.call} ₹${callAmount}`);
                
                nextPlayer();
            }
        }

        // Relancer
        function raiseBet() {
            const player = gameState.players[gameState.currentPlayer];
            const raiseAmount = gameState.betAmount;
            
            if (player.chips &gt;= raiseAmount &amp;&amp; raiseAmount &gt; gameState.currentBet) {
                player.chips -= raiseAmount;
                gameState.pot += raiseAmount;
                gameState.currentBet = raiseAmount;
                player.currentBet = raiseAmount;
                
                const t = translations[gameState.currentLanguage];
                showMessage(`${player.name} ${t.actions.raise} à ₹${raiseAmount}`);
                
                nextPlayer();
            }
        }

        // Se coucher
        function foldHand() {
            const player = gameState.players[gameState.currentPlayer];
            player.folded = true;
            
            const t = translations[gameState.currentLanguage];
            showMessage(`${player.name} ${t.actions.fold}`);
            
            nextPlayer();
        }

        // Miser
        function placeBet() {
            const player = gameState.players[gameState.currentPlayer];
            const betAmount = gameState.betAmount;
            
            if (player.chips &gt;= betAmount &amp;&amp; betAmount &gt; 0) {
                player.chips -= betAmount;
                gameState.pot += betAmount;
                gameState.currentBet = Math.max(gameState.currentBet, betAmount);
                player.currentBet = betAmount;
                
                const t = translations[gameState.currentLanguage];
                showMessage(`${player.name} ${t.actions.bet} ₹${betAmount}`);
                
                nextPlayer();
            }
        }

        // Joueur suivant
        function nextPlayer() {
            gameState.currentPlayer = (gameState.currentPlayer + 1) % gameState.players.length;
            
            // Vérifier si tous les joueurs ont joué
            const activePlayers = gameState.players.filter(p =&gt; !p.folded);
            if (activePlayers.length === 1) {
                endHand();
                return;
            }
            
            // Si c&#x27;est un joueur IA
            if (gameState.players[gameState.currentPlayer].isAI) {
                setTimeout(() =&gt; {
                    playAITurn();
                }, 2000);
            }
            
            updateDisplay();
        }

        // Jouer le tour de l&#x27;IA
        function playAITurn() {
            const player = gameState.players[gameState.currentPlayer];
            const t = translations[gameState.currentLanguage];
            
            // Ajouter l&#x27;effet de réflexion
            const seat = document.getElementById(`seat${gameState.currentPlayer + 1}`);
            seat.classList.add(&#x27;ai-thinking&#x27;);
            
            setTimeout(() =&gt; {
                seat.classList.remove(&#x27;ai-thinking&#x27;);
                
                // Logique IA simplifiée
                const decision = Math.random();
                
                if (decision &lt; 0.3) {
                    // Se coucher
                    player.folded = true;
                    showMessage(`${player.name} ${t.actions.fold}`);
                } else if (decision &lt; 0.7) {
                    // Suivre
                    const callAmount = gameState.currentBet - player.currentBet;
                    if (player.chips &gt;= callAmount) {
                        player.chips -= callAmount;
                        player.currentBet = gameState.currentBet;
                        gameState.pot += callAmount;
                        showMessage(`${player.name} ${t.actions.call} ₹${callAmount}`);
                    } else {
                        player.folded = true;
                        showMessage(`${player.name} ${t.actions.fold}`);
                    }
                } else {
                    // Relancer
                    const raiseAmount = Math.floor(Math.random() * 200) + 50;
                    if (player.chips &gt;= raiseAmount) {
                        player.chips -= raiseAmount;
                        gameState.pot += raiseAmount;
                        gameState.currentBet = Math.max(gameState.currentBet, raiseAmount);
                        player.currentBet = raiseAmount;
                        showMessage(`${player.name} ${t.actions.raise} à ₹${raiseAmount}`);
                    } else {
                        // Suivre si pas assez de jetons pour relancer
                        const callAmount = gameState.currentBet - player.currentBet;
                        if (player.chips &gt;= callAmount) {
                            player.chips -= callAmount;
                            player.currentBet = gameState.currentBet;
                            gameState.pot += callAmount;
                            showMessage(`${player.name} ${t.actions.call} ₹${callAmount}`);
                        } else {
                            player.folded = true;
                            showMessage(`${player.name} ${t.actions.fold}`);
                        }
                    }
                }
                
                nextPlayer();
            }, 1500);
        }

        // Terminer la main
        function endHand() {
            const activePlayers = gameState.players.filter(p =&gt; !p.folded);
            
            if (activePlayers.length === 1) {
                // Un seul joueur reste
                activePlayers[0].chips += gameState.pot;
                showMessage(`${activePlayers[0].name} remporte ₹${gameState.pot}!`);
            } else {
                // Évaluer les mains (logique simplifiée)
                const winner = activePlayers[Math.floor(Math.random() * activePlayers.length)];
                winner.chips += gameState.pot;
                showMessage(`${winner.name} remporte ₹${gameState.pot}!`);
            }
            
            // Réinitialiser pour la prochaine main
            setTimeout(() =&gt; {
                gameState.handNumber++;
                gameState.pot = 0;
                gameState.currentBet = 0;
                gameState.round = &#x27;preflop&#x27;;
                gameState.communityCards = [];
                
                gameState.players.forEach(player =&gt; {
                    player.cards = [];
                    player.folded = false;
                    player.currentBet = 0;
                });
                
                if (gameState.players.filter(p =&gt; p.chips &gt; 0).length &gt; 1) {
                    gameState.deck = createDeck();
                    dealCards();
                    updateDisplay();
                    
                    const t = translations[gameState.currentLanguage];
                    showMessage(`Main ${gameState.handNumber} - ${t.gameStarted}`);
                } else {
                    endGame();
                }
            }, 3000);
        }

        // Terminer le jeu
        function endGame() {
            const winner = gameState.players.reduce((prev, current) =&gt; 
                (prev.chips &gt; current.chips) ? prev : current
            );
            
            showMessage(`🏆 ${winner.name} remporte la partie avec ₹${winner.chips}!`);
            
            // Désactiver les boutons
            document.getElementById(&#x27;callBtn&#x27;).disabled = true;
            document.getElementById(&#x27;raiseBtn&#x27;).disabled = true;
            document.getElementById(&#x27;foldBtn&#x27;).disabled = true;
            document.getElementById(&#x27;betBtn&#x27;).disabled = true;
            
            gameState.isPlaying = false;
        }

        // Mettre à jour le montant de la mise
        function updateBetAmount() {
            const slider = document.getElementById(&#x27;betSlider&#x27;);
            gameState.betAmount = parseInt(slider.value);
            document.getElementById(&#x27;betAmount&#x27;).textContent = `₹${gameState.betAmount}`;
        }

        // Mettre à jour l&#x27;affichage
        function updateDisplay() {
            updatePlayersDisplay();
            updateStatsDisplay();
            updateRoundDisplay();
            updatePotDisplay();
        }

        // Mettre à jour l&#x27;affichage des joueurs
        function updatePlayersDisplay() {
            const container = document.getElementById(&#x27;playersContainer&#x27;);
            container.innerHTML = &#x27;&#x27;;
            
            const t = translations[gameState.currentLanguage];
            
            gameState.players.forEach((player, index) =&gt; {
                const playerDiv = document.createElement(&#x27;div&#x27;);
                playerDiv.className = `player-info ${index === gameState.currentPlayer ? &#x27;current-player&#x27; : &#x27;&#x27;}`;
                
                // Nom du joueur avec traduction
                const playerName = player.isAI ? t.aiName : `${t.playerName} ${index + 1}`;
                
                playerDiv.innerHTML = `
                    &lt;div class=&quot;player-name&quot;&gt;${playerName}&lt;/div&gt;
                    &lt;div class=&quot;stat-item&quot;&gt;
                        &lt;span&gt;${t.chipsLabel}:&lt;/span&gt;
                        &lt;span class=&quot;stat-value&quot;&gt;₹${player.chips}&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;stat-item&quot;&gt;
                        &lt;span&gt;${t.betLabel}:&lt;/span&gt;
                        &lt;span class=&quot;stat-value&quot;&gt;₹${player.currentBet}&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;stat-item&quot;&gt;
                        &lt;span&gt;${t.statusLabel}:&lt;/span&gt;
                        &lt;span class=&quot;stat-value&quot;&gt;${player.folded ? &#x27;❌&#x27; : &#x27;✅&#x27;}&lt;/span&gt;
                    &lt;/div&gt;
                `;
                container.appendChild(playerDiv);
                
                // Mettre à jour le siège correspondant
                const seat = document.getElementById(`seat${index + 1}`);
                if (seat) {
                    seat.querySelector(&#x27;.player-name&#x27;).textContent = playerName;
                    seat.querySelector(&#x27;.player-chips&#x27;).textContent = `₹${player.chips}`;
                    seat.className = `player-seat seat-${index + 1} ${player.isAI ? &#x27;ai&#x27; : &#x27;&#x27;} ${index === gameState.currentPlayer ? &#x27;active&#x27; : &#x27;&#x27;}`;
                }
            });
        }

        // Mettre à jour l&#x27;affichage des statistiques
        function updateStatsDisplay() {
            document.getElementById(&#x27;handValue&#x27;).textContent = gameState.handNumber;
            document.getElementById(&#x27;potValue&#x27;).textContent = `₹${gameState.pot}`;
        }

        // Mettre à jour l&#x27;affichage de la manche
        function updateRoundDisplay() {
            const t = translations[gameState.currentLanguage];
            document.getElementById(&#x27;roundValue&#x27;).textContent = t.rounds[gameState.round];
        }

        // Mettre à jour l&#x27;affichage du pot
        function updatePotDisplay() {
            document.getElementById(&#x27;potAmount&#x27;).textContent = `₹${gameState.pot}`;
        }

        // Afficher un message
        function showMessage(message) {
            const messageElement = document.getElementById(&#x27;gameMessage&#x27;);
            messageElement.innerHTML = `&lt;span&gt;${message}&lt;/span&gt;`;
        }

        // Afficher les règles
        function showRules() {
            const t = translations[gameState.currentLanguage];
            alert(`Règles du Quantum Poker:\n\n1. Chaque joueur reçoit 2 cartes\n2. Misez, suivez ou couchez-vous\n3. 5 cartes communes sont révélées\n4. Formez la meilleure main de 5 cartes\n5. Le joueur avec la meilleure main gagne le pot!`);
        }

        // Initialisation
        document.addEventListener(&#x27;DOMContentLoaded&#x27;, function() {
            createQuantumParticles();
            initializePlayers();
            updateDisplay();
            updateLanguageInterface();
            
            // Initialiser le slider de mise
            const slider = document.getElementById(&#x27;betSlider&#x27;);
            slider.max = 1000;
            updateBetAmount();
        });
    &lt;/script&gt;
&lt;script&gt;(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement(&#x27;script&#x27;);d.innerHTML=&quot;window.__CF$cv$params={r:&#x27;985b34cee229c123&#x27;,t:&#x27;MTc1ODk3ODI2MC4wMDAwMDA=&#x27;};var a=document.createElement(&#x27;script&#x27;);a.nonce=&#x27;&#x27;;a.src=&#x27;/cdn-cgi/challenge-platform/scripts/jsd/main.js&#x27;;document.getElementsByTagName(&#x27;head&#x27;)[0].appendChild(a);&quot;;b.getElementsByTagName(&#x27;head&#x27;)[0].appendChild(d)}}if(document.body){var a=document.createElement(&#x27;iframe&#x27;);a.height=1;a.width=1;a.style.position=&#x27;absolute&#x27;;a.style.top=0;a.style.left=0;a.style.border=&#x27;none&#x27;;a.style.visibility=&#x27;hidden&#x27;;document.body.appendChild(a);if(&#x27;loading&#x27;!==document.readyState)c();else if(window.addEventListener)document.addEventListener(&#x27;DOMContentLoaded&#x27;,c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);&#x27;loading&#x27;!==document.readyState&amp;&amp;(document.onreadystatechange=e,c())}}}})();&lt;/script&gt;&lt;/body&gt;
&lt;/html&gt;
" style="width:100%;height:100%;border:none;"></iframe>
</div>
<script>
function launchGame12() {
  var ov = document.getElementById('game12Overlay');
  if(ov) ov.style.display = 'block';
}
function closeGame12() {
  var ov = document.getElementById('game12Overlay');
  if(ov) ov.style.display = 'none';
  var ifr = document.getElementById('iframeGame12');
  try { ifr.srcdoc = ''; } catch(e){ ifr.src = 'about:blank'; }
}
document.addEventListener('keydown', function(e) {
  if(e.key === 'Escape') { var ov = document.getElementById('game12Overlay'); if(ov && ov.style.display==='block') closeGame12(); }
}, true);
</script>



            </div>
        </div>

        <!-- Bloc de contrôles de jeu -->
        <div class="game-controls">
            <div style="display: flex; gap: 15px; flex-wrap: wrap;">
                <button class="quantum-btn action-btn" onclick="newGame()">🚀 <span id="newGameBtn">Nouvelle Partie</span></button>
                <button class="quantum-btn" onclick="undoMove()" id="undoBtn" disabled>↶ <span id="undoBtnText">Annuler</span></button>
                <button class="quantum-btn" onclick="getHint()" id="hintBtn">💡 <span id="hintBtnText">Indice</span></button>
                <button class="quantum-btn danger-btn" onclick="resetGame()">🔄 <span id="resetBtnText">Recommencer</span></button>
                <button class="quantum-btn" onclick="showRules()">📋 <span id="rulesBtn">Règles</span></button>
            </div>
            
            <div class="difficulty-selector">
                <button class="quantum-btn difficulty-btn active" onclick="setDifficulty('easy')" id="easyBtn">
                    <span id="easyBtnText">Facile</span>
                </button>
                <button class="quantum-btn difficulty-btn" onclick="setDifficulty('medium')" id="mediumBtn">
                    <span id="mediumBtnText">Moyen</span>
                </button>
                <button class="quantum-btn difficulty-btn" onclick="setDifficulty('hard')" id="hardBtn">
                    <span id="hardBtnText">Difficile</span>
                </button>
            </div>
        </div>

        <div class="game-container">
            <!-- Sidebar gauche - Statistiques -->
            <div class="sidebar">
                <div class="section-title" id="statsTitle">📊 Statistiques</div>
                
                <div class="stats-panel">
                    <div class="stat-item">
                        <span id="scoreLabel">Score:</span>
                        <span class="stat-value" id="scoreValue">0</span>
                    </div>
                    <div class="stat-item">
                        <span id="movesLabel">Coups:</span>
                        <span class="stat-value" id="movesValue">0</span>
                    </div>
                    <div class="stat-item">
                        <span id="timeLabel">Temps:</span>
                        <span class="stat-value" id="timeValue">00:00</span>
                    </div>
                    <div class="stat-item">
                        <span id="cardsLeftLabel">Cartes restantes:</span>
                        <span class="stat-value" id="cardsLeftValue">52</span>
                    </div>
                </div>

                <div class="section-title" id="progressTitle">🎯 Progression</div>
                <div class="stats-panel">
                    <div class="stat-item">
                        <span id="foundationsLabel">Fondations:</span>
                        <span class="stat-value" id="foundationsValue">0/4</span>
                    </div>
                    <div class="stat-item">
                        <span id="completionLabel">Complétion:</span>
                        <span class="stat-value" id="completionValue">0%</span>
                    </div>
                </div>

                <div class="section-title" id="bestScoresTitle">🏆 Meilleurs Scores</div>
                <div class="stats-panel" id="bestScoresPanel">
                    <div class="stat-item">
                        <span id="bestTimeLabel">Meilleur temps:</span>
                        <span class="stat-value" id="bestTimeValue">--:--</span>
                    </div>
                    <div class="stat-item">
                        <span id="bestScoreLabel">Meilleur score:</span>
                        <span class="stat-value" id="bestScoreValue">0</span>
                    </div>
                    <div class="stat-item">
                        <span id="gamesWonLabel">Parties gagnées:</span>
                        <span class="stat-value" id="gamesWonValue">0</span>
                    </div>
                </div>
            </div>

            <!-- Plateau de jeu principal -->
            <div class="game-board">
                <div class="game-message" id="gameMessage">
                    <span>Bienvenue au Solitaire Fusion! Cliquez sur "Nouvelle Partie" pour commencer.</span>
                </div>

                <!-- Zone des fondations -->
                <div class="section-title" id="foundationsTitle">🏛️ Fondations</div>
                <div class="foundation-area" id="foundationArea">
                    <div class="card-pile foundation-pile" data-suit="spades">
                        <div class="card card-empty">♠</div>
                    </div>
                    <div class="card-pile foundation-pile" data-suit="hearts">
                        <div class="card card-empty">♥</div>
                    </div>
                    <div class="card-pile foundation-pile" data-suit="diamonds">
                        <div class="card card-empty">♦</div>
                    </div>
                    <div class="card-pile foundation-pile" data-suit="clubs">
                        <div class="card card-empty">♣</div>
                    </div>
                </div>

                <!-- Zone stock et défausse -->
                <div class="section-title" id="stockWasteTitle">🎴 Stock & Défausse</div>
                <div class="stock-waste-area">
                    <div class="card-pile" id="stockPile">
                        <div class="card card-back">🃏</div>
                    </div>
                    <div class="card-pile" id="wastePile">
                        <div class="card card-empty">📤</div>
                    </div>
                </div>

                <!-- Zone tableau -->
                <div class="section-title" id="tableauTitle">🎯 Tableau</div>
                <div class="tableau-area" id="tableauArea">
                    <div class="card-pile tableau-pile" data-column="0"></div>
                    <div class="card-pile tableau-pile" data-column="1"></div>
                    <div class="card-pile tableau-pile" data-column="2"></div>
                    <div class="card-pile tableau-pile" data-column="3"></div>
                    <div class="card-pile tableau-pile" data-column="4"></div>
                    <div class="card-pile tableau-pile" data-column="5"></div>
                    <div class="card-pile tableau-pile" data-column="6"></div>
                </div>
            </div>

            <!-- Sidebar droite - IA et Aide -->
            <div class="sidebar">
                <div class="section-title" id="aiTitle">🤖 Assistant IA</div>
                <div class="ai-panel" id="aiPanel">
                    <div style="color: #00ffff; font-size: 14px; line-height: 1.4;" id="aiStatusText">
                        Assistant IA activé<br>
                        Analyse des coups possibles...
                    </div>
                </div>
                
                <div class="section-title" id="hintsTitle">💡 Indices</div>
                <div class="stats-panel">
                    <div class="stat-item">
                        <span id="hintsUsedLabel">Indices utilisés:</span>
                        <span class="stat-value" id="hintsUsedValue">0</span>
                    </div>
                    <div class="stat-item">
                        <span id="hintsAvailableLabel">Indices disponibles:</span>
                        <span class="stat-value" id="hintsAvailableValue">3</span>
                    </div>
                </div>

                <div class="section-title" id="actionsTitle">⚡ Actions Rapides</div>
                <div style="display: flex; flex-direction: column; gap: 10px;">
                    <button class="quantum-btn" onclick="autoMoveToFoundations()" id="autoMoveBtn">
                        🎯 <span id="autoMoveBtnText">Auto-placement</span>
                    </button>
                    <button class="quantum-btn" onclick="shuffleWaste()" id="shuffleBtn" disabled>
                        🔀 <span id="shuffleBtnText">Mélanger défausse</span>
                    </button>
                    <button class="quantum-btn action-btn" onclick="celebrateWin()" id="celebrateBtn" style="display: none;">
                        🎉 <span id="celebrateBtnText">Célébrer!</span>
                    </button>
                </div>

                <div class="section-title" id="difficultyTitle">⚙️ Difficulté</div>
                <div class="stats-panel">
                    <div style="text-align: center; color: #ffd700; font-weight: bold;" id="currentDifficultyText">
                        Mode: <span id="currentDifficultyValue">Facile</span>
                    </div>
                    <div style="font-size: 12px; text-align: center; margin-top: 10px; color: #aaa;" id="difficultyDescText">
                        Tirage par 1 carte, indices illimités
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // État du jeu
    var gameState = {
            isPlaying: false,
            currentLanguage: 'fr',
            difficulty: 'easy',
            score: 0,
            moves: 0,
            startTime: null,
            gameTime: 0,
            timer: null,
            deck: [],
            stock: [],
            waste: [],
            foundations: { spades: [], hearts: [], diamonds: [], clubs: [] },
            tableau: [[], [], [], [], [], [], []],
            selectedCard: null,
            selectedPile: null,
            hintsUsed: 0,
            hintsAvailable: 3,
            moveHistory: [],
            bestScores: JSON.parse(localStorage.getItem('solitaireFusionBestScores')) || {
                bestTime: null,
                bestScore: 0,
                gamesWon: 0
            }
        };

        // Traductions
        const translations = {
            fr: {
                gameTitle: 'SOLITAIRE FUSION',
                statsTitle: '📊 Statistiques',
                progressTitle: '🎯 Progression',
                bestScoresTitle: '🏆 Meilleurs Scores',
                aiTitle: '🤖 Assistant IA',
                hintsTitle: '💡 Indices',
                actionsTitle: '⚡ Actions Rapides',
                difficultyTitle: '⚙️ Difficulté',
                foundationsTitle: '🏛️ Fondations',
                stockWasteTitle: '🎴 Stock & Défausse',
                tableauTitle: '🎯 Tableau',
                welcomeMessage: 'Bienvenue au Solitaire Fusion! Cliquez sur "Nouvelle Partie" pour commencer.',
                gameStarted: 'Nouvelle partie commencée! Bonne chance!',
                gameWon: '🎉 Félicitations! Vous avez gagné!',
                scoreLabel: 'Score',
                movesLabel: 'Coups',
                timeLabel: 'Temps',
                cardsLeftLabel: 'Cartes restantes',
                foundationsLabel: 'Fondations',
                completionLabel: 'Complétion',
                bestTimeLabel: 'Meilleur temps',
                bestScoreLabel: 'Meilleur score',
                gamesWonLabel: 'Parties gagnées',
                hintsUsedLabel: 'Indices utilisés',
                hintsAvailableLabel: 'Indices disponibles',
                currentDifficultyText: 'Mode',
                newGameBtn: 'Nouvelle Partie',
                undoBtnText: 'Annuler',
                hintBtnText: 'Indice',
                resetBtnText: 'Recommencer',
                rulesBtn: 'Règles',
                easyBtnText: 'Facile',
                mediumBtnText: 'Moyen',
                hardBtnText: 'Difficile',
                autoMoveBtnText: 'Auto-placement',
                shuffleBtnText: 'Mélanger défausse',
                celebrateBtnText: 'Célébrer!',
                aiStatus: 'Assistant IA activé\nAnalyse des coups possibles...',
                difficultyDesc: {
                    easy: 'Tirage par 1 carte, indices illimités',
                    medium: 'Tirage par 3 cartes, 5 indices',
                    hard: 'Tirage par 3 cartes, 3 indices'
                },
                hints: {
                    noMoves: 'Aucun coup évident disponible.',
                    moveToFoundation: 'Vous pouvez placer {card} sur la fondation {suit}.',
                    revealCard: 'Retournez la carte dans la colonne {column}.',
                    moveCard: 'Déplacez {card} sur {target}.',
                    drawStock: 'Tirez une carte du stock.'
                }
            },
            es: {
                gameTitle: 'SOLITARIO FUSION',
                statsTitle: '📊 Estadísticas',
                progressTitle: '🎯 Progreso',
                bestScoresTitle: '🏆 Mejores Puntuaciones',
                aiTitle: '🤖 Asistente IA',
                hintsTitle: '💡 Pistas',
                actionsTitle: '⚡ Acciones Rápidas',
                difficultyTitle: '⚙️ Dificultad',
                foundationsTitle: '🏛️ Fundaciones',
                stockWasteTitle: '🎴 Mazo y Descarte',
                tableauTitle: '🎯 Tablero',
                welcomeMessage: '¡Bienvenido a Solitario Fusion! Haz clic en "Nueva Partida" para comenzar.',
                gameStarted: '¡Nueva partida iniciada! ¡Buena suerte!',
                gameWon: '🎉 ¡Felicitaciones! ¡Has ganado!',
                scoreLabel: 'Puntuación',
                movesLabel: 'Movimientos',
                timeLabel: 'Tiempo',
                cardsLeftLabel: 'Cartas restantes',
                foundationsLabel: 'Fundaciones',
                completionLabel: 'Completado',
                bestTimeLabel: 'Mejor tiempo',
                bestScoreLabel: 'Mejor puntuación',
                gamesWonLabel: 'Partidas ganadas',
                hintsUsedLabel: 'Pistas usadas',
                hintsAvailableLabel: 'Pistas disponibles',
                currentDifficultyText: 'Modo',
                newGameBtn: 'Nueva Partida',
                undoBtnText: 'Deshacer',
                hintBtnText: 'Pista',
                resetBtnText: 'Reiniciar',
                rulesBtn: 'Reglas',
                easyBtnText: 'Fácil',
                mediumBtnText: 'Medio',
                hardBtnText: 'Difícil',
                autoMoveBtnText: 'Auto-mover',
                shuffleBtnText: 'Mezclar descarte',
                celebrateBtnText: '¡Celebrar!',
                aiStatus: 'Asistente IA activado\nAnalizando movimientos posibles...',
                difficultyDesc: {
                    easy: 'Robar 1 carta, pistas ilimitadas',
                    medium: 'Robar 3 cartas, 5 pistas',
                    hard: 'Robar 3 cartas, 3 pistas'
                },
                hints: {
                    noMoves: 'No hay movimientos obvios disponibles.',
                    moveToFoundation: 'Puedes colocar {card} en la fundación {suit}.',
                    revealCard: 'Voltea la carta en la columna {column}.',
                    moveCard: 'Mueve {card} a {target}.',
                    drawStock: 'Roba una carta del mazo.'
                }
            },
            ar: {
                gameTitle: 'سوليتير فيوجن',
                statsTitle: '📊 الإحصائيات',
                progressTitle: '🎯 التقدم',
                bestScoresTitle: '🏆 أفضل النتائج',
                aiTitle: '🤖 مساعد الذكي',
                hintsTitle: '💡 التلميحات',
                actionsTitle: '⚡ إجراءات سريعة',
                difficultyTitle: '⚙️ الصعوبة',
                foundationsTitle: '🏛️ الأسس',
                stockWasteTitle: '🎴 المخزون والنفايات',
                tableauTitle: '🎯 اللوحة',
                welcomeMessage: 'مرحباً بك في سوليتير فيوجن! انقر على "لعبة جديدة" للبدء.',
                gameStarted: 'بدأت لعبة جديدة! حظاً سعيداً!',
                gameWon: '🎉 تهانينا! لقد فزت!',
                scoreLabel: 'النقاط',
                movesLabel: 'الحركات',
                timeLabel: 'الوقت',
                cardsLeftLabel: 'الأوراق المتبقية',
                foundationsLabel: 'الأسس',
                completionLabel: 'الإنجاز',
                bestTimeLabel: 'أفضل وقت',
                bestScoreLabel: 'أفضل نقاط',
                gamesWonLabel: 'الألعاب المكسوبة',
                hintsUsedLabel: 'التلميحات المستخدمة',
                hintsAvailableLabel: 'التلميحات المتاحة',
                currentDifficultyText: 'الوضع',
                newGameBtn: 'لعبة جديدة',
                undoBtnText: 'تراجع',
                hintBtnText: 'تلميح',
                resetBtnText: 'إعادة تعيين',
                rulesBtn: 'القواعد',
                easyBtnText: 'سهل',
                mediumBtnText: 'متوسط',
                hardBtnText: 'صعب',
                autoMoveBtnText: 'حركة تلقائية',
                shuffleBtnText: 'خلط النفايات',
                celebrateBtnText: 'احتفل!',
                aiStatus: 'تم تفعيل المساعد الذكي\nتحليل الحركات الممكنة...',
                difficultyDesc: {
                    easy: 'سحب ورقة واحدة، تلميحات غير محدودة',
                    medium: 'سحب 3 أوراق، 5 تلميحات',
                    hard: 'سحب 3 أوراق، 3 تلميحات'
                },
                hints: {
                    noMoves: 'لا توجد حركات واضحة متاحة.',
                    moveToFoundation: 'يمكنك وضع {card} على أساس {suit}.',
                    revealCard: 'اقلب الورقة في العمود {column}.',
                    moveCard: 'انقل {card} إلى {target}.',
                    drawStock: 'اسحب ورقة من المخزون.'
                }
            },
            de: {
                gameTitle: 'SOLITÄR FUSION',
                statsTitle: '📊 Statistiken',
                progressTitle: '🎯 Fortschritt',
                bestScoresTitle: '🏆 Beste Ergebnisse',
                aiTitle: '🤖 KI-Assistent',
                hintsTitle: '💡 Hinweise',
                actionsTitle: '⚡ Schnellaktionen',
                difficultyTitle: '⚙️ Schwierigkeit',
                foundationsTitle: '🏛️ Fundamente',
                stockWasteTitle: '🎴 Stapel & Abfall',
                tableauTitle: '🎯 Tableau',
                welcomeMessage: 'Willkommen bei Solitär Fusion! Klicken Sie auf "Neues Spiel" um zu beginnen.',
                gameStarted: 'Neues Spiel gestartet! Viel Glück!',
                gameWon: '🎉 Herzlichen Glückwunsch! Sie haben gewonnen!',
                scoreLabel: 'Punkte',
                movesLabel: 'Züge',
                timeLabel: 'Zeit',
                cardsLeftLabel: 'Karten übrig',
                foundationsLabel: 'Fundamente',
                completionLabel: 'Fertigstellung',
                bestTimeLabel: 'Beste Zeit',
                bestScoreLabel: 'Beste Punkte',
                gamesWonLabel: 'Gewonnene Spiele',
                hintsUsedLabel: 'Hinweise verwendet',
                hintsAvailableLabel: 'Hinweise verfügbar',
                currentDifficultyText: 'Modus',
                newGameBtn: 'Neues Spiel',
                undoBtnText: 'Rückgängig',
                hintBtnText: 'Hinweis',
                resetBtnText: 'Zurücksetzen',
                rulesBtn: 'Regeln',
                easyBtnText: 'Einfach',
                mediumBtnText: 'Mittel',
                hardBtnText: 'Schwer',
                autoMoveBtnText: 'Auto-Zug',
                shuffleBtnText: 'Abfall mischen',
                celebrateBtnText: 'Feiern!',
                aiStatus: 'KI-Assistent aktiviert\nAnalysiere mögliche Züge...',
                difficultyDesc: {
                    easy: '1 Karte ziehen, unbegrenzte Hinweise',
                    medium: '3 Karten ziehen, 5 Hinweise',
                    hard: '3 Karten ziehen, 3 Hinweise'
                },
                hints: {
                    noMoves: 'Keine offensichtlichen Züge verfügbar.',
                    moveToFoundation: 'Sie können {card} auf das {suit} Fundament legen.',
                    revealCard: 'Drehen Sie die Karte in Spalte {column} um.',
                    moveCard: 'Bewegen Sie {card} zu {target}.',
                    drawStock: 'Ziehen Sie eine Karte vom Stapel.'
                }
            },
            zh: {
                gameTitle: '纸牌融合',
                statsTitle: '📊 统计',
                progressTitle: '🎯 进度',
                bestScoresTitle: '🏆 最佳成绩',
                aiTitle: '🤖 AI助手',
                hintsTitle: '💡 提示',
                actionsTitle: '⚡ 快速操作',
                difficultyTitle: '⚙️ 难度',
                foundationsTitle: '🏛️ 基础堆',
                stockWasteTitle: '🎴 库存和废牌',
                tableauTitle: '🎯 牌桌',
                welcomeMessage: '欢迎来到纸牌融合！点击"新游戏"开始。',
                gameStarted: '新游戏开始！祝你好运！',
                gameWon: '🎉 恭喜！你赢了！',
                scoreLabel: '得分',
                movesLabel: '移动',
                timeLabel: '时间',
                cardsLeftLabel: '剩余牌数',
                foundationsLabel: '基础堆',
                completionLabel: '完成度',
                bestTimeLabel: '最佳时间',
                bestScoreLabel: '最高分',
                gamesWonLabel: '获胜游戏',
                hintsUsedLabel: '已用提示',
                hintsAvailableLabel: '可用提示',
                currentDifficultyText: '模式',
                newGameBtn: '新游戏',
                undoBtnText: '撤销',
                hintBtnText: '提示',
                resetBtnText: '重置',
                rulesBtn: '规则',
                easyBtnText: '简单',
                mediumBtnText: '中等',
                hardBtnText: '困难',
                autoMoveBtnText: '自动移动',
                shuffleBtnText: '洗废牌',
                celebrateBtnText: '庆祝！',
                aiStatus: 'AI助手已激活\n分析可能的移动...',
                difficultyDesc: {
                    easy: '抽1张牌，无限提示',
                    medium: '抽3张牌，5个提示',
                    hard: '抽3张牌，3个提示'
                },
                hints: {
                    noMoves: '没有明显的移动可用。',
                    moveToFoundation: '你可以将{card}放在{suit}基础堆上。',
                    revealCard: '翻转第{column}列的牌。',
                    moveCard: '将{card}移动到{target}。',
                    drawStock: '从库存中抽一张牌。'
                }
            },
            en: {
                gameTitle: 'SOLITAIRE FUSION',
                statsTitle: '📊 Statistics',
                progressTitle: '🎯 Progress',
                bestScoresTitle: '🏆 Best Scores',
                aiTitle: '🤖 AI Assistant',
                hintsTitle: '💡 Hints',
                actionsTitle: '⚡ Quick Actions',
                difficultyTitle: '⚙️ Difficulty',
                foundationsTitle: '🏛️ Foundations',
                stockWasteTitle: '🎴 Stock & Waste',
                tableauTitle: '🎯 Tableau',
                welcomeMessage: 'Welcome to Solitaire Fusion! Click "New Game" to start.',
                gameStarted: 'New game started! Good luck!',
                gameWon: '🎉 Congratulations! You won!',
                scoreLabel: 'Score',
                movesLabel: 'Moves',
                timeLabel: 'Time',
                cardsLeftLabel: 'Cards left',
                foundationsLabel: 'Foundations',
                completionLabel: 'Completion',
                bestTimeLabel: 'Best time',
                bestScoreLabel: 'Best score',
                gamesWonLabel: 'Games won',
                hintsUsedLabel: 'Hints used',
                hintsAvailableLabel: 'Hints available',
                currentDifficultyText: 'Mode',
                newGameBtn: 'New Game',
                undoBtnText: 'Undo',
                hintBtnText: 'Hint',
                resetBtnText: 'Reset',
                rulesBtn: 'Rules',
                easyBtnText: 'Easy',
                mediumBtnText: 'Medium',
                hardBtnText: 'Hard',
                autoMoveBtnText: 'Auto-move',
                shuffleBtnText: 'Shuffle waste',
                celebrateBtnText: 'Celebrate!',
                aiStatus: 'AI Assistant activated\nAnalyzing possible moves...',
                difficultyDesc: {
                    easy: 'Draw 1 card, unlimited hints',
                    medium: 'Draw 3 cards, 5 hints',
                    hard: 'Draw 3 cards, 3 hints'
                },
                hints: {
                    noMoves: 'No obvious moves available.',
                    moveToFoundation: 'You can place {card} on {suit} foundation.',
                    revealCard: 'Flip the card in column {column}.',
                    moveCard: 'Move {card} to {target}.',
                    drawStock: 'Draw a card from stock.'
                }
            }
        };

        // Créer un jeu de cartes
        function createDeck() {
            const suits = ['spades', 'hearts', 'diamonds', 'clubs'];
            const suitSymbols = { spades: '♠', hearts: '♥', diamonds: '♦', clubs: '♣' };
            const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
            const deck = [];
            
            for (let suit of suits) {
                for (let i = 0; i < ranks.length; i++) {
                    deck.push({
                        suit: suit,
                        rank: ranks[i],
                        value: i + 1,
                        symbol: suitSymbols[suit],
                        color: (suit === 'hearts' || suit === 'diamonds') ? 'red' : 'black',
                        faceUp: false
                    });
                }
            }
            
            return createWinnableDeck(shuffleDeck(deck));
        }

        // Créer un jeu avec 80% de chances de victoire
        function createWinnableDeck(deck) {
            // 80% de chance de créer une configuration gagnante
            if (Math.random() < 0.8) {
                return optimizeDeckForWinning(deck);
            }
            return deck;
        }

        // Optimiser le jeu pour augmenter les chances de victoire
        function optimizeDeckForWinning(deck) {
            // Placer plus d'As et de cartes basses dans les positions accessibles
            const aces = deck.filter(card => card.rank === 'A');
            const lowCards = deck.filter(card => card.value <= 4 && card.rank !== 'A');
            const otherCards = deck.filter(card => card.value > 4);
            
            // Mélanger chaque groupe séparément
            const shuffledAces = shuffleDeck([...aces]);
            const shuffledLowCards = shuffleDeck([...lowCards]);
            const shuffledOtherCards = shuffleDeck([...otherCards]);
            
            // Répartir de manière à favoriser l'accès aux cartes importantes
            const optimizedDeck = [];
            
            // Alterner les types de cartes pour une meilleure distribution
            let aceIndex = 0, lowIndex = 0, otherIndex = 0;
            
            for (let i = 0; i < 52; i++) {
                if (i % 4 === 0 && aceIndex < shuffledAces.length) {
                    optimizedDeck.push(shuffledAces[aceIndex++]);
                } else if (i % 3 === 0 && lowIndex < shuffledLowCards.length) {
                    optimizedDeck.push(shuffledLowCards[lowIndex++]);
                } else if (otherIndex < shuffledOtherCards.length) {
                    optimizedDeck.push(shuffledOtherCards[otherIndex++]);
                } else if (lowIndex < shuffledLowCards.length) {
                    optimizedDeck.push(shuffledLowCards[lowIndex++]);
                } else if (aceIndex < shuffledAces.length) {
                    optimizedDeck.push(shuffledAces[aceIndex++]);
                }
            }
            
            return optimizedDeck;
        }

        // Mélanger le jeu
        function shuffleDeck(deck) {
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
            return deck;
        }

        // Créer les particules quantiques
        function createQuantumParticles() {
            const bg = document.querySelector('.quantum-bg');
            for (let i = 0; i < 50; i++) {
                const particle = document.createElement('div');
                particle.className = 'quantum-particle';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.top = Math.random() * 100 + '%';
                particle.style.animationDelay = Math.random() * 6 + 's';
                particle.style.animationDuration = (Math.random() * 4 + 4) + 's';
                bg.appendChild(particle);
            }
        }

        // Basculer le dropdown de langue
        function toggleLanguageDropdown() {
            const options = document.getElementById('languageOptions');
            options.classList.toggle('show');
            
            document.addEventListener('click', function closeDropdown(e) {
                if (!e.target.closest('.language-selector')) {
                    options.classList.remove('show');
                    document.removeEventListener('click', closeDropdown);
                }
            });
        }

        // Sélectionner une langue
        function selectLanguage(langCode, langText) {
            gameState.currentLanguage = langCode;
            
            document.getElementById('currentLanguage').textContent = langText;
            
            document.querySelectorAll('.language-option').forEach(option => {
                option.classList.remove('active');
            });
            event.target.classList.add('active');
            
            document.getElementById('languageOptions').classList.remove('show');
            
            updateLanguageInterface();
        }

        // Mettre à jour l'interface selon la langue
        function updateLanguageInterface() {
            const t = translations[gameState.currentLanguage];
            
            // Titres principaux
            document.getElementById('gameTitle').textContent = t.gameTitle;
            document.getElementById('statsTitle').textContent = t.statsTitle;
            document.getElementById('progressTitle').textContent = t.progressTitle;
            document.getElementById('bestScoresTitle').textContent = t.bestScoresTitle;
            document.getElementById('aiTitle').textContent = t.aiTitle;
            document.getElementById('hintsTitle').textContent = t.hintsTitle;
            document.getElementById('actionsTitle').textContent = t.actionsTitle;
            document.getElementById('difficultyTitle').textContent = t.difficultyTitle;
            document.getElementById('foundationsTitle').textContent = t.foundationsTitle;
            document.getElementById('stockWasteTitle').textContent = t.stockWasteTitle;
            document.getElementById('tableauTitle').textContent = t.tableauTitle;
            
            // Labels des statistiques
            document.getElementById('scoreLabel').textContent = t.scoreLabel + ':';
            document.getElementById('movesLabel').textContent = t.movesLabel + ':';
            document.getElementById('timeLabel').textContent = t.timeLabel + ':';
            document.getElementById('cardsLeftLabel').textContent = t.cardsLeftLabel + ':';
            document.getElementById('foundationsLabel').textContent = t.foundationsLabel + ':';
            document.getElementById('completionLabel').textContent = t.completionLabel + ':';
            document.getElementById('bestTimeLabel').textContent = t.bestTimeLabel + ':';
            document.getElementById('bestScoreLabel').textContent = t.bestScoreLabel + ':';
            document.getElementById('gamesWonLabel').textContent = t.gamesWonLabel + ':';
            document.getElementById('hintsUsedLabel').textContent = t.hintsUsedLabel + ':';
            document.getElementById('hintsAvailableLabel').textContent = t.hintsAvailableLabel + ':';
            
            // Boutons
            document.getElementById('newGameBtn').textContent = t.newGameBtn;
            document.getElementById('undoBtnText').textContent = t.undoBtnText;
            document.getElementById('hintBtnText').textContent = t.hintBtnText;
            document.getElementById('resetBtnText').textContent = t.resetBtnText;
            document.getElementById('rulesBtn').textContent = t.rulesBtn;
            document.getElementById('easyBtnText').textContent = t.easyBtnText;
            document.getElementById('mediumBtnText').textContent = t.mediumBtnText;
            document.getElementById('hardBtnText').textContent = t.hardBtnText;
            document.getElementById('autoMoveBtnText').textContent = t.autoMoveBtnText;
            document.getElementById('shuffleBtnText').textContent = t.shuffleBtnText;
            document.getElementById('celebrateBtnText').textContent = t.celebrateBtnText;
            
            // Textes dynamiques
            document.getElementById('aiStatusText').innerHTML = t.aiStatus.replace(/\n/g, '<br>');
            document.getElementById('currentDifficultyText').innerHTML = `${t.currentDifficultyText}: <span id="currentDifficultyValue">${t[gameState.difficulty + 'BtnText']}</span>`;
            document.getElementById('difficultyDescText').textContent = t.difficultyDesc[gameState.difficulty];
            
            if (!gameState.isPlaying) {
                document.getElementById('gameMessage').innerHTML = `<span>${t.welcomeMessage}</span>`;
            }
        }

        // Définir la difficulté
        function setDifficulty(level) {
            gameState.difficulty = level;
            
            // Mettre à jour les boutons
            document.querySelectorAll('.difficulty-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(level + 'Btn').classList.add('active');
            
            // Ajuster les paramètres selon la difficulté
            switch(level) {
                case 'easy':
                    gameState.hintsAvailable = 999;
                    break;
                case 'medium':
                    gameState.hintsAvailable = 5;
                    break;
                case 'hard':
                    gameState.hintsAvailable = 3;
                    break;
            }
            
            updateLanguageInterface();
            updateDisplay();
        }

        // Nouvelle partie
        function newGame() {
            gameState.isPlaying = true;
            gameState.score = 0;
            gameState.moves = 0;
            gameState.startTime = Date.now();
            gameState.gameTime = 0;
            gameState.hintsUsed = 0;
            gameState.selectedCard = null;
            gameState.selectedPile = null;
            gameState.moveHistory = [];
            
            // Réinitialiser les piles
            gameState.foundations = { spades: [], hearts: [], diamonds: [], clubs: [] };
            gameState.tableau = [[], [], [], [], [], [], []];
            gameState.stock = [];
            gameState.waste = [];
            
            // Créer et distribuer les cartes
            gameState.deck = createDeck();
            dealCards();
            
            // Démarrer le timer
            if (gameState.timer) clearInterval(gameState.timer);
            gameState.timer = setInterval(updateTimer, 1000);
            
            // Activer les boutons
            document.getElementById('undoBtn').disabled = false;
            document.getElementById('hintBtn').disabled = false;
            
            updateDisplay();
            
            const t = translations[gameState.currentLanguage];
            showMessage(t.gameStarted);
        }

        // Distribuer les cartes
        function dealCards() {
            // Distribuer au tableau (1, 2, 3, 4, 5, 6, 7 cartes par colonne)
            for (let col = 0; col < 7; col++) {
                for (let row = 0; row <= col; row++) {
                    const card = gameState.deck.pop();
                    card.faceUp = (row === col); // Dernière carte face visible
                    gameState.tableau[col].push(card);
                }
            }
            
            // Le reste va au stock
            gameState.stock = [...gameState.deck];
            gameState.waste = [];
            
            renderBoard();
        }

        // Afficher le plateau
        function renderBoard() {
            renderFoundations();
            renderStock();
            renderWaste();
            renderTableau();
        }

        // Afficher les fondations
        function renderFoundations() {
            const suits = ['spades', 'hearts', 'diamonds', 'clubs'];
            suits.forEach((suit, index) => {
                const pile = document.querySelector(`[data-suit="${suit}"]`);
                pile.innerHTML = '';
                
                if (gameState.foundations[suit].length === 0) {
                    const suitSymbols = { spades: '♠', hearts: '♥', diamonds: '♦', clubs: '♣' };
                    const emptyCard = document.createElement('div');
                    emptyCard.className = 'card card-empty';
                    emptyCard.innerHTML = suitSymbols[suit];
                    emptyCard.onclick = () => handleFoundationClick(pile);
                    pile.appendChild(emptyCard);
                } else {
                    const topCard = gameState.foundations[suit][gameState.foundations[suit].length - 1];
                    const cardElement = createCardElement(topCard);
                    cardElement.onclick = () => handleFoundationClick(pile);
                    pile.appendChild(cardElement);
                }
            });
        }

        // Afficher le stock
        function renderStock() {
            const stockPile = document.getElementById('stockPile');
            stockPile.innerHTML = '';
            
            if (gameState.stock.length > 0) {
                const stockCard = document.createElement('div');
                stockCard.className = 'card card-back';
                stockCard.innerHTML = '🃏';
                stockCard.onclick = drawFromStock;
                stockPile.appendChild(stockCard);
            } else {
                const emptyCard = document.createElement('div');
                emptyCard.className = 'card card-empty';
                emptyCard.innerHTML = '🔄';
                emptyCard.onclick = drawFromStock;
                stockPile.appendChild(emptyCard);
            }
        }

        // Afficher la défausse
        function renderWaste() {
            const wastePile = document.getElementById('wastePile');
            wastePile.innerHTML = '';
            
            if (gameState.waste.length === 0) {
                const emptyCard = document.createElement('div');
                emptyCard.className = 'card card-empty';
                emptyCard.innerHTML = '📤';
                wastePile.appendChild(emptyCard);
            } else {
                const topCard = gameState.waste[gameState.waste.length - 1];
                const cardElement = createCardElement(topCard);
                cardElement.onclick = () => handleCardClick(topCard, 'waste', 0);
                cardElement.ondblclick = () => tryAutoMoveCard(topCard, 'waste', 0);
                wastePile.appendChild(cardElement);
            }
        }

        // Afficher le tableau
        function renderTableau() {
            for (let col = 0; col < 7; col++) {
                const pile = document.querySelector(`[data-column="${col}"]`);
                pile.innerHTML = '';
                
                const columnCards = gameState.tableau[col];
                
                if (columnCards.length === 0) {
                    const emptyCard = document.createElement('div');
                    emptyCard.className = 'card card-empty';
                    emptyCard.innerHTML = '👑';
                    emptyCard.onclick = () => handleTableauClick(col);
                    pile.appendChild(emptyCard);
                } else {
                    columnCards.forEach((card, index) => {
                        const cardElement = createCardElement(card);
                        cardElement.style.position = 'absolute';
                        cardElement.style.top = (index * 20) + 'px';
                        cardElement.style.zIndex = index + 1;
                        cardElement.onclick = () => handleCardClick(card, 'tableau', col);
                        cardElement.ondblclick = () => tryAutoMoveCard(card, 'tableau', col);
                        pile.appendChild(cardElement);
                    });
                }
            }
        }

        // Créer un élément carte
        function createCardElement(card) {
            const cardElement = document.createElement('div');
            cardElement.className = `card ${card.color}`;
            
            if (card.faceUp) {
                let centerContent = '';
                
                // Contenu central selon le rang
                if (card.rank === 'A') {
                    centerContent = `<div style="font-size: 40px; font-weight: bold; color: ${card.color === 'red' ? '#d63031' : '#2d3436'}; text-shadow: 0 0 3px rgba(0,0,0,0.4); display: flex; align-items: center; justify-content: center; height: 100%;">${card.symbol}</div>`;
                } else if (card.rank === 'J') {
                    centerContent = `<div style="font-size: 50px; font-weight: bold; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; width: 100%; color: ${card.color === 'red' ? '#d63031' : '#2d3436'}; text-shadow: 0 0 3px rgba(0,0,0,0.4);">
                        <div style="font-size: 40px; margin-bottom: 2px;">👨‍💼</div>
                        <div style="font-size: 24px; font-weight: bold; letter-spacing: 1px;">J</div>
                    </div>`;
                } else if (card.rank === 'Q') {
                    centerContent = `<div style="font-size: 50px; font-weight: bold; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; width: 100%; color: ${card.color === 'red' ? '#d63031' : '#2d3436'}; text-shadow: 0 0 3px rgba(0,0,0,0.4);">
                        <div style="font-size: 40px; margin-bottom: 2px;">👸</div>
                        <div style="font-size: 24px; font-weight: bold; letter-spacing: 1px;">Q</div>
                    </div>`;
                } else if (card.rank === 'K') {
                    centerContent = `<div style="font-size: 50px; font-weight: bold; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; width: 100%; color: ${card.color === 'red' ? '#d63031' : '#2d3436'}; text-shadow: 0 0 3px rgba(0,0,0,0.4);">
                        <div style="font-size: 40px; margin-bottom: 2px;">🤴</div>
                        <div style="font-size: 24px; font-weight: bold; letter-spacing: 1px;">K</div>
                    </div>`;
                } else {
                    // Cartes numériques (2-10) - afficher le nombre correct de symboles
                    const numValue = parseInt(card.rank);
                    if (numValue >= 2 && numValue <= 10) {
                        let symbolsArray = [];
                        for (let i = 0; i < numValue; i++) {
                            symbolsArray.push(`<span style="font-size: 18px; font-weight: bold; color: ${card.color === 'red' ? '#d63031' : '#2d3436'}; text-shadow: 0 0 2px rgba(0,0,0,0.3);">${card.symbol}</span>`);
                        }
                        
                        // Disposition équilibrée selon le nombre exact
                        if (numValue === 2) {
                            centerContent = `<div style="display: flex; flex-direction: column; align-items: center; justify-content: space-around; height: 80%; padding: 8px 0;">${symbolsArray.join('')}</div>`;
                        } else if (numValue === 3) {
                            centerContent = `<div style="display: flex; flex-direction: column; align-items: center; justify-content: space-around; height: 85%; padding: 6px 0;">${symbolsArray.join('')}</div>`;
                        } else if (numValue === 4) {
                            centerContent = `<div style="display: grid; grid-template-columns: 1fr 1fr; grid-template-rows: 1fr 1fr; gap: 4px; align-items: center; justify-items: center; height: 70%; width: 70%; margin: auto; justify-self: center;">${symbolsArray.join('')}</div>`;
                        } else if (numValue === 5) {
                            centerContent = `<div style="display: flex; flex-direction: column; align-items: center; justify-content: space-between; height: 85%; width: 100%; padding: 4px 0;">
                                <div style="display: flex; justify-content: space-around; width: 80%;">${symbolsArray[0]}${symbolsArray[1]}</div>
                                <div style="display: flex; justify-content: center; width: 80%;">${symbolsArray[2]}</div>
                                <div style="display: flex; justify-content: space-around; width: 80%;">${symbolsArray[3]}${symbolsArray[4]}</div>
                            </div>`;
                        } else if (numValue === 6) {
                            centerContent = `<div style="display: grid; grid-template-columns: 1fr 1fr; grid-template-rows: 1fr 1fr 1fr; gap: 2px; align-items: center; justify-items: center; height: 80%; width: 70%; margin: auto; justify-self: center;">${symbolsArray.join('')}</div>`;
                        } else if (numValue === 7) {
                            centerContent = `<div style="display: grid; grid-template-columns: 1fr 1fr 1fr; grid-template-rows: 1fr 1fr 1fr; gap: 1px; align-items: center; justify-items: center; height: 85%; width: 85%; margin: auto;">
                                ${symbolsArray[0]}${symbolsArray[1]}${symbolsArray[2]}<div></div>${symbolsArray[3]}<div></div>${symbolsArray[4]}${symbolsArray[5]}${symbolsArray[6]}
                            </div>`;
                        } else if (numValue === 8) {
                            centerContent = `<div style="display: flex; flex-direction: column; align-items: center; justify-content: space-between; height: 90%; width: 100%; padding: 2px 0;">
                                <div style="display: flex; justify-content: space-around; width: 85%;">${symbolsArray[0]}${symbolsArray[1]}${symbolsArray[2]}</div>
                                <div style="display: flex; justify-content: center; width: 85%; gap: 8px;">${symbolsArray[3]}${symbolsArray[4]}</div>
                                <div style="display: flex; justify-content: space-around; width: 85%;">${symbolsArray[5]}${symbolsArray[6]}${symbolsArray[7]}</div>
                            </div>`;
                        } else if (numValue === 9) {
                            centerContent = `<div style="display: grid; grid-template-columns: 1fr 1fr 1fr; grid-template-rows: 1fr 1fr 1fr; gap: 1px; align-items: center; justify-items: center; height: 85%; width: 85%; margin: auto;">${symbolsArray.join('')}</div>`;
                        } else if (numValue === 10) {
                            centerContent = `<div style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; grid-template-rows: 1fr 1fr 1fr; gap: 1px; align-items: center; justify-items: center; height: 85%; width: 90%; margin: auto;">
                                ${symbolsArray[0]}${symbolsArray[1]}${symbolsArray[2]}${symbolsArray[3]}${symbolsArray[4]}${symbolsArray[5]}${symbolsArray[6]}${symbolsArray[7]}${symbolsArray[8]}${symbolsArray[9]}
                            </div>`;
                        }
                    } else {
                        centerContent = `<div style="font-size: 32px; font-weight: bold;">${card.symbol}</div>`;
                    }
                }
                
                // Masquer les coins pour les figures (J, Q, K) pour un look plus classique
                const hideCornersForFigures = ['J', 'Q', 'K'].includes(card.rank);
                
                cardElement.innerHTML = `
                    <div style="position: absolute; top: 3px; left: 3px; font-size: 9px; font-weight: bold; line-height: 1; ${hideCornersForFigures ? 'opacity: 0.3;' : ''}">
                        <div>${card.rank}</div>
                        <div style="font-size: 8px;">${card.symbol}</div>
                    </div>
                    <div style="display: flex; align-items: center; justify-content: center; height: 100%; flex-direction: column;">
                        ${centerContent}
                    </div>
                    <div style="position: absolute; bottom: 3px; right: 3px; font-size: 9px; font-weight: bold; transform: rotate(180deg); line-height: 1; ${hideCornersForFigures ? 'opacity: 0.3;' : ''}">
                        <div>${card.rank}</div>
                        <div style="font-size: 8px;">${card.symbol}</div>
                    </div>
                `;
            } else {
                cardElement.className = 'card card-back';
                cardElement.innerHTML = '🃏';
            }
            
            cardElement.cardData = card;
            return cardElement;
        }

        // Gérer le clic sur une carte
        function handleCardClick(card, pileType, pileIndex) {
            if (!gameState.isPlaying) {
                showMessage('Commencez une nouvelle partie pour jouer!');
                return;
            }
            
            if (!card.faceUp && pileType === 'tableau') {
                // Retourner la carte si elle est face cachée
                card.faceUp = true;
                gameState.moves++;
                gameState.score += 5;
                addToHistory('flip', { card, pileType, pileIndex });
                renderBoard();
                updateDisplay();
                showMessage(`Carte ${card.rank}${card.symbol} retournée!`);
                return;
            }
            
            if (gameState.selectedCard) {
                // Tentative de déplacement
                if (gameState.selectedCard === card) {
                    // Désélectionner si on clique sur la même carte
                    clearSelection();
                    showMessage('Sélection annulée.');
                    return;
                }
                
                if (canMoveCard(gameState.selectedCard, card, pileType, pileIndex)) {
                    moveCard(gameState.selectedCard, gameState.selectedPile, card, pileType, pileIndex);
                    showMessage(`${gameState.selectedCard.rank}${gameState.selectedCard.symbol} déplacé sur ${card.rank}${card.symbol}!`);
                } else {
                    showMessage('Déplacement impossible! Vérifiez les règles.');
                }
                clearSelection();
            } else {
                // Sélectionner la carte
                if (card.faceUp && canSelectCard(card, pileType, pileIndex)) {
                    selectCard(card, pileType, pileIndex);
                    showMessage(`${card.rank}${card.symbol} sélectionné. Cliquez sur la destination.`);
                } else {
                    showMessage('Cette carte ne peut pas être sélectionnée.');
                }
            }
        }

        // Vérifier si une carte peut être sélectionnée
        function canSelectCard(card, pileType, pileIndex) {
            if (pileType === 'tableau') {
                const column = gameState.tableau[pileIndex];
                const cardIndex = column.indexOf(card);
                return cardIndex === column.length - 1 || isValidSequence(column, cardIndex);
            } else if (pileType === 'waste') {
                return gameState.waste[gameState.waste.length - 1] === card;
            } else if (pileType === 'foundation') {
                const suits = ['spades', 'hearts', 'diamonds', 'clubs'];
                const foundation = gameState.foundations[suits[pileIndex]];
                return foundation[foundation.length - 1] === card;
            }
            return false;
        }

        // Vérifier si les cartes forment une séquence valide
        function isValidSequence(column, startIndex) {
            for (let i = startIndex; i < column.length - 1; i++) {
                const current = column[i];
                const next = column[i + 1];
                if (current.color === next.color || current.value !== next.value + 1) {
                    return false;
                }
            }
            return true;
        }

        // Gérer le clic sur une colonne vide du tableau
        function handleTableauClick(columnIndex) {
            if (!gameState.isPlaying) {
                showMessage('Commencez une nouvelle partie pour jouer!');
                return;
            }
            
            if (gameState.selectedCard && gameState.selectedCard.rank === 'K') {
                moveCard(gameState.selectedCard, gameState.selectedPile, null, 'tableau', columnIndex);
                showMessage(`Roi ${gameState.selectedCard.symbol} placé sur colonne vide!`);
                clearSelection();
            } else if (gameState.selectedCard) {
                showMessage('Seuls les Rois peuvent être placés sur des colonnes vides!');
            }
        }

        // Sélectionner une carte
        function selectCard(card, pileType, pileIndex) {
            gameState.selectedCard = card;
            gameState.selectedPile = { type: pileType, index: pileIndex };
            
            document.querySelectorAll('.card').forEach(c => c.classList.remove('selected'));
            
            const cardElements = document.querySelectorAll('.card');
            cardElements.forEach(element => {
                if (element.cardData && 
                    element.cardData.rank === card.rank && 
                    element.cardData.suit === card.suit) {
                    element.classList.add('selected');
                }
            });
        }

        // Effacer la sélection
        function clearSelection() {
            gameState.selectedCard = null;
            gameState.selectedPile = null;
            document.querySelectorAll('.card').forEach(c => c.classList.remove('selected'));
        }

        // Vérifier si un déplacement est possible
        function canMoveCard(fromCard, toCard, toPileType, toPileIndex) {
            if (toPileType === 'foundation') {
                const suits = ['spades', 'hearts', 'diamonds', 'clubs'];
                return canMoveToFoundation(fromCard, suits[toPileIndex]);
            } else if (toPileType === 'tableau') {
                return canMoveToTableau(fromCard, toCard, toPileIndex);
            }
            return false;
        }

        // Vérifier si on peut déplacer vers une fondation
        function canMoveToFoundation(card, suit) {
            const foundation = gameState.foundations[suit];
            
            if (foundation.length === 0) {
                return card.rank === 'A';
            } else {
                const topCard = foundation[foundation.length - 1];
                return card.suit === suit && card.value === topCard.value + 1;
            }
        }

        // Vérifier si on peut déplacer vers le tableau
        function canMoveToTableau(card, targetCard, columnIndex) {
            const column = gameState.tableau[columnIndex];
            
            if (column.length === 0) {
                return card.rank === 'K';
            } else {
                return targetCard.color !== card.color && targetCard.value === card.value + 1;
            }
        }

        // Déplacer une carte ou une séquence
        function moveCard(fromCard, fromPile, toCard, toPileType, toPileIndex) {
            const cardsToMove = getCardsToMove(fromCard, fromPile);
            
            // Retirer les cartes de leur pile d'origine
            removeCardsFromPile(cardsToMove, fromPile);
            
            // Ajouter les cartes à leur nouvelle destination
            if (toPileType === 'foundation') {
                const suits = ['spades', 'hearts', 'diamonds', 'clubs'];
                gameState.foundations[suits[toPileIndex]].push(fromCard);
                gameState.score += 10;
            } else if (toPileType === 'tableau') {
                cardsToMove.forEach(card => {
                    gameState.tableau[toPileIndex].push(card);
                });
                gameState.score += cardsToMove.length * 5;
            }
            
            gameState.moves++;
            
            addToHistory('move', {
                cardsToMove, fromPile, toCard, toPileType, toPileIndex
            });
            
            renderBoard();
            updateDisplay();
            checkWinCondition();
        }

        // Obtenir les cartes à déplacer (carte seule ou séquence)
        function getCardsToMove(fromCard, fromPile) {
            if (fromPile.type === 'tableau') {
                const column = gameState.tableau[fromPile.index];
                const cardIndex = column.indexOf(fromCard);
                return column.slice(cardIndex);
            } else {
                return [fromCard];
            }
        }

        // Tirer du stock
        function drawFromStock() {
            if (!gameState.isPlaying) {
                showMessage('Commencez une nouvelle partie pour jouer!');
                return;
            }
            
            clearSelection();
            
            if (gameState.stock.length === 0) {
                if (gameState.waste.length === 0) {
                    showMessage('Plus de cartes disponibles!');
                    return;
                }
                
                // Remettre la défausse dans le stock
                gameState.stock = [...gameState.waste].reverse();
                gameState.waste = [];
                gameState.stock.forEach(card => card.faceUp = false);
                gameState.moves++;
                showMessage('Stock rechargé depuis la défausse!');
            } else {
                // Tirer des cartes selon la difficulté
                const drawCount = gameState.difficulty === 'easy' ? 1 : 3;
                const drawnCards = [];
                
                for (let i = 0; i < drawCount && gameState.stock.length > 0; i++) {
                    const card = gameState.stock.pop();
                    card.faceUp = true;
                    gameState.waste.push(card);
                    drawnCards.push(card);
                }
                
                gameState.moves++;
                
                if (drawnCards.length > 0) {
                    const lastCard = drawnCards[drawnCards.length - 1];
                    showMessage(`Carte tirée: ${lastCard.rank}${lastCard.symbol}`);
                }
            }
            
            renderBoard();
            updateDisplay();
        }

        // Gérer le clic sur une fondation
        function handleFoundationClick(element) {
            const suit = element.dataset.suit;
            const suits = ['spades', 'hearts', 'diamonds', 'clubs'];
            const suitIndex = suits.indexOf(suit);
            
            if (!gameState.isPlaying) {
                showMessage('Commencez une nouvelle partie pour jouer!');
                return;
            }
            
            if (gameState.selectedCard) {
                if (canMoveToFoundation(gameState.selectedCard, suit)) {
                    moveCard(gameState.selectedCard, gameState.selectedPile, null, 'foundation', suitIndex);
                    showMessage(`${gameState.selectedCard.rank}${gameState.selectedCard.symbol} placé sur la fondation!`);
                    clearSelection();
                } else {
                    showMessage('Cette carte ne peut pas être placée sur cette fondation!');
                }
            } else {
                // Sélectionner la carte du dessus de la fondation si elle existe
                const foundation = gameState.foundations[suit];
                if (foundation.length > 0) {
                    const topCard = foundation[foundation.length - 1];
                    selectCard(topCard, 'foundation', suitIndex);
                    showMessage(`${topCard.rank}${topCard.symbol} sélectionné depuis la fondation.`);
                }
            }
        }

        // Retirer des cartes de leur pile
        function removeCardsFromPile(cards, pile) {
            if (pile.type === 'tableau') {
                const column = gameState.tableau[pile.index];
                const firstCardIndex = column.indexOf(cards[0]);
                column.splice(firstCardIndex, cards.length);
                
                // Retourner la carte suivante si nécessaire
                if (column.length > 0 && !column[column.length - 1].faceUp) {
                    column[column.length - 1].faceUp = true;
                    gameState.score += 5;
                }
            } else if (pile.type === 'waste') {
                gameState.waste.pop();
            } else if (pile.type === 'foundation') {
                const suits = ['spades', 'hearts', 'diamonds', 'clubs'];
                gameState.foundations[suits[pile.index]].pop();
            }
        }

        // Ajouter à l'historique
        function addToHistory(action, data) {
            gameState.moveHistory.push({ action, data, timestamp: Date.now() });
        }

        // Annuler le dernier coup
        function undoMove() {
            if (gameState.moveHistory.length === 0) return;
            
            const lastMove = gameState.moveHistory.pop();
            
            gameState.moves = Math.max(0, gameState.moves - 1);
            renderBoard();
            updateDisplay();
        }

        // Obtenir un indice
        function getHint() {
            if (gameState.hintsAvailable <= 0) return;
            
            gameState.hintsUsed++;
            gameState.hintsAvailable--;
            
            const t = translations[gameState.currentLanguage];
            
            const hints = [
                t.hints.drawStock,
                t.hints.noMoves
            ];
            
            const randomHint = hints[Math.floor(Math.random() * hints.length)];
            showMessage(randomHint);
            
            const aiPanel = document.getElementById('aiPanel');
            aiPanel.classList.add('ai-thinking');
            setTimeout(() => {
                aiPanel.classList.remove('ai-thinking');
            }, 2000);
            
            updateDisplay();
        }

        // Auto-placement vers les fondations
        function autoMoveToFoundations() {
            if (!gameState.isPlaying) {
                showMessage('Commencez une nouvelle partie pour jouer!');
                return;
            }
            
            let moved = false;
            let movedCards = [];
            
            // Vérifier toutes les cartes visibles pour un placement automatique
            for (let col = 0; col < 7; col++) {
                const column = gameState.tableau[col];
                if (column.length > 0) {
                    const topCard = column[column.length - 1];
                    if (topCard.faceUp) {
                        for (let suit in gameState.foundations) {
                            if (canMoveToFoundation(topCard, suit)) {
                                gameState.foundations[suit].push(topCard);
                                column.pop();
                                
                                if (column.length > 0 && !column[column.length - 1].faceUp) {
                                    column[column.length - 1].faceUp = true;
                                    gameState.score += 5;
                                }
                                
                                gameState.moves++;
                                gameState.score += 10;
                                movedCards.push(`${topCard.rank}${topCard.symbol}`);
                                moved = true;
                                break;
                            }
                        }
                    }
                }
            }
            
            // Vérifier la défausse
            if (gameState.waste.length > 0) {
                const topCard = gameState.waste[gameState.waste.length - 1];
                for (let suit in gameState.foundations) {
                    if (canMoveToFoundation(topCard, suit)) {
                        gameState.foundations[suit].push(topCard);
                        gameState.waste.pop();
                        gameState.moves++;
                        gameState.score += 10;
                        movedCards.push(`${topCard.rank}${topCard.symbol}`);
                        moved = true;
                        break;
                    }
                }
            }
            
            if (moved) {
                showMessage(`Auto-placement: ${movedCards.join(', ')} déplacé(s)!`);
                renderBoard();
                updateDisplay();
                checkWinCondition();
            } else {
                showMessage('Aucun auto-placement possible pour le moment.');
            }
        }

        // Essayer de déplacer automatiquement une carte
        function tryAutoMoveCard(card, pileType, pileIndex) {
            if (!gameState.isPlaying) return;
            
            // Essayer de placer sur une fondation
            for (let suit in gameState.foundations) {
                if (canMoveToFoundation(card, suit)) {
                    const suits = ['spades', 'hearts', 'diamonds', 'clubs'];
                    const suitIndex = suits.indexOf(suit);
                    moveCard(card, { type: pileType, index: pileIndex }, null, 'foundation', suitIndex);
                    showMessage(`${card.rank}${card.symbol} auto-placé sur la fondation!`);
                    return;
                }
            }
            
            // Essayer de placer sur le tableau
            for (let col = 0; col < 7; col++) {
                const column = gameState.tableau[col];
                if (column.length === 0 && card.rank === 'K') {
                    moveCard(card, { type: pileType, index: pileIndex }, null, 'tableau', col);
                    showMessage(`${card.rank}${card.symbol} auto-placé sur colonne vide!`);
                    return;
                } else if (column.length > 0) {
                    const topCard = column[column.length - 1];
                    if (canMoveToTableau(card, topCard, col)) {
                        moveCard(card, { type: pileType, index: pileIndex }, topCard, 'tableau', col);
                        showMessage(`${card.rank}${card.symbol} auto-placé sur ${topCard.rank}${topCard.symbol}!`);
                        return;
                    }
                }
            }
            
            showMessage(`Aucun placement automatique possible pour ${card.rank}${card.symbol}.`);
        }

        // Mélanger la défausse
        function shuffleWaste() {
            if (gameState.waste.length > 0) {
                gameState.waste = shuffleDeck(gameState.waste);
                renderBoard();
                showMessage('Défausse mélangée!');
            }
        }

        // Vérifier la condition de victoire
        function checkWinCondition() {
            const totalFoundationCards = Object.values(gameState.foundations)
                .reduce((sum, pile) => sum + pile.length, 0);
            
            if (totalFoundationCards === 52) {
                winGame();
            }
        }

        // Gagner le jeu
        function winGame() {
            clearInterval(gameState.timer);
            gameState.isPlaying = false;
            
            // Mettre à jour les meilleurs scores
            const currentTime = gameState.gameTime;
            if (!gameState.bestScores.bestTime || currentTime < gameState.bestScores.bestTime) {
                gameState.bestScores.bestTime = currentTime;
            }
            if (gameState.score > gameState.bestScores.bestScore) {
                gameState.bestScores.bestScore = gameState.score;
            }
            gameState.bestScores.gamesWon++;
            
            localStorage.setItem('solitaireFusionBestScores', JSON.stringify(gameState.bestScores));
            
            const t = translations[gameState.currentLanguage];
            showMessage(t.gameWon);
            
            document.getElementById('celebrateBtn').style.display = 'block';
            updateDisplay();
        }

        // Célébrer la victoire
        function celebrateWin() {
            const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57'];
            
            for (let i = 0; i < 50; i++) {
                setTimeout(() => {
                    const confetti = document.createElement('div');
                    confetti.style.position = 'fixed';
                    confetti.style.left = Math.random() * 100 + 'vw';
                    confetti.style.top = '-10px';
                    confetti.style.width = '10px';
                    confetti.style.height = '10px';
                    confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                    confetti.style.borderRadius = '50%';
                    confetti.style.zIndex = '9999';
                    confetti.style.animation = 'fall 3s linear forwards';
                    
                    document.body.appendChild(confetti);
                    
                    setTimeout(() => {
                        confetti.remove();
                    }, 3000);
                }, i * 100);
            }
        }

        // Réinitialiser le jeu
        function resetGame() {
            if (gameState.timer) clearInterval(gameState.timer);
            gameState.isPlaying = false;
            gameState.selectedCard = null;
            gameState.selectedPile = null;
            
            document.getElementById('celebrateBtn').style.display = 'none';
            
            const t = translations[gameState.currentLanguage];
            showMessage(t.welcomeMessage);
            
            updateDisplay();
        }

        // Mettre à jour le timer
        function updateTimer() {
            if (gameState.isPlaying) {
                gameState.gameTime = Math.floor((Date.now() - gameState.startTime) / 1000);
                const minutes = Math.floor(gameState.gameTime / 60);
                const seconds = gameState.gameTime % 60;
                document.getElementById('timeValue').textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
        }

        // Mettre à jour l'affichage
        function updateDisplay() {
            document.getElementById('scoreValue').textContent = gameState.score;
            document.getElementById('movesValue').textContent = gameState.moves;
            
            const cardsLeft = gameState.stock.length + gameState.waste.length + 
                gameState.tableau.reduce((sum, col) => sum + col.length, 0);
            document.getElementById('cardsLeftValue').textContent = cardsLeft;
            
            const foundationsComplete = Object.values(gameState.foundations)
                .filter(pile => pile.length === 13).length;
            document.getElementById('foundationsValue').textContent = `${foundationsComplete}/4`;
            
            const completion = Math.floor((Object.values(gameState.foundations)
                .reduce((sum, pile) => sum + pile.length, 0) / 52) * 100);
            document.getElementById('completionValue').textContent = `${completion}%`;
            
            document.getElementById('hintsUsedValue').textContent = gameState.hintsUsed;
            document.getElementById('hintsAvailableValue').textContent = gameState.hintsAvailable;
            
            // Meilleurs scores
            const bestTime = gameState.bestScores.bestTime;
            if (bestTime) {
                const minutes = Math.floor(bestTime / 60);
                const seconds = bestTime % 60;
                document.getElementById('bestTimeValue').textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
            document.getElementById('bestScoreValue').textContent = gameState.bestScores.bestScore;
            document.getElementById('gamesWonValue').textContent = gameState.bestScores.gamesWon;
            
            // Activer/désactiver les boutons
            document.getElementById('undoBtn').disabled = gameState.moveHistory.length === 0;
            document.getElementById('hintBtn').disabled = gameState.hintsAvailable <= 0;
            document.getElementById('shuffleBtn').disabled = gameState.waste.length === 0;
        }

        // Afficher un message
        function showMessage(message) {
            const messageElement = document.getElementById('gameMessage');
            messageElement.innerHTML = `<span>${message}</span>`;
        }

        // Afficher les règles
        function showRules() {
            const t = translations[gameState.currentLanguage];
            alert(`Règles du Solitaire Fusion:\n\n1. Déplacez toutes les cartes vers les fondations\n2. Les fondations se construisent par couleur de A à K\n3. Dans le tableau, alternez les couleurs en ordre décroissant\n4. Seuls les Rois peuvent être placés sur des colonnes vides\n5. Utilisez le stock pour révéler de nouvelles cartes\n6. Gagnez en complétant les 4 fondations!`);
        }

        // Initialisation
        document.addEventListener('DOMContentLoaded', function() {
            createQuantumParticles();
            updateLanguageInterface();
            updateDisplay();
            setDifficulty('easy');
        });
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'9862d4071073e1d5',t:'MTc1OTA1ODE4Mi4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script>
  </div>
</div>

<!-- Overlay for Game 15 -->
<div id="game15Overlay" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:#000; z-index:10000; overflow:auto;">
  <button onclick="closeGame15()" aria-label="Fermer jeu 15"
          style="position:absolute; top:20px; right:20px; background:red; color:#fff; border:none; padding:10px; font-size:20px; cursor:pointer; z-index:10001;">✖</button>
  <iframe id="game15Frame" style="width:100%; height:100%; border:none;" srcdoc="&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;fr&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;NeuroSynth Explorer - Brainova Premium&lt;/title&gt;
    &lt;style&gt;
        body {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: &#x27;Orbitron&#x27;, &#x27;Segoe UI&#x27;, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            color: #ffffff;
            overflow: hidden;
            height: 100vh;
        }

        @import url(&#x27;https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&amp;display=swap&#x27;);

        .quantum-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -2;
            background: 
                radial-gradient(circle at 20% 80%, rgba(0, 255, 255, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(255, 0, 255, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(0, 255, 0, 0.2) 0%, transparent 50%);
            animation: quantumShift 10s ease-in-out infinite;
        }

        @keyframes quantumShift {
            0%, 100% { transform: scale(1) rotate(0deg); }
            50% { transform: scale(1.1) rotate(2deg); }
        }

        .neural-particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            pointer-events: none;
        }

        .particle {
            position: absolute;
            width: 3px;
            height: 3px;
            background: #00ffff;
            border-radius: 50%;
            animation: float 8s ease-in-out infinite;
            box-shadow: 0 0 10px #00ffff;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px) translateX(0px) rotate(0deg); opacity: 0.3; }
            25% { transform: translateY(-30px) translateX(20px) rotate(90deg); opacity: 1; }
            50% { transform: translateY(-60px) translateX(-10px) rotate(180deg); opacity: 0.7; }
            75% { transform: translateY(-30px) translateX(-20px) rotate(270deg); opacity: 1; }
        }

        .main-container {
            width: 100vw;
            height: 100vh;
            position: relative;
            background: linear-gradient(135deg, rgba(10, 10, 20, 0.95) 0%, rgba(20, 30, 40, 0.95) 100%);
            backdrop-filter: blur(20px);
            display: flex;
            flex-direction: column;
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 25px;
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.1) 0%, rgba(255, 0, 255, 0.1) 100%);
            border-bottom: 2px solid rgba(0, 255, 255, 0.3);
            backdrop-filter: blur(15px);
            z-index: 100;
        }

        .game-title {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .game-title h1 {
            font-size: 24px;
            font-weight: 900;
            background: linear-gradient(135deg, #00ffff, #ff00ff, #00ff00);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin: 0;
            text-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
            letter-spacing: 2px;
            animation: titlePulse 3s ease-in-out infinite;
        }

        @keyframes titlePulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .game-logo {
            font-size: 28px;
            filter: drop-shadow(0 0 20px #00ffff);
            animation: logoRotate 6s linear infinite;
        }

        @keyframes logoRotate {
            0% { transform: rotate(0deg) scale(1); }
            50% { transform: rotate(180deg) scale(1.1); }
            100% { transform: rotate(360deg) scale(1); }
        }

        .hud-stats {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .language-selector {
            margin-right: 20px;
        }

        .lang-select {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.2) 0%, rgba(255, 0, 255, 0.2) 100%);
            border: 1px solid rgba(0, 255, 255, 0.5);
            border-radius: 10px;
            color: #ffffff;
            padding: 8px 12px;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }

        .lang-select:hover {
            border-color: rgba(0, 255, 255, 0.8);
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.3) 0%, rgba(255, 0, 255, 0.3) 100%);
        }

        .lang-select option {
            background: #1a1a2e;
            color: #ffffff;
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 8px 12px;
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 10px;
            backdrop-filter: blur(10px);
            min-width: 60px;
        }

        .stat-label {
            font-size: 10px;
            color: #00ffff;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-value {
            font-size: 16px;
            font-weight: bold;
            color: #ffffff;
            margin-top: 2px;
        }

        .game-world {
            flex: 1;
            position: relative;
            overflow: hidden;
            display: flex;
        }

        .world-3d {
            flex: 1;
            position: relative;
            background: 
                linear-gradient(180deg, 
                    rgba(135, 206, 235, 0.9) 0%,
                    rgba(144, 238, 144, 0.8) 20%,
                    rgba(34, 139, 34, 0.7) 40%,
                    rgba(0, 100, 0, 0.8) 70%,
                    rgba(25, 25, 112, 0.9) 100%),
                radial-gradient(ellipse at 30% 20%, rgba(255, 255, 255, 0.3) 0%, transparent 50%),
                radial-gradient(ellipse at 70% 80%, rgba(46, 125, 50, 0.4) 0%, transparent 60%);
            perspective: 1000px;
            overflow: hidden;
        }

        .forest-layer {
            position: absolute;
            width: 120%;
            height: 120%;
            background-image: 
                radial-gradient(ellipse at 15% 25%, rgba(34, 139, 34, 0.6) 0%, transparent 30%),
                radial-gradient(ellipse at 45% 60%, rgba(0, 128, 0, 0.4) 0%, transparent 40%),
                radial-gradient(ellipse at 75% 35%, rgba(46, 125, 50, 0.5) 0%, transparent 35%),
                radial-gradient(ellipse at 85% 75%, rgba(25, 111, 61, 0.3) 0%, transparent 45%),
                linear-gradient(90deg, 
                    rgba(139, 69, 19, 0.2) 0%, 
                    transparent 20%, 
                    transparent 80%, 
                    rgba(160, 82, 45, 0.2) 100%);
            animation: forestSway 15s ease-in-out infinite;
        }

        .ground-layer {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 30%;
            background: 
                linear-gradient(180deg, 
                    rgba(34, 139, 34, 0.8) 0%,
                    rgba(107, 142, 35, 0.9) 30%,
                    rgba(85, 107, 47, 0.95) 70%,
                    rgba(139, 69, 19, 1) 100%);
            z-index: 0;
        }

        .sky-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 40%;
            background: 
                linear-gradient(180deg, 
                    rgba(135, 206, 235, 0.9) 0%,
                    rgba(176, 224, 230, 0.7) 50%,
                    rgba(144, 238, 144, 0.5) 100%);
            z-index: -1;
        }

        .mountain-layer {
            position: absolute;
            bottom: 30%;
            left: 0;
            width: 100%;
            height: 40%;
            background: 
                linear-gradient(180deg, 
                    rgba(105, 105, 105, 0.8) 0%,
                    rgba(119, 136, 153, 0.6) 50%,
                    rgba(34, 139, 34, 0.4) 100%);
            clip-path: polygon(0% 100%, 15% 60%, 25% 80%, 40% 40%, 55% 70%, 70% 30%, 85% 60%, 100% 50%, 100% 100%);
            z-index: -1;
        }

        @keyframes forestSway {
            0%, 100% { transform: translateX(-10px) translateY(-5px) rotateX(2deg); }
            50% { transform: translateX(10px) translateY(5px) rotateX(-2deg); }
        }

        .tree {
            position: absolute;
            width: 60px;
            height: 120px;
            background: linear-gradient(180deg, 
                rgba(34, 139, 34, 0.9) 0%,
                rgba(0, 128, 0, 0.8) 20%,
                rgba(46, 125, 50, 0.7) 40%,
                rgba(139, 69, 19, 0.9) 65%,
                rgba(101, 67, 33, 1) 100%);
            border-radius: 30px 30px 8px 8px;
            transform-style: preserve-3d;
            animation: treeGlow 4s ease-in-out infinite;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 
                0 0 15px rgba(34, 139, 34, 0.4),
                inset 0 0 20px rgba(0, 0, 0, 0.2);
        }

        .tree::before {
            content: &#x27;&#x27;;
            position: absolute;
            top: 5px;
            left: 50%;
            transform: translateX(-50%);
            width: 40px;
            height: 40px;
            background: radial-gradient(circle, rgba(46, 125, 50, 0.8) 0%, rgba(34, 139, 34, 0.6) 70%, transparent 100%);
            border-radius: 50%;
            z-index: 1;
        }

        .tree::after {
            content: &#x27;&#x27;;
            position: absolute;
            top: 15px;
            left: 20%;
            width: 25px;
            height: 25px;
            background: radial-gradient(circle, rgba(0, 128, 0, 0.7) 0%, rgba(34, 139, 34, 0.5) 70%, transparent 100%);
            border-radius: 50%;
            z-index: 1;
        }

        .tree:hover {
            transform: scale(1.1) rotateY(10deg);
            box-shadow: 
                0 0 30px rgba(34, 139, 34, 0.8),
                0 0 50px rgba(0, 255, 255, 0.3);
        }

        @keyframes treeGlow {
            0%, 100% { 
                box-shadow: 
                    0 0 15px rgba(34, 139, 34, 0.4),
                    inset 0 0 20px rgba(0, 0, 0, 0.2);
            }
            50% { 
                box-shadow: 
                    0 0 25px rgba(34, 139, 34, 0.6),
                    0 0 40px rgba(0, 255, 255, 0.2),
                    inset 0 0 20px rgba(0, 0, 0, 0.2);
            }
        }

        .neural-node {
            position: absolute;
            width: 40px;
            height: 40px;
            background: radial-gradient(circle, rgba(255, 0, 255, 0.8) 0%, rgba(0, 255, 255, 0.4) 100%);
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.6);
            cursor: pointer;
            animation: nodePulse 2s ease-in-out infinite;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            transition: all 0.3s ease;
        }

        .neural-node:hover {
            transform: scale(1.2);
            animation-duration: 0.5s;
        }

        @keyframes nodePulse {
            0%, 100% { transform: scale(1); box-shadow: 0 0 20px rgba(255, 0, 255, 0.5); }
            50% { transform: scale(1.1); box-shadow: 0 0 40px rgba(255, 0, 255, 0.8); }
        }

        .memory-crystal {
            position: absolute;
            width: 30px;
            height: 30px;
            background: linear-gradient(45deg, 
                rgba(255, 215, 0, 0.9) 0%,
                rgba(255, 255, 0, 0.7) 50%,
                rgba(255, 215, 0, 0.9) 100%);
            clip-path: polygon(50% 0%, 0% 100%, 100% 100%);
            animation: crystalSpin 3s linear infinite;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .memory-crystal:hover {
            transform: scale(1.3);
            filter: brightness(1.5);
        }

        @keyframes crystalSpin {
            0% { transform: rotateY(0deg); }
            100% { transform: rotateY(360deg); }
        }

        .ai-entity {
            position: absolute;
            width: 80px;
            height: 80px;
            background: radial-gradient(circle, 
                rgba(0, 255, 255, 0.8) 0%,
                rgba(0, 200, 255, 0.6) 30%,
                rgba(0, 150, 255, 0.4) 60%,
                rgba(0, 100, 255, 0.2) 100%);
            border-radius: 50%;
            border: 3px solid rgba(255, 255, 255, 0.8);
            animation: aiFloat 5s ease-in-out infinite;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            transition: all 0.3s ease;
        }

        .ai-entity:hover {
            transform: scale(1.2);
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.8);
        }

        @keyframes aiFloat {
            0%, 100% { transform: translateY(0px) rotateZ(0deg); }
            25% { transform: translateY(-20px) rotateZ(5deg); }
            50% { transform: translateY(-40px) rotateZ(0deg); }
            75% { transform: translateY(-20px) rotateZ(-5deg); }
        }

        .side-panel {
            width: 300px;
            background: linear-gradient(135deg, rgba(10, 10, 30, 0.95) 0%, rgba(20, 20, 40, 0.95) 100%);
            border-left: 2px solid rgba(0, 255, 255, 0.3);
            backdrop-filter: blur(15px);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        .panel-section {
            padding: 20px;
            border-bottom: 1px solid rgba(0, 255, 255, 0.2);
        }

        .panel-title {
            font-size: 16px;
            font-weight: bold;
            color: #00ffff;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 2px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .neural-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            color: white;
            padding: 12px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
            margin: 5px 0;
            width: 100%;
        }

        .neural-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
            background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
        }

        .neural-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .neural-btn::before {
            content: &#x27;&#x27;;
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transition: left 0.5s ease;
        }

        .neural-btn:hover::before {
            left: 100%;
        }

        .action-btn {
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
            color: #1a1a2e;
        }

        .action-btn:hover:not(:disabled) {
            background: linear-gradient(135deg, #ffed4e 0%, #ffd700 100%);
            box-shadow: 0 6px 20px rgba(255, 215, 0, 0.6);
        }

        .danger-btn {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
        }

        .danger-btn:hover:not(:disabled) {
            background: linear-gradient(135deg, #ee5a24 0%, #ff6b6b 100%);
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.6);
        }

        .success-btn {
            background: linear-gradient(135deg, #00d2d3 0%, #54a0ff 100%);
        }

        .success-btn:hover:not(:disabled) {
            background: linear-gradient(135deg, #54a0ff 0%, #00d2d3 100%);
            box-shadow: 0 6px 20px rgba(0, 210, 211, 0.6);
        }

        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 10px;
        }

        .inventory-slot {
            width: 60px;
            height: 60px;
            border: 2px solid rgba(0, 255, 255, 0.3);
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .inventory-slot:hover {
            border-color: rgba(0, 255, 255, 0.8);
            background: rgba(0, 255, 255, 0.1);
            transform: scale(1.05);
        }

        .inventory-slot.filled {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.2) 0%, rgba(255, 0, 255, 0.2) 100%);
            border-color: rgba(0, 255, 255, 0.8);
        }

        .quest-item {
            padding: 15px;
            margin: 10px 0;
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .quest-item:hover {
            background: rgba(0, 255, 255, 0.2);
            border-color: rgba(0, 255, 255, 0.6);
            transform: translateX(5px);
        }

        .quest-item.completed {
            background: rgba(0, 255, 0, 0.1);
            border-color: rgba(0, 255, 0, 0.3);
            opacity: 0.7;
        }

        .quest-title {
            font-weight: bold;
            color: #00ffff;
            margin-bottom: 5px;
        }

        .quest-description {
            font-size: 12px;
            color: #cccccc;
            line-height: 1.4;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ffff, #ff00ff);
            transition: width 0.3s ease;
            border-radius: 4px;
        }

        .neural-network {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .neural-connection {
            position: absolute;
            height: 2px;
            background: linear-gradient(90deg, rgba(0, 255, 255, 0.6), rgba(255, 0, 255, 0.6));
            transform-origin: left center;
            animation: connectionPulse 3s ease-in-out infinite;
        }

        @keyframes connectionPulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        .modal-content {
            background: linear-gradient(135deg, rgba(10, 10, 30, 0.95) 0%, rgba(20, 20, 40, 0.95) 100%);
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 20px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            text-align: center;
            backdrop-filter: blur(15px);
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.3);
        }

        .modal-title {
            font-size: 24px;
            font-weight: bold;
            color: #00ffff;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .modal-text {
            font-size: 16px;
            color: #ffffff;
            line-height: 1.6;
            margin-bottom: 20px;
        }

        .puzzle-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin: 20px 0;
            max-width: 300px;
            margin-left: auto;
            margin-right: auto;
        }

        .puzzle-cell {
            width: 60px;
            height: 60px;
            border: 2px solid rgba(0, 255, 255, 0.3);
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .puzzle-cell:hover {
            border-color: rgba(0, 255, 255, 0.8);
            background: rgba(0, 255, 255, 0.1);
            transform: scale(1.05);
        }

        .puzzle-cell.active {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.3) 0%, rgba(255, 0, 255, 0.3) 100%);
            border-color: rgba(0, 255, 255, 0.8);
        }

        .message-display {
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.9) 0%, rgba(255, 0, 255, 0.9) 100%);
            color: #000000;
            padding: 15px 25px;
            border-radius: 25px;
            font-weight: bold;
            font-size: 16px;
            z-index: 999;
            opacity: 0;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
        }

        .message-display.show {
            opacity: 1;
            transform: translateX(-50%) translateY(10px);
        }

        @media (max-width: 1200px) {
            .game-world {
                flex-direction: column;
            }
            
            .side-panel {
                width: 100%;
                height: 200px;
                border-left: none;
                border-top: 2px solid rgba(0, 255, 255, 0.3);
            }
            
            .panel-section {
                padding: 10px;
            }
        }

        @media (max-width: 800px) {
            .game-title h1 {
                font-size: 18px;
            }
            
            .hud-stats {
                gap: 10px;
            }
            
            .stat-item {
                padding: 6px 8px;
                min-width: 50px;
            }
        }

        .minimap {
            width: 150px;
            height: 150px;
            border: 2px solid rgba(0, 255, 255, 0.3);
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.5);
            position: relative;
            margin: 10px 0;
        }

        .minimap-dot {
            position: absolute;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #00ffff;
            animation: minimapPulse 2s ease-in-out infinite;
        }

        @keyframes minimapPulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }

        .ai-chat {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            max-height: 200px;
            overflow-y: auto;
        }

        .chat-message {
            margin: 8px 0;
            padding: 8px 12px;
            border-radius: 15px;
            font-size: 12px;
            line-height: 1.4;
        }

        .chat-message.ai {
            background: rgba(0, 255, 255, 0.1);
            border-left: 3px solid #00ffff;
        }

        .chat-message.player {
            background: rgba(255, 0, 255, 0.1);
            border-right: 3px solid #ff00ff;
            text-align: right;
        }

        /* Styles pour l&#x27;arabe (RTL) */
        .rtl {
            direction: rtl;
            text-align: right;
        }

        .rtl .game-header {
            flex-direction: row-reverse;
        }

        .rtl .hud-stats {
            flex-direction: row-reverse;
        }

        .rtl .game-title {
            flex-direction: row-reverse;
        }

        .rtl .panel-title {
            flex-direction: row-reverse;
        }

        .rtl .quest-item:hover {
            transform: translateX(-5px);
        }

        .rtl .chat-message.ai {
            border-left: none;
            border-right: 3px solid #00ffff;
            text-align: right;
        }

        .rtl .chat-message.player {
            border-right: none;
            border-left: 3px solid #ff00ff;
            text-align: left;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;quantum-bg&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;neural-particles&quot; id=&quot;neuralParticles&quot;&gt;&lt;/div&gt;
    
    &lt;div class=&quot;main-container&quot;&gt;
        &lt;!-- En-tête du jeu --&gt;
        &lt;div class=&quot;game-header&quot;&gt;
            &lt;div class=&quot;game-title&quot;&gt;
                &lt;div class=&quot;game-logo&quot;&gt;🧠&lt;/div&gt;
                &lt;h1&gt;NEUROSYNTH EXPLORER&lt;/h1&gt;
                &lt;div style=&quot;font-size: 12px; color: #00ffff; margin-left: 10px;&quot;&gt;BRAINOVA PREMIUM&lt;/div&gt;
            &lt;/div&gt;
            
            &lt;div class=&quot;hud-stats&quot;&gt;
                &lt;div class=&quot;language-selector&quot;&gt;
                    &lt;select id=&quot;languageSelect&quot; onchange=&quot;changeLanguage(this.value)&quot; class=&quot;lang-select&quot;&gt;
                        &lt;option value=&quot;fr&quot;&gt;🇫🇷 Français&lt;/option&gt;
                        &lt;option value=&quot;en&quot;&gt;🇺🇸 English&lt;/option&gt;
                        &lt;option value=&quot;ar&quot;&gt;🇸🇦 العربية&lt;/option&gt;
                        &lt;option value=&quot;es&quot;&gt;🇪🇸 Español&lt;/option&gt;
                        &lt;option value=&quot;de&quot;&gt;🇩🇪 Deutsch&lt;/option&gt;
                        &lt;option value=&quot;zh&quot;&gt;🇨🇳 中文&lt;/option&gt;
                    &lt;/select&gt;
                &lt;/div&gt;
                &lt;div class=&quot;stat-item&quot;&gt;
                    &lt;div class=&quot;stat-label&quot; data-lang=&quot;level&quot;&gt;Niveau&lt;/div&gt;
                    &lt;div class=&quot;stat-value&quot; id=&quot;playerLevel&quot;&gt;1&lt;/div&gt;
                &lt;/div&gt;
                &lt;div class=&quot;stat-item&quot;&gt;
                    &lt;div class=&quot;stat-label&quot; data-lang=&quot;xp&quot;&gt;XP&lt;/div&gt;
                    &lt;div class=&quot;stat-value&quot; id=&quot;playerXP&quot;&gt;0&lt;/div&gt;
                &lt;/div&gt;
                &lt;div class=&quot;stat-item&quot;&gt;
                    &lt;div class=&quot;stat-label&quot; data-lang=&quot;energy&quot;&gt;Énergie&lt;/div&gt;
                    &lt;div class=&quot;stat-value&quot; id=&quot;playerEnergy&quot;&gt;100&lt;/div&gt;
                &lt;/div&gt;
                &lt;div class=&quot;stat-item&quot;&gt;
                    &lt;div class=&quot;stat-label&quot; data-lang=&quot;crystals&quot;&gt;Cristaux&lt;/div&gt;
                    &lt;div class=&quot;stat-value&quot; id=&quot;crystalCount&quot;&gt;0&lt;/div&gt;
                &lt;/div&gt;
                &lt;div class=&quot;stat-item&quot;&gt;
                    &lt;div class=&quot;stat-label&quot; data-lang=&quot;time&quot;&gt;Temps&lt;/div&gt;
                    &lt;div class=&quot;stat-value&quot; id=&quot;gameTime&quot;&gt;00:00&lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;

        &lt;div class=&quot;game-world&quot;&gt;
            &lt;!-- Monde 3D principal --&gt;
            &lt;div class=&quot;world-3d&quot; id=&quot;gameWorld&quot;&gt;
                &lt;div class=&quot;sky-layer&quot;&gt;&lt;/div&gt;
                &lt;div class=&quot;mountain-layer&quot;&gt;&lt;/div&gt;
                &lt;div class=&quot;forest-layer&quot;&gt;&lt;/div&gt;
                &lt;div class=&quot;ground-layer&quot;&gt;&lt;/div&gt;
                &lt;div class=&quot;neural-network&quot; id=&quot;neuralNetwork&quot;&gt;&lt;/div&gt;
                
                &lt;!-- Les éléments du jeu seront générés dynamiquement --&gt;
            &lt;/div&gt;

            &lt;!-- Panneau latéral --&gt;
            &lt;div class=&quot;side-panel&quot;&gt;
                &lt;!-- Section Contrôles du Jeu --&gt;
                &lt;div class=&quot;panel-section&quot;&gt;
                    &lt;div class=&quot;panel-title&quot;&gt;🎮 Contrôles&lt;/div&gt;
                    &lt;button class=&quot;neural-btn action-btn&quot; id=&quot;startGameBtn&quot; onclick=&quot;startGame()&quot; data-lang=&quot;start_game&quot;&gt;🎮 Commencer le Jeu&lt;/button&gt;
                    &lt;button class=&quot;neural-btn&quot; id=&quot;pauseResumeBtn&quot; onclick=&quot;togglePause()&quot; data-lang=&quot;pause_game&quot; style=&quot;display: none;&quot;&gt;⏸️ Pause&lt;/button&gt;
                &lt;/div&gt;

                &lt;!-- Section Guide --&gt;
                &lt;div class=&quot;panel-section&quot;&gt;
                    &lt;div class=&quot;panel-title&quot; data-lang=&quot;game_guide&quot;&gt;📖 Guide de Jeu&lt;/div&gt;
                    &lt;div style=&quot;font-size: 11px; color: #cccccc; line-height: 1.4; margin-bottom: 10px;&quot; id=&quot;gameGuideContent&quot;&gt;
                        &lt;strong style=&quot;color: #00ffff;&quot; data-lang=&quot;how_to_play&quot;&gt;🎮 COMMENT JOUER :&lt;/strong&gt;&lt;br&gt;
                        &lt;span data-lang=&quot;guide_crystals&quot;&gt;• Cliquez sur les 💎 cristaux pour les collecter&lt;/span&gt;&lt;br&gt;
                        &lt;span data-lang=&quot;guide_nodes&quot;&gt;• Activez les 🧠 nœuds neuraux (2 cristaux requis)&lt;/span&gt;&lt;br&gt;
                        &lt;span data-lang=&quot;guide_ai&quot;&gt;• Parlez aux 🤖 entités IA pour progresser&lt;/span&gt;&lt;br&gt;
                        &lt;span data-lang=&quot;guide_puzzles&quot;&gt;• Résolvez les énigmes pour gagner de l&#x27;XP&lt;/span&gt;&lt;br&gt;
                        &lt;span data-lang=&quot;guide_scan&quot;&gt;• Utilisez ESPACE pour scanner la zone&lt;/span&gt;&lt;br&gt;
                        &lt;span data-lang=&quot;guide_meditate&quot;&gt;• Appuyez sur M pour méditer&lt;/span&gt;&lt;br&gt;&lt;br&gt;
                        &lt;strong style=&quot;color: #ffd700;&quot; data-lang=&quot;objectives&quot;&gt;🏆 OBJECTIFS :&lt;/strong&gt;&lt;br&gt;
                        &lt;span data-lang=&quot;obj_crystals&quot;&gt;• Collectez 5 cristaux de mémoire&lt;/span&gt;&lt;br&gt;
                        &lt;span data-lang=&quot;obj_ai&quot;&gt;• Connectez-vous à 3 entités IA&lt;/span&gt;&lt;br&gt;
                        &lt;span data-lang=&quot;obj_puzzles&quot;&gt;• Résolvez 10 énigmes neurales&lt;/span&gt;
                    &lt;/div&gt;
                &lt;/div&gt;

                &lt;!-- Section Actions --&gt;
                &lt;div class=&quot;panel-section&quot;&gt;
                    &lt;div class=&quot;panel-title&quot; data-lang=&quot;actions&quot;&gt;⚡ Actions&lt;/div&gt;
                    &lt;button class=&quot;neural-btn action-btn&quot; onclick=&quot;scanArea()&quot; data-lang=&quot;scan_area&quot;&gt;🔍 Scanner Zone&lt;/button&gt;
                    &lt;button class=&quot;neural-btn&quot; onclick=&quot;meditate()&quot; data-lang=&quot;neural_meditation&quot;&gt;🧘 Méditation Neural&lt;/button&gt;
                    &lt;button class=&quot;neural-btn success-btn&quot; onclick=&quot;saveProgress()&quot; data-lang=&quot;save&quot;&gt;💾 Sauvegarder&lt;/button&gt;
                    &lt;button class=&quot;neural-btn danger-btn&quot; onclick=&quot;resetGame()&quot; data-lang=&quot;new_journey&quot;&gt;🔄 Nouveau Voyage&lt;/button&gt;
                &lt;/div&gt;

                &lt;!-- Section Quêtes --&gt;
                &lt;div class=&quot;panel-section&quot;&gt;
                    &lt;div class=&quot;panel-title&quot; data-lang=&quot;active_missions&quot;&gt;🎯 Missions Actives&lt;/div&gt;
                    &lt;div id=&quot;questList&quot;&gt;
                        &lt;div class=&quot;quest-item&quot; onclick=&quot;selectQuest(0)&quot;&gt;
                            &lt;div class=&quot;quest-title&quot; data-lang=&quot;neural_awakening&quot;&gt;Éveil Neural&lt;/div&gt;
                            &lt;div class=&quot;quest-description&quot; data-lang=&quot;neural_awakening_desc&quot;&gt;Collectez 5 cristaux de mémoire pour activer votre premier nœud neural.&lt;/div&gt;
                            &lt;div class=&quot;progress-bar&quot;&gt;
                                &lt;div class=&quot;progress-fill&quot; style=&quot;width: 0%&quot; id=&quot;quest0Progress&quot;&gt;&lt;/div&gt;
                            &lt;/div&gt;
                        &lt;/div&gt;
                        &lt;div class=&quot;quest-item&quot; onclick=&quot;selectQuest(1)&quot;&gt;
                            &lt;div class=&quot;quest-title&quot; data-lang=&quot;ai_connection&quot;&gt;Connexion IA&lt;/div&gt;
                            &lt;div class=&quot;quest-description&quot; data-lang=&quot;ai_connection_desc&quot;&gt;Établissez le contact avec 3 entités IA dans la forêt mystique.&lt;/div&gt;
                            &lt;div class=&quot;progress-bar&quot;&gt;
                                &lt;div class=&quot;progress-fill&quot; style=&quot;width: 0%&quot; id=&quot;quest1Progress&quot;&gt;&lt;/div&gt;
                            &lt;/div&gt;
                        &lt;/div&gt;
                        &lt;div class=&quot;quest-item&quot; onclick=&quot;selectQuest(2)&quot;&gt;
                            &lt;div class=&quot;quest-title&quot; data-lang=&quot;puzzle_master&quot;&gt;Maître des Énigmes&lt;/div&gt;
                            &lt;div class=&quot;quest-description&quot; data-lang=&quot;puzzle_master_desc&quot;&gt;Résolvez 10 énigmes neurales pour débloquer de nouveaux pouvoirs.&lt;/div&gt;
                            &lt;div class=&quot;progress-bar&quot;&gt;
                                &lt;div class=&quot;progress-fill&quot; style=&quot;width: 0%&quot; id=&quot;quest2Progress&quot;&gt;&lt;/div&gt;
                            &lt;/div&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                &lt;/div&gt;

                &lt;!-- Section Inventaire --&gt;
                &lt;div class=&quot;panel-section&quot;&gt;
                    &lt;div class=&quot;panel-title&quot; data-lang=&quot;neural_inventory&quot;&gt;🎒 Inventaire Neural&lt;/div&gt;
                    &lt;div class=&quot;inventory-grid&quot; id=&quot;inventoryGrid&quot;&gt;
                        &lt;!-- Les slots d&#x27;inventaire seront générés dynamiquement --&gt;
                    &lt;/div&gt;
                &lt;/div&gt;

                &lt;!-- Section Minimap --&gt;
                &lt;div class=&quot;panel-section&quot;&gt;
                    &lt;div class=&quot;panel-title&quot; data-lang=&quot;neural_map&quot;&gt;🗺️ Carte Neural&lt;/div&gt;
                    &lt;div class=&quot;minimap&quot; id=&quot;minimap&quot;&gt;
                        &lt;!-- Les points de la minimap seront générés dynamiquement --&gt;
                    &lt;/div&gt;
                &lt;/div&gt;

                &lt;!-- Section IA Assistant --&gt;
                &lt;div class=&quot;panel-section&quot;&gt;
                    &lt;div class=&quot;panel-title&quot; data-lang=&quot;assistant_aria&quot;&gt;🤖 Assistant ARIA&lt;/div&gt;
                    &lt;div class=&quot;ai-chat&quot; id=&quot;aiChat&quot;&gt;
                        &lt;div class=&quot;chat-message ai&quot; data-lang=&quot;welcome_message&quot;&gt;
                            Bienvenue, Explorateur Neural ! Je suis ARIA, votre assistant IA. Prêt à explorer les mystères de la forêt quantique ?
                        &lt;/div&gt;
                    &lt;/div&gt;
                    &lt;button class=&quot;neural-btn success-btn&quot; onclick=&quot;askAI()&quot; data-lang=&quot;talk_to_aria&quot;&gt;💬 Parler à ARIA&lt;/button&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;!-- Modal pour les énigmes --&gt;
    &lt;div class=&quot;modal&quot; id=&quot;puzzleModal&quot;&gt;
        &lt;div class=&quot;modal-content&quot;&gt;
            &lt;div class=&quot;modal-title&quot; id=&quot;puzzleTitle&quot; data-lang=&quot;neural_puzzle&quot;&gt;Énigme Neural&lt;/div&gt;
            &lt;div class=&quot;modal-text&quot; id=&quot;puzzleDescription&quot; data-lang=&quot;puzzle_description&quot;&gt;Résolvez cette énigme pour progresser...&lt;/div&gt;
            &lt;div style=&quot;text-align: center; margin: 10px 0; color: #00ffff; font-weight: bold;&quot;&gt;
                &lt;span data-lang=&quot;moves_left&quot;&gt;Mouvements restants&lt;/span&gt;: &lt;span id=&quot;movesCounter&quot;&gt;5&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class=&quot;puzzle-grid&quot; id=&quot;puzzleGrid&quot;&gt;
                &lt;!-- La grille de puzzle sera générée dynamiquement --&gt;
            &lt;/div&gt;
            &lt;div style=&quot;display: flex; gap: 10px; justify-content: center; margin-top: 20px;&quot;&gt;
                &lt;button class=&quot;neural-btn success-btn&quot; onclick=&quot;solvePuzzle()&quot; data-lang=&quot;validate&quot;&gt;✓ Valider&lt;/button&gt;
                &lt;button class=&quot;neural-btn danger-btn&quot; onclick=&quot;closePuzzle()&quot; data-lang=&quot;close&quot;&gt;✗ Fermer&lt;/button&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;!-- Affichage des messages --&gt;
    &lt;div class=&quot;message-display&quot; id=&quot;messageDisplay&quot;&gt;&lt;/div&gt;

    &lt;script&gt;
        // Système de traduction multilingue
        const translations = {
            fr: {
                level: &quot;Niveau&quot;,
                xp: &quot;XP&quot;,
                energy: &quot;Énergie&quot;,
                crystals: &quot;Cristaux&quot;,
                time: &quot;Temps&quot;,
                active_missions: &quot;🎯 Missions Actives&quot;,
                neural_awakening: &quot;Éveil Neural&quot;,
                neural_awakening_desc: &quot;Collectez 5 cristaux de mémoire pour activer votre premier nœud neural.&quot;,
                ai_connection: &quot;Connexion IA&quot;,
                ai_connection_desc: &quot;Établissez le contact avec 3 entités IA dans la forêt mystique.&quot;,
                puzzle_master: &quot;Maître des Énigmes&quot;,
                puzzle_master_desc: &quot;Résolvez 10 énigmes neurales pour débloquer de nouveaux pouvoirs.&quot;,
                neural_inventory: &quot;🎒 Inventaire Neural&quot;,
                neural_map: &quot;🗺️ Carte Neural&quot;,
                assistant_aria: &quot;🤖 Assistant ARIA&quot;,
                welcome_message: &quot;Bienvenue, Explorateur Neural ! Je suis ARIA, votre assistant IA. Prêt à explorer les mystères de la forêt quantique ?&quot;,
                talk_to_aria: &quot;💬 Parler à ARIA&quot;,
                game_guide: &quot;📖 Guide de Jeu&quot;,
                how_to_play: &quot;🎮 COMMENT JOUER :&quot;,
                guide_crystals: &quot;• Cliquez sur les 💎 cristaux pour les collecter&quot;,
                guide_nodes: &quot;• Activez les 🧠 nœuds neuraux (2 cristaux requis)&quot;,
                guide_ai: &quot;• Parlez aux 🤖 entités IA pour progresser&quot;,
                guide_puzzles: &quot;• Résolvez les énigmes pour gagner de l&#x27;XP&quot;,
                guide_scan: &quot;• Utilisez ESPACE pour scanner la zone&quot;,
                guide_meditate: &quot;• Appuyez sur M pour méditer&quot;,
                objectives: &quot;🏆 OBJECTIFS :&quot;,
                obj_crystals: &quot;• Collectez 5 cristaux de mémoire&quot;,
                obj_ai: &quot;• Connectez-vous à 3 entités IA&quot;,
                obj_puzzles: &quot;• Résolvez 10 énigmes neurales&quot;,
                actions: &quot;⚡ Actions&quot;,
                scan_area: &quot;🔍 Scanner Zone&quot;,
                neural_meditation: &quot;🧘 Méditation Neural&quot;,
                save: &quot;💾 Sauvegarder&quot;,
                new_journey: &quot;🔄 Nouveau Voyage&quot;,
                neural_puzzle: &quot;Énigme Neural&quot;,
                puzzle_description: &quot;Résolvez cette énigme pour progresser...&quot;,
                validate: &quot;✓ Valider&quot;,
                close: &quot;✗ Fermer&quot;,
                start_game: &quot;🎮 Commencer le Jeu&quot;,
                pause_game: &quot;⏸️ Pause&quot;,
                resume_game: &quot;▶️ Reprendre&quot;,
                moves_left: &quot;Mouvements restants&quot;,
                puzzle_failed: &quot;❌ Échec ! Plus de mouvements disponibles.&quot;,
                try_again: &quot;Essayez à nouveau&quot;,
                puzzle_success: &quot;🎉 Parfait ! Énigme résolue !&quot;,
                next_level: &quot;Niveau suivant&quot;
            },
            en: {
                level: &quot;Level&quot;,
                xp: &quot;XP&quot;,
                energy: &quot;Energy&quot;,
                crystals: &quot;Crystals&quot;,
                time: &quot;Time&quot;,
                active_missions: &quot;🎯 Active Missions&quot;,
                neural_awakening: &quot;Neural Awakening&quot;,
                neural_awakening_desc: &quot;Collect 5 memory crystals to activate your first neural node.&quot;,
                ai_connection: &quot;AI Connection&quot;,
                ai_connection_desc: &quot;Establish contact with 3 AI entities in the mystical forest.&quot;,
                puzzle_master: &quot;Puzzle Master&quot;,
                puzzle_master_desc: &quot;Solve 10 neural puzzles to unlock new powers.&quot;,
                neural_inventory: &quot;🎒 Neural Inventory&quot;,
                neural_map: &quot;🗺️ Neural Map&quot;,
                assistant_aria: &quot;🤖 Assistant ARIA&quot;,
                welcome_message: &quot;Welcome, Neural Explorer! I am ARIA, your AI assistant. Ready to explore the mysteries of the quantum forest?&quot;,
                talk_to_aria: &quot;💬 Talk to ARIA&quot;,
                game_guide: &quot;📖 Game Guide&quot;,
                how_to_play: &quot;🎮 HOW TO PLAY:&quot;,
                guide_crystals: &quot;• Click on 💎 crystals to collect them&quot;,
                guide_nodes: &quot;• Activate 🧠 neural nodes (2 crystals required)&quot;,
                guide_ai: &quot;• Talk to 🤖 AI entities to progress&quot;,
                guide_puzzles: &quot;• Solve puzzles to gain XP&quot;,
                guide_scan: &quot;• Use SPACE to scan the area&quot;,
                guide_meditate: &quot;• Press M to meditate&quot;,
                objectives: &quot;🏆 OBJECTIVES:&quot;,
                obj_crystals: &quot;• Collect 5 memory crystals&quot;,
                obj_ai: &quot;• Connect to 3 AI entities&quot;,
                obj_puzzles: &quot;• Solve 10 neural puzzles&quot;,
                actions: &quot;⚡ Actions&quot;,
                scan_area: &quot;🔍 Scan Area&quot;,
                neural_meditation: &quot;🧘 Neural Meditation&quot;,
                save: &quot;💾 Save&quot;,
                new_journey: &quot;🔄 New Journey&quot;,
                neural_puzzle: &quot;Neural Puzzle&quot;,
                puzzle_description: &quot;Solve this puzzle to progress...&quot;,
                validate: &quot;✓ Validate&quot;,
                close: &quot;✗ Close&quot;,
                start_game: &quot;🎮 Start Game&quot;,
                pause_game: &quot;⏸️ Pause&quot;,
                resume_game: &quot;▶️ Resume&quot;,
                moves_left: &quot;Moves left&quot;,
                puzzle_failed: &quot;❌ Failed! No more moves available.&quot;,
                try_again: &quot;Try again&quot;,
                puzzle_success: &quot;🎉 Perfect! Puzzle solved!&quot;,
                next_level: &quot;Next level&quot;
            },
            ar: {
                level: &quot;المستوى&quot;,
                xp: &quot;نقاط الخبرة&quot;,
                energy: &quot;الطاقة&quot;,
                crystals: &quot;البلورات&quot;,
                time: &quot;الوقت&quot;,
                active_missions: &quot;🎯 المهام النشطة&quot;,
                neural_awakening: &quot;الصحوة العصبية&quot;,
                neural_awakening_desc: &quot;اجمع 5 بلورات ذاكرة لتفعيل أول عقدة عصبية لك.&quot;,
                ai_connection: &quot;اتصال الذكاء الاصطناعي&quot;,
                ai_connection_desc: &quot;أقم اتصالاً مع 3 كيانات ذكاء اصطناعي في الغابة الصوفية.&quot;,
                puzzle_master: &quot;سيد الألغاز&quot;,
                puzzle_master_desc: &quot;حل 10 ألغاز عصبية لفتح قوى جديدة.&quot;,
                neural_inventory: &quot;🎒 المخزون العصبي&quot;,
                neural_map: &quot;🗺️ الخريطة العصبية&quot;,
                assistant_aria: &quot;🤖 المساعد آريا&quot;,
                welcome_message: &quot;مرحباً، المستكشف العصبي! أنا آريا، مساعدك الذكي. هل أنت مستعد لاستكشاف أسرار الغابة الكمية؟&quot;,
                talk_to_aria: &quot;💬 تحدث مع آريا&quot;,
                game_guide: &quot;📖 دليل اللعبة&quot;,
                how_to_play: &quot;🎮 كيفية اللعب:&quot;,
                guide_crystals: &quot;• انقر على البلورات 💎 لجمعها&quot;,
                guide_nodes: &quot;• فعّل العقد العصبية 🧠 (مطلوب بلورتان)&quot;,
                guide_ai: &quot;• تحدث مع كيانات الذكاء الاصطناعي 🤖 للتقدم&quot;,
                guide_puzzles: &quot;• حل الألغاز لكسب نقاط الخبرة&quot;,
                guide_scan: &quot;• استخدم مفتاح المسافة لمسح المنطقة&quot;,
                guide_meditate: &quot;• اضغط M للتأمل&quot;,
                objectives: &quot;🏆 الأهداف:&quot;,
                obj_crystals: &quot;• اجمع 5 بلورات ذاكرة&quot;,
                obj_ai: &quot;• اتصل بـ 3 كيانات ذكاء اصطناعي&quot;,
                obj_puzzles: &quot;• حل 10 ألغاز عصبية&quot;,
                actions: &quot;⚡ الإجراءات&quot;,
                scan_area: &quot;🔍 مسح المنطقة&quot;,
                neural_meditation: &quot;🧘 التأمل العصبي&quot;,
                save: &quot;💾 حفظ&quot;,
                new_journey: &quot;🔄 رحلة جديدة&quot;,
                neural_puzzle: &quot;اللغز العصبي&quot;,
                puzzle_description: &quot;حل هذا اللغز للتقدم...&quot;,
                validate: &quot;✓ تأكيد&quot;,
                close: &quot;✗ إغلاق&quot;,
                start_game: &quot;🎮 بدء اللعبة&quot;,
                pause_game: &quot;⏸️ إيقاف مؤقت&quot;,
                resume_game: &quot;▶️ استئناف&quot;,
                moves_left: &quot;الحركات المتبقية&quot;,
                puzzle_failed: &quot;❌ فشل! لا توجد حركات متاحة.&quot;,
                try_again: &quot;حاول مرة أخرى&quot;,
                puzzle_success: &quot;🎉 مثالي! تم حل اللغز!&quot;,
                next_level: &quot;المستوى التالي&quot;
            },
            es: {
                level: &quot;Nivel&quot;,
                xp: &quot;XP&quot;,
                energy: &quot;Energía&quot;,
                crystals: &quot;Cristales&quot;,
                time: &quot;Tiempo&quot;,
                active_missions: &quot;🎯 Misiones Activas&quot;,
                neural_awakening: &quot;Despertar Neural&quot;,
                neural_awakening_desc: &quot;Recolecta 5 cristales de memoria para activar tu primer nodo neural.&quot;,
                ai_connection: &quot;Conexión IA&quot;,
                ai_connection_desc: &quot;Establece contacto con 3 entidades IA en el bosque místico.&quot;,
                puzzle_master: &quot;Maestro de Enigmas&quot;,
                puzzle_master_desc: &quot;Resuelve 10 enigmas neurales para desbloquear nuevos poderes.&quot;,
                neural_inventory: &quot;🎒 Inventario Neural&quot;,
                neural_map: &quot;🗺️ Mapa Neural&quot;,
                assistant_aria: &quot;🤖 Asistente ARIA&quot;,
                welcome_message: &quot;¡Bienvenido, Explorador Neural! Soy ARIA, tu asistente IA. ¿Listo para explorar los misterios del bosque cuántico?&quot;,
                talk_to_aria: &quot;💬 Hablar con ARIA&quot;,
                game_guide: &quot;📖 Guía del Juego&quot;,
                how_to_play: &quot;🎮 CÓMO JUGAR:&quot;,
                guide_crystals: &quot;• Haz clic en los cristales 💎 para recolectarlos&quot;,
                guide_nodes: &quot;• Activa los nodos neurales 🧠 (2 cristales requeridos)&quot;,
                guide_ai: &quot;• Habla con las entidades IA 🤖 para progresar&quot;,
                guide_puzzles: &quot;• Resuelve enigmas para ganar XP&quot;,
                guide_scan: &quot;• Usa ESPACIO para escanear el área&quot;,
                guide_meditate: &quot;• Presiona M para meditar&quot;,
                objectives: &quot;🏆 OBJETIVOS:&quot;,
                obj_crystals: &quot;• Recolecta 5 cristales de memoria&quot;,
                obj_ai: &quot;• Conéctate con 3 entidades IA&quot;,
                obj_puzzles: &quot;• Resuelve 10 enigmas neurales&quot;,
                actions: &quot;⚡ Acciones&quot;,
                scan_area: &quot;🔍 Escanear Área&quot;,
                neural_meditation: &quot;🧘 Meditación Neural&quot;,
                save: &quot;💾 Guardar&quot;,
                new_journey: &quot;🔄 Nuevo Viaje&quot;,
                neural_puzzle: &quot;Enigma Neural&quot;,
                puzzle_description: &quot;Resuelve este enigma para progresar...&quot;,
                validate: &quot;✓ Validar&quot;,
                close: &quot;✗ Cerrar&quot;,
                start_game: &quot;🎮 Iniciar Juego&quot;,
                pause_game: &quot;⏸️ Pausa&quot;,
                resume_game: &quot;▶️ Reanudar&quot;,
                moves_left: &quot;Movimientos restantes&quot;,
                puzzle_failed: &quot;❌ ¡Fallido! No hay más movimientos disponibles.&quot;,
                try_again: &quot;Inténtalo de nuevo&quot;,
                puzzle_success: &quot;🎉 ¡Perfecto! ¡Enigma resuelto!&quot;,
                next_level: &quot;Siguiente nivel&quot;
            },
            de: {
                level: &quot;Level&quot;,
                xp: &quot;EP&quot;,
                energy: &quot;Energie&quot;,
                crystals: &quot;Kristalle&quot;,
                time: &quot;Zeit&quot;,
                active_missions: &quot;🎯 Aktive Missionen&quot;,
                neural_awakening: &quot;Neurales Erwachen&quot;,
                neural_awakening_desc: &quot;Sammle 5 Gedächtniskristalle, um deinen ersten neuralen Knoten zu aktivieren.&quot;,
                ai_connection: &quot;KI-Verbindung&quot;,
                ai_connection_desc: &quot;Stelle Kontakt zu 3 KI-Entitäten im mystischen Wald her.&quot;,
                puzzle_master: &quot;Rätselmeister&quot;,
                puzzle_master_desc: &quot;Löse 10 neurale Rätsel, um neue Kräfte freizuschalten.&quot;,
                neural_inventory: &quot;🎒 Neurales Inventar&quot;,
                neural_map: &quot;🗺️ Neurale Karte&quot;,
                assistant_aria: &quot;🤖 Assistent ARIA&quot;,
                welcome_message: &quot;Willkommen, Neuraler Entdecker! Ich bin ARIA, dein KI-Assistent. Bereit, die Geheimnisse des Quantenwaldes zu erkunden?&quot;,
                talk_to_aria: &quot;💬 Mit ARIA sprechen&quot;,
                game_guide: &quot;📖 Spielanleitung&quot;,
                how_to_play: &quot;🎮 WIE MAN SPIELT:&quot;,
                guide_crystals: &quot;• Klicke auf die Kristalle 💎, um sie zu sammeln&quot;,
                guide_nodes: &quot;• Aktiviere neurale Knoten 🧠 (2 Kristalle erforderlich)&quot;,
                guide_ai: &quot;• Sprich mit KI-Entitäten 🤖, um voranzukommen&quot;,
                guide_puzzles: &quot;• Löse Rätsel, um EP zu gewinnen&quot;,
                guide_scan: &quot;• Verwende LEERTASTE, um das Gebiet zu scannen&quot;,
                guide_meditate: &quot;• Drücke M zum Meditieren&quot;,
                objectives: &quot;🏆 ZIELE:&quot;,
                obj_crystals: &quot;• Sammle 5 Gedächtniskristalle&quot;,
                obj_ai: &quot;• Verbinde dich mit 3 KI-Entitäten&quot;,
                obj_puzzles: &quot;• Löse 10 neurale Rätsel&quot;,
                actions: &quot;⚡ Aktionen&quot;,
                scan_area: &quot;🔍 Gebiet scannen&quot;,
                neural_meditation: &quot;🧘 Neurale Meditation&quot;,
                save: &quot;💾 Speichern&quot;,
                new_journey: &quot;🔄 Neue Reise&quot;,
                neural_puzzle: &quot;Neurales Rätsel&quot;,
                puzzle_description: &quot;Löse dieses Rätsel, um voranzukommen...&quot;,
                validate: &quot;✓ Bestätigen&quot;,
                close: &quot;✗ Schließen&quot;,
                start_game: &quot;🎮 Spiel Starten&quot;,
                pause_game: &quot;⏸️ Pause&quot;,
                resume_game: &quot;▶️ Fortsetzen&quot;,
                moves_left: &quot;Züge übrig&quot;,
                puzzle_failed: &quot;❌ Gescheitert! Keine Züge mehr verfügbar.&quot;,
                try_again: &quot;Versuche es erneut&quot;,
                puzzle_success: &quot;🎉 Perfekt! Rätsel gelöst!&quot;,
                next_level: &quot;Nächstes Level&quot;
            },
            zh: {
                level: &quot;等级&quot;,
                xp: &quot;经验值&quot;,
                energy: &quot;能量&quot;,
                crystals: &quot;水晶&quot;,
                time: &quot;时间&quot;,
                active_missions: &quot;🎯 活跃任务&quot;,
                neural_awakening: &quot;神经觉醒&quot;,
                neural_awakening_desc: &quot;收集5个记忆水晶来激活你的第一个神经节点。&quot;,
                ai_connection: &quot;AI连接&quot;,
                ai_connection_desc: &quot;在神秘森林中与3个AI实体建立联系。&quot;,
                puzzle_master: &quot;谜题大师&quot;,
                puzzle_master_desc: &quot;解决10个神经谜题来解锁新能力。&quot;,
                neural_inventory: &quot;🎒 神经背包&quot;,
                neural_map: &quot;🗺️ 神经地图&quot;,
                assistant_aria: &quot;🤖 助手ARIA&quot;,
                welcome_message: &quot;欢迎，神经探索者！我是ARIA，你的AI助手。准备好探索量子森林的奥秘了吗？&quot;,
                talk_to_aria: &quot;💬 与ARIA对话&quot;,
                game_guide: &quot;📖 游戏指南&quot;,
                how_to_play: &quot;🎮 如何游戏：&quot;,
                guide_crystals: &quot;• 点击💎水晶来收集它们&quot;,
                guide_nodes: &quot;• 激活🧠神经节点（需要2个水晶）&quot;,
                guide_ai: &quot;• 与🤖AI实体对话来进步&quot;,
                guide_puzzles: &quot;• 解决谜题来获得经验值&quot;,
                guide_scan: &quot;• 使用空格键扫描区域&quot;,
                guide_meditate: &quot;• 按M键冥想&quot;,
                objectives: &quot;🏆 目标：&quot;,
                obj_crystals: &quot;• 收集5个记忆水晶&quot;,
                obj_ai: &quot;• 连接3个AI实体&quot;,
                obj_puzzles: &quot;• 解决10个神经谜题&quot;,
                actions: &quot;⚡ 行动&quot;,
                scan_area: &quot;🔍 扫描区域&quot;,
                neural_meditation: &quot;🧘 神经冥想&quot;,
                save: &quot;💾 保存&quot;,
                new_journey: &quot;🔄 新旅程&quot;,
                neural_puzzle: &quot;神经谜题&quot;,
                puzzle_description: &quot;解决这个谜题来进步...&quot;,
                validate: &quot;✓ 验证&quot;,
                close: &quot;✗ 关闭&quot;,
                start_game: &quot;🎮 开始游戏&quot;,
                pause_game: &quot;⏸️ 暂停&quot;,
                resume_game: &quot;▶️ 继续&quot;,
                moves_left: &quot;剩余移动&quot;,
                puzzle_failed: &quot;❌ 失败！没有更多移动可用。&quot;,
                try_again: &quot;再试一次&quot;,
                puzzle_success: &quot;🎉 完美！谜题解决！&quot;,
                next_level: &quot;下一关&quot;
            }
        };

        let currentLanguage = &#x27;fr&#x27;;

        // Fonction pour changer la langue
        function changeLanguage(lang) {
            currentLanguage = lang;
            
            // Appliquer la direction RTL pour l&#x27;arabe
            if (lang === &#x27;ar&#x27;) {
                document.body.classList.add(&#x27;rtl&#x27;);
                document.documentElement.setAttribute(&#x27;dir&#x27;, &#x27;rtl&#x27;);
            } else {
                document.body.classList.remove(&#x27;rtl&#x27;);
                document.documentElement.setAttribute(&#x27;dir&#x27;, &#x27;ltr&#x27;);
            }
            
            // Mettre à jour tous les éléments avec data-lang
            const elements = document.querySelectorAll(&#x27;[data-lang]&#x27;);
            elements.forEach(element =&gt; {
                const key = element.getAttribute(&#x27;data-lang&#x27;);
                if (translations[lang] &amp;&amp; translations[lang][key]) {
                    element.textContent = translations[lang][key];
                }
            });
            
            // Mettre à jour les boutons de contrôle du jeu
            updateGameControlButtons();
            
            // Sauvegarder la langue choisie
            localStorage.setItem(&#x27;neurosynthLanguage&#x27;, lang);
            
            // Mettre à jour les messages dynamiques
            updateDynamicMessages();
        }

        // Fonction pour obtenir une traduction
        function t(key) {
            return translations[currentLanguage] &amp;&amp; translations[currentLanguage][key] 
                ? translations[currentLanguage][key] 
                : translations[&#x27;fr&#x27;][key] || key;
        }

        // Messages dynamiques traduits
        const dynamicMessages = {
            fr: {
                welcome: &quot;🌟 Bienvenue dans NeuroSynth Explorer ! Explorez la forêt quantique et éveillez votre conscience neural.&quot;,
                tree_messages: [
                    &quot;🌳 Cet arbre ancien pulse d&#x27;énergie quantique...&quot;,
                    &quot;🍃 Les feuilles murmurent des secrets neuraux...&quot;,
                    &quot;🌿 Vous ressentez une connexion profonde avec la nature digitale...&quot;,
                    &quot;🌲 L&#x27;arbre semble réagir à votre présence neural...&quot;
                ],
                crystal_collected: &quot;💎 Cristal de mémoire collecté ! Énergie neural +10 XP&quot;,
                node_locked: &quot;🔒 Vous avez besoin de 2 cristaux de mémoire pour activer ce nœud neural.&quot;,
                ai_messages: [
                    &quot;🤖 Salutations, être neural. Je détecte un potentiel quantique élevé en vous.&quot;,
                    &quot;🔮 Vos ondes cérébrales résonnent avec la fréquence de la forêt mystique.&quot;,
                    &quot;⚡ Connexion établie. Transfert de données neurales en cours...&quot;,
                    &quot;🌟 Votre évolution neural progresse admirablement, explorateur.&quot;,
                    &quot;🧬 Les patterns de votre conscience s&#x27;alignent avec la matrice universelle.&quot;
                ]
            },
            en: {
                welcome: &quot;🌟 Welcome to NeuroSynth Explorer! Explore the quantum forest and awaken your neural consciousness.&quot;,
                tree_messages: [
                    &quot;🌳 This ancient tree pulses with quantum energy...&quot;,
                    &quot;🍃 The leaves whisper neural secrets...&quot;,
                    &quot;🌿 You feel a deep connection with digital nature...&quot;,
                    &quot;🌲 The tree seems to react to your neural presence...&quot;
                ],
                crystal_collected: &quot;💎 Memory crystal collected! Neural energy +10 XP&quot;,
                node_locked: &quot;🔒 You need 2 memory crystals to activate this neural node.&quot;,
                ai_messages: [
                    &quot;🤖 Greetings, neural being. I detect high quantum potential in you.&quot;,
                    &quot;🔮 Your brain waves resonate with the mystical forest frequency.&quot;,
                    &quot;⚡ Connection established. Neural data transfer in progress...&quot;,
                    &quot;🌟 Your neural evolution progresses admirably, explorer.&quot;,
                    &quot;🧬 Your consciousness patterns align with the universal matrix.&quot;
                ]
            },
            ar: {
                welcome: &quot;🌟 مرحباً بك في مستكشف NeuroSynth! استكشف الغابة الكمية وأيقظ وعيك العصبي.&quot;,
                tree_messages: [
                    &quot;🌳 هذه الشجرة القديمة تنبض بالطاقة الكمية...&quot;,
                    &quot;🍃 الأوراق تهمس بأسرار عصبية...&quot;,
                    &quot;🌿 تشعر بارتباط عميق مع الطبيعة الرقمية...&quot;,
                    &quot;🌲 الشجرة تبدو وكأنها تتفاعل مع حضورك العصبي...&quot;
                ],
                crystal_collected: &quot;💎 تم جمع بلورة الذاكرة! طاقة عصبية +10 نقطة خبرة&quot;,
                node_locked: &quot;🔒 تحتاج إلى بلورتي ذاكرة لتفعيل هذه العقدة العصبية.&quot;,
                ai_messages: [
                    &quot;🤖 تحياتي، الكائن العصبي. أكتشف إمكانات كمية عالية فيك.&quot;,
                    &quot;🔮 موجات دماغك تتردد مع تردد الغابة الصوفية.&quot;,
                    &quot;⚡ تم إنشاء الاتصال. نقل البيانات العصبية قيد التقدم...&quot;,
                    &quot;🌟 تطورك العصبي يتقدم بشكل رائع، أيها المستكشف.&quot;,
                    &quot;🧬 أنماط وعيك تتماشى مع المصفوفة الكونية.&quot;
                ]
            },
            es: {
                welcome: &quot;🌟 ¡Bienvenido a NeuroSynth Explorer! Explora el bosque cuántico y despierta tu conciencia neural.&quot;,
                tree_messages: [
                    &quot;🌳 Este árbol ancestral pulsa con energía cuántica...&quot;,
                    &quot;🍃 Las hojas susurran secretos neurales...&quot;,
                    &quot;🌿 Sientes una conexión profunda con la naturaleza digital...&quot;,
                    &quot;🌲 El árbol parece reaccionar a tu presencia neural...&quot;
                ],
                crystal_collected: &quot;💎 ¡Cristal de memoria recolectado! Energía neural +10 XP&quot;,
                node_locked: &quot;🔒 Necesitas 2 cristales de memoria para activar este nodo neural.&quot;,
                ai_messages: [
                    &quot;🤖 Saludos, ser neural. Detecto alto potencial cuántico en ti.&quot;,
                    &quot;🔮 Tus ondas cerebrales resuenan con la frecuencia del bosque místico.&quot;,
                    &quot;⚡ Conexión establecida. Transferencia de datos neurales en progreso...&quot;,
                    &quot;🌟 Tu evolución neural progresa admirablemente, explorador.&quot;,
                    &quot;🧬 Los patrones de tu conciencia se alinean con la matriz universal.&quot;
                ]
            },
            de: {
                welcome: &quot;🌟 Willkommen bei NeuroSynth Explorer! Erkunde den Quantenwald und erwecke dein neurales Bewusstsein.&quot;,
                tree_messages: [
                    &quot;🌳 Dieser uralte Baum pulsiert mit Quantenenergie...&quot;,
                    &quot;🍃 Die Blätter flüstern neurale Geheimnisse...&quot;,
                    &quot;🌿 Du spürst eine tiefe Verbindung zur digitalen Natur...&quot;,
                    &quot;🌲 Der Baum scheint auf deine neurale Präsenz zu reagieren...&quot;
                ],
                crystal_collected: &quot;💎 Gedächtniskristall gesammelt! Neurale Energie +10 EP&quot;,
                node_locked: &quot;🔒 Du benötigst 2 Gedächtniskristalle, um diesen neuralen Knoten zu aktivieren.&quot;,
                ai_messages: [
                    &quot;🤖 Grüße, neurales Wesen. Ich erkenne hohes Quantenpotential in dir.&quot;,
                    &quot;🔮 Deine Gehirnwellen resonieren mit der Frequenz des mystischen Waldes.&quot;,
                    &quot;⚡ Verbindung hergestellt. Neuraler Datentransfer läuft...&quot;,
                    &quot;🌟 Deine neurale Evolution schreitet bewundernswert voran, Entdecker.&quot;,
                    &quot;🧬 Die Muster deines Bewusstseins richten sich an der universellen Matrix aus.&quot;
                ]
            },
            zh: {
                welcome: &quot;🌟 欢迎来到NeuroSynth Explorer！探索量子森林，唤醒你的神经意识。&quot;,
                tree_messages: [
                    &quot;🌳 这棵古老的树脉动着量子能量...&quot;,
                    &quot;🍃 叶子低语着神经秘密...&quot;,
                    &quot;🌿 你感受到与数字自然的深层连接...&quot;,
                    &quot;🌲 这棵树似乎对你的神经存在有反应...&quot;
                ],
                crystal_collected: &quot;💎 记忆水晶已收集！神经能量 +10 经验值&quot;,
                node_locked: &quot;🔒 你需要2个记忆水晶来激活这个神经节点。&quot;,
                ai_messages: [
                    &quot;🤖 问候，神经存在。我在你身上检测到高量子潜力。&quot;,
                    &quot;🔮 你的脑波与神秘森林的频率共鸣。&quot;,
                    &quot;⚡ 连接已建立。神经数据传输进行中...&quot;,
                    &quot;🌟 你的神经进化进展令人钦佩，探索者。&quot;,
                    &quot;🧬 你的意识模式与宇宙矩阵对齐。&quot;
                ]
            }
        };

        function updateDynamicMessages() {
            // Cette fonction sera appelée quand on change de langue
            // pour mettre à jour les messages qui ne sont pas dans le DOM
        }

        function updateGameControlButtons() {
            const startBtn = document.getElementById(&#x27;startGameBtn&#x27;);
            const pauseBtn = document.getElementById(&#x27;pauseResumeBtn&#x27;);
            
            if (startBtn) {
                startBtn.textContent = t(&#x27;start_game&#x27;);
            }
            
            if (pauseBtn) {
                if (gameState.gamePaused) {
                    pauseBtn.textContent = t(&#x27;resume_game&#x27;);
                    pauseBtn.setAttribute(&#x27;data-lang&#x27;, &#x27;resume_game&#x27;);
                } else {
                    pauseBtn.textContent = t(&#x27;pause_game&#x27;);
                    pauseBtn.setAttribute(&#x27;data-lang&#x27;, &#x27;pause_game&#x27;);
                }
            }
        }

        function startGame() {
            if (!gameState.gameStarted) {
                gameState.gameStarted = true;
                gameState.startTime = Date.now();
                
                document.getElementById(&#x27;startGameBtn&#x27;).style.display = &#x27;none&#x27;;
                document.getElementById(&#x27;pauseResumeBtn&#x27;).style.display = &#x27;block&#x27;;
                
                const msg = currentLanguage === &#x27;fr&#x27; ? &quot;🎮 Jeu commencé ! Bonne exploration !&quot; :
                           currentLanguage === &#x27;en&#x27; ? &quot;🎮 Game started! Happy exploring!&quot; :
                           currentLanguage === &#x27;ar&#x27; ? &quot;🎮 بدأت اللعبة! استكشاف سعيد!&quot; :
                           currentLanguage === &#x27;es&#x27; ? &quot;🎮 ¡Juego iniciado! ¡Feliz exploración!&quot; :
                           currentLanguage === &#x27;de&#x27; ? &quot;🎮 Spiel gestartet! Viel Spaß beim Erkunden!&quot; :
                           &quot;🎮 游戏开始！愉快探索！&quot;;
                
                showMessage(msg);
                updateGameControlButtons();
            }
        }

        function togglePause() {
            if (!gameState.gameStarted) return;
            
            gameState.gamePaused = !gameState.gamePaused;
            
            if (gameState.gamePaused) {
                const msg = currentLanguage === &#x27;fr&#x27; ? &quot;⏸️ Jeu en pause&quot; :
                           currentLanguage === &#x27;en&#x27; ? &quot;⏸️ Game paused&quot; :
                           currentLanguage === &#x27;ar&#x27; ? &quot;⏸️ اللعبة متوقفة مؤقتاً&quot; :
                           currentLanguage === &#x27;es&#x27; ? &quot;⏸️ Juego pausado&quot; :
                           currentLanguage === &#x27;de&#x27; ? &quot;⏸️ Spiel pausiert&quot; :
                           &quot;⏸️ 游戏暂停&quot;;
                showMessage(msg);
            } else {
                const msg = currentLanguage === &#x27;fr&#x27; ? &quot;▶️ Jeu repris&quot; :
                           currentLanguage === &#x27;en&#x27; ? &quot;▶️ Game resumed&quot; :
                           currentLanguage === &#x27;ar&#x27; ? &quot;▶️ تم استئناف اللعبة&quot; :
                           currentLanguage === &#x27;es&#x27; ? &quot;▶️ Juego reanudado&quot; :
                           currentLanguage === &#x27;de&#x27; ? &quot;▶️ Spiel fortgesetzt&quot; :
                           &quot;▶️ 游戏继续&quot;;
                showMessage(msg);
            }
            
            updateGameControlButtons();
        }

        function getDynamicMessage(category, index = null) {
            const messages = dynamicMessages[currentLanguage] || dynamicMessages[&#x27;fr&#x27;];
            if (index !== null &amp;&amp; Array.isArray(messages[category])) {
                return messages[category][index] || messages[category][0];
            }
            return messages[category] || category;
        }

        // État du jeu
        let gameState = {
            player: {
                level: 1,
                xp: 0,
                energy: 100,
                maxEnergy: 100,
                position: { x: 50, y: 50 },
                crystals: 0,
                inventory: [],
                unlockedNodes: []
            },
            world: {
                trees: [],
                neuralNodes: [],
                memoryCrystals: [],
                aiEntities: [],
                connections: []
            },
            quests: [
                { id: 0, title: &quot;neural_awakening&quot;, progress: 0, target: 5, completed: false },
                { id: 1, title: &quot;ai_connection&quot;, progress: 0, target: 3, completed: false },
                { id: 2, title: &quot;puzzle_master&quot;, progress: 0, target: 10, completed: false }
            ],
            currentPuzzle: null,
            gameTime: 0,
            startTime: Date.now(),
            aiMessages: [],
            discoveredAreas: [],
            gameStarted: false,
            gamePaused: false,
            puzzleMovesLeft: 5
        };

        // Initialisation du jeu
        function initGame() {
            console.log(&quot;🧠 Initialisation de NeuroSynth Explorer...&quot;);
            
            // Charger la langue sauvegardée
            const savedLanguage = localStorage.getItem(&#x27;neurosynthLanguage&#x27;);
            if (savedLanguage) {
                currentLanguage = savedLanguage;
                document.getElementById(&#x27;languageSelect&#x27;).value = savedLanguage;
                changeLanguage(savedLanguage);
            }
            
            generateParticles();
            generateWorld();
            createInventorySlots();
            updateMinimap();
            startGameTimer();
            
            showMessage(getDynamicMessage(&#x27;welcome&#x27;));
            
            // Première interaction avec l&#x27;IA
            setTimeout(() =&gt; {
                addAIMessage(getDynamicMessage(&#x27;ai_messages&#x27;, 0));
            }, 3000);
        }

        // Génération des particules neurales
        function generateParticles() {
            const container = document.getElementById(&#x27;neuralParticles&#x27;);
            container.innerHTML = &#x27;&#x27;;
            
            for (let i = 0; i &lt; 50; i++) {
                const particle = document.createElement(&#x27;div&#x27;);
                particle.className = &#x27;particle&#x27;;
                particle.style.left = Math.random() * 100 + &#x27;%&#x27;;
                particle.style.top = Math.random() * 100 + &#x27;%&#x27;;
                particle.style.animationDelay = Math.random() * 8 + &#x27;s&#x27;;
                particle.style.animationDuration = (8 + Math.random() * 4) + &#x27;s&#x27;;
                container.appendChild(particle);
            }
        }

        // Génération du monde 3D
        function generateWorld() {
            const world = document.getElementById(&#x27;gameWorld&#x27;);
            
            // Nettoyer le monde existant (garder les couches de base)
            const existingElements = world.querySelectorAll(&#x27;.tree, .neural-node, .memory-crystal, .ai-entity&#x27;);
            existingElements.forEach(el =&gt; el.remove());
            
            // Générer les arbres
            for (let i = 0; i &lt; 15; i++) {
                createTree();
            }
            
            // Générer les nœuds neuraux
            for (let i = 0; i &lt; 8; i++) {
                createNeuralNode();
            }
            
            // Générer les cristaux de mémoire
            for (let i = 0; i &lt; 12; i++) {
                createMemoryCrystal();
            }
            
            // Générer les entités IA
            for (let i = 0; i &lt; 5; i++) {
                createAIEntity();
            }
            
            // Créer les connexions neurales
            setTimeout(() =&gt; {
                createNeuralConnections();
            }, 1000);
        }

        function createTree() {
            const tree = document.createElement(&#x27;div&#x27;);
            tree.className = &#x27;tree&#x27;;
            tree.style.left = Math.random() * 80 + 10 + &#x27;%&#x27;;
            tree.style.top = Math.random() * 70 + 15 + &#x27;%&#x27;;
            tree.style.transform = `rotateY(${Math.random() * 360}deg) rotateX(${Math.random() * 20 - 10}deg)`;
            tree.onclick = () =&gt; interactWithTree(tree);
            
            document.getElementById(&#x27;gameWorld&#x27;).appendChild(tree);
            gameState.world.trees.push(tree);
        }

        function createNeuralNode() {
            const node = document.createElement(&#x27;div&#x27;);
            node.className = &#x27;neural-node&#x27;;
            node.style.left = Math.random() * 85 + 5 + &#x27;%&#x27;;
            node.style.top = Math.random() * 75 + 10 + &#x27;%&#x27;;
            node.innerHTML = &#x27;🧠&#x27;;
            node.onclick = () =&gt; interactWithNeuralNode(node);
            
            document.getElementById(&#x27;gameWorld&#x27;).appendChild(node);
            gameState.world.neuralNodes.push(node);
        }

        function createMemoryCrystal() {
            const crystal = document.createElement(&#x27;div&#x27;);
            crystal.className = &#x27;memory-crystal&#x27;;
            crystal.style.left = Math.random() * 90 + 5 + &#x27;%&#x27;;
            crystal.style.top = Math.random() * 80 + 10 + &#x27;%&#x27;;
            crystal.onclick = () =&gt; collectCrystal(crystal);
            
            document.getElementById(&#x27;gameWorld&#x27;).appendChild(crystal);
            gameState.world.memoryCrystals.push(crystal);
        }

        function createAIEntity() {
            const entity = document.createElement(&#x27;div&#x27;);
            entity.className = &#x27;ai-entity&#x27;;
            entity.style.left = Math.random() * 75 + 10 + &#x27;%&#x27;;
            entity.style.top = Math.random() * 65 + 15 + &#x27;%&#x27;;
            entity.innerHTML = &#x27;🤖&#x27;;
            entity.onclick = () =&gt; interactWithAI(entity);
            
            document.getElementById(&#x27;gameWorld&#x27;).appendChild(entity);
            gameState.world.aiEntities.push(entity);
        }

        function createNeuralConnections() {
            const network = document.getElementById(&#x27;neuralNetwork&#x27;);
            network.innerHTML = &#x27;&#x27;;
            
            const nodes = gameState.world.neuralNodes;
            
            for (let i = 0; i &lt; nodes.length - 1; i++) {
                for (let j = i + 1; j &lt; nodes.length; j++) {
                    if (Math.random() &lt; 0.3) { // 30% de chance de connexion
                        createConnection(nodes[i], nodes[j]);
                    }
                }
            }
        }

        function createConnection(node1, node2) {
            const connection = document.createElement(&#x27;div&#x27;);
            connection.className = &#x27;neural-connection&#x27;;
            
            const rect1 = node1.getBoundingClientRect();
            const rect2 = node2.getBoundingClientRect();
            const worldRect = document.getElementById(&#x27;gameWorld&#x27;).getBoundingClientRect();
            
            const x1 = rect1.left - worldRect.left + rect1.width / 2;
            const y1 = rect1.top - worldRect.top + rect1.height / 2;
            const x2 = rect2.left - worldRect.left + rect2.width / 2;
            const y2 = rect2.top - worldRect.top + rect2.height / 2;
            
            const length = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
            const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;
            
            connection.style.left = x1 + &#x27;px&#x27;;
            connection.style.top = y1 + &#x27;px&#x27;;
            connection.style.width = length + &#x27;px&#x27;;
            connection.style.transform = `rotate(${angle}deg)`;
            connection.style.animationDelay = Math.random() * 3 + &#x27;s&#x27;;
            
            document.getElementById(&#x27;neuralNetwork&#x27;).appendChild(connection);
            gameState.world.connections.push(connection);
        }

        // Interactions avec les éléments du monde
        function interactWithTree(tree) {
            const messages = dynamicMessages[currentLanguage].tree_messages;
            const message = messages[Math.floor(Math.random() * messages.length)];
            showMessage(message);
            
            // Chance de trouver quelque chose
            if (Math.random() &lt; 0.3) {
                gainXP(5);
                showMessage(&quot;✨ &quot; + (currentLanguage === &#x27;fr&#x27; ? &quot;Vous gagnez de l&#x27;expérience en communiant avec l&#x27;arbre !&quot; :
                                   currentLanguage === &#x27;en&#x27; ? &quot;You gain experience by communing with the tree!&quot; :
                                   currentLanguage === &#x27;ar&#x27; ? &quot;تكسب خبرة من خلال التواصل مع الشجرة!&quot; :
                                   currentLanguage === &#x27;es&#x27; ? &quot;¡Ganas experiencia al comunicarte con el árbol!&quot; :
                                   currentLanguage === &#x27;de&#x27; ? &quot;Du gewinnst Erfahrung durch die Kommunikation mit dem Baum!&quot; :
                                   &quot;你通过与树木交流获得经验！&quot;));
            }
        }

        function interactWithNeuralNode(node) {
            if (gameState.player.crystals &gt;= 2) {
                // Ouvrir une énigme
                openPuzzle(&quot;neural&quot;);
                node.style.background = &#x27;radial-gradient(circle, rgba(0, 255, 0, 0.8) 0%, rgba(0, 200, 0, 0.4) 100%)&#x27;;
            } else {
                showMessage(getDynamicMessage(&#x27;node_locked&#x27;));
            }
        }

        function collectCrystal(crystal) {
            gameState.player.crystals++;
            gameState.quests[0].progress++;
            
            // Animation de collecte
            crystal.style.animation = &#x27;crystalSpin 0.5s ease-in-out&#x27;;
            crystal.style.transform = &#x27;scale(2)&#x27;;
            crystal.style.opacity = &#x27;0&#x27;;
            
            setTimeout(() =&gt; {
                crystal.remove();
                const index = gameState.world.memoryCrystals.indexOf(crystal);
                if (index &gt; -1) {
                    gameState.world.memoryCrystals.splice(index, 1);
                }
            }, 500);
            
            gainXP(10);
            showMessage(getDynamicMessage(&#x27;crystal_collected&#x27;));
            
            updateStats();
            updateQuestProgress();
            
            // Vérifier si la quête est terminée
            if (gameState.quests[0].progress &gt;= gameState.quests[0].target &amp;&amp; !gameState.quests[0].completed) {
                completeQuest(0);
            }
        }

        function interactWithAI(entity) {
            gameState.quests[1].progress++;
            
            const messages = dynamicMessages[currentLanguage].ai_messages;
            const message = messages[Math.floor(Math.random() * messages.length)];
            addAIMessage(message);
            
            const connectionMsg = currentLanguage === &#x27;fr&#x27; ? &quot;🤖 Connexion IA établie ! Nouveau message reçu.&quot; :
                                 currentLanguage === &#x27;en&#x27; ? &quot;🤖 AI Connection established! New message received.&quot; :
                                 currentLanguage === &#x27;ar&#x27; ? &quot;🤖 تم إنشاء اتصال الذكاء الاصطناعي! تم استلام رسالة جديدة.&quot; :
                                 currentLanguage === &#x27;es&#x27; ? &quot;🤖 ¡Conexión IA establecida! Nuevo mensaje recibido.&quot; :
                                 currentLanguage === &#x27;de&#x27; ? &quot;🤖 KI-Verbindung hergestellt! Neue Nachricht erhalten.&quot; :
                                 &quot;🤖 AI连接已建立！收到新消息。&quot;;
            
            showMessage(connectionMsg);
            
            // Animation de connexion
            entity.style.boxShadow = &#x27;0 0 50px rgba(0, 255, 255, 1)&#x27;;
            setTimeout(() =&gt; {
                entity.style.boxShadow = &#x27;0 0 20px rgba(0, 255, 255, 0.5)&#x27;;
            }, 2000);
            
            gainXP(15);
            updateStats();
            updateQuestProgress();
            
            // Vérifier si la quête est terminée
            if (gameState.quests[1].progress &gt;= gameState.quests[1].target &amp;&amp; !gameState.quests[1].completed) {
                completeQuest(1);
            }
        }

        // Système d&#x27;énigmes
        function openPuzzle(type) {
            if (gameState.gamePaused) {
                showMessage(currentLanguage === &#x27;fr&#x27; ? &quot;⏸️ Jeu en pause ! Reprenez pour jouer.&quot; :
                           currentLanguage === &#x27;en&#x27; ? &quot;⏸️ Game paused! Resume to play.&quot; :
                           currentLanguage === &#x27;ar&#x27; ? &quot;⏸️ اللعبة متوقفة! استأنف للعب.&quot; :
                           currentLanguage === &#x27;es&#x27; ? &quot;⏸️ ¡Juego pausado! Reanuda para jugar.&quot; :
                           currentLanguage === &#x27;de&#x27; ? &quot;⏸️ Spiel pausiert! Fortsetzen zum Spielen.&quot; :
                           &quot;⏸️ 游戏暂停！继续游戏。&quot;);
                return;
            }
            
            const modal = document.getElementById(&#x27;puzzleModal&#x27;);
            const puzzles = {
                neural: {
                    title: t(&quot;neural_puzzle&quot;),
                    description: t(&quot;puzzle_description&quot;),
                    type: &quot;sequence&quot;
                }
            };
            
            const puzzle = puzzles[type] || puzzles.neural;
            gameState.currentPuzzle = puzzle;
            gameState.puzzleMovesLeft = 5;
            
            document.getElementById(&#x27;puzzleTitle&#x27;).textContent = puzzle.title;
            document.getElementById(&#x27;puzzleDescription&#x27;).textContent = puzzle.description;
            document.getElementById(&#x27;movesCounter&#x27;).textContent = gameState.puzzleMovesLeft;
            
            generatePuzzleGrid(puzzle.type);
            modal.style.display = &#x27;flex&#x27;;
        }

        function generatePuzzleGrid(type) {
            const grid = document.getElementById(&#x27;puzzleGrid&#x27;);
            grid.innerHTML = &#x27;&#x27;;
            
            if (type === &quot;sequence&quot;) {
                // Créer une grille 4x4 pour la séquence
                for (let i = 0; i &lt; 16; i++) {
                    const cell = document.createElement(&#x27;div&#x27;);
                    cell.className = &#x27;puzzle-cell&#x27;;
                    cell.dataset.index = i;
                    cell.onclick = () =&gt; togglePuzzleCell(cell);
                    grid.appendChild(cell);
                }
                
                // Générer une séquence aléatoire
                gameState.currentPuzzle.sequence = [];
                for (let i = 0; i &lt; 6; i++) {
                    gameState.currentPuzzle.sequence.push(Math.floor(Math.random() * 16));
                }
                
                // Montrer la séquence
                showSequence();
            }
        }

        function showSequence() {
            const sequence = gameState.currentPuzzle.sequence;
            let index = 0;
            
            const showNext = () =&gt; {
                if (index &lt; sequence.length) {
                    const cell = document.querySelector(`[data-index=&quot;${sequence[index]}&quot;]`);
                    cell.style.background = &#x27;linear-gradient(135deg, #00ffff 0%, #ff00ff 100%)&#x27;;
                    
                    setTimeout(() =&gt; {
                        cell.style.background = &#x27;&#x27;;
                        index++;
                        setTimeout(showNext, 300);
                    }, 800);
                } else {
                    // Séquence terminée, permettre à l&#x27;utilisateur de jouer
                    gameState.currentPuzzle.playerSequence = [];
                    const msg = currentLanguage === &#x27;fr&#x27; ? &quot;🧠 Reproduisez la séquence que vous venez de voir !&quot; :
                               currentLanguage === &#x27;en&#x27; ? &quot;🧠 Reproduce the sequence you just saw!&quot; :
                               currentLanguage === &#x27;ar&#x27; ? &quot;🧠 أعد إنتاج التسلسل الذي رأيته للتو!&quot; :
                               currentLanguage === &#x27;es&#x27; ? &quot;🧠 ¡Reproduce la secuencia que acabas de ver!&quot; :
                               currentLanguage === &#x27;de&#x27; ? &quot;🧠 Reproduziere die Sequenz, die du gerade gesehen hast!&quot; :
                               &quot;🧠 重现你刚才看到的序列！&quot;;
                    showMessage(msg);
                }
            };
            
            setTimeout(showNext, 1000);
        }

        function togglePuzzleCell(cell) {
            if (!gameState.currentPuzzle.playerSequence || gameState.puzzleMovesLeft &lt;= 0) return;
            
            const index = parseInt(cell.dataset.index);
            gameState.currentPuzzle.playerSequence.push(index);
            gameState.puzzleMovesLeft--;
            
            document.getElementById(&#x27;movesCounter&#x27;).textContent = gameState.puzzleMovesLeft;
            
            cell.classList.add(&#x27;active&#x27;);
            
            // Vérifier si la séquence est correcte jusqu&#x27;à présent
            const playerSeq = gameState.currentPuzzle.playerSequence;
            const targetSeq = gameState.currentPuzzle.sequence;
            
            if (playerSeq.length &lt;= targetSeq.length) {
                const isCorrect = playerSeq.every((val, i) =&gt; val === targetSeq[i]);
                
                if (!isCorrect) {
                    // Séquence incorrecte
                    gameState.puzzleMovesLeft--;
                    document.getElementById(&#x27;movesCounter&#x27;).textContent = gameState.puzzleMovesLeft;
                    
                    if (gameState.puzzleMovesLeft &lt;= 0) {
                        showMessage(t(&#x27;puzzle_failed&#x27;));
                        setTimeout(() =&gt; {
                            closePuzzle();
                        }, 2000);
                    } else {
                        const msg = currentLanguage === &#x27;fr&#x27; ? &quot;❌ Séquence incorrecte ! Essayez à nouveau.&quot; :
                                   currentLanguage === &#x27;en&#x27; ? &quot;❌ Incorrect sequence! Try again.&quot; :
                                   currentLanguage === &#x27;ar&#x27; ? &quot;❌ تسلسل خاطئ! حاول مرة أخرى.&quot; :
                                   currentLanguage === &#x27;es&#x27; ? &quot;❌ ¡Secuencia incorrecta! Inténtalo de nuevo.&quot; :
                                   currentLanguage === &#x27;de&#x27; ? &quot;❌ Falsche Sequenz! Versuche es erneut.&quot; :
                                   &quot;❌ 序列错误！再试一次。&quot;;
                        showMessage(msg);
                        resetPuzzle();
                    }
                } else if (playerSeq.length === targetSeq.length) {
                    // Séquence complète et correcte
                    showMessage(t(&#x27;puzzle_success&#x27;));
                    setTimeout(() =&gt; {
                        solvePuzzle();
                    }, 1500);
                }
            }
        }

        function resetPuzzle() {
            gameState.currentPuzzle.playerSequence = [];
            gameState.puzzleMovesLeft = 5;
            document.getElementById(&#x27;movesCounter&#x27;).textContent = gameState.puzzleMovesLeft;
            
            document.querySelectorAll(&#x27;.puzzle-cell&#x27;).forEach(cell =&gt; {
                cell.classList.remove(&#x27;active&#x27;);
            });
            
            setTimeout(() =&gt; {
                showSequence();
            }, 1000);
        }

        function solvePuzzle() {
            gameState.quests[2].progress++;
            gameState.player.crystals += 2;
            
            const msg = currentLanguage === &#x27;fr&#x27; ? &quot;🎉 Énigme résolue ! +25 XP et 2 cristaux de mémoire !&quot; :
                       currentLanguage === &#x27;en&#x27; ? &quot;🎉 Puzzle solved! +25 XP and 2 memory crystals!&quot; :
                       currentLanguage === &#x27;ar&#x27; ? &quot;🎉 تم حل اللغز! +25 نقطة خبرة و 2 بلورة ذاكرة!&quot; :
                       currentLanguage === &#x27;es&#x27; ? &quot;🎉 ¡Enigma resuelto! ¡+25 XP y 2 cristales de memoria!&quot; :
                       currentLanguage === &#x27;de&#x27; ? &quot;🎉 Rätsel gelöst! +25 EP und 2 Gedächtniskristalle!&quot; :
                       &quot;🎉 谜题解决！+25经验值和2个记忆水晶！&quot;;
            
            showMessage(msg);
            gainXP(25);
            
            closePuzzle();
            updateStats();
            updateQuestProgress();
            
            // Vérifier si la quête est terminée
            if (gameState.quests[2].progress &gt;= gameState.quests[2].target &amp;&amp; !gameState.quests[2].completed) {
                completeQuest(2);
            }
        }

        function closePuzzle() {
            document.getElementById(&#x27;puzzleModal&#x27;).style.display = &#x27;none&#x27;;
            gameState.currentPuzzle = null;
        }

        // Système de progression
        function gainXP(amount) {
            gameState.player.xp += amount;
            
            // Vérifier le niveau
            const newLevel = Math.floor(gameState.player.xp / 100) + 1;
            if (newLevel &gt; gameState.player.level) {
                levelUp(newLevel);
            }
        }

        function levelUp(newLevel) {
            gameState.player.level = newLevel;
            gameState.player.maxEnergy += 20;
            gameState.player.energy = gameState.player.maxEnergy;
            
            const msg = currentLanguage === &#x27;fr&#x27; ? `🌟 NIVEAU SUPÉRIEUR ! Niveau ${newLevel} atteint ! Énergie maximale augmentée !` :
                       currentLanguage === &#x27;en&#x27; ? `🌟 LEVEL UP! Level ${newLevel} reached! Maximum energy increased!` :
                       currentLanguage === &#x27;ar&#x27; ? `🌟 ارتقاء في المستوى! تم الوصول للمستوى ${newLevel}! زيادة الطاقة القصوى!` :
                       currentLanguage === &#x27;es&#x27; ? `🌟 ¡SUBIDA DE NIVEL! ¡Nivel ${newLevel} alcanzado! ¡Energía máxima aumentada!` :
                       currentLanguage === &#x27;de&#x27; ? `🌟 LEVEL AUFSTIEG! Level ${newLevel} erreicht! Maximale Energie erhöht!` :
                       `🌟 升级！达到等级${newLevel}！最大能量增加！`;
            
            showMessage(msg);
            
            // Effets visuels de niveau supérieur
            document.body.style.animation = &#x27;quantumShift 2s ease-in-out&#x27;;
            setTimeout(() =&gt; {
                document.body.style.animation = &#x27;&#x27;;
            }, 2000);
        }

        function completeQuest(questId) {
            gameState.quests[questId].completed = true;
            const quest = gameState.quests[questId];
            
            const msg = currentLanguage === &#x27;fr&#x27; ? `🏆 QUÊTE TERMINÉE : ${t(quest.title)} ! Récompense spéciale débloquée !` :
                       currentLanguage === &#x27;en&#x27; ? `🏆 QUEST COMPLETED: ${t(quest.title)}! Special reward unlocked!` :
                       currentLanguage === &#x27;ar&#x27; ? `🏆 تمت المهمة: ${t(quest.title)}! تم فتح مكافأة خاصة!` :
                       currentLanguage === &#x27;es&#x27; ? `🏆 MISIÓN COMPLETADA: ${t(quest.title)}! ¡Recompensa especial desbloqueada!` :
                       currentLanguage === &#x27;de&#x27; ? `🏆 MISSION ABGESCHLOSSEN: ${t(quest.title)}! Spezielle Belohnung freigeschaltet!` :
                       `🏆 任务完成：${t(quest.title)}！特殊奖励解锁！`;
            
            showMessage(msg);
            
            // Récompenses spéciales
            gainXP(50);
            gameState.player.crystals += 5;
            
            // Marquer visuellement la quête comme terminée
            const questElement = document.querySelector(`#questList .quest-item:nth-child(${questId + 1})`);
            if (questElement) {
                questElement.classList.add(&#x27;completed&#x27;);
            }
            
            updateStats();
        }

        // Actions du joueur
        function scanArea() {
            if (!gameState.gameStarted || gameState.gamePaused) {
                showMessage(currentLanguage === &#x27;fr&#x27; ? &quot;🎮 Commencez ou reprenez le jeu pour utiliser cette action.&quot; :
                           currentLanguage === &#x27;en&#x27; ? &quot;🎮 Start or resume the game to use this action.&quot; :
                           currentLanguage === &#x27;ar&#x27; ? &quot;🎮 ابدأ أو استأنف اللعبة لاستخدام هذا الإجراء.&quot; :
                           currentLanguage === &#x27;es&#x27; ? &quot;🎮 Inicia o reanuda el juego para usar esta acción.&quot; :
                           currentLanguage === &#x27;de&#x27; ? &quot;🎮 Starte oder setze das Spiel fort, um diese Aktion zu verwenden.&quot; :
                           &quot;🎮 开始或继续游戏以使用此操作。&quot;);
                return;
            }
            
            if (gameState.player.energy &lt; 10) {
                const msg = currentLanguage === &#x27;fr&#x27; ? &quot;⚡ Énergie insuffisante pour scanner la zone.&quot; :
                           currentLanguage === &#x27;en&#x27; ? &quot;⚡ Insufficient energy to scan the area.&quot; :
                           currentLanguage === &#x27;ar&#x27; ? &quot;⚡ طاقة غير كافية لمسح المنطقة.&quot; :
                           currentLanguage === &#x27;es&#x27; ? &quot;⚡ Energía insuficiente para escanear el área.&quot; :
                           currentLanguage === &#x27;de&#x27; ? &quot;⚡ Unzureichende Energie zum Scannen des Gebiets.&quot; :
                           &quot;⚡ 能量不足，无法扫描区域。&quot;;
                showMessage(msg);
                return;
            }
            
            gameState.player.energy -= 10;
            
            // Révéler des éléments cachés
            const hiddenElements = Math.floor(Math.random() * 3) + 1;
            
            for (let i = 0; i &lt; hiddenElements; i++) {
                if (Math.random() &lt; 0.5) {
                    createMemoryCrystal();
                } else {
                    createNeuralNode();
                }
            }
            
            const msg = currentLanguage === &#x27;fr&#x27; ? `🔍 Scan terminé ! ${hiddenElements} nouveaux éléments détectés dans la zone.` :
                       currentLanguage === &#x27;en&#x27; ? `🔍 Scan complete! ${hiddenElements} new elements detected in the area.` :
                       currentLanguage === &#x27;ar&#x27; ? `🔍 اكتمل المسح! تم اكتشاف ${hiddenElements} عناصر جديدة في المنطقة.` :
                       currentLanguage === &#x27;es&#x27; ? `🔍 ¡Escaneo completo! ${hiddenElements} nuevos elementos detectados en el área.` :
                       currentLanguage === &#x27;de&#x27; ? `🔍 Scan abgeschlossen! ${hiddenElements} neue Elemente im Gebiet entdeckt.` :
                       `🔍 扫描完成！在区域中检测到${hiddenElements}个新元素。`;
            
            showMessage(msg);
            updateStats();
        }

        function meditate() {
            if (!gameState.gameStarted || gameState.gamePaused) {
                showMessage(currentLanguage === &#x27;fr&#x27; ? &quot;🎮 Commencez ou reprenez le jeu pour méditer.&quot; :
                           currentLanguage === &#x27;en&#x27; ? &quot;🎮 Start or resume the game to meditate.&quot; :
                           currentLanguage === &#x27;ar&#x27; ? &quot;🎮 ابدأ أو استأنف اللعبة للتأمل.&quot; :
                           currentLanguage === &#x27;es&#x27; ? &quot;🎮 Inicia o reanuda el juego para meditar.&quot; :
                           currentLanguage === &#x27;de&#x27; ? &quot;🎮 Starte oder setze das Spiel fort zum Meditieren.&quot; :
                           &quot;🎮 开始或继续游戏进行冥想。&quot;);
                return;
            }
            
            if (gameState.player.energy &gt;= gameState.player.maxEnergy) {
                const msg = currentLanguage === &#x27;fr&#x27; ? &quot;🧘 Votre énergie est déjà au maximum.&quot; :
                           currentLanguage === &#x27;en&#x27; ? &quot;🧘 Your energy is already at maximum.&quot; :
                           currentLanguage === &#x27;ar&#x27; ? &quot;🧘 طاقتك في الحد الأقصى بالفعل.&quot; :
                           currentLanguage === &#x27;es&#x27; ? &quot;🧘 Tu energía ya está al máximo.&quot; :
                           currentLanguage === &#x27;de&#x27; ? &quot;🧘 Deine Energie ist bereits am Maximum.&quot; :
                           &quot;🧘 你的能量已经达到最大值。&quot;;
                showMessage(msg);
                return;
            }
            
            gameState.player.energy = Math.min(gameState.player.maxEnergy, gameState.player.energy + 30);
            
            const msg = currentLanguage === &#x27;fr&#x27; ? &quot;🧘 Méditation neural terminée. Énergie restaurée !&quot; :
                       currentLanguage === &#x27;en&#x27; ? &quot;🧘 Neural meditation complete. Energy restored!&quot; :
                       currentLanguage === &#x27;ar&#x27; ? &quot;🧘 اكتمل التأمل العصبي. تم استعادة الطاقة!&quot; :
                       currentLanguage === &#x27;es&#x27; ? &quot;🧘 Meditación neural completa. ¡Energía restaurada!&quot; :
                       currentLanguage === &#x27;de&#x27; ? &quot;🧘 Neurale Meditation abgeschlossen. Energie wiederhergestellt!&quot; :
                       &quot;🧘 神经冥想完成。能量恢复！&quot;;
            
            showMessage(msg);
            
            // Effet visuel de méditation
            document.getElementById(&#x27;gameWorld&#x27;).style.filter = &#x27;hue-rotate(60deg)&#x27;;
            setTimeout(() =&gt; {
                document.getElementById(&#x27;gameWorld&#x27;).style.filter = &#x27;&#x27;;
            }, 2000);
            
            updateStats();
        }

        function askAI() {
            const responses = [
                getDynamicMessage(&#x27;ai_messages&#x27;, 0),
                getDynamicMessage(&#x27;ai_messages&#x27;, 1),
                getDynamicMessage(&#x27;ai_messages&#x27;, 2),
                getDynamicMessage(&#x27;ai_messages&#x27;, 3),
                getDynamicMessage(&#x27;ai_messages&#x27;, 4)
            ];
            
            const response = responses[Math.floor(Math.random() * responses.length)];
            addAIMessage(response);
        }

        function addAIMessage(message) {
            const chat = document.getElementById(&#x27;aiChat&#x27;);
            const messageDiv = document.createElement(&#x27;div&#x27;);
            messageDiv.className = &#x27;chat-message ai&#x27;;
            messageDiv.textContent = message;
            chat.appendChild(messageDiv);
            
            // Faire défiler vers le bas
            chat.scrollTop = chat.scrollHeight;
            
            // Limiter le nombre de messages
            const messages = chat.querySelectorAll(&#x27;.chat-message&#x27;);
            if (messages.length &gt; 10) {
                messages[0].remove();
            }
        }

        function saveProgress() {
            localStorage.setItem(&#x27;neurosynthExplorer&#x27;, JSON.stringify(gameState));
            
            const msg = currentLanguage === &#x27;fr&#x27; ? &quot;💾 Progression sauvegardée avec succès !&quot; :
                       currentLanguage === &#x27;en&#x27; ? &quot;💾 Progress saved successfully!&quot; :
                       currentLanguage === &#x27;ar&#x27; ? &quot;💾 تم حفظ التقدم بنجاح!&quot; :
                       currentLanguage === &#x27;es&#x27; ? &quot;💾 ¡Progreso guardado con éxito!&quot; :
                       currentLanguage === &#x27;de&#x27; ? &quot;💾 Fortschritt erfolgreich gespeichert!&quot; :
                       &quot;💾 进度保存成功！&quot;;
            
            showMessage(msg);
        }

        function loadProgress() {
            const saved = localStorage.getItem(&#x27;neurosynthExplorer&#x27;);
            if (saved) {
                gameState = JSON.parse(saved);
                updateStats();
                updateQuestProgress();
                
                const msg = currentLanguage === &#x27;fr&#x27; ? &quot;📁 Progression chargée !&quot; :
                           currentLanguage === &#x27;en&#x27; ? &quot;📁 Progress loaded!&quot; :
                           currentLanguage === &#x27;ar&#x27; ? &quot;📁 تم تحميل التقدم!&quot; :
                           currentLanguage === &#x27;es&#x27; ? &quot;📁 ¡Progreso cargado!&quot; :
                           currentLanguage === &#x27;de&#x27; ? &quot;📁 Fortschritt geladen!&quot; :
                           &quot;📁 进度已加载！&quot;;
                
                showMessage(msg);
                return true;
            }
            return false;
        }

        function resetGame() {
            const confirmMsg = currentLanguage === &#x27;fr&#x27; ? &quot;🔄 Êtes-vous sûr de vouloir recommencer votre voyage neural ?&quot; :
                              currentLanguage === &#x27;en&#x27; ? &quot;🔄 Are you sure you want to restart your neural journey?&quot; :
                              currentLanguage === &#x27;ar&#x27; ? &quot;🔄 هل أنت متأكد من أنك تريد إعادة تشغيل رحلتك العصبية؟&quot; :
                              currentLanguage === &#x27;es&#x27; ? &quot;🔄 ¿Estás seguro de que quieres reiniciar tu viaje neural?&quot; :
                              currentLanguage === &#x27;de&#x27; ? &quot;🔄 Bist du sicher, dass du deine neurale Reise neu starten möchtest?&quot; :
                              &quot;🔄 你确定要重新开始你的神经之旅吗？&quot;;
            
            if (confirm(confirmMsg)) {
                localStorage.removeItem(&#x27;neurosynthExplorer&#x27;);
                location.reload();
            }
        }

        // Fonctions utilitaires
        function updateStats() {
            document.getElementById(&#x27;playerLevel&#x27;).textContent = gameState.player.level;
            document.getElementById(&#x27;playerXP&#x27;).textContent = gameState.player.xp;
            document.getElementById(&#x27;playerEnergy&#x27;).textContent = gameState.player.energy;
            document.getElementById(&#x27;crystalCount&#x27;).textContent = gameState.player.crystals;
        }

        function updateQuestProgress() {
            gameState.quests.forEach((quest, index) =&gt; {
                const progressBar = document.getElementById(`quest${index}Progress`);
                if (progressBar) {
                    const percentage = Math.min(100, (quest.progress / quest.target) * 100);
                    progressBar.style.width = percentage + &#x27;%&#x27;;
                }
            });
        }

        function createInventorySlots() {
            const grid = document.getElementById(&#x27;inventoryGrid&#x27;);
            grid.innerHTML = &#x27;&#x27;;
            
            for (let i = 0; i &lt; 9; i++) {
                const slot = document.createElement(&#x27;div&#x27;);
                slot.className = &#x27;inventory-slot&#x27;;
                slot.dataset.slot = i;
                
                if (gameState.player.inventory[i]) {
                    slot.textContent = gameState.player.inventory[i].icon;
                    slot.classList.add(&#x27;filled&#x27;);
                }
                
                grid.appendChild(slot);
            }
        }

        function updateMinimap() {
            const minimap = document.getElementById(&#x27;minimap&#x27;);
            minimap.innerHTML = &#x27;&#x27;;
            
            // Ajouter des points pour les éléments importants
            const elements = [
                ...gameState.world.neuralNodes,
                ...gameState.world.aiEntities,
                ...gameState.world.memoryCrystals
            ];
            
            elements.forEach((element, index) =&gt; {
                if (index &lt; 20) { // Limiter le nombre de points
                    const dot = document.createElement(&#x27;div&#x27;);
                    dot.className = &#x27;minimap-dot&#x27;;
                    dot.style.left = Math.random() * 90 + 5 + &#x27;%&#x27;;
                    dot.style.top = Math.random() * 90 + 5 + &#x27;%&#x27;;
                    
                    if (element.classList.contains(&#x27;neural-node&#x27;)) {
                        dot.style.background = &#x27;#00ffff&#x27;;
                    } else if (element.classList.contains(&#x27;ai-entity&#x27;)) {
                        dot.style.background = &#x27;#ff00ff&#x27;;
                    } else {
                        dot.style.background = &#x27;#ffff00&#x27;;
                    }
                    
                    minimap.appendChild(dot);
                }
            });
        }

        function startGameTimer() {
            setInterval(() =&gt; {
                gameState.gameTime = Math.floor((Date.now() - gameState.startTime) / 1000);
                const minutes = Math.floor(gameState.gameTime / 60);
                const seconds = gameState.gameTime % 60;
                document.getElementById(&#x27;gameTime&#x27;).textContent = 
                    `${minutes.toString().padStart(2, &#x27;0&#x27;)}:${seconds.toString().padStart(2, &#x27;0&#x27;)}`;
            }, 1000);
        }

        function showMessage(text) {
            const display = document.getElementById(&#x27;messageDisplay&#x27;);
            display.textContent = text;
            display.classList.add(&#x27;show&#x27;);
            
            setTimeout(() =&gt; {
                display.classList.remove(&#x27;show&#x27;);
            }, 4000);
        }

        function selectQuest(questId) {
            const quest = gameState.quests[questId];
            const msg = currentLanguage === &#x27;fr&#x27; ? `🎯 Quête sélectionnée : ${t(quest.title)} (${quest.progress}/${quest.target})` :
                       currentLanguage === &#x27;en&#x27; ? `🎯 Quest selected: ${t(quest.title)} (${quest.progress}/${quest.target})` :
                       currentLanguage === &#x27;ar&#x27; ? `🎯 تم اختيار المهمة: ${t(quest.title)} (${quest.progress}/${quest.target})` :
                       currentLanguage === &#x27;es&#x27; ? `🎯 Misión seleccionada: ${t(quest.title)} (${quest.progress}/${quest.target})` :
                       currentLanguage === &#x27;de&#x27; ? `🎯 Mission ausgewählt: ${t(quest.title)} (${quest.progress}/${quest.target})` :
                       `🎯 任务已选择：${t(quest.title)} (${quest.progress}/${quest.target})`;
            
            showMessage(msg);
        }

        // Initialisation au chargement de la page
        window.addEventListener(&#x27;load&#x27;, () =&gt; {
            console.log(&quot;🚀 Lancement de NeuroSynth Explorer...&quot;);
            
            // Essayer de charger une progression sauvegardée
            if (!loadProgress()) {
                initGame();
            } else {
                // Régénérer le monde si progression chargée
                generateWorld();
                createInventorySlots();
                updateMinimap();
                startGameTimer();
            }
        });

        // Gestion des événements clavier
        document.addEventListener(&#x27;keydown&#x27;, (event) =&gt; {
            switch(event.key) {
                case &#x27;Escape&#x27;:
                    closePuzzle();
                    break;
                case &#x27; &#x27;:
                    event.preventDefault();
                    scanArea();
                    break;
                case &#x27;m&#x27;:
                case &#x27;M&#x27;:
                    meditate();
                    break;
            }
        });

        // Régénération périodique d&#x27;éléments
        setInterval(() =&gt; {
            if (gameState.world.memoryCrystals.length &lt; 5) {
                createMemoryCrystal();
            }
        }, 30000); // Toutes les 30 secondes

        // Régénération d&#x27;énergie passive
        setInterval(() =&gt; {
            if (gameState.player.energy &lt; gameState.player.maxEnergy) {
                gameState.player.energy = Math.min(gameState.player.maxEnergy, gameState.player.energy + 1);
                updateStats();
            }
        }, 5000); // Toutes les 5 secondes
    &lt;/script&gt;
&lt;script&gt;(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement(&#x27;script&#x27;);d.innerHTML=&quot;window.__CF$cv$params={r:&#x27;986a8f5b5033e280&#x27;,t:&#x27;MTc1OTEzOTI1NS4wMDAwMDA=&#x27;};var a=document.createElement(&#x27;script&#x27;);a.nonce=&#x27;&#x27;;a.src=&#x27;/cdn-cgi/challenge-platform/scripts/jsd/main.js&#x27;;document.getElementsByTagName(&#x27;head&#x27;)[0].appendChild(a);&quot;;b.getElementsByTagName(&#x27;head&#x27;)[0].appendChild(d)}}if(document.body){var a=document.createElement(&#x27;iframe&#x27;);a.height=1;a.width=1;a.style.position=&#x27;absolute&#x27;;a.style.top=0;a.style.left=0;a.style.border=&#x27;none&#x27;;a.style.visibility=&#x27;hidden&#x27;;document.body.appendChild(a);if(&#x27;loading&#x27;!==document.readyState)c();else if(window.addEventListener)document.addEventListener(&#x27;DOMContentLoaded&#x27;,c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);&#x27;loading&#x27;!==document.readyState&amp;&amp;(document.onreadystatechange=e,c())}}}})();&lt;/script&gt;&lt;/body&gt;
&lt;/html&gt;
"></iframe>
</div>

<script>
function launchGame15() {
  var o = document.getElementById('game15Overlay');
  if (o) { o.style.display = 'block'; }
}
function closeGame15() {
  var o = document.getElementById('game15Overlay');
  if (o) { 
    o.style.display = 'none'; 
    var ifr = document.getElementById('game15Frame'); 
    if (ifr) { try { ifr.srcdoc = ifr.srcdoc; } catch(e) { ifr.src = 'about:blank'; } }
  }
}
document.addEventListener('keydown', function(e) {
  if (e.key === "Escape") closeGame15();
}, true);
</script>
<!-- Overlay for Game 13 -->
<div id="game13Overlay" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:#000; z-index:10000; overflow:auto;">
  <button onclick="closeGame13()" aria-label="Fermer jeu 13"
          style="position:absolute; top:20px; right:20px; background:red; color:#fff; border:none; padding:10px; font-size:20px; cursor:pointer; z-index:10001;">✖</button>
  <iframe id="game13Frame" style="width:100%; height:100%; border:none;" srcdoc="&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;fr&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Blackjack Quantum&lt;/title&gt;
    &lt;style&gt;
        body {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: &#x27;Courier New&#x27;, monospace;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            min-height: 100vh;
            color: #00ff88;
            overflow-x: hidden;
            position: relative;
        }

        /* Animated quantum grid background */
        body::before {
            content: &#x27;&#x27;;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(0, 255, 136, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 136, 0.1) 1px, transparent 1px);
            background-size: 30px 30px;
            animation: quantumGrid 15s linear infinite;
            z-index: -1;
        }

        @keyframes quantumGrid {
            0% { transform: translate(0, 0) rotate(0deg); }
            100% { transform: translate(30px, 30px) rotate(360deg); }
        }

        .quantum-particles {
            position: fixed;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .particle {
            position: absolute;
            width: 3px;
            height: 3px;
            background: #00ccff;
            border-radius: 50%;
            animation: quantumFloat 8s linear infinite;
            box-shadow: 0 0 10px rgba(0, 204, 255, 0.8);
        }

        @keyframes quantumFloat {
            0% {
                transform: translateY(100vh) translateX(0) scale(0);
                opacity: 0;
            }
            10% {
                opacity: 1;
                transform: scale(1);
            }
            90% {
                opacity: 1;
            }
            100% {
                transform: translateY(-10vh) translateX(200px) scale(0);
                opacity: 0;
            }
        }

        .game-container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 15px;
            position: relative;
            z-index: 2;
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
            position: relative;
        }

        .title {
            font-size: 2.2rem;
            margin: 0;
            text-shadow: 0 0 30px rgba(0, 255, 136, 0.8);
            background: linear-gradient(45deg, #00ff88, #00ccff, #ff0088, #ffaa00);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: titlePulse 4s ease-in-out infinite;
            letter-spacing: 3px;
            text-transform: uppercase;
        }

        @keyframes titlePulse {
            0%, 100% { 
                filter: drop-shadow(0 0 20px rgba(0, 255, 136, 0.5));
                transform: scale(1);
            }
            50% { 
                filter: drop-shadow(0 0 40px rgba(0, 255, 136, 1));
                transform: scale(1.05);
            }
        }

        .subtitle {
            font-size: 1.2rem;
            color: #00ccff;
            margin: 10px 0;
            opacity: 0.8;
            letter-spacing: 2px;
        }

        .language-selector {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 1000;
        }

        .language-dropdown {
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #00ff88;
            border-radius: 8px;
            padding: 10px 15px;
            color: #00ff88;
            font-family: &#x27;Courier New&#x27;, monospace;
            font-size: 14px;
            cursor: pointer;
            outline: none;
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.3);
            transition: all 0.3s ease;
        }

        .language-dropdown:hover {
            background: rgba(0, 255, 136, 0.1);
            box-shadow: 0 0 25px rgba(0, 255, 136, 0.5);
            transform: scale(1.05);
        }

        .control-panel {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .quantum-btn {
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.2) 0%, rgba(0, 204, 255, 0.2) 100%);
            border: 2px solid #00ff88;
            padding: 8px 12px;
            border-radius: 6px;
            color: #00ff88;
            font-size: 0.8rem;
            font-family: &#x27;Courier New&#x27;, monospace;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 1px;
            min-width: 100px;
        }

        .quantum-btn::before {
            content: &#x27;&#x27;;
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 136, 0.4), transparent);
            transition: left 0.5s;
        }

        .quantum-btn:hover::before {
            left: 100%;
        }

        .quantum-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 30px rgba(0, 255, 136, 0.4);
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.4) 0%, rgba(0, 204, 255, 0.4) 100%);
            border-color: #00ccff;
            color: #ffffff;
        }

        .quantum-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .quantum-btn:disabled:hover {
            transform: none;
            box-shadow: none;
        }

        .rules-btn {
            background: linear-gradient(135deg, rgba(255, 170, 0, 0.2) 0%, rgba(255, 136, 0, 0.2) 100%);
            border-color: #ffaa00;
            color: #ffaa00;
        }

        .rules-btn:hover {
            background: linear-gradient(135deg, rgba(255, 170, 0, 0.4) 0%, rgba(255, 136, 0, 0.4) 100%);
            border-color: #ff8800;
        }

        .pause-btn {
            background: linear-gradient(135deg, rgba(255, 0, 136, 0.2) 0%, rgba(136, 0, 255, 0.2) 100%);
            border-color: #ff0088;
            color: #ff0088;
        }

        .pause-btn:hover {
            background: linear-gradient(135deg, rgba(255, 0, 136, 0.4) 0%, rgba(136, 0, 255, 0.4) 100%);
            border-color: #cc0066;
        }

        .game-area {
            display: grid;
            grid-template-columns: 200px 1fr 200px;
            gap: 15px;
            margin: 10px 0;
            min-height: 400px;
        }

        .main-game {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ff88;
            border-radius: 12px;
            padding: 20px;
            position: relative;
            overflow: hidden;
        }

        .main-game::before {
            content: &#x27;&#x27;;
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, #00ff88, #00ccff, #ff0088, #ffaa00);
            border-radius: 14px;
            z-index: -1;
            animation: borderGlow 6s linear infinite;
        }

        @keyframes borderGlow {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }

        .side-panel {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .game-actions-panel {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ff88;
            border-radius: 10px;
            padding: 12px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        .game-actions-panel::before {
            content: &#x27;&#x27;;
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, #00ff88, #00ccff, #ff0088, #ffaa00);
            border-radius: 12px;
            z-index: -1;
            animation: borderGlow 6s linear infinite;
        }

        .ai-assistant {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ccff;
            border-radius: 8px;
            padding: 10px;
            text-align: center;
        }

        .ai-avatar {
            width: 35px;
            height: 35px;
            margin: 0 auto 6px;
            border-radius: 50%;
            background: radial-gradient(circle, #00ccff 0%, #0088ff 50%, #0044ff 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            animation: aiPulse 3s ease-in-out infinite;
            box-shadow: 0 0 15px rgba(0, 204, 255, 0.6);
        }

        @keyframes aiPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .ai-name {
            font-size: 0.8rem;
            color: #00ccff;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .ai-message {
            font-size: 0.7rem;
            line-height: 1.3;
            color: #88ffcc;
            background: rgba(0, 204, 255, 0.1);
            padding: 8px;
            border-radius: 4px;
            border-left: 2px solid #00ccff;
        }

        .stats-panel {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #ffaa00;
            border-radius: 8px;
            padding: 10px;
        }

        .stats-title {
            font-size: 0.8rem;
            color: #ffaa00;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-align: center;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            margin: 4px 0;
            padding: 4px;
            background: rgba(255, 170, 0, 0.1);
            border-radius: 3px;
            font-size: 0.7rem;
        }

        .stat-label {
            color: #ffcc66;
        }

        .stat-value {
            color: #ffaa00;
            font-weight: bold;
        }

        .dealer-area, .player-area {
            margin: 15px 0;
            padding: 12px;
            border-radius: 6px;
            position: relative;
        }

        .dealer-area {
            background: rgba(255, 0, 136, 0.1);
            border: 2px solid #ff0088;
        }

        .player-area {
            background: rgba(0, 255, 136, 0.1);
            border: 2px solid #00ff88;
        }

        .area-title {
            font-size: 1.1rem;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .dealer-area .area-title {
            color: #ff0088;
        }

        .player-area .area-title {
            color: #00ff88;
        }

        .cards-container {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            min-height: 90px;
            align-items: center;
        }

        .card {
            width: 60px;
            height: 90px;
            background: linear-gradient(135deg, #ffffff 0%, #f0f0f0 100%);
            border: 2px solid #333;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 6px;
            color: #333;
            font-weight: bold;
            position: relative;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .card:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
        }

        .card.red {
            color: #b71c1c;
        }

        .card.black {
            color: #1a1a1a;
        }

        .card.hidden {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #00ff88;
            border-color: #00ff88;
        }

        .card-value {
            font-size: 1.4rem;
            text-align: center;
            font-weight: bold;
        }

        .card-suit {
            font-size: 2rem;
            text-align: center;
        }

        .score-display {
            font-size: 1.3rem;
            font-weight: bold;
            margin: 10px 0;
            text-align: center;
            padding: 8px;
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.5);
        }

        .dealer-area .score-display {
            color: #ff0088;
            border: 1px solid #ff0088;
        }

        .player-area .score-display {
            color: #00ff88;
            border: 1px solid #00ff88;
        }

        .game-actions {
            display: flex;
            flex-direction: column;
            gap: 8px;
            width: 100%;
        }

        .bet-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 15px 0;
            justify-content: center;
            flex-wrap: wrap;
        }

        .bet-input {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ff88;
            border-radius: 8px;
            padding: 10px 15px;
            color: #00ff88;
            font-family: &#x27;Courier New&#x27;, monospace;
            font-size: 1.1rem;
            width: 120px;
            text-align: center;
        }

        .bet-input:focus {
            outline: none;
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.5);
        }

        .game-message {
            text-align: center;
            font-size: 1.1rem;
            margin: 15px 0;
            padding: 12px;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #00ccff;
            color: #00ccff;
            min-height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .rules-panel, .pause-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #00ff88;
            border-radius: 15px;
            padding: 30px;
            z-index: 3000;
            display: none;
            min-width: 500px;
            max-width: 80vw;
            max-height: 80vh;
            overflow-y: auto;
        }

        .rules-content {
            color: #00ff88;
            line-height: 1.8;
        }

        .rules-content h3 {
            color: #00ccff;
            margin-top: 25px;
            margin-bottom: 15px;
            border-bottom: 2px solid #00ff88;
            padding-bottom: 8px;
            font-size: 1.3rem;
        }

        .rules-content ul {
            margin: 15px 0;
            padding-left: 25px;
        }

        .rules-content li {
            margin: 8px 0;
        }

        .pause-panel {
            text-align: center;
            border-color: #ff0088;
        }

        .pause-panel h3 {
            color: #ff0088;
            font-size: 2rem;
            margin-bottom: 20px;
        }

        .level-indicator {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #ffaa00;
            border-radius: 10px;
            padding: 10px 20px;
            color: #ffaa00;
            font-weight: bold;
        }

        @media (max-width: 768px) {
            .game-area {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .side-panel:first-child {
                order: -1;
            }
            
            .game-actions {
                flex-direction: row;
                flex-wrap: wrap;
                gap: 10px;
            }
            
            .title {
                font-size: 2rem;
            }
            
            .control-panel {
                gap: 10px;
            }
            
            .quantum-btn {
                min-width: 120px;
                padding: 12px 20px;
                font-size: 1rem;
            }
            
            .cards-container {
                gap: 10px;
            }
            
            .card {
                width: 60px;
                height: 90px;
                padding: 5px;
            }
            
            .card-value {
                font-size: 1.3rem;
            }
            
            .card-suit {
                font-size: 1.8rem;
            }
            
            .language-selector {
                top: 10px;
                right: 10px;
            }
            
            .rules-panel {
                min-width: 90vw;
                padding: 20px;
            }
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;quantum-particles&quot; id=&quot;particles&quot;&gt;&lt;/div&gt;
    
    &lt;div class=&quot;language-selector&quot;&gt;
        &lt;select class=&quot;language-dropdown&quot; id=&quot;languageSelect&quot;&gt;
            &lt;option value=&quot;fr&quot;&gt;🇫🇷 Français&lt;/option&gt;
            &lt;option value=&quot;en&quot;&gt;🇬🇧 English&lt;/option&gt;
            &lt;option value=&quot;ar&quot;&gt;🇸🇦 العربية&lt;/option&gt;
            &lt;option value=&quot;es&quot;&gt;🇪🇸 Español&lt;/option&gt;
            &lt;option value=&quot;de&quot;&gt;🇩🇪 Deutsch&lt;/option&gt;
            &lt;option value=&quot;zh&quot;&gt;🇨🇳 中文&lt;/option&gt;
        &lt;/select&gt;
    &lt;/div&gt;

    &lt;div class=&quot;level-indicator&quot; id=&quot;levelIndicator&quot;&gt;
        Niveau 1
    &lt;/div&gt;

    &lt;div class=&quot;game-container&quot;&gt;
        &lt;div class=&quot;header&quot;&gt;
            &lt;h1 class=&quot;title&quot; id=&quot;gameTitle&quot;&gt;Blackjack Quantum&lt;/h1&gt;
            &lt;p class=&quot;subtitle&quot; id=&quot;gameSubtitle&quot;&gt;Expérience de jeu futuriste avec IA&lt;/p&gt;
        &lt;/div&gt;



        &lt;div class=&quot;game-area&quot;&gt;
            &lt;div class=&quot;side-panel&quot;&gt;
                &lt;div class=&quot;game-actions-panel&quot;&gt;
                    &lt;div class=&quot;control-panel&quot; style=&quot;flex-direction: column; gap: 8px; margin: 0;&quot;&gt;
                        &lt;button class=&quot;quantum-btn&quot; id=&quot;startBtn2&quot; onclick=&quot;startGame()&quot;&gt;🚀 Démarrer&lt;/button&gt;
                        &lt;button class=&quot;quantum-btn pause-btn&quot; id=&quot;pauseBtn2&quot; onclick=&quot;togglePause()&quot; disabled&gt;⏸️ Pause&lt;/button&gt;
                        &lt;button class=&quot;quantum-btn rules-btn&quot; id=&quot;rulesBtn2&quot; onclick=&quot;showRules()&quot;&gt;📖 Règles&lt;/button&gt;
                        &lt;button class=&quot;quantum-btn&quot; id=&quot;newGameBtn2&quot; onclick=&quot;newGame()&quot; disabled&gt;🔄 Nouvelle Partie&lt;/button&gt;
                    &lt;/div&gt;
                &lt;/div&gt;

                &lt;div class=&quot;stats-panel&quot;&gt;
                    &lt;div class=&quot;stats-title&quot; id=&quot;statsTitle&quot;&gt;Statistiques&lt;/div&gt;
                    &lt;div class=&quot;stat-item&quot;&gt;
                        &lt;span class=&quot;stat-label&quot; id=&quot;winsLabel&quot;&gt;Victoires:&lt;/span&gt;
                        &lt;span class=&quot;stat-value&quot; id=&quot;winsValue&quot;&gt;0&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;stat-item&quot;&gt;
                        &lt;span class=&quot;stat-label&quot; id=&quot;lossesLabel&quot;&gt;Défaites:&lt;/span&gt;
                        &lt;span class=&quot;stat-value&quot; id=&quot;lossesValue&quot;&gt;0&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;stat-item&quot;&gt;
                        &lt;span class=&quot;stat-label&quot; id=&quot;blackjacksLabel&quot;&gt;Blackjacks:&lt;/span&gt;
                        &lt;span class=&quot;stat-value&quot; id=&quot;blackjacksValue&quot;&gt;0&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;stat-item&quot;&gt;
                        &lt;span class=&quot;stat-label&quot; id=&quot;winRateLabel&quot;&gt;Taux victoire:&lt;/span&gt;
                        &lt;span class=&quot;stat-value&quot; id=&quot;winRateValue&quot;&gt;0%&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;stat-item&quot;&gt;
                        &lt;span class=&quot;stat-label&quot; id=&quot;levelLabel&quot;&gt;Niveau:&lt;/span&gt;
                        &lt;span class=&quot;stat-value&quot; id=&quot;levelValue&quot;&gt;1&lt;/span&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;div class=&quot;main-game&quot;&gt;
                &lt;div class=&quot;dealer-area&quot;&gt;
                    &lt;div class=&quot;area-title&quot; id=&quot;dealerTitle&quot;&gt;🤖 Croupier IA Quantum&lt;/div&gt;
                    &lt;div class=&quot;cards-container&quot; id=&quot;dealerCards&quot;&gt;&lt;/div&gt;
                    &lt;div class=&quot;score-display&quot; id=&quot;dealerScore&quot;&gt;Score: --&lt;/div&gt;
                &lt;/div&gt;

                &lt;div class=&quot;game-message&quot; id=&quot;gameMessage&quot;&gt;
                    Cliquez sur &quot;Démarrer&quot; pour commencer une partie
                &lt;/div&gt;

                &lt;div class=&quot;bet-controls&quot; id=&quot;betControls&quot;&gt;
                    &lt;label for=&quot;betAmount&quot; id=&quot;betLabel&quot;&gt;Mise:&lt;/label&gt;
                    &lt;input type=&quot;number&quot; id=&quot;betAmount&quot; class=&quot;bet-input&quot; value=&quot;10&quot; min=&quot;1&quot; max=&quot;1000&quot;&gt;
                    &lt;span id=&quot;creditsLabel&quot;&gt;Crédits: &lt;span id=&quot;creditsAmount&quot;&gt;1000&lt;/span&gt;&lt;/span&gt;
                &lt;/div&gt;

                &lt;div class=&quot;player-area&quot;&gt;
                    &lt;div class=&quot;area-title&quot; id=&quot;playerTitle&quot;&gt;👤 Joueur&lt;/div&gt;
                    &lt;div class=&quot;cards-container&quot; id=&quot;playerCards&quot;&gt;&lt;/div&gt;
                    &lt;div class=&quot;score-display&quot; id=&quot;playerScore&quot;&gt;Score: --&lt;/div&gt;
                &lt;/div&gt;

            &lt;/div&gt;



            &lt;div class=&quot;side-panel&quot;&gt;
                &lt;div class=&quot;ai-assistant&quot;&gt;
                    &lt;div class=&quot;ai-avatar&quot;&gt;🧠&lt;/div&gt;
                    &lt;div class=&quot;ai-name&quot; id=&quot;aiName&quot;&gt;ARIA-Q&lt;/div&gt;
                    &lt;div class=&quot;ai-message&quot; id=&quot;aiMessage&quot;&gt;
                        Bonjour ! Je suis ARIA-Q, votre assistant IA quantique. Prêt pour une partie de Blackjack futuriste ?
                    &lt;/div&gt;
                &lt;/div&gt;

                &lt;div class=&quot;game-actions-panel&quot;&gt;
                    &lt;div class=&quot;game-actions&quot; id=&quot;gameActions&quot; style=&quot;display: none;&quot;&gt;
                        &lt;button class=&quot;quantum-btn&quot; id=&quot;hitBtn&quot; onclick=&quot;hit()&quot;&gt;📥 Carte&lt;/button&gt;
                        &lt;button class=&quot;quantum-btn&quot; id=&quot;standBtn&quot; onclick=&quot;stand()&quot;&gt;✋ Rester&lt;/button&gt;
                        &lt;button class=&quot;quantum-btn&quot; id=&quot;doubleBtn&quot; onclick=&quot;doubleDown()&quot;&gt;⚡ Doubler&lt;/button&gt;
                        &lt;button class=&quot;quantum-btn&quot; id=&quot;surrenderBtn&quot; onclick=&quot;surrender()&quot;&gt;🏳️ Abandonner&lt;/button&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;!-- Rules Panel --&gt;
    &lt;div class=&quot;rules-panel&quot; id=&quot;rulesPanel&quot;&gt;
        &lt;h3 style=&quot;color: #00ff88; text-align: center; margin-bottom: 20px;&quot; id=&quot;rulesTitle&quot;&gt;📖 Règles du Blackjack Quantum&lt;/h3&gt;
        &lt;div class=&quot;rules-content&quot; id=&quot;rulesContent&quot;&gt;
            &lt;div id=&quot;rulesObjective&quot;&gt;
                &lt;h3&gt;🎯 Objectif&lt;/h3&gt;
                &lt;p&gt;Obtenez une main dont la valeur est plus proche de 21 que celle du croupier, sans dépasser 21.&lt;/p&gt;
            &lt;/div&gt;
            
            &lt;div id=&quot;rulesCardValues&quot;&gt;
                &lt;h3&gt;🃏 Valeurs des Cartes&lt;/h3&gt;
                &lt;ul&gt;
                    &lt;li&gt;&lt;strong&gt;As:&lt;/strong&gt; 1 ou 11 (la meilleure valeur automatiquement)&lt;/li&gt;
                    &lt;li&gt;&lt;strong&gt;Figures (Roi, Dame, Valet):&lt;/strong&gt; 10 points&lt;/li&gt;
                    &lt;li&gt;&lt;strong&gt;Cartes numériques:&lt;/strong&gt; Valeur nominale (2-10)&lt;/li&gt;
                &lt;/ul&gt;
            &lt;/div&gt;
            
            &lt;div id=&quot;rulesActions&quot;&gt;
                &lt;h3&gt;🎮 Actions Disponibles&lt;/h3&gt;
                &lt;ul&gt;
                    &lt;li&gt;&lt;strong&gt;Carte:&lt;/strong&gt; Demander une carte supplémentaire&lt;/li&gt;
                    &lt;li&gt;&lt;strong&gt;Rester:&lt;/strong&gt; Garder votre main actuelle&lt;/li&gt;
                    &lt;li&gt;&lt;strong&gt;Doubler:&lt;/strong&gt; Doubler la mise et recevoir exactement une carte&lt;/li&gt;
                    &lt;li&gt;&lt;strong&gt;Abandonner:&lt;/strong&gt; Abandonner et récupérer la moitié de votre mise&lt;/li&gt;
                &lt;/ul&gt;
            &lt;/div&gt;
            
            &lt;div id=&quot;rulesWinning&quot;&gt;
                &lt;h3&gt;🏆 Conditions de Victoire&lt;/h3&gt;
                &lt;ul&gt;
                    &lt;li&gt;&lt;strong&gt;Blackjack:&lt;/strong&gt; As + carte de 10 (paiement 3:2)&lt;/li&gt;
                    &lt;li&gt;&lt;strong&gt;Victoire normale:&lt;/strong&gt; Plus proche de 21 que le croupier&lt;/li&gt;
                    &lt;li&gt;&lt;strong&gt;Croupier dépasse:&lt;/strong&gt; Le croupier dépasse 21&lt;/li&gt;
                &lt;/ul&gt;
            &lt;/div&gt;
            
            &lt;div id=&quot;rulesAI&quot;&gt;
                &lt;h3&gt;🤖 IA Quantique&lt;/h3&gt;
                &lt;ul&gt;
                    &lt;li&gt;Le croupier tire jusqu&#x27;à 17 (soft 17 inclus)&lt;/li&gt;
                    &lt;li&gt;ARIA-Q vous donne des conseils stratégiques&lt;/li&gt;
                    &lt;li&gt;Système de niveaux basé sur les performances&lt;/li&gt;
                &lt;/ul&gt;
            &lt;/div&gt;
            
            &lt;div id=&quot;rulesCredits&quot;&gt;
                &lt;h3&gt;💰 Système de Crédits&lt;/h3&gt;
                &lt;ul&gt;
                    &lt;li&gt;Commencez avec 1000 crédits&lt;/li&gt;
                    &lt;li&gt;Mise minimum: 1 crédit&lt;/li&gt;
                    &lt;li&gt;Gagnez des bonus de niveau&lt;/li&gt;
                    &lt;li&gt;Débloquez de nouvelles fonctionnalités&lt;/li&gt;
                &lt;/ul&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;button class=&quot;quantum-btn&quot; onclick=&quot;hideRules()&quot; style=&quot;margin-top: 20px;&quot;&gt;Fermer&lt;/button&gt;
    &lt;/div&gt;

    &lt;!-- Pause Panel --&gt;
    &lt;div class=&quot;pause-panel&quot; id=&quot;pausePanel&quot;&gt;
        &lt;h3&gt;⏸️ Jeu en Pause&lt;/h3&gt;
        &lt;p style=&quot;color: #ff88cc; margin: 20px 0;&quot;&gt;Le jeu est actuellement en pause.&lt;/p&gt;
        &lt;button class=&quot;quantum-btn&quot; onclick=&quot;togglePause()&quot;&gt;▶️ Reprendre&lt;/button&gt;
    &lt;/div&gt;

    &lt;script&gt;
        const translations = {
            fr: {
                title: &quot;Blackjack Quantum&quot;,
                subtitle: &quot;Expérience de jeu futuriste avec IA&quot;,
                start: &quot;🚀 Démarrer&quot;,
                pause: &quot;⏸️ Pause&quot;,
                resume: &quot;▶️ Reprendre&quot;,
                rules: &quot;📖 Règles&quot;,
                newGame: &quot;🔄 Nouvelle Partie&quot;,
                dealerTitle: &quot;🤖 Croupier IA Quantum&quot;,
                playerTitle: &quot;👤 Joueur&quot;,
                aiName: &quot;ARIA-Q&quot;,
                aiWelcome: &quot;Bonjour ! Je suis ARIA-Q, votre assistant IA quantique. Prêt pour une partie de Blackjack futuriste ?&quot;,
                statsTitle: &quot;Statistiques&quot;,
                wins: &quot;Victoires:&quot;,
                losses: &quot;Défaites:&quot;,
                blackjacks: &quot;Blackjacks:&quot;,
                winRate: &quot;Taux victoire:&quot;,
                level: &quot;Niveau:&quot;,
                bet: &quot;Mise:&quot;,
                credits: &quot;Crédits:&quot;,
                hit: &quot;📥 Carte&quot;,
                stand: &quot;✋ Rester&quot;,
                double: &quot;⚡ Doubler&quot;,
                surrender: &quot;🏳️ Abandonner&quot;,
                score: &quot;Score:&quot;,
                startMessage: &quot;Cliquez sur \&quot;Démarrer\&quot; pour commencer une partie&quot;,
                rulesTitle: &quot;📖 Règles du Blackjack Quantum&quot;,
                pauseTitle: &quot;⏸️ Jeu en Pause&quot;,
                pauseMessage: &quot;Le jeu est actuellement en pause.&quot;,
                levelIndicator: &quot;Niveau&quot;,
                closeBtn: &quot;Fermer&quot;,
                rulesContent: {
                    objective: {
                        title: &quot;🎯 Objectif&quot;,
                        text: &quot;Obtenez une main dont la valeur est plus proche de 21 que celle du croupier, sans dépasser 21.&quot;
                    },
                    cardValues: {
                        title: &quot;🃏 Valeurs des Cartes&quot;,
                        ace: &quot;As: 1 ou 11 (la meilleure valeur automatiquement)&quot;,
                        figures: &quot;Figures (Roi, Dame, Valet): 10 points&quot;,
                        numbers: &quot;Cartes numériques: Valeur nominale (2-10)&quot;
                    },
                    actions: {
                        title: &quot;🎮 Actions Disponibles&quot;,
                        hit: &quot;Carte: Demander une carte supplémentaire&quot;,
                        stand: &quot;Rester: Garder votre main actuelle&quot;,
                        double: &quot;Doubler: Doubler la mise et recevoir exactement une carte&quot;,
                        surrender: &quot;Abandonner: Abandonner et récupérer la moitié de votre mise&quot;
                    },
                    winning: {
                        title: &quot;🏆 Conditions de Victoire&quot;,
                        blackjack: &quot;Blackjack: As + carte de 10 (paiement 3:2)&quot;,
                        normal: &quot;Victoire normale: Plus proche de 21 que le croupier&quot;,
                        dealerBust: &quot;Croupier dépasse: Le croupier dépasse 21&quot;
                    },
                    ai: {
                        title: &quot;🤖 IA Quantique&quot;,
                        dealer: &quot;Le croupier tire jusqu&#x27;à 17 (soft 17 inclus)&quot;,
                        advice: &quot;ARIA-Q vous donne des conseils stratégiques&quot;,
                        levels: &quot;Système de niveaux basé sur les performances&quot;
                    },
                    credits: {
                        title: &quot;💰 Système de Crédits&quot;,
                        start: &quot;Commencez avec 1000 crédits&quot;,
                        minimum: &quot;Mise minimum: 1 crédit&quot;,
                        bonus: &quot;Gagnez des bonus de niveau&quot;,
                        features: &quot;Débloquez de nouvelles fonctionnalités&quot;
                    }
                },
                messages: {
                    blackjack: &quot;🎉 BLACKJACK ! Vous gagnez !&quot;,
                    playerWin: &quot;🎉 Vous gagnez !&quot;,
                    dealerWin: &quot;😔 Le croupier gagne&quot;,
                    tie: &quot;🤝 Égalité !&quot;,
                    bust: &quot;💥 Vous avez dépassé 21 !&quot;,
                    dealerBust: &quot;🎉 Le croupier a dépassé 21 !&quot;,
                    surrender: &quot;🏳️ Vous abandonnez&quot;,
                    levelUp: &quot;🎊 Niveau supérieur ! Bonus de crédits !&quot;,
                    gameOver: &quot;💸 Plus de crédits ! Nouvelle partie ?&quot;,
                    aiAdvice: {
                        hit: &quot;Je recommande de prendre une carte.&quot;,
                        stand: &quot;Je recommande de rester.&quot;,
                        double: &quot;Bonne opportunité pour doubler !&quot;,
                        careful: &quot;Attention, risque de dépasser 21.&quot;,
                        goodHand: &quot;Excellente main ! Restez confiant.&quot;
                    }
                }
            },
            en: {
                title: &quot;Blackjack Quantum&quot;,
                subtitle: &quot;Futuristic gaming experience with AI&quot;,
                start: &quot;🚀 Start&quot;,
                pause: &quot;⏸️ Pause&quot;,
                resume: &quot;▶️ Resume&quot;,
                rules: &quot;📖 Rules&quot;,
                newGame: &quot;🔄 New Game&quot;,
                dealerTitle: &quot;🤖 Quantum AI Dealer&quot;,
                playerTitle: &quot;👤 Player&quot;,
                aiName: &quot;ARIA-Q&quot;,
                aiWelcome: &quot;Hello! I&#x27;m ARIA-Q, your quantum AI assistant. Ready for a futuristic Blackjack game?&quot;,
                statsTitle: &quot;Statistics&quot;,
                wins: &quot;Wins:&quot;,
                losses: &quot;Losses:&quot;,
                blackjacks: &quot;Blackjacks:&quot;,
                winRate: &quot;Win Rate:&quot;,
                level: &quot;Level:&quot;,
                bet: &quot;Bet:&quot;,
                credits: &quot;Credits:&quot;,
                hit: &quot;📥 Hit&quot;,
                stand: &quot;✋ Stand&quot;,
                double: &quot;⚡ Double&quot;,
                surrender: &quot;🏳️ Surrender&quot;,
                score: &quot;Score:&quot;,
                startMessage: &quot;Click \&quot;Start\&quot; to begin a game&quot;,
                rulesTitle: &quot;📖 Blackjack Quantum Rules&quot;,
                pauseTitle: &quot;⏸️ Game Paused&quot;,
                pauseMessage: &quot;The game is currently paused.&quot;,
                levelIndicator: &quot;Level&quot;,
                closeBtn: &quot;Close&quot;,
                rulesContent: {
                    objective: {
                        title: &quot;🎯 Objective&quot;,
                        text: &quot;Get a hand value closer to 21 than the dealer&#x27;s, without exceeding 21.&quot;
                    },
                    cardValues: {
                        title: &quot;🃏 Card Values&quot;,
                        ace: &quot;Ace: 1 or 11 (best value automatically)&quot;,
                        figures: &quot;Face cards (King, Queen, Jack): 10 points&quot;,
                        numbers: &quot;Number cards: Face value (2-10)&quot;
                    },
                    actions: {
                        title: &quot;🎮 Available Actions&quot;,
                        hit: &quot;Hit: Request an additional card&quot;,
                        stand: &quot;Stand: Keep your current hand&quot;,
                        double: &quot;Double: Double the bet and receive exactly one card&quot;,
                        surrender: &quot;Surrender: Give up and recover half your bet&quot;
                    },
                    winning: {
                        title: &quot;🏆 Winning Conditions&quot;,
                        blackjack: &quot;Blackjack: Ace + 10-value card (3:2 payout)&quot;,
                        normal: &quot;Normal win: Closer to 21 than dealer&quot;,
                        dealerBust: &quot;Dealer busts: Dealer exceeds 21&quot;
                    },
                    ai: {
                        title: &quot;🤖 Quantum AI&quot;,
                        dealer: &quot;Dealer draws to 17 (soft 17 included)&quot;,
                        advice: &quot;ARIA-Q gives you strategic advice&quot;,
                        levels: &quot;Level system based on performance&quot;
                    },
                    credits: {
                        title: &quot;💰 Credit System&quot;,
                        start: &quot;Start with 1000 credits&quot;,
                        minimum: &quot;Minimum bet: 1 credit&quot;,
                        bonus: &quot;Earn level bonuses&quot;,
                        features: &quot;Unlock new features&quot;
                    }
                },
                messages: {
                    blackjack: &quot;🎉 BLACKJACK! You win!&quot;,
                    playerWin: &quot;🎉 You win!&quot;,
                    dealerWin: &quot;😔 Dealer wins&quot;,
                    tie: &quot;🤝 Push!&quot;,
                    bust: &quot;💥 You busted!&quot;,
                    dealerBust: &quot;🎉 Dealer busted!&quot;,
                    surrender: &quot;🏳️ You surrendered&quot;,
                    levelUp: &quot;🎊 Level up! Credit bonus!&quot;,
                    gameOver: &quot;💸 Out of credits! New game?&quot;,
                    aiAdvice: {
                        hit: &quot;I recommend taking a card.&quot;,
                        stand: &quot;I recommend standing.&quot;,
                        double: &quot;Good opportunity to double!&quot;,
                        careful: &quot;Careful, risk of busting.&quot;,
                        goodHand: &quot;Excellent hand! Stay confident.&quot;
                    }
                }
            },
            ar: {
                title: &quot;بلاك جاك كمي&quot;,
                subtitle: &quot;تجربة لعب مستقبلية مع الذكاء الاصطناعي&quot;,
                start: &quot;🚀 ابدأ&quot;,
                pause: &quot;⏸️ توقف&quot;,
                resume: &quot;▶️ استئناف&quot;,
                rules: &quot;📖 القواعد&quot;,
                newGame: &quot;🔄 لعبة جديدة&quot;,
                dealerTitle: &quot;🤖 موزع الذكاء الاصطناعي الكمي&quot;,
                playerTitle: &quot;👤 اللاعب&quot;,
                aiName: &quot;آريا-كيو&quot;,
                aiWelcome: &quot;مرحباً! أنا آريا-كيو، مساعدك الذكي الكمي. مستعد للعبة بلاك جاك مستقبلية؟&quot;,
                statsTitle: &quot;الإحصائيات&quot;,
                wins: &quot;الانتصارات:&quot;,
                losses: &quot;الهزائم:&quot;,
                blackjacks: &quot;البلاك جاك:&quot;,
                winRate: &quot;معدل الفوز:&quot;,
                level: &quot;المستوى:&quot;,
                bet: &quot;الرهان:&quot;,
                credits: &quot;الرصيد:&quot;,
                hit: &quot;📥 بطاقة&quot;,
                stand: &quot;✋ ثبات&quot;,
                double: &quot;⚡ مضاعفة&quot;,
                surrender: &quot;🏳️ استسلام&quot;,
                score: &quot;النقاط:&quot;,
                startMessage: &quot;انقر على \&quot;ابدأ\&quot; لبدء اللعبة&quot;,
                rulesTitle: &quot;📖 قواعد بلاك جاك الكمي&quot;,
                pauseTitle: &quot;⏸️ اللعبة متوقفة&quot;,
                pauseMessage: &quot;اللعبة متوقفة حالياً.&quot;,
                levelIndicator: &quot;المستوى&quot;,
                closeBtn: &quot;إغلاق&quot;,
                rulesContent: {
                    objective: {
                        title: &quot;🎯 الهدف&quot;,
                        text: &quot;احصل على يد قيمتها أقرب إلى 21 من يد الموزع، دون تجاوز 21.&quot;
                    },
                    cardValues: {
                        title: &quot;🃏 قيم البطاقات&quot;,
                        ace: &quot;الآس: 1 أو 11 (أفضل قيمة تلقائياً)&quot;,
                        figures: &quot;بطاقات الوجه (الملك، الملكة، الولد): 10 نقاط&quot;,
                        numbers: &quot;البطاقات المرقمة: القيمة الاسمية (2-10)&quot;
                    },
                    actions: {
                        title: &quot;🎮 الإجراءات المتاحة&quot;,
                        hit: &quot;بطاقة: طلب بطاقة إضافية&quot;,
                        stand: &quot;ثبات: الاحتفاظ بيدك الحالية&quot;,
                        double: &quot;مضاعفة: مضاعفة الرهان وتلقي بطاقة واحدة بالضبط&quot;,
                        surrender: &quot;استسلام: الاستسلام واسترداد نصف رهانك&quot;
                    },
                    winning: {
                        title: &quot;🏆 شروط الفوز&quot;,
                        blackjack: &quot;بلاك جاك: آس + بطاقة بقيمة 10 (دفع 3:2)&quot;,
                        normal: &quot;فوز عادي: أقرب إلى 21 من الموزع&quot;,
                        dealerBust: &quot;انفجار الموزع: الموزع يتجاوز 21&quot;
                    },
                    ai: {
                        title: &quot;🤖 الذكاء الاصطناعي الكمي&quot;,
                        dealer: &quot;الموزع يسحب حتى 17 (17 الناعم مشمول)&quot;,
                        advice: &quot;آريا-كيو تعطيك نصائح استراتيجية&quot;,
                        levels: &quot;نظام مستويات مبني على الأداء&quot;
                    },
                    credits: {
                        title: &quot;💰 نظام الرصيد&quot;,
                        start: &quot;ابدأ بـ 1000 رصيد&quot;,
                        minimum: &quot;الحد الأدنى للرهان: 1 رصيد&quot;,
                        bonus: &quot;اكسب مكافآت المستوى&quot;,
                        features: &quot;افتح ميزات جديدة&quot;
                    }
                },
                messages: {
                    blackjack: &quot;🎉 بلاك جاك! لقد فزت!&quot;,
                    playerWin: &quot;🎉 لقد فزت!&quot;,
                    dealerWin: &quot;😔 الموزع يفوز&quot;,
                    tie: &quot;🤝 تعادل!&quot;,
                    bust: &quot;💥 لقد تجاوزت 21!&quot;,
                    dealerBust: &quot;🎉 الموزع تجاوز 21!&quot;,
                    surrender: &quot;🏳️ لقد استسلمت&quot;,
                    levelUp: &quot;🎊 مستوى أعلى! مكافأة رصيد!&quot;,
                    gameOver: &quot;💸 نفد الرصيد! لعبة جديدة؟&quot;,
                    aiAdvice: {
                        hit: &quot;أنصح بأخذ بطاقة.&quot;,
                        stand: &quot;أنصح بالثبات.&quot;,
                        double: &quot;فرصة جيدة للمضاعفة!&quot;,
                        careful: &quot;احذر، خطر تجاوز 21.&quot;,
                        goodHand: &quot;يد ممتازة! ابق واثقاً.&quot;
                    }
                }
            },
            es: {
                title: &quot;Blackjack Cuántico&quot;,
                subtitle: &quot;Experiencia de juego futurista con IA&quot;,
                start: &quot;🚀 Iniciar&quot;,
                pause: &quot;⏸️ Pausa&quot;,
                resume: &quot;▶️ Reanudar&quot;,
                rules: &quot;📖 Reglas&quot;,
                newGame: &quot;🔄 Nuevo Juego&quot;,
                dealerTitle: &quot;🤖 Crupier IA Cuántico&quot;,
                playerTitle: &quot;👤 Jugador&quot;,
                aiName: &quot;ARIA-Q&quot;,
                aiWelcome: &quot;¡Hola! Soy ARIA-Q, tu asistente IA cuántico. ¿Listo para un Blackjack futurista?&quot;,
                statsTitle: &quot;Estadísticas&quot;,
                wins: &quot;Victorias:&quot;,
                losses: &quot;Derrotas:&quot;,
                blackjacks: &quot;Blackjacks:&quot;,
                winRate: &quot;Tasa Victoria:&quot;,
                level: &quot;Nivel:&quot;,
                bet: &quot;Apuesta:&quot;,
                credits: &quot;Créditos:&quot;,
                hit: &quot;📥 Carta&quot;,
                stand: &quot;✋ Plantarse&quot;,
                double: &quot;⚡ Doblar&quot;,
                surrender: &quot;🏳️ Rendirse&quot;,
                score: &quot;Puntuación:&quot;,
                startMessage: &quot;Haz clic en \&quot;Iniciar\&quot; para comenzar&quot;,
                rulesTitle: &quot;📖 Reglas del Blackjack Cuántico&quot;,
                pauseTitle: &quot;⏸️ Juego Pausado&quot;,
                pauseMessage: &quot;El juego está actualmente pausado.&quot;,
                levelIndicator: &quot;Nivel&quot;,
                closeBtn: &quot;Cerrar&quot;,
                rulesContent: {
                    objective: {
                        title: &quot;🎯 Objetivo&quot;,
                        text: &quot;Obtén una mano con valor más cercano a 21 que la del crupier, sin exceder 21.&quot;
                    },
                    cardValues: {
                        title: &quot;🃏 Valores de las Cartas&quot;,
                        ace: &quot;As: 1 u 11 (mejor valor automáticamente)&quot;,
                        figures: &quot;Figuras (Rey, Reina, Jota): 10 puntos&quot;,
                        numbers: &quot;Cartas numéricas: Valor nominal (2-10)&quot;
                    },
                    actions: {
                        title: &quot;🎮 Acciones Disponibles&quot;,
                        hit: &quot;Carta: Solicitar una carta adicional&quot;,
                        stand: &quot;Plantarse: Mantener tu mano actual&quot;,
                        double: &quot;Doblar: Doblar la apuesta y recibir exactamente una carta&quot;,
                        surrender: &quot;Rendirse: Abandonar y recuperar la mitad de tu apuesta&quot;
                    },
                    winning: {
                        title: &quot;🏆 Condiciones de Victoria&quot;,
                        blackjack: &quot;Blackjack: As + carta de 10 (pago 3:2)&quot;,
                        normal: &quot;Victoria normal: Más cerca de 21 que el crupier&quot;,
                        dealerBust: &quot;Crupier se pasa: El crupier excede 21&quot;
                    },
                    ai: {
                        title: &quot;🤖 IA Cuántica&quot;,
                        dealer: &quot;El crupier roba hasta 17 (17 suave incluido)&quot;,
                        advice: &quot;ARIA-Q te da consejos estratégicos&quot;,
                        levels: &quot;Sistema de niveles basado en rendimiento&quot;
                    },
                    credits: {
                        title: &quot;💰 Sistema de Créditos&quot;,
                        start: &quot;Comienza con 1000 créditos&quot;,
                        minimum: &quot;Apuesta mínima: 1 crédito&quot;,
                        bonus: &quot;Gana bonos de nivel&quot;,
                        features: &quot;Desbloquea nuevas características&quot;
                    }
                },
                messages: {
                    blackjack: &quot;🎉 ¡BLACKJACK! ¡Ganas!&quot;,
                    playerWin: &quot;🎉 ¡Ganas!&quot;,
                    dealerWin: &quot;😔 El crupier gana&quot;,
                    tie: &quot;🤝 ¡Empate!&quot;,
                    bust: &quot;💥 ¡Te pasaste de 21!&quot;,
                    dealerBust: &quot;🎉 ¡El crupier se pasó!&quot;,
                    surrender: &quot;🏳️ Te rendiste&quot;,
                    levelUp: &quot;🎊 ¡Subiste de nivel! ¡Bonus de créditos!&quot;,
                    gameOver: &quot;💸 ¡Sin créditos! ¿Nuevo juego?&quot;,
                    aiAdvice: {
                        hit: &quot;Recomiendo tomar una carta.&quot;,
                        stand: &quot;Recomiendo plantarse.&quot;,
                        double: &quot;¡Buena oportunidad para doblar!&quot;,
                        careful: &quot;Cuidado, riesgo de pasarse.&quot;,
                        goodHand: &quot;¡Excelente mano! Mantén la confianza.&quot;
                    }
                }
            },
            de: {
                title: &quot;Blackjack Quantum&quot;,
                subtitle: &quot;Futuristische Spielerfahrung mit KI&quot;,
                start: &quot;🚀 Starten&quot;,
                pause: &quot;⏸️ Pause&quot;,
                resume: &quot;▶️ Fortsetzen&quot;,
                rules: &quot;📖 Regeln&quot;,
                newGame: &quot;🔄 Neues Spiel&quot;,
                dealerTitle: &quot;🤖 Quantum KI Dealer&quot;,
                playerTitle: &quot;👤 Spieler&quot;,
                aiName: &quot;ARIA-Q&quot;,
                aiWelcome: &quot;Hallo! Ich bin ARIA-Q, dein Quantum KI-Assistent. Bereit für futuristisches Blackjack?&quot;,
                statsTitle: &quot;Statistiken&quot;,
                wins: &quot;Siege:&quot;,
                losses: &quot;Niederlagen:&quot;,
                blackjacks: &quot;Blackjacks:&quot;,
                winRate: &quot;Gewinnrate:&quot;,
                level: &quot;Level:&quot;,
                bet: &quot;Einsatz:&quot;,
                credits: &quot;Kredite:&quot;,
                hit: &quot;📥 Karte&quot;,
                stand: &quot;✋ Halten&quot;,
                double: &quot;⚡ Verdoppeln&quot;,
                surrender: &quot;🏳️ Aufgeben&quot;,
                score: &quot;Punkte:&quot;,
                startMessage: &quot;Klicke \&quot;Starten\&quot; um zu beginnen&quot;,
                rulesTitle: &quot;📖 Blackjack Quantum Regeln&quot;,
                pauseTitle: &quot;⏸️ Spiel Pausiert&quot;,
                pauseMessage: &quot;Das Spiel ist derzeit pausiert.&quot;,
                levelIndicator: &quot;Level&quot;,
                closeBtn: &quot;Schließen&quot;,
                rulesContent: {
                    objective: {
                        title: &quot;🎯 Ziel&quot;,
                        text: &quot;Erhalte eine Hand mit einem Wert näher zu 21 als der Dealer, ohne 21 zu überschreiten.&quot;
                    },
                    cardValues: {
                        title: &quot;🃏 Kartenwerte&quot;,
                        ace: &quot;Ass: 1 oder 11 (bester Wert automatisch)&quot;,
                        figures: &quot;Bildkarten (König, Dame, Bube): 10 Punkte&quot;,
                        numbers: &quot;Zahlenkarten: Nennwert (2-10)&quot;
                    },
                    actions: {
                        title: &quot;🎮 Verfügbare Aktionen&quot;,
                        hit: &quot;Karte: Eine zusätzliche Karte anfordern&quot;,
                        stand: &quot;Halten: Deine aktuelle Hand behalten&quot;,
                        double: &quot;Verdoppeln: Einsatz verdoppeln und genau eine Karte erhalten&quot;,
                        surrender: &quot;Aufgeben: Aufgeben und die Hälfte deines Einsatzes zurückbekommen&quot;
                    },
                    winning: {
                        title: &quot;🏆 Gewinnbedingungen&quot;,
                        blackjack: &quot;Blackjack: Ass + 10-Wert-Karte (3:2 Auszahlung)&quot;,
                        normal: &quot;Normaler Gewinn: Näher zu 21 als der Dealer&quot;,
                        dealerBust: &quot;Dealer überzogen: Dealer überschreitet 21&quot;
                    },
                    ai: {
                        title: &quot;🤖 Quantum KI&quot;,
                        dealer: &quot;Dealer zieht bis 17 (weiche 17 eingeschlossen)&quot;,
                        advice: &quot;ARIA-Q gibt dir strategische Ratschläge&quot;,
                        levels: &quot;Level-System basierend auf Leistung&quot;
                    },
                    credits: {
                        title: &quot;💰 Kredit-System&quot;,
                        start: &quot;Beginne mit 1000 Krediten&quot;,
                        minimum: &quot;Mindesteinsatz: 1 Kredit&quot;,
                        bonus: &quot;Verdiene Level-Boni&quot;,
                        features: &quot;Schalte neue Features frei&quot;
                    }
                },
                messages: {
                    blackjack: &quot;🎉 BLACKJACK! Du gewinnst!&quot;,
                    playerWin: &quot;🎉 Du gewinnst!&quot;,
                    dealerWin: &quot;😔 Dealer gewinnt&quot;,
                    tie: &quot;🤝 Unentschieden!&quot;,
                    bust: &quot;💥 Du hast 21 überschritten!&quot;,
                    dealerBust: &quot;🎉 Dealer überschritten!&quot;,
                    surrender: &quot;🏳️ Du hast aufgegeben&quot;,
                    levelUp: &quot;🎊 Level aufgestiegen! Kredit-Bonus!&quot;,
                    gameOver: &quot;💸 Keine Kredite mehr! Neues Spiel?&quot;,
                    aiAdvice: {
                        hit: &quot;Ich empfehle eine Karte zu nehmen.&quot;,
                        stand: &quot;Ich empfehle zu halten.&quot;,
                        double: &quot;Gute Gelegenheit zu verdoppeln!&quot;,
                        careful: &quot;Vorsicht, Risiko zu überziehen.&quot;,
                        goodHand: &quot;Ausgezeichnete Hand! Bleib zuversichtlich.&quot;
                    }
                }
            },
            zh: {
                title: &quot;量子二十一点&quot;,
                subtitle: &quot;未来主义AI游戏体验&quot;,
                start: &quot;🚀 开始&quot;,
                pause: &quot;⏸️ 暂停&quot;,
                resume: &quot;▶️ 继续&quot;,
                rules: &quot;📖 规则&quot;,
                newGame: &quot;🔄 新游戏&quot;,
                dealerTitle: &quot;🤖 量子AI庄家&quot;,
                playerTitle: &quot;👤 玩家&quot;,
                aiName: &quot;ARIA-Q&quot;,
                aiWelcome: &quot;你好！我是ARIA-Q，你的量子AI助手。准备好未来主义二十一点了吗？&quot;,
                statsTitle: &quot;统计&quot;,
                wins: &quot;胜利:&quot;,
                losses: &quot;失败:&quot;,
                blackjacks: &quot;二十一点:&quot;,
                winRate: &quot;胜率:&quot;,
                level: &quot;等级:&quot;,
                bet: &quot;下注:&quot;,
                credits: &quot;积分:&quot;,
                hit: &quot;📥 要牌&quot;,
                stand: &quot;✋ 停牌&quot;,
                double: &quot;⚡ 加倍&quot;,
                surrender: &quot;🏳️ 投降&quot;,
                score: &quot;分数:&quot;,
                startMessage: &quot;点击\&quot;开始\&quot;开始游戏&quot;,
                rulesTitle: &quot;📖 量子二十一点规则&quot;,
                pauseTitle: &quot;⏸️ 游戏暂停&quot;,
                pauseMessage: &quot;游戏当前已暂停。&quot;,
                levelIndicator: &quot;等级&quot;,
                closeBtn: &quot;关闭&quot;,
                rulesContent: {
                    objective: {
                        title: &quot;🎯 目标&quot;,
                        text: &quot;获得比庄家更接近21点的手牌，但不能超过21点。&quot;
                    },
                    cardValues: {
                        title: &quot;🃏 牌面价值&quot;,
                        ace: &quot;A：1或11（自动选择最佳值）&quot;,
                        figures: &quot;人头牌（K、Q、J）：10点&quot;,
                        numbers: &quot;数字牌：面值（2-10）&quot;
                    },
                    actions: {
                        title: &quot;🎮 可用操作&quot;,
                        hit: &quot;要牌：请求额外的牌&quot;,
                        stand: &quot;停牌：保持当前手牌&quot;,
                        double: &quot;加倍：加倍下注并只拿一张牌&quot;,
                        surrender: &quot;投降：放弃并收回一半赌注&quot;
                    },
                    winning: {
                        title: &quot;🏆 获胜条件&quot;,
                        blackjack: &quot;二十一点：A + 10点牌（3:2赔付）&quot;,
                        normal: &quot;普通获胜：比庄家更接近21点&quot;,
                        dealerBust: &quot;庄家爆牌：庄家超过21点&quot;
                    },
                    ai: {
                        title: &quot;🤖 量子AI&quot;,
                        dealer: &quot;庄家抽牌至17点（包括软17）&quot;,
                        advice: &quot;ARIA-Q为你提供策略建议&quot;,
                        levels: &quot;基于表现的等级系统&quot;
                    },
                    credits: {
                        title: &quot;💰 积分系统&quot;,
                        start: &quot;从1000积分开始&quot;,
                        minimum: &quot;最小下注：1积分&quot;,
                        bonus: &quot;获得等级奖励&quot;,
                        features: &quot;解锁新功能&quot;
                    }
                },
                messages: {
                    blackjack: &quot;🎉 二十一点！你赢了！&quot;,
                    playerWin: &quot;🎉 你赢了！&quot;,
                    dealerWin: &quot;😔 庄家获胜&quot;,
                    tie: &quot;🤝 平局！&quot;,
                    bust: &quot;💥 你爆牌了！&quot;,
                    dealerBust: &quot;🎉 庄家爆牌！&quot;,
                    surrender: &quot;🏳️ 你投降了&quot;,
                    levelUp: &quot;🎊 升级了！积分奖励！&quot;,
                    gameOver: &quot;💸 积分用完！新游戏？&quot;,
                    aiAdvice: {
                        hit: &quot;我建议要一张牌。&quot;,
                        stand: &quot;我建议停牌。&quot;,
                        double: &quot;加倍的好机会！&quot;,
                        careful: &quot;小心，有爆牌风险。&quot;,
                        goodHand: &quot;很好的牌！保持信心。&quot;
                    }
                }
            }
        };

        let currentLanguage = &#x27;fr&#x27;;
        let gameState = {
            isPlaying: false,
            isPaused: false,
            playerCards: [],
            dealerCards: [],
            playerScore: 0,
            dealerScore: 0,
            bet: 10,
            credits: 1000,
            level: 1,
            wins: 0,
            losses: 0,
            blackjacks: 0,
            deck: [],
            gamePhase: &#x27;betting&#x27; // betting, playing, dealer, finished
        };

        const suits = [&#x27;♠&#x27;, &#x27;♥&#x27;, &#x27;♦&#x27;, &#x27;♣&#x27;];
        const values = [&#x27;A&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;10&#x27;, &#x27;J&#x27;, &#x27;Q&#x27;, &#x27;K&#x27;];

        function createParticles() {
            const particlesContainer = document.getElementById(&#x27;particles&#x27;);
            for (let i = 0; i &lt; 15; i++) {
                const particle = document.createElement(&#x27;div&#x27;);
                particle.className = &#x27;particle&#x27;;
                particle.style.left = Math.random() * 100 + &#x27;%&#x27;;
                particle.style.animationDelay = Math.random() * 8 + &#x27;s&#x27;;
                particle.style.animationDuration = (Math.random() * 4 + 4) + &#x27;s&#x27;;
                particlesContainer.appendChild(particle);
            }
        }

        function updateLanguage() {
            const lang = document.getElementById(&#x27;languageSelect&#x27;).value;
            currentLanguage = lang;
            const t = translations[lang];
            
            // Update UI elements
            document.getElementById(&#x27;gameTitle&#x27;).textContent = t.title;
            document.getElementById(&#x27;gameSubtitle&#x27;).textContent = t.subtitle;
            document.getElementById(&#x27;startBtn2&#x27;).innerHTML = t.start;
            document.getElementById(&#x27;pauseBtn2&#x27;).innerHTML = gameState.isPaused ? t.resume : t.pause;
            document.getElementById(&#x27;rulesBtn2&#x27;).innerHTML = t.rules;
            document.getElementById(&#x27;newGameBtn2&#x27;).innerHTML = t.newGame;
            document.getElementById(&#x27;dealerTitle&#x27;).textContent = t.dealerTitle;
            document.getElementById(&#x27;playerTitle&#x27;).textContent = t.playerTitle;
            document.getElementById(&#x27;aiName&#x27;).textContent = t.aiName;
            document.getElementById(&#x27;aiMessage&#x27;).textContent = t.aiWelcome;
            document.getElementById(&#x27;statsTitle&#x27;).textContent = t.statsTitle;
            document.getElementById(&#x27;winsLabel&#x27;).textContent = t.wins;
            document.getElementById(&#x27;lossesLabel&#x27;).textContent = t.losses;
            document.getElementById(&#x27;blackjacksLabel&#x27;).textContent = t.blackjacks;
            document.getElementById(&#x27;winRateLabel&#x27;).textContent = t.winRate;
            document.getElementById(&#x27;levelLabel&#x27;).textContent = t.level;
            document.getElementById(&#x27;betLabel&#x27;).textContent = t.bet;
            document.getElementById(&#x27;creditsLabel&#x27;).innerHTML = t.credits + &#x27; &lt;span id=&quot;creditsAmount&quot;&gt;&#x27; + gameState.credits + &#x27;&lt;/span&gt;&#x27;;
            document.getElementById(&#x27;hitBtn&#x27;).innerHTML = t.hit;
            document.getElementById(&#x27;standBtn&#x27;).innerHTML = t.stand;
            document.getElementById(&#x27;doubleBtn&#x27;).innerHTML = t.double;
            document.getElementById(&#x27;surrenderBtn&#x27;).innerHTML = t.surrender;
            document.getElementById(&#x27;levelIndicator&#x27;).textContent = t.levelIndicator + &#x27; &#x27; + gameState.level;
            
            // Update rules content
            updateRulesContent();
            
            if (!gameState.isPlaying) {
                document.getElementById(&#x27;gameMessage&#x27;).textContent = t.startMessage;
            }
            
            // Update score displays
            updateScoreDisplays();
            
            // Set text direction for Arabic
            if (lang === &#x27;ar&#x27;) {
                document.body.style.direction = &#x27;rtl&#x27;;
                document.body.style.textAlign = &#x27;right&#x27;;
            } else {
                document.body.style.direction = &#x27;ltr&#x27;;
                document.body.style.textAlign = &#x27;left&#x27;;
            }
        }

        function updateRulesContent() {
            const t = translations[currentLanguage];
            
            // Update rules title
            document.getElementById(&#x27;rulesTitle&#x27;).textContent = t.rulesTitle;
            
            // Update rules content if it exists
            if (t.rulesContent) {
                // Objective
                const objectiveEl = document.getElementById(&#x27;rulesObjective&#x27;);
                if (objectiveEl) {
                    objectiveEl.innerHTML = `
                        &lt;h3&gt;${t.rulesContent.objective.title}&lt;/h3&gt;
                        &lt;p&gt;${t.rulesContent.objective.text}&lt;/p&gt;
                    `;
                }
                
                // Card Values
                const cardValuesEl = document.getElementById(&#x27;rulesCardValues&#x27;);
                if (cardValuesEl) {
                    cardValuesEl.innerHTML = `
                        &lt;h3&gt;${t.rulesContent.cardValues.title}&lt;/h3&gt;
                        &lt;ul&gt;
                            &lt;li&gt;&lt;strong&gt;${t.rulesContent.cardValues.ace}&lt;/strong&gt;&lt;/li&gt;
                            &lt;li&gt;&lt;strong&gt;${t.rulesContent.cardValues.figures}&lt;/strong&gt;&lt;/li&gt;
                            &lt;li&gt;&lt;strong&gt;${t.rulesContent.cardValues.numbers}&lt;/strong&gt;&lt;/li&gt;
                        &lt;/ul&gt;
                    `;
                }
                
                // Actions
                const actionsEl = document.getElementById(&#x27;rulesActions&#x27;);
                if (actionsEl) {
                    actionsEl.innerHTML = `
                        &lt;h3&gt;${t.rulesContent.actions.title}&lt;/h3&gt;
                        &lt;ul&gt;
                            &lt;li&gt;&lt;strong&gt;${t.rulesContent.actions.hit}&lt;/strong&gt;&lt;/li&gt;
                            &lt;li&gt;&lt;strong&gt;${t.rulesContent.actions.stand}&lt;/strong&gt;&lt;/li&gt;
                            &lt;li&gt;&lt;strong&gt;${t.rulesContent.actions.double}&lt;/strong&gt;&lt;/li&gt;
                            &lt;li&gt;&lt;strong&gt;${t.rulesContent.actions.surrender}&lt;/strong&gt;&lt;/li&gt;
                        &lt;/ul&gt;
                    `;
                }
                
                // Winning conditions
                const winningEl = document.getElementById(&#x27;rulesWinning&#x27;);
                if (winningEl) {
                    winningEl.innerHTML = `
                        &lt;h3&gt;${t.rulesContent.winning.title}&lt;/h3&gt;
                        &lt;ul&gt;
                            &lt;li&gt;&lt;strong&gt;${t.rulesContent.winning.blackjack}&lt;/strong&gt;&lt;/li&gt;
                            &lt;li&gt;&lt;strong&gt;${t.rulesContent.winning.normal}&lt;/strong&gt;&lt;/li&gt;
                            &lt;li&gt;&lt;strong&gt;${t.rulesContent.winning.dealerBust}&lt;/strong&gt;&lt;/li&gt;
                        &lt;/ul&gt;
                    `;
                }
                
                // AI
                const aiEl = document.getElementById(&#x27;rulesAI&#x27;);
                if (aiEl) {
                    aiEl.innerHTML = `
                        &lt;h3&gt;${t.rulesContent.ai.title}&lt;/h3&gt;
                        &lt;ul&gt;
                            &lt;li&gt;${t.rulesContent.ai.dealer}&lt;/li&gt;
                            &lt;li&gt;${t.rulesContent.ai.advice}&lt;/li&gt;
                            &lt;li&gt;${t.rulesContent.ai.levels}&lt;/li&gt;
                        &lt;/ul&gt;
                    `;
                }
                
                // Credits
                const creditsEl = document.getElementById(&#x27;rulesCredits&#x27;);
                if (creditsEl) {
                    creditsEl.innerHTML = `
                        &lt;h3&gt;${t.rulesContent.credits.title}&lt;/h3&gt;
                        &lt;ul&gt;
                            &lt;li&gt;${t.rulesContent.credits.start}&lt;/li&gt;
                            &lt;li&gt;${t.rulesContent.credits.minimum}&lt;/li&gt;
                            &lt;li&gt;${t.rulesContent.credits.bonus}&lt;/li&gt;
                            &lt;li&gt;${t.rulesContent.credits.features}&lt;/li&gt;
                        &lt;/ul&gt;
                    `;
                }
            }
            
            // Update close button
            const closeBtn = document.querySelector(&#x27;.rules-panel .quantum-btn&#x27;);
            if (closeBtn &amp;&amp; t.closeBtn) {
                closeBtn.textContent = t.closeBtn;
            }
        }

        function createDeck() {
            const deck = [];
            for (let suit of suits) {
                for (let value of values) {
                    deck.push({ suit, value });
                }
            }
            return shuffleDeck(deck);
        }

        function shuffleDeck(deck) {
            const shuffled = [...deck];
            for (let i = shuffled.length - 1; i &gt; 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        function getCardValue(card) {
            if (card.value === &#x27;A&#x27;) return 11;
            if ([&#x27;J&#x27;, &#x27;Q&#x27;, &#x27;K&#x27;].includes(card.value)) return 10;
            return parseInt(card.value);
        }

        function calculateScore(cards) {
            let score = 0;
            let aces = 0;
            
            for (let card of cards) {
                if (card.value === &#x27;A&#x27;) {
                    aces++;
                    score += 11;
                } else if ([&#x27;J&#x27;, &#x27;Q&#x27;, &#x27;K&#x27;].includes(card.value)) {
                    score += 10;
                } else {
                    score += parseInt(card.value);
                }
            }
            
            // Adjust for aces
            while (score &gt; 21 &amp;&amp; aces &gt; 0) {
                score -= 10;
                aces--;
            }
            
            return score;
        }

        function createCardElement(card, hidden = false) {
            const cardEl = document.createElement(&#x27;div&#x27;);
            cardEl.className = &#x27;card&#x27;;
            
            if (hidden) {
                cardEl.classList.add(&#x27;hidden&#x27;);
                cardEl.innerHTML = `
                    &lt;div class=&quot;card-value&quot;&gt;?&lt;/div&gt;
                    &lt;div class=&quot;card-suit&quot;&gt;🔒&lt;/div&gt;
                `;
            } else {
                const isRed = [&#x27;♥&#x27;, &#x27;♦&#x27;].includes(card.suit);
                cardEl.classList.add(isRed ? &#x27;red&#x27; : &#x27;black&#x27;);
                cardEl.innerHTML = `
                    &lt;div class=&quot;card-value&quot;&gt;${card.value}&lt;/div&gt;
                    &lt;div class=&quot;card-suit&quot;&gt;${card.suit}&lt;/div&gt;
                `;
            }
            
            return cardEl;
        }

        function updateDisplay() {
            // Update cards
            const dealerCardsEl = document.getElementById(&#x27;dealerCards&#x27;);
            const playerCardsEl = document.getElementById(&#x27;playerCards&#x27;);
            
            dealerCardsEl.innerHTML = &#x27;&#x27;;
            playerCardsEl.innerHTML = &#x27;&#x27;;
            
            // Dealer cards (hide first card during play)
            gameState.dealerCards.forEach((card, index) =&gt; {
                const hidden = gameState.gamePhase === &#x27;playing&#x27; &amp;&amp; index === 0;
                dealerCardsEl.appendChild(createCardElement(card, hidden));
            });
            
            // Player cards
            gameState.playerCards.forEach(card =&gt; {
                playerCardsEl.appendChild(createCardElement(card));
            });
            
            updateScoreDisplays();
            updateStats();
        }

        function updateScoreDisplays() {
            const t = translations[currentLanguage];
            const dealerScoreEl = document.getElementById(&#x27;dealerScore&#x27;);
            const playerScoreEl = document.getElementById(&#x27;playerScore&#x27;);
            
            if (gameState.gamePhase === &#x27;playing&#x27;) {
                dealerScoreEl.textContent = t.score + &#x27; ?&#x27;;
            } else {
                dealerScoreEl.textContent = t.score + &#x27; &#x27; + gameState.dealerScore;
            }
            
            playerScoreEl.textContent = t.score + &#x27; &#x27; + gameState.playerScore;
        }

        function updateStats() {
            document.getElementById(&#x27;winsValue&#x27;).textContent = gameState.wins;
            document.getElementById(&#x27;lossesValue&#x27;).textContent = gameState.losses;
            document.getElementById(&#x27;blackjacksValue&#x27;).textContent = gameState.blackjacks;
            
            const totalGames = gameState.wins + gameState.losses;
            const winRate = totalGames &gt; 0 ? Math.round((gameState.wins / totalGames) * 100) : 0;
            document.getElementById(&#x27;winRateValue&#x27;).textContent = winRate + &#x27;%&#x27;;
            
            document.getElementById(&#x27;levelValue&#x27;).textContent = gameState.level;
            document.getElementById(&#x27;creditsAmount&#x27;).textContent = gameState.credits;
            document.getElementById(&#x27;levelIndicator&#x27;).textContent = translations[currentLanguage].levelIndicator + &#x27; &#x27; + gameState.level;
        }

        function startGame() {
            if (gameState.isPaused) {
                togglePause();
                return;
            }
            
            const betAmount = parseInt(document.getElementById(&#x27;betAmount&#x27;).value);
            if (betAmount &gt; gameState.credits) {
                showMessage(&quot;Mise trop élevée !&quot;);
                return;
            }
            
            gameState.bet = betAmount;
            gameState.credits -= betAmount;
            gameState.isPlaying = true;
            gameState.gamePhase = &#x27;playing&#x27;;
            gameState.deck = createDeck();
            gameState.playerCards = [];
            gameState.dealerCards = [];
            
            // Deal initial cards
            gameState.playerCards.push(gameState.deck.pop());
            gameState.dealerCards.push(gameState.deck.pop());
            gameState.playerCards.push(gameState.deck.pop());
            gameState.dealerCards.push(gameState.deck.pop());
            
            gameState.playerScore = calculateScore(gameState.playerCards);
            gameState.dealerScore = calculateScore(gameState.dealerCards);
            
            updateDisplay();
            updateUI();
            
            // Check for blackjack
            if (gameState.playerScore === 21) {
                if (gameState.dealerScore === 21) {
                    endGame(&#x27;tie&#x27;);
                } else {
                    endGame(&#x27;blackjack&#x27;);
                }
            } else {
                showMessage(&quot;Votre tour ! Choisissez une action.&quot;);
                giveAIAdvice();
            }
        }

        function hit() {
            if (!gameState.isPlaying || gameState.gamePhase !== &#x27;playing&#x27;) return;
            
            gameState.playerCards.push(gameState.deck.pop());
            gameState.playerScore = calculateScore(gameState.playerCards);
            
            updateDisplay();
            
            if (gameState.playerScore &gt; 21) {
                endGame(&#x27;bust&#x27;);
            } else if (gameState.playerScore === 21) {
                stand();
            } else {
                giveAIAdvice();
            }
        }

        function stand() {
            if (!gameState.isPlaying || gameState.gamePhase !== &#x27;playing&#x27;) return;
            
            gameState.gamePhase = &#x27;dealer&#x27;;
            
            // Dealer plays
            while (gameState.dealerScore &lt; 17) {
                gameState.dealerCards.push(gameState.deck.pop());
                gameState.dealerScore = calculateScore(gameState.dealerCards);
            }
            
            updateDisplay();
            
            // Determine winner
            if (gameState.dealerScore &gt; 21) {
                endGame(&#x27;dealerBust&#x27;);
            } else if (gameState.dealerScore &gt; gameState.playerScore) {
                endGame(&#x27;dealerWin&#x27;);
            } else if (gameState.playerScore &gt; gameState.dealerScore) {
                endGame(&#x27;playerWin&#x27;);
            } else {
                endGame(&#x27;tie&#x27;);
            }
        }

        function doubleDown() {
            if (!gameState.isPlaying || gameState.gamePhase !== &#x27;playing&#x27;) return;
            if (gameState.credits &lt; gameState.bet) {
                showMessage(&quot;Pas assez de crédits pour doubler !&quot;);
                return;
            }
            
            gameState.credits -= gameState.bet;
            gameState.bet *= 2;
            
            hit();
            if (gameState.playerScore &lt;= 21) {
                stand();
            }
        }

        function surrender() {
            if (!gameState.isPlaying || gameState.gamePhase !== &#x27;playing&#x27;) return;
            
            gameState.credits += Math.floor(gameState.bet / 2);
            endGame(&#x27;surrender&#x27;);
        }

        function endGame(result) {
            gameState.gamePhase = &#x27;finished&#x27;;
            const t = translations[currentLanguage];
            
            switch (result) {
                case &#x27;blackjack&#x27;:
                    gameState.credits += Math.floor(gameState.bet * 2.5);
                    gameState.wins++;
                    gameState.blackjacks++;
                    showMessage(t.messages.blackjack);
                    break;
                case &#x27;playerWin&#x27;:
                    gameState.credits += gameState.bet * 2;
                    gameState.wins++;
                    showMessage(t.messages.playerWin);
                    break;
                case &#x27;dealerWin&#x27;:
                    gameState.losses++;
                    showMessage(t.messages.dealerWin);
                    break;
                case &#x27;tie&#x27;:
                    gameState.credits += gameState.bet;
                    showMessage(t.messages.tie);
                    break;
                case &#x27;bust&#x27;:
                    gameState.losses++;
                    showMessage(t.messages.bust);
                    break;
                case &#x27;dealerBust&#x27;:
                    gameState.credits += gameState.bet * 2;
                    gameState.wins++;
                    showMessage(t.messages.dealerBust);
                    break;
                case &#x27;surrender&#x27;:
                    gameState.losses++;
                    showMessage(t.messages.surrender);
                    break;
            }
            
            checkLevelUp();
            updateDisplay();
            updateUI();
            
            if (gameState.credits &lt;= 0) {
                showMessage(t.messages.gameOver);
                setTimeout(() =&gt; {
                    if (confirm(&quot;Nouvelle partie avec 1000 crédits ?&quot;)) {
                        newGame();
                    }
                }, 2000);
            }
        }

        function checkLevelUp() {
            const newLevel = Math.floor(gameState.wins / 5) + 1;
            if (newLevel &gt; gameState.level) {
                gameState.level = newLevel;
                const bonus = newLevel * 100;
                gameState.credits += bonus;
                showMessage(translations[currentLanguage].messages.levelUp);
            }
        }

        function giveAIAdvice() {
            const t = translations[currentLanguage];
            let advice = &quot;&quot;;
            
            if (gameState.playerScore &lt; 12) {
                advice = t.messages.aiAdvice.hit;
            } else if (gameState.playerScore &gt;= 17) {
                advice = t.messages.aiAdvice.stand;
            } else if (gameState.playerScore === 11 &amp;&amp; gameState.playerCards.length === 2) {
                advice = t.messages.aiAdvice.double;
            } else if (gameState.playerScore &gt;= 15) {
                advice = t.messages.aiAdvice.careful;
            } else {
                advice = t.messages.aiAdvice.goodHand;
            }
            
            document.getElementById(&#x27;aiMessage&#x27;).textContent = advice;
        }

        function showMessage(message) {
            document.getElementById(&#x27;gameMessage&#x27;).textContent = message;
        }

        function updateUI() {
            const isPlaying = gameState.isPlaying &amp;&amp; gameState.gamePhase === &#x27;playing&#x27;;
            
            // Update both sets of buttons
            document.getElementById(&#x27;startBtn2&#x27;).disabled = false; // Toujours activé pour permettre l&#x27;arrêt
            document.getElementById(&#x27;pauseBtn2&#x27;).disabled = !gameState.isPlaying;
            document.getElementById(&#x27;newGameBtn2&#x27;).disabled = false; // Toujours activé pour sortir du jeu
            document.getElementById(&#x27;gameActions&#x27;).style.display = isPlaying ? &#x27;flex&#x27; : &#x27;none&#x27;;
            document.getElementById(&#x27;betControls&#x27;).style.display = gameState.isPlaying ? &#x27;none&#x27; : &#x27;flex&#x27;;
            
            // Update button text and functionality
            const t = translations[currentLanguage];
            const startBtn = document.getElementById(&#x27;startBtn2&#x27;);
            
            if (gameState.isPlaying &amp;&amp; !gameState.isPaused) {
                startBtn.innerHTML = &quot;🎮 En cours...&quot;;
                startBtn.onclick = function() {
                    // Permettre de sortir du jeu en cours
                    const confirmMessage = currentLanguage === &#x27;fr&#x27; ? 
                        &#x27;Voulez-vous arrêter la partie en cours ?&#x27; :
                        currentLanguage === &#x27;en&#x27; ? 
                        &#x27;Do you want to stop the current game?&#x27; :
                        currentLanguage === &#x27;ar&#x27; ?
                        &#x27;هل تريد إيقاف اللعبة الحالية؟&#x27; :
                        currentLanguage === &#x27;es&#x27; ?
                        &#x27;¿Quieres parar el juego actual?&#x27; :
                        currentLanguage === &#x27;de&#x27; ?
                        &#x27;Möchten Sie das aktuelle Spiel beenden?&#x27; :
                        &#x27;您想停止当前游戏吗？&#x27;;
                    
                    if (confirm(confirmMessage)) {
                        stopCurrentGame();
                    }
                };
            } else {
                startBtn.innerHTML = t.start;
                startBtn.onclick = startGame;
            }
            
            document.getElementById(&#x27;pauseBtn2&#x27;).innerHTML = gameState.isPaused ? t.resume : t.pause;
        }

        function togglePause() {
            if (!gameState.isPlaying) return;
            
            gameState.isPaused = !gameState.isPaused;
            const t = translations[currentLanguage];
            
            if (gameState.isPaused) {
                document.getElementById(&#x27;pausePanel&#x27;).style.display = &#x27;block&#x27;;
                document.getElementById(&#x27;pauseBtn&#x27;).innerHTML = t.resume;
            } else {
                document.getElementById(&#x27;pausePanel&#x27;).style.display = &#x27;none&#x27;;
                document.getElementById(&#x27;pauseBtn&#x27;).innerHTML = t.pause;
            }
        }

        function stopCurrentGame() {
            console.log(&#x27;🛑 Arrêt de la partie en cours&#x27;);
            
            // Force stop current game
            gameState.isPlaying = false;
            gameState.isPaused = false;
            gameState.gamePhase = &#x27;betting&#x27;;
            
            // Clear cards and reset display
            gameState.playerCards = [];
            gameState.dealerCards = [];
            gameState.playerScore = 0;
            gameState.dealerScore = 0;
            
            // Reset UI
            document.getElementById(&#x27;dealerCards&#x27;).innerHTML = &#x27;&#x27;;
            document.getElementById(&#x27;playerCards&#x27;).innerHTML = &#x27;&#x27;;
            document.getElementById(&#x27;gameActions&#x27;).style.display = &#x27;none&#x27;;
            document.getElementById(&#x27;betControls&#x27;).style.display = &#x27;flex&#x27;;
            document.getElementById(&#x27;pausePanel&#x27;).style.display = &#x27;none&#x27;;
            
            // Update displays
            updateDisplay();
            updateUI();
            
            // Reset messages
            const t = translations[currentLanguage];
            showMessage(t.startMessage);
            document.getElementById(&#x27;aiMessage&#x27;).textContent = &quot;Partie arrêtée. Prêt pour une nouvelle partie !&quot;;
            
            console.log(&#x27;✅ Partie arrêtée avec succès&#x27;);
        }

        function newGame() {
            // Show confirmation dialog if game is in progress
            if (gameState.isPlaying) {
                const t = translations[currentLanguage];
                const confirmMessage = currentLanguage === &#x27;fr&#x27; ? 
                    &#x27;Êtes-vous sûr de vouloir commencer une nouvelle partie ? Vous perdrez votre progression actuelle.&#x27; :
                    currentLanguage === &#x27;en&#x27; ? 
                    &#x27;Are you sure you want to start a new game? You will lose your current progress.&#x27; :
                    currentLanguage === &#x27;ar&#x27; ?
                    &#x27;هل أنت متأكد من أنك تريد بدء لعبة جديدة؟ ستفقد تقدمك الحالي.&#x27; :
                    currentLanguage === &#x27;es&#x27; ?
                    &#x27;¿Estás seguro de que quieres empezar un nuevo juego? Perderás tu progreso actual.&#x27; :
                    currentLanguage === &#x27;de&#x27; ?
                    &#x27;Sind Sie sicher, dass Sie ein neues Spiel starten möchten? Sie verlieren Ihren aktuellen Fortschritt.&#x27; :
                    &#x27;您确定要开始新游戏吗？您将失去当前进度。&#x27;;
                
                if (!confirm(confirmMessage)) {
                    return;
                }
            }
            
            console.log(&#x27;🔄 Nouvelle partie démarrée - Réinitialisation complète&#x27;);
            
            // Stop current game immediately
            gameState.isPlaying = false;
            gameState.isPaused = false;
            gameState.gamePhase = &#x27;betting&#x27;;
            
            // Reset all game statistics and state
            gameState.playerCards = [];
            gameState.dealerCards = [];
            gameState.playerScore = 0;
            gameState.dealerScore = 0;
            gameState.bet = 10;
            gameState.credits = 1000;
            gameState.level = 1;
            gameState.wins = 0;
            gameState.losses = 0;
            gameState.blackjacks = 0;
            gameState.deck = [];
            
            console.log(&#x27;📊 État du jeu réinitialisé:&#x27;, gameState);
            
            // Reset UI elements immediately
            document.getElementById(&#x27;betAmount&#x27;).value = 10;
            document.getElementById(&#x27;dealerCards&#x27;).innerHTML = &#x27;&#x27;;
            document.getElementById(&#x27;playerCards&#x27;).innerHTML = &#x27;&#x27;;
            document.getElementById(&#x27;gameActions&#x27;).style.display = &#x27;none&#x27;;
            document.getElementById(&#x27;betControls&#x27;).style.display = &#x27;flex&#x27;;
            
            // Hide panels
            document.getElementById(&#x27;pausePanel&#x27;).style.display = &#x27;none&#x27;;
            document.getElementById(&#x27;rulesPanel&#x27;).style.display = &#x27;none&#x27;;
            
            // Force update all displays and stats
            updateDisplay();
            updateUI();
            updateStats();
            
            // Reset messages
            const t = translations[currentLanguage];
            showMessage(t.startMessage);
            document.getElementById(&#x27;aiMessage&#x27;).textContent = t.aiWelcome;
            
            // Update button states
            document.getElementById(&#x27;startBtn2&#x27;).disabled = false;
            document.getElementById(&#x27;pauseBtn2&#x27;).disabled = true;
            document.getElementById(&#x27;newGameBtn2&#x27;).disabled = false; // Keep enabled for easy access
            
            // Clear localStorage
            localStorage.removeItem(&#x27;blackjackQuantumSave&#x27;);
            
            console.log(&#x27;✅ Nouvelle partie complètement réinitialisée - Prêt à jouer!&#x27;);
            
            // Enhanced visual feedback with animation
            const newGameBtn = document.getElementById(&#x27;newGameBtn2&#x27;);
            const originalText = newGameBtn.innerHTML;
            const originalBg = newGameBtn.style.background;
            
            // Success animation
            newGameBtn.innerHTML = &#x27;✅ Réinitialisé!&#x27;;
            newGameBtn.style.background = &#x27;linear-gradient(135deg, rgba(0, 255, 136, 0.6) 0%, rgba(0, 204, 255, 0.6) 100%)&#x27;;
            newGameBtn.style.transform = &#x27;scale(1.1)&#x27;;
            newGameBtn.style.boxShadow = &#x27;0 0 30px rgba(0, 255, 136, 0.8)&#x27;;
            
            // Add particle effect
            createResetParticles();
            
            setTimeout(() =&gt; {
                newGameBtn.innerHTML = originalText;
                newGameBtn.style.background = originalBg;
                newGameBtn.style.transform = &#x27;&#x27;;
                newGameBtn.style.boxShadow = &#x27;&#x27;;
            }, 2000);
            
            // Show welcome message from AI
            setTimeout(() =&gt; {
                const welcomeMessages = {
                    fr: &quot;Parfait ! Nouvelle partie initialisée. Bonne chance !&quot;,
                    en: &quot;Perfect! New game initialized. Good luck!&quot;,
                    ar: &quot;ممتاز! تم تهيئة لعبة جديدة. حظ سعيد!&quot;,
                    es: &quot;¡Perfecto! Nuevo juego inicializado. ¡Buena suerte!&quot;,
                    de: &quot;Perfekt! Neues Spiel initialisiert. Viel Glück!&quot;,
                    zh: &quot;完美！新游戏已初始化。祝你好运！&quot;
                };
                document.getElementById(&#x27;aiMessage&#x27;).textContent = welcomeMessages[currentLanguage];
            }, 1000);
        }

        function createResetParticles() {
            const container = document.querySelector(&#x27;.game-container&#x27;);
            for (let i = 0; i &lt; 20; i++) {
                const particle = document.createElement(&#x27;div&#x27;);
                particle.style.position = &#x27;absolute&#x27;;
                particle.style.width = &#x27;6px&#x27;;
                particle.style.height = &#x27;6px&#x27;;
                particle.style.background = &#x27;#00ff88&#x27;;
                particle.style.borderRadius = &#x27;50%&#x27;;
                particle.style.pointerEvents = &#x27;none&#x27;;
                particle.style.zIndex = &#x27;9999&#x27;;
                particle.style.left = &#x27;50%&#x27;;
                particle.style.top = &#x27;50%&#x27;;
                particle.style.boxShadow = &#x27;0 0 10px rgba(0, 255, 136, 0.8)&#x27;;
                
                const angle = (i / 20) * Math.PI * 2;
                const distance = 100 + Math.random() * 100;
                const duration = 1000 + Math.random() * 500;
                
                container.appendChild(particle);
                
                particle.animate([
                    { 
                        transform: &#x27;translate(-50%, -50%) scale(0)&#x27;,
                        opacity: 1
                    },
                    { 
                        transform: `translate(${Math.cos(angle) * distance - 50}%, ${Math.sin(angle) * distance - 50}%) scale(1)`,
                        opacity: 0
                    }
                ], {
                    duration: duration,
                    easing: &#x27;ease-out&#x27;
                }).onfinish = () =&gt; particle.remove();
            }
        }

        function showRules() {
            document.getElementById(&#x27;rulesPanel&#x27;).style.display = &#x27;block&#x27;;
        }

        function hideRules() {
            document.getElementById(&#x27;rulesPanel&#x27;).style.display = &#x27;none&#x27;;
        }

        // Initialize game
        document.getElementById(&#x27;languageSelect&#x27;).addEventListener(&#x27;change&#x27;, updateLanguage);
        createParticles();
        updateLanguage();
        updateDisplay();
        updateUI();

        // Auto-save game state
        setInterval(() =&gt; {
            if (gameState.isPlaying) {
                localStorage.setItem(&#x27;blackjackQuantumSave&#x27;, JSON.stringify(gameState));
            }
        }, 10000);

        // Load saved game on startup
        const savedGame = localStorage.getItem(&#x27;blackjackQuantumSave&#x27;);
        if (savedGame) {
            try {
                const saved = JSON.parse(savedGame);
                if (saved.credits &gt; 0) {
                    Object.assign(gameState, saved);
                    updateDisplay();
                    updateUI();
                }
            } catch (e) {
                console.log(&#x27;Could not load saved game&#x27;);
            }
        }
    &lt;/script&gt;
&lt;script&gt;(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement(&#x27;script&#x27;);d.innerHTML=&quot;window.__CF$cv$params={r:&#x27;986e2b11d4f1777e&#x27;,t:&#x27;MTc1OTE3NzA5MS4wMDAwMDA=&#x27;};var a=document.createElement(&#x27;script&#x27;);a.nonce=&#x27;&#x27;;a.src=&#x27;/cdn-cgi/challenge-platform/scripts/jsd/main.js&#x27;;document.getElementsByTagName(&#x27;head&#x27;)[0].appendChild(a);&quot;;b.getElementsByTagName(&#x27;head&#x27;)[0].appendChild(d)}}if(document.body){var a=document.createElement(&#x27;iframe&#x27;);a.height=1;a.width=1;a.style.position=&#x27;absolute&#x27;;a.style.top=0;a.style.left=0;a.style.border=&#x27;none&#x27;;a.style.visibility=&#x27;hidden&#x27;;document.body.appendChild(a);if(&#x27;loading&#x27;!==document.readyState)c();else if(window.addEventListener)document.addEventListener(&#x27;DOMContentLoaded&#x27;,c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);&#x27;loading&#x27;!==document.readyState&amp;&amp;(document.onreadystatechange=e,c())}}}})();&lt;/script&gt;&lt;/body&gt;
&lt;/html&gt;
"></iframe>
</div>
<!-- Overlay for Game 14 -->
<div id="game14Overlay" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:#000; z-index:10000; overflow:auto;">
  <button onclick="closeGame14()" aria-label="Fermer jeu 14"
          style="position:absolute; top:20px; right:20px; background:red; color:#fff; border:none; padding:10px; font-size:20px; cursor:pointer; z-index:10001;">✖</button>
  <iframe id="game14Frame" style="width:100%; height:100%; border:none;" srcdoc="&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;fr&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Solitaire Fusion - Jeu de Cartes Futuriste&lt;/title&gt;
    &lt;style&gt;
        body {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: &#x27;Segoe UI&#x27;, Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            color: #ffffff;
            min-height: 100vh;
            overflow-x: auto;
        }

        .quantum-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            background: radial-gradient(circle at 20% 80%, rgba(0, 255, 255, 0.3) 0%, transparent 50%),
                        radial-gradient(circle at 80% 20%, rgba(255, 0, 255, 0.3) 0%, transparent 50%),
                        radial-gradient(circle at 40% 40%, rgba(255, 215, 0, 0.2) 0%, transparent 50%);
        }

        .quantum-particle {
            position: absolute;
            width: 2px;
            height: 2px;
            background: #00ffff;
            border-radius: 50%;
            animation: float 6s ease-in-out infinite;
            box-shadow: 0 0 6px #00ffff;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px) rotate(0deg); opacity: 0.7; }
            50% { transform: translateY(-20px) rotate(180deg); opacity: 1; }
        }

        .main-container {
            max-width: 1400px;
            margin: 0 auto;
            position: relative;
            background: linear-gradient(135deg, rgba(15, 15, 35, 0.95) 0%, rgba(30, 30, 60, 0.95) 100%);
            border: 3px solid rgba(0, 255, 255, 0.4);
            border-radius: 25px;
            backdrop-filter: blur(20px);
            box-shadow: 
                0 0 50px rgba(0, 255, 255, 0.3),
                inset 0 0 50px rgba(0, 255, 255, 0.1);
            padding: 20px;
            margin: 20px auto;
            position: relative;
            overflow: hidden;
        }

        .main-container::before {
            content: &#x27;&#x27;;
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, #00ffff, #ff00ff, #ffff00, #00ffff);
            border-radius: 25px;
            z-index: -1;
            animation: borderGlow 3s linear infinite;
        }

        @keyframes borderGlow {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            background: linear-gradient(135deg, rgba(15, 15, 35, 0.95) 0%, rgba(30, 30, 60, 0.95) 100%);
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 15px;
            padding: 20px 25px;
            backdrop-filter: blur(15px);
            box-shadow: 0 8px 32px rgba(0, 255, 255, 0.2);
            position: relative;
            z-index: 10;
        }

        .game-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            background: linear-gradient(135deg, rgba(15, 15, 35, 0.95) 0%, rgba(30, 30, 60, 0.95) 100%);
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 15px;
            padding: 12px 20px;
            backdrop-filter: blur(15px);
            box-shadow: 0 8px 32px rgba(0, 255, 255, 0.2);
            position: relative;
            z-index: 1;
        }

        .game-title {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .game-title h1 {
            font-size: 28px;
            font-weight: bold;
            background: linear-gradient(135deg, #00ffff, #ff00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin: 0;
            text-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
            letter-spacing: 2px;
        }

        .game-logo {
            font-size: 32px;
            filter: drop-shadow(0 0 20px #00ffff);
            animation: pulse 3s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .language-selector {
            position: relative;
            display: inline-block;
        }

        .language-dropdown {
            background: linear-gradient(135deg, rgba(15, 15, 35, 0.95) 0%, rgba(30, 30, 60, 0.95) 100%);
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 8px;
            color: #00ffff;
            padding: 6px 10px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0, 255, 255, 0.2);
            display: flex;
            align-items: center;
            gap: 5px;
            font-weight: bold;
            min-width: 70px;
            justify-content: space-between;
        }

        .language-dropdown:hover {
            border-color: rgba(0, 255, 255, 0.8);
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.1) 0%, rgba(255, 0, 255, 0.1) 100%);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 255, 255, 0.3);
        }

        .language-options {
            position: absolute;
            top: 100%;
            right: 0;
            left: auto;
            min-width: 160px;
            background: linear-gradient(135deg, rgba(15, 15, 35, 0.98) 0%, rgba(30, 30, 60, 0.98) 100%);
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 15px;
            backdrop-filter: blur(15px);
            box-shadow: 0 8px 32px rgba(0, 255, 255, 0.3);
            z-index: 99999999;
            margin-top: 8px;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px);
            transition: all 0.3s ease;
        }

        .language-options.show {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .language-option {
            padding: 12px 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            color: #ffffff;
            font-weight: bold;
            border-bottom: 1px solid rgba(0, 255, 255, 0.1);
        }

        .language-option:last-child {
            border-bottom: none;
            border-radius: 0 0 13px 13px;
        }

        .language-option:first-child {
            border-radius: 13px 13px 0 0;
        }

        .language-option:hover {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.2) 0%, rgba(255, 0, 255, 0.2) 100%);
            color: #00ffff;
            transform: translateX(5px);
        }

        .language-option.active {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.3) 0%, rgba(255, 0, 255, 0.3) 100%);
            color: #00ffff;
        }

        .game-container {
            display: grid;
            grid-template-columns: 250px 1fr 250px;
            gap: 25px;
            min-height: 650px;
            margin-top: 5px;
        }

        .sidebar {
            background: linear-gradient(135deg, rgba(15, 15, 35, 0.95) 0%, rgba(30, 30, 60, 0.95) 100%);
            border: 3px solid rgba(0, 255, 255, 0.4);
            border-radius: 20px;
            padding: 20px;
            backdrop-filter: blur(15px);
            box-shadow: 
                0 10px 40px rgba(0, 255, 255, 0.2),
                inset 0 0 30px rgba(0, 255, 255, 0.05);
            height: fit-content;
            position: relative;
            overflow: hidden;
        }

        .sidebar::before {
            content: &#x27;&#x27;;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, #00ffff, #ff00ff, #00ffff, transparent);
            animation: scanLine 2s linear infinite;
        }

        @keyframes scanLine {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .game-board {
            background: linear-gradient(135deg, rgba(15, 15, 35, 0.98) 0%, rgba(30, 30, 60, 0.98) 100%);
            border: 4px solid rgba(0, 255, 255, 0.6);
            border-radius: 20px;
            padding: 20px 25px;
            backdrop-filter: blur(20px);
            box-shadow: 
                0 0 60px rgba(0, 255, 255, 0.4),
                inset 0 0 40px rgba(0, 255, 255, 0.1);
            height: fit-content;
            max-height: 650px;
            width: 100%;
            max-width: 700px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        .section-title {
            font-size: 18px;
            font-weight: bold;
            color: #00ffff;
            margin-bottom: 15px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 2px;
            position: relative;
            z-index: 10;
        }

        .quantum-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            font-size: 12px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
            margin: 3px;
        }

        .quantum-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
            background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
        }

        .quantum-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .quantum-btn::before {
            content: &#x27;&#x27;;
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transition: left 0.5s ease;
        }

        .quantum-btn:hover::before {
            left: 100%;
        }

        .action-btn {
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
            color: #1a1a2e;
        }

        .action-btn:hover:not(:disabled) {
            background: linear-gradient(135deg, #ffed4e 0%, #ffd700 100%);
            box-shadow: 0 6px 20px rgba(255, 215, 0, 0.6);
        }

        .danger-btn {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
        }

        .danger-btn:hover:not(:disabled) {
            background: linear-gradient(135deg, #ee5a24 0%, #ff6b6b 100%);
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.6);
        }

        .card {
            width: 60px;
            height: 85px;
            background: linear-gradient(135deg, #ffffff 0%, #f0f0f0 100%);
            border: 2px solid #333;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            padding: 5px;
            font-weight: bold;
            font-size: 14px;
            color: #333;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            cursor: pointer;
            margin: 2px;
            position: relative;
        }

        .card:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 8px 25px rgba(0, 255, 255, 0.4);
        }

        .card.red {
            color: #d63031;
        }

        .card.black {
            color: #2d3436;
        }

        .card.selected {
            border-color: #00ffff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.6);
            transform: translateY(-10px);
        }

        .card-back {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
        }

        .card-empty {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0.05) 100%);
            border: 2px dashed rgba(0, 255, 255, 0.3);
            color: rgba(0, 255, 255, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
        }

        .card-empty:hover {
            border-color: rgba(0, 255, 255, 0.6);
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.1) 0%, rgba(255, 0, 255, 0.1) 100%);
        }

        .foundation-area {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-bottom: 30px;
        }

        .tableau-area {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 10px;
            margin-bottom: 30px;
        }

        .stock-waste-area {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-bottom: 30px;
        }

        .card-pile {
            min-height: 85px;
            position: relative;
        }

        .tableau-pile {
            min-height: 200px;
        }

        .tableau-pile .card {
            position: absolute;
            top: 0;
        }

        .tableau-pile .card:nth-child(1) { top: 0px; }
        .tableau-pile .card:nth-child(2) { top: 20px; }
        .tableau-pile .card:nth-child(3) { top: 40px; }
        .tableau-pile .card:nth-child(4) { top: 60px; }
        .tableau-pile .card:nth-child(5) { top: 80px; }
        .tableau-pile .card:nth-child(6) { top: 100px; }
        .tableau-pile .card:nth-child(7) { top: 120px; }
        .tableau-pile .card:nth-child(8) { top: 140px; }
        .tableau-pile .card:nth-child(9) { top: 160px; }
        .tableau-pile .card:nth-child(10) { top: 180px; }
        .tableau-pile .card:nth-child(11) { top: 200px; }
        .tableau-pile .card:nth-child(12) { top: 220px; }
        .tableau-pile .card:nth-child(13) { top: 240px; }

        .stats-panel {
            background: rgba(30, 30, 60, 0.8);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            backdrop-filter: blur(5px);
            transition: all 0.3s ease;
        }

        .stats-panel:hover {
            border-color: rgba(0, 255, 255, 0.6);
            background: rgba(30, 30, 60, 0.9);
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .stat-value {
            font-weight: bold;
            color: #ffffff;
        }

        .ai-panel {
            background: linear-gradient(135deg, rgba(255, 0, 255, 0.1) 0%, rgba(0, 255, 255, 0.1) 100%);
            border: 2px solid rgba(255, 0, 255, 0.3);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            margin-bottom: 20px;
        }

        .ai-thinking {
            animation: thinking 2s ease-in-out infinite;
        }

        @keyframes thinking {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }

        .game-message {
            background: rgba(15, 15, 35, 0.9);
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 15px;
            padding: 15px;
            text-align: center;
            font-size: 16px;
            font-weight: bold;
            color: #00ffff;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            margin-bottom: 20px;
        }

        .difficulty-selector {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 20px;
        }

        .difficulty-btn {
            padding: 8px 16px;
            font-size: 12px;
            border-radius: 20px;
        }

        .difficulty-btn.active {
            background: linear-gradient(135deg, #00ff00 0%, #00cc00 100%);
            color: #000;
        }

        @media (max-width: 1200px) {
            .game-container {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .sidebar {
                order: 2;
            }
        }

        @media (max-width: 800px) {
            .foundation-area {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .tableau-area {
                grid-template-columns: repeat(4, 1fr);
            }
            
            .game-title h1 {
                font-size: 20px;
            }
        }

        @keyframes fall {
            to {
                transform: translateY(100vh) rotate(360deg);
            }
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;quantum-bg&quot;&gt;&lt;/div&gt;
    
    &lt;div class=&quot;main-container&quot;&gt;
        &lt;!-- En-tête du jeu --&gt;
        &lt;div class=&quot;game-header&quot;&gt;
            &lt;div class=&quot;game-title&quot;&gt;
                &lt;div class=&quot;game-logo&quot;&gt;🃏&lt;/div&gt;
                &lt;h1 id=&quot;gameTitle&quot;&gt;SOLITAIRE FUSION&lt;/h1&gt;
            &lt;/div&gt;
            
            &lt;div class=&quot;language-selector&quot;&gt;
                &lt;div class=&quot;language-dropdown&quot; onclick=&quot;toggleLanguageDropdown()&quot;&gt;
                    &lt;span id=&quot;currentLanguage&quot;&gt;🇫🇷 FR&lt;/span&gt;
                    &lt;span style=&quot;font-size: 10px;&quot;&gt;▼&lt;/span&gt;
                &lt;/div&gt;
                &lt;div class=&quot;language-options&quot; id=&quot;languageOptions&quot;&gt;
                    &lt;div class=&quot;language-option active&quot; onclick=&quot;selectLanguage(&#x27;fr&#x27;, &#x27;🇫🇷 FR&#x27;)&quot;&gt;🇫🇷 Français&lt;/div&gt;
                    &lt;div class=&quot;language-option&quot; onclick=&quot;selectLanguage(&#x27;en&#x27;, &#x27;🇬🇧 EN&#x27;)&quot;&gt;🇬🇧 English&lt;/div&gt;
                    &lt;div class=&quot;language-option&quot; onclick=&quot;selectLanguage(&#x27;es&#x27;, &#x27;🇪🇸 ES&#x27;)&quot;&gt;🇪🇸 Español&lt;/div&gt;
                    &lt;div class=&quot;language-option&quot; onclick=&quot;selectLanguage(&#x27;ar&#x27;, &#x27;🇸🇦 AR&#x27;)&quot;&gt;🇸🇦 العربية&lt;/div&gt;
                    &lt;div class=&quot;language-option&quot; onclick=&quot;selectLanguage(&#x27;de&#x27;, &#x27;🇩🇪 DE&#x27;)&quot;&gt;🇩🇪 Deutsch&lt;/div&gt;
                    &lt;div class=&quot;language-option&quot; onclick=&quot;selectLanguage(&#x27;zh&#x27;, &#x27;🇨🇳 ZH&#x27;)&quot;&gt;🇨🇳 中文&lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;

        &lt;!-- Bloc de contrôles de jeu --&gt;
        &lt;div class=&quot;game-controls&quot;&gt;
            &lt;div style=&quot;display: flex; gap: 15px; flex-wrap: wrap;&quot;&gt;
                &lt;button class=&quot;quantum-btn action-btn&quot; onclick=&quot;newGame()&quot;&gt;🚀 &lt;span id=&quot;newGameBtn&quot;&gt;Nouvelle Partie&lt;/span&gt;&lt;/button&gt;
                &lt;button class=&quot;quantum-btn&quot; onclick=&quot;undoMove()&quot; id=&quot;undoBtn&quot; disabled&gt;↶ &lt;span id=&quot;undoBtnText&quot;&gt;Annuler&lt;/span&gt;&lt;/button&gt;
                &lt;button class=&quot;quantum-btn&quot; onclick=&quot;getHint()&quot; id=&quot;hintBtn&quot;&gt;💡 &lt;span id=&quot;hintBtnText&quot;&gt;Indice&lt;/span&gt;&lt;/button&gt;
                &lt;button class=&quot;quantum-btn danger-btn&quot; onclick=&quot;resetGame()&quot;&gt;🔄 &lt;span id=&quot;resetBtnText&quot;&gt;Recommencer&lt;/span&gt;&lt;/button&gt;
                &lt;button class=&quot;quantum-btn&quot; onclick=&quot;showRules()&quot;&gt;📋 &lt;span id=&quot;rulesBtn&quot;&gt;Règles&lt;/span&gt;&lt;/button&gt;
            &lt;/div&gt;
            
            &lt;div class=&quot;difficulty-selector&quot;&gt;
                &lt;button class=&quot;quantum-btn difficulty-btn active&quot; onclick=&quot;setDifficulty(&#x27;easy&#x27;)&quot; id=&quot;easyBtn&quot;&gt;
                    &lt;span id=&quot;easyBtnText&quot;&gt;Facile&lt;/span&gt;
                &lt;/button&gt;
                &lt;button class=&quot;quantum-btn difficulty-btn&quot; onclick=&quot;setDifficulty(&#x27;medium&#x27;)&quot; id=&quot;mediumBtn&quot;&gt;
                    &lt;span id=&quot;mediumBtnText&quot;&gt;Moyen&lt;/span&gt;
                &lt;/button&gt;
                &lt;button class=&quot;quantum-btn difficulty-btn&quot; onclick=&quot;setDifficulty(&#x27;hard&#x27;)&quot; id=&quot;hardBtn&quot;&gt;
                    &lt;span id=&quot;hardBtnText&quot;&gt;Difficile&lt;/span&gt;
                &lt;/button&gt;
            &lt;/div&gt;
        &lt;/div&gt;

        &lt;div class=&quot;game-container&quot;&gt;
            &lt;!-- Sidebar gauche - Statistiques --&gt;
            &lt;div class=&quot;sidebar&quot;&gt;
                &lt;div class=&quot;section-title&quot; id=&quot;statsTitle&quot;&gt;📊 Statistiques&lt;/div&gt;
                
                &lt;div class=&quot;stats-panel&quot;&gt;
                    &lt;div class=&quot;stat-item&quot;&gt;
                        &lt;span id=&quot;scoreLabel&quot;&gt;Score:&lt;/span&gt;
                        &lt;span class=&quot;stat-value&quot; id=&quot;scoreValue&quot;&gt;0&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;stat-item&quot;&gt;
                        &lt;span id=&quot;movesLabel&quot;&gt;Coups:&lt;/span&gt;
                        &lt;span class=&quot;stat-value&quot; id=&quot;movesValue&quot;&gt;0&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;stat-item&quot;&gt;
                        &lt;span id=&quot;timeLabel&quot;&gt;Temps:&lt;/span&gt;
                        &lt;span class=&quot;stat-value&quot; id=&quot;timeValue&quot;&gt;00:00&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;stat-item&quot;&gt;
                        &lt;span id=&quot;cardsLeftLabel&quot;&gt;Cartes restantes:&lt;/span&gt;
                        &lt;span class=&quot;stat-value&quot; id=&quot;cardsLeftValue&quot;&gt;52&lt;/span&gt;
                    &lt;/div&gt;
                &lt;/div&gt;

                &lt;div class=&quot;section-title&quot; id=&quot;progressTitle&quot;&gt;🎯 Progression&lt;/div&gt;
                &lt;div class=&quot;stats-panel&quot;&gt;
                    &lt;div class=&quot;stat-item&quot;&gt;
                        &lt;span id=&quot;foundationsLabel&quot;&gt;Fondations:&lt;/span&gt;
                        &lt;span class=&quot;stat-value&quot; id=&quot;foundationsValue&quot;&gt;0/4&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;stat-item&quot;&gt;
                        &lt;span id=&quot;completionLabel&quot;&gt;Complétion:&lt;/span&gt;
                        &lt;span class=&quot;stat-value&quot; id=&quot;completionValue&quot;&gt;0%&lt;/span&gt;
                    &lt;/div&gt;
                &lt;/div&gt;

                &lt;div class=&quot;section-title&quot; id=&quot;bestScoresTitle&quot;&gt;🏆 Meilleurs Scores&lt;/div&gt;
                &lt;div class=&quot;stats-panel&quot; id=&quot;bestScoresPanel&quot;&gt;
                    &lt;div class=&quot;stat-item&quot;&gt;
                        &lt;span id=&quot;bestTimeLabel&quot;&gt;Meilleur temps:&lt;/span&gt;
                        &lt;span class=&quot;stat-value&quot; id=&quot;bestTimeValue&quot;&gt;--:--&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;stat-item&quot;&gt;
                        &lt;span id=&quot;bestScoreLabel&quot;&gt;Meilleur score:&lt;/span&gt;
                        &lt;span class=&quot;stat-value&quot; id=&quot;bestScoreValue&quot;&gt;0&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;stat-item&quot;&gt;
                        &lt;span id=&quot;gamesWonLabel&quot;&gt;Parties gagnées:&lt;/span&gt;
                        &lt;span class=&quot;stat-value&quot; id=&quot;gamesWonValue&quot;&gt;0&lt;/span&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;!-- Plateau de jeu principal --&gt;
            &lt;div class=&quot;game-board&quot;&gt;
                &lt;div class=&quot;game-message&quot; id=&quot;gameMessage&quot;&gt;
                    &lt;span&gt;Bienvenue au Solitaire Fusion! Cliquez sur &quot;Nouvelle Partie&quot; pour commencer.&lt;/span&gt;
                &lt;/div&gt;

                &lt;!-- Zone des fondations --&gt;
                &lt;div class=&quot;section-title&quot; id=&quot;foundationsTitle&quot;&gt;🏛️ Fondations&lt;/div&gt;
                &lt;div class=&quot;foundation-area&quot; id=&quot;foundationArea&quot;&gt;
                    &lt;div class=&quot;card-pile foundation-pile&quot; data-suit=&quot;spades&quot;&gt;
                        &lt;div class=&quot;card card-empty&quot;&gt;♠&lt;/div&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;card-pile foundation-pile&quot; data-suit=&quot;hearts&quot;&gt;
                        &lt;div class=&quot;card card-empty&quot;&gt;♥&lt;/div&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;card-pile foundation-pile&quot; data-suit=&quot;diamonds&quot;&gt;
                        &lt;div class=&quot;card card-empty&quot;&gt;♦&lt;/div&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;card-pile foundation-pile&quot; data-suit=&quot;clubs&quot;&gt;
                        &lt;div class=&quot;card card-empty&quot;&gt;♣&lt;/div&gt;
                    &lt;/div&gt;
                &lt;/div&gt;

                &lt;!-- Zone stock et défausse --&gt;
                &lt;div class=&quot;section-title&quot; id=&quot;stockWasteTitle&quot;&gt;🎴 Stock &amp; Défausse&lt;/div&gt;
                &lt;div class=&quot;stock-waste-area&quot;&gt;
                    &lt;div class=&quot;card-pile&quot; id=&quot;stockPile&quot;&gt;
                        &lt;div class=&quot;card card-back&quot;&gt;🃏&lt;/div&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;card-pile&quot; id=&quot;wastePile&quot;&gt;
                        &lt;div class=&quot;card card-empty&quot;&gt;📤&lt;/div&gt;
                    &lt;/div&gt;
                &lt;/div&gt;

                &lt;!-- Zone tableau --&gt;
                &lt;div class=&quot;section-title&quot; id=&quot;tableauTitle&quot;&gt;🎯 Tableau&lt;/div&gt;
                &lt;div class=&quot;tableau-area&quot; id=&quot;tableauArea&quot;&gt;
                    &lt;div class=&quot;card-pile tableau-pile&quot; data-column=&quot;0&quot;&gt;&lt;/div&gt;
                    &lt;div class=&quot;card-pile tableau-pile&quot; data-column=&quot;1&quot;&gt;&lt;/div&gt;
                    &lt;div class=&quot;card-pile tableau-pile&quot; data-column=&quot;2&quot;&gt;&lt;/div&gt;
                    &lt;div class=&quot;card-pile tableau-pile&quot; data-column=&quot;3&quot;&gt;&lt;/div&gt;
                    &lt;div class=&quot;card-pile tableau-pile&quot; data-column=&quot;4&quot;&gt;&lt;/div&gt;
                    &lt;div class=&quot;card-pile tableau-pile&quot; data-column=&quot;5&quot;&gt;&lt;/div&gt;
                    &lt;div class=&quot;card-pile tableau-pile&quot; data-column=&quot;6&quot;&gt;&lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;!-- Sidebar droite - IA et Aide --&gt;
            &lt;div class=&quot;sidebar&quot;&gt;
                &lt;div class=&quot;section-title&quot; id=&quot;aiTitle&quot;&gt;🤖 Assistant IA&lt;/div&gt;
                &lt;div class=&quot;ai-panel&quot; id=&quot;aiPanel&quot;&gt;
                    &lt;div style=&quot;color: #00ffff; font-size: 14px; line-height: 1.4;&quot; id=&quot;aiStatusText&quot;&gt;
                        Assistant IA activé&lt;br&gt;
                        Analyse des coups possibles...
                    &lt;/div&gt;
                &lt;/div&gt;
                
                &lt;div class=&quot;section-title&quot; id=&quot;hintsTitle&quot;&gt;💡 Indices&lt;/div&gt;
                &lt;div class=&quot;stats-panel&quot;&gt;
                    &lt;div class=&quot;stat-item&quot;&gt;
                        &lt;span id=&quot;hintsUsedLabel&quot;&gt;Indices utilisés:&lt;/span&gt;
                        &lt;span class=&quot;stat-value&quot; id=&quot;hintsUsedValue&quot;&gt;0&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;stat-item&quot;&gt;
                        &lt;span id=&quot;hintsAvailableLabel&quot;&gt;Indices disponibles:&lt;/span&gt;
                        &lt;span class=&quot;stat-value&quot; id=&quot;hintsAvailableValue&quot;&gt;3&lt;/span&gt;
                    &lt;/div&gt;
                &lt;/div&gt;

                &lt;div class=&quot;section-title&quot; id=&quot;actionsTitle&quot;&gt;⚡ Actions Rapides&lt;/div&gt;
                &lt;div style=&quot;display: flex; flex-direction: column; gap: 10px;&quot;&gt;
                    &lt;button class=&quot;quantum-btn&quot; onclick=&quot;autoMoveToFoundations()&quot; id=&quot;autoMoveBtn&quot;&gt;
                        🎯 &lt;span id=&quot;autoMoveBtnText&quot;&gt;Auto-placement&lt;/span&gt;
                    &lt;/button&gt;
                    &lt;button class=&quot;quantum-btn&quot; onclick=&quot;shuffleWaste()&quot; id=&quot;shuffleBtn&quot; disabled&gt;
                        🔀 &lt;span id=&quot;shuffleBtnText&quot;&gt;Mélanger défausse&lt;/span&gt;
                    &lt;/button&gt;
                    &lt;button class=&quot;quantum-btn action-btn&quot; onclick=&quot;celebrateWin()&quot; id=&quot;celebrateBtn&quot; style=&quot;display: none;&quot;&gt;
                        🎉 &lt;span id=&quot;celebrateBtnText&quot;&gt;Célébrer!&lt;/span&gt;
                    &lt;/button&gt;
                &lt;/div&gt;

                &lt;div class=&quot;section-title&quot; id=&quot;difficultyTitle&quot;&gt;⚙️ Difficulté&lt;/div&gt;
                &lt;div class=&quot;stats-panel&quot;&gt;
                    &lt;div style=&quot;text-align: center; color: #ffd700; font-weight: bold;&quot; id=&quot;currentDifficultyText&quot;&gt;
                        Mode: &lt;span id=&quot;currentDifficultyValue&quot;&gt;Facile&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div style=&quot;font-size: 12px; text-align: center; margin-top: 10px; color: #aaa;&quot; id=&quot;difficultyDescText&quot;&gt;
                        Tirage par 1 carte, indices illimités
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;script&gt;
        // État du jeu
        let gameState = {
            isPlaying: false,
            currentLanguage: &#x27;fr&#x27;,
            difficulty: &#x27;easy&#x27;,
            score: 0,
            moves: 0,
            startTime: null,
            gameTime: 0,
            timer: null,
            deck: [],
            stock: [],
            waste: [],
            foundations: { spades: [], hearts: [], diamonds: [], clubs: [] },
            tableau: [[], [], [], [], [], [], []],
            selectedCard: null,
            selectedPile: null,
            hintsUsed: 0,
            hintsAvailable: 3,
            moveHistory: [],
            bestScores: JSON.parse(localStorage.getItem(&#x27;solitaireFusionBestScores&#x27;)) || {
                bestTime: null,
                bestScore: 0,
                gamesWon: 0
            }
        };

        // Traductions
        const translations = {
            fr: {
                gameTitle: &#x27;SOLITAIRE FUSION&#x27;,
                statsTitle: &#x27;📊 Statistiques&#x27;,
                progressTitle: &#x27;🎯 Progression&#x27;,
                bestScoresTitle: &#x27;🏆 Meilleurs Scores&#x27;,
                aiTitle: &#x27;🤖 Assistant IA&#x27;,
                hintsTitle: &#x27;💡 Indices&#x27;,
                actionsTitle: &#x27;⚡ Actions Rapides&#x27;,
                difficultyTitle: &#x27;⚙️ Difficulté&#x27;,
                foundationsTitle: &#x27;🏛️ Fondations&#x27;,
                stockWasteTitle: &#x27;🎴 Stock &amp; Défausse&#x27;,
                tableauTitle: &#x27;🎯 Tableau&#x27;,
                welcomeMessage: &#x27;Bienvenue au Solitaire Fusion! Cliquez sur &quot;Nouvelle Partie&quot; pour commencer.&#x27;,
                gameStarted: &#x27;Nouvelle partie commencée! Bonne chance!&#x27;,
                gameWon: &#x27;🎉 Félicitations! Vous avez gagné!&#x27;,
                scoreLabel: &#x27;Score&#x27;,
                movesLabel: &#x27;Coups&#x27;,
                timeLabel: &#x27;Temps&#x27;,
                cardsLeftLabel: &#x27;Cartes restantes&#x27;,
                foundationsLabel: &#x27;Fondations&#x27;,
                completionLabel: &#x27;Complétion&#x27;,
                bestTimeLabel: &#x27;Meilleur temps&#x27;,
                bestScoreLabel: &#x27;Meilleur score&#x27;,
                gamesWonLabel: &#x27;Parties gagnées&#x27;,
                hintsUsedLabel: &#x27;Indices utilisés&#x27;,
                hintsAvailableLabel: &#x27;Indices disponibles&#x27;,
                currentDifficultyText: &#x27;Mode&#x27;,
                newGameBtn: &#x27;Nouvelle Partie&#x27;,
                undoBtnText: &#x27;Annuler&#x27;,
                hintBtnText: &#x27;Indice&#x27;,
                resetBtnText: &#x27;Recommencer&#x27;,
                rulesBtn: &#x27;Règles&#x27;,
                easyBtnText: &#x27;Facile&#x27;,
                mediumBtnText: &#x27;Moyen&#x27;,
                hardBtnText: &#x27;Difficile&#x27;,
                autoMoveBtnText: &#x27;Auto-placement&#x27;,
                shuffleBtnText: &#x27;Mélanger défausse&#x27;,
                celebrateBtnText: &#x27;Célébrer!&#x27;,
                aiStatus: &#x27;Assistant IA activé\nAnalyse des coups possibles...&#x27;,
                difficultyDesc: {
                    easy: &#x27;Tirage par 1 carte, indices illimités&#x27;,
                    medium: &#x27;Tirage par 3 cartes, 5 indices&#x27;,
                    hard: &#x27;Tirage par 3 cartes, 3 indices&#x27;
                },
                hints: {
                    noMoves: &#x27;Aucun coup évident disponible.&#x27;,
                    moveToFoundation: &#x27;Vous pouvez placer {card} sur la fondation {suit}.&#x27;,
                    revealCard: &#x27;Retournez la carte dans la colonne {column}.&#x27;,
                    moveCard: &#x27;Déplacez {card} sur {target}.&#x27;,
                    drawStock: &#x27;Tirez une carte du stock.&#x27;
                }
            },
            es: {
                gameTitle: &#x27;SOLITARIO FUSION&#x27;,
                statsTitle: &#x27;📊 Estadísticas&#x27;,
                progressTitle: &#x27;🎯 Progreso&#x27;,
                bestScoresTitle: &#x27;🏆 Mejores Puntuaciones&#x27;,
                aiTitle: &#x27;🤖 Asistente IA&#x27;,
                hintsTitle: &#x27;💡 Pistas&#x27;,
                actionsTitle: &#x27;⚡ Acciones Rápidas&#x27;,
                difficultyTitle: &#x27;⚙️ Dificultad&#x27;,
                foundationsTitle: &#x27;🏛️ Fundaciones&#x27;,
                stockWasteTitle: &#x27;🎴 Mazo y Descarte&#x27;,
                tableauTitle: &#x27;🎯 Tablero&#x27;,
                welcomeMessage: &#x27;¡Bienvenido a Solitario Fusion! Haz clic en &quot;Nueva Partida&quot; para comenzar.&#x27;,
                gameStarted: &#x27;¡Nueva partida iniciada! ¡Buena suerte!&#x27;,
                gameWon: &#x27;🎉 ¡Felicitaciones! ¡Has ganado!&#x27;,
                scoreLabel: &#x27;Puntuación&#x27;,
                movesLabel: &#x27;Movimientos&#x27;,
                timeLabel: &#x27;Tiempo&#x27;,
                cardsLeftLabel: &#x27;Cartas restantes&#x27;,
                foundationsLabel: &#x27;Fundaciones&#x27;,
                completionLabel: &#x27;Completado&#x27;,
                bestTimeLabel: &#x27;Mejor tiempo&#x27;,
                bestScoreLabel: &#x27;Mejor puntuación&#x27;,
                gamesWonLabel: &#x27;Partidas ganadas&#x27;,
                hintsUsedLabel: &#x27;Pistas usadas&#x27;,
                hintsAvailableLabel: &#x27;Pistas disponibles&#x27;,
                currentDifficultyText: &#x27;Modo&#x27;,
                newGameBtn: &#x27;Nueva Partida&#x27;,
                undoBtnText: &#x27;Deshacer&#x27;,
                hintBtnText: &#x27;Pista&#x27;,
                resetBtnText: &#x27;Reiniciar&#x27;,
                rulesBtn: &#x27;Reglas&#x27;,
                easyBtnText: &#x27;Fácil&#x27;,
                mediumBtnText: &#x27;Medio&#x27;,
                hardBtnText: &#x27;Difícil&#x27;,
                autoMoveBtnText: &#x27;Auto-mover&#x27;,
                shuffleBtnText: &#x27;Mezclar descarte&#x27;,
                celebrateBtnText: &#x27;¡Celebrar!&#x27;,
                aiStatus: &#x27;Asistente IA activado\nAnalizando movimientos posibles...&#x27;,
                difficultyDesc: {
                    easy: &#x27;Robar 1 carta, pistas ilimitadas&#x27;,
                    medium: &#x27;Robar 3 cartas, 5 pistas&#x27;,
                    hard: &#x27;Robar 3 cartas, 3 pistas&#x27;
                },
                hints: {
                    noMoves: &#x27;No hay movimientos obvios disponibles.&#x27;,
                    moveToFoundation: &#x27;Puedes colocar {card} en la fundación {suit}.&#x27;,
                    revealCard: &#x27;Voltea la carta en la columna {column}.&#x27;,
                    moveCard: &#x27;Mueve {card} a {target}.&#x27;,
                    drawStock: &#x27;Roba una carta del mazo.&#x27;
                }
            },
            ar: {
                gameTitle: &#x27;سوليتير فيوجن&#x27;,
                statsTitle: &#x27;📊 الإحصائيات&#x27;,
                progressTitle: &#x27;🎯 التقدم&#x27;,
                bestScoresTitle: &#x27;🏆 أفضل النتائج&#x27;,
                aiTitle: &#x27;🤖 مساعد الذكي&#x27;,
                hintsTitle: &#x27;💡 التلميحات&#x27;,
                actionsTitle: &#x27;⚡ إجراءات سريعة&#x27;,
                difficultyTitle: &#x27;⚙️ الصعوبة&#x27;,
                foundationsTitle: &#x27;🏛️ الأسس&#x27;,
                stockWasteTitle: &#x27;🎴 المخزون والنفايات&#x27;,
                tableauTitle: &#x27;🎯 اللوحة&#x27;,
                welcomeMessage: &#x27;مرحباً بك في سوليتير فيوجن! انقر على &quot;لعبة جديدة&quot; للبدء.&#x27;,
                gameStarted: &#x27;بدأت لعبة جديدة! حظاً سعيداً!&#x27;,
                gameWon: &#x27;🎉 تهانينا! لقد فزت!&#x27;,
                scoreLabel: &#x27;النقاط&#x27;,
                movesLabel: &#x27;الحركات&#x27;,
                timeLabel: &#x27;الوقت&#x27;,
                cardsLeftLabel: &#x27;الأوراق المتبقية&#x27;,
                foundationsLabel: &#x27;الأسس&#x27;,
                completionLabel: &#x27;الإنجاز&#x27;,
                bestTimeLabel: &#x27;أفضل وقت&#x27;,
                bestScoreLabel: &#x27;أفضل نقاط&#x27;,
                gamesWonLabel: &#x27;الألعاب المكسوبة&#x27;,
                hintsUsedLabel: &#x27;التلميحات المستخدمة&#x27;,
                hintsAvailableLabel: &#x27;التلميحات المتاحة&#x27;,
                currentDifficultyText: &#x27;الوضع&#x27;,
                newGameBtn: &#x27;لعبة جديدة&#x27;,
                undoBtnText: &#x27;تراجع&#x27;,
                hintBtnText: &#x27;تلميح&#x27;,
                resetBtnText: &#x27;إعادة تعيين&#x27;,
                rulesBtn: &#x27;القواعد&#x27;,
                easyBtnText: &#x27;سهل&#x27;,
                mediumBtnText: &#x27;متوسط&#x27;,
                hardBtnText: &#x27;صعب&#x27;,
                autoMoveBtnText: &#x27;حركة تلقائية&#x27;,
                shuffleBtnText: &#x27;خلط النفايات&#x27;,
                celebrateBtnText: &#x27;احتفل!&#x27;,
                aiStatus: &#x27;تم تفعيل المساعد الذكي\nتحليل الحركات الممكنة...&#x27;,
                difficultyDesc: {
                    easy: &#x27;سحب ورقة واحدة، تلميحات غير محدودة&#x27;,
                    medium: &#x27;سحب 3 أوراق، 5 تلميحات&#x27;,
                    hard: &#x27;سحب 3 أوراق، 3 تلميحات&#x27;
                },
                hints: {
                    noMoves: &#x27;لا توجد حركات واضحة متاحة.&#x27;,
                    moveToFoundation: &#x27;يمكنك وضع {card} على أساس {suit}.&#x27;,
                    revealCard: &#x27;اقلب الورقة في العمود {column}.&#x27;,
                    moveCard: &#x27;انقل {card} إلى {target}.&#x27;,
                    drawStock: &#x27;اسحب ورقة من المخزون.&#x27;
                }
            },
            de: {
                gameTitle: &#x27;SOLITÄR FUSION&#x27;,
                statsTitle: &#x27;📊 Statistiken&#x27;,
                progressTitle: &#x27;🎯 Fortschritt&#x27;,
                bestScoresTitle: &#x27;🏆 Beste Ergebnisse&#x27;,
                aiTitle: &#x27;🤖 KI-Assistent&#x27;,
                hintsTitle: &#x27;💡 Hinweise&#x27;,
                actionsTitle: &#x27;⚡ Schnellaktionen&#x27;,
                difficultyTitle: &#x27;⚙️ Schwierigkeit&#x27;,
                foundationsTitle: &#x27;🏛️ Fundamente&#x27;,
                stockWasteTitle: &#x27;🎴 Stapel &amp; Abfall&#x27;,
                tableauTitle: &#x27;🎯 Tableau&#x27;,
                welcomeMessage: &#x27;Willkommen bei Solitär Fusion! Klicken Sie auf &quot;Neues Spiel&quot; um zu beginnen.&#x27;,
                gameStarted: &#x27;Neues Spiel gestartet! Viel Glück!&#x27;,
                gameWon: &#x27;🎉 Herzlichen Glückwunsch! Sie haben gewonnen!&#x27;,
                scoreLabel: &#x27;Punkte&#x27;,
                movesLabel: &#x27;Züge&#x27;,
                timeLabel: &#x27;Zeit&#x27;,
                cardsLeftLabel: &#x27;Karten übrig&#x27;,
                foundationsLabel: &#x27;Fundamente&#x27;,
                completionLabel: &#x27;Fertigstellung&#x27;,
                bestTimeLabel: &#x27;Beste Zeit&#x27;,
                bestScoreLabel: &#x27;Beste Punkte&#x27;,
                gamesWonLabel: &#x27;Gewonnene Spiele&#x27;,
                hintsUsedLabel: &#x27;Hinweise verwendet&#x27;,
                hintsAvailableLabel: &#x27;Hinweise verfügbar&#x27;,
                currentDifficultyText: &#x27;Modus&#x27;,
                newGameBtn: &#x27;Neues Spiel&#x27;,
                undoBtnText: &#x27;Rückgängig&#x27;,
                hintBtnText: &#x27;Hinweis&#x27;,
                resetBtnText: &#x27;Zurücksetzen&#x27;,
                rulesBtn: &#x27;Regeln&#x27;,
                easyBtnText: &#x27;Einfach&#x27;,
                mediumBtnText: &#x27;Mittel&#x27;,
                hardBtnText: &#x27;Schwer&#x27;,
                autoMoveBtnText: &#x27;Auto-Zug&#x27;,
                shuffleBtnText: &#x27;Abfall mischen&#x27;,
                celebrateBtnText: &#x27;Feiern!&#x27;,
                aiStatus: &#x27;KI-Assistent aktiviert\nAnalysiere mögliche Züge...&#x27;,
                difficultyDesc: {
                    easy: &#x27;1 Karte ziehen, unbegrenzte Hinweise&#x27;,
                    medium: &#x27;3 Karten ziehen, 5 Hinweise&#x27;,
                    hard: &#x27;3 Karten ziehen, 3 Hinweise&#x27;
                },
                hints: {
                    noMoves: &#x27;Keine offensichtlichen Züge verfügbar.&#x27;,
                    moveToFoundation: &#x27;Sie können {card} auf das {suit} Fundament legen.&#x27;,
                    revealCard: &#x27;Drehen Sie die Karte in Spalte {column} um.&#x27;,
                    moveCard: &#x27;Bewegen Sie {card} zu {target}.&#x27;,
                    drawStock: &#x27;Ziehen Sie eine Karte vom Stapel.&#x27;
                }
            },
            zh: {
                gameTitle: &#x27;纸牌融合&#x27;,
                statsTitle: &#x27;📊 统计&#x27;,
                progressTitle: &#x27;🎯 进度&#x27;,
                bestScoresTitle: &#x27;🏆 最佳成绩&#x27;,
                aiTitle: &#x27;🤖 AI助手&#x27;,
                hintsTitle: &#x27;💡 提示&#x27;,
                actionsTitle: &#x27;⚡ 快速操作&#x27;,
                difficultyTitle: &#x27;⚙️ 难度&#x27;,
                foundationsTitle: &#x27;🏛️ 基础堆&#x27;,
                stockWasteTitle: &#x27;🎴 库存和废牌&#x27;,
                tableauTitle: &#x27;🎯 牌桌&#x27;,
                welcomeMessage: &#x27;欢迎来到纸牌融合！点击&quot;新游戏&quot;开始。&#x27;,
                gameStarted: &#x27;新游戏开始！祝你好运！&#x27;,
                gameWon: &#x27;🎉 恭喜！你赢了！&#x27;,
                scoreLabel: &#x27;得分&#x27;,
                movesLabel: &#x27;移动&#x27;,
                timeLabel: &#x27;时间&#x27;,
                cardsLeftLabel: &#x27;剩余牌数&#x27;,
                foundationsLabel: &#x27;基础堆&#x27;,
                completionLabel: &#x27;完成度&#x27;,
                bestTimeLabel: &#x27;最佳时间&#x27;,
                bestScoreLabel: &#x27;最高分&#x27;,
                gamesWonLabel: &#x27;获胜游戏&#x27;,
                hintsUsedLabel: &#x27;已用提示&#x27;,
                hintsAvailableLabel: &#x27;可用提示&#x27;,
                currentDifficultyText: &#x27;模式&#x27;,
                newGameBtn: &#x27;新游戏&#x27;,
                undoBtnText: &#x27;撤销&#x27;,
                hintBtnText: &#x27;提示&#x27;,
                resetBtnText: &#x27;重置&#x27;,
                rulesBtn: &#x27;规则&#x27;,
                easyBtnText: &#x27;简单&#x27;,
                mediumBtnText: &#x27;中等&#x27;,
                hardBtnText: &#x27;困难&#x27;,
                autoMoveBtnText: &#x27;自动移动&#x27;,
                shuffleBtnText: &#x27;洗废牌&#x27;,
                celebrateBtnText: &#x27;庆祝！&#x27;,
                aiStatus: &#x27;AI助手已激活\n分析可能的移动...&#x27;,
                difficultyDesc: {
                    easy: &#x27;抽1张牌，无限提示&#x27;,
                    medium: &#x27;抽3张牌，5个提示&#x27;,
                    hard: &#x27;抽3张牌，3个提示&#x27;
                },
                hints: {
                    noMoves: &#x27;没有明显的移动可用。&#x27;,
                    moveToFoundation: &#x27;你可以将{card}放在{suit}基础堆上。&#x27;,
                    revealCard: &#x27;翻转第{column}列的牌。&#x27;,
                    moveCard: &#x27;将{card}移动到{target}。&#x27;,
                    drawStock: &#x27;从库存中抽一张牌。&#x27;
                }
            },
            en: {
                gameTitle: &#x27;SOLITAIRE FUSION&#x27;,
                statsTitle: &#x27;📊 Statistics&#x27;,
                progressTitle: &#x27;🎯 Progress&#x27;,
                bestScoresTitle: &#x27;🏆 Best Scores&#x27;,
                aiTitle: &#x27;🤖 AI Assistant&#x27;,
                hintsTitle: &#x27;💡 Hints&#x27;,
                actionsTitle: &#x27;⚡ Quick Actions&#x27;,
                difficultyTitle: &#x27;⚙️ Difficulty&#x27;,
                foundationsTitle: &#x27;🏛️ Foundations&#x27;,
                stockWasteTitle: &#x27;🎴 Stock &amp; Waste&#x27;,
                tableauTitle: &#x27;🎯 Tableau&#x27;,
                welcomeMessage: &#x27;Welcome to Solitaire Fusion! Click &quot;New Game&quot; to start.&#x27;,
                gameStarted: &#x27;New game started! Good luck!&#x27;,
                gameWon: &#x27;🎉 Congratulations! You won!&#x27;,
                scoreLabel: &#x27;Score&#x27;,
                movesLabel: &#x27;Moves&#x27;,
                timeLabel: &#x27;Time&#x27;,
                cardsLeftLabel: &#x27;Cards left&#x27;,
                foundationsLabel: &#x27;Foundations&#x27;,
                completionLabel: &#x27;Completion&#x27;,
                bestTimeLabel: &#x27;Best time&#x27;,
                bestScoreLabel: &#x27;Best score&#x27;,
                gamesWonLabel: &#x27;Games won&#x27;,
                hintsUsedLabel: &#x27;Hints used&#x27;,
                hintsAvailableLabel: &#x27;Hints available&#x27;,
                currentDifficultyText: &#x27;Mode&#x27;,
                newGameBtn: &#x27;New Game&#x27;,
                undoBtnText: &#x27;Undo&#x27;,
                hintBtnText: &#x27;Hint&#x27;,
                resetBtnText: &#x27;Reset&#x27;,
                rulesBtn: &#x27;Rules&#x27;,
                easyBtnText: &#x27;Easy&#x27;,
                mediumBtnText: &#x27;Medium&#x27;,
                hardBtnText: &#x27;Hard&#x27;,
                autoMoveBtnText: &#x27;Auto-move&#x27;,
                shuffleBtnText: &#x27;Shuffle waste&#x27;,
                celebrateBtnText: &#x27;Celebrate!&#x27;,
                aiStatus: &#x27;AI Assistant activated\nAnalyzing possible moves...&#x27;,
                difficultyDesc: {
                    easy: &#x27;Draw 1 card, unlimited hints&#x27;,
                    medium: &#x27;Draw 3 cards, 5 hints&#x27;,
                    hard: &#x27;Draw 3 cards, 3 hints&#x27;
                },
                hints: {
                    noMoves: &#x27;No obvious moves available.&#x27;,
                    moveToFoundation: &#x27;You can place {card} on {suit} foundation.&#x27;,
                    revealCard: &#x27;Flip the card in column {column}.&#x27;,
                    moveCard: &#x27;Move {card} to {target}.&#x27;,
                    drawStock: &#x27;Draw a card from stock.&#x27;
                }
            }
        };

        // Créer un jeu de cartes
        function createDeck() {
            const suits = [&#x27;spades&#x27;, &#x27;hearts&#x27;, &#x27;diamonds&#x27;, &#x27;clubs&#x27;];
            const suitSymbols = { spades: &#x27;♠&#x27;, hearts: &#x27;♥&#x27;, diamonds: &#x27;♦&#x27;, clubs: &#x27;♣&#x27; };
            const ranks = [&#x27;A&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;10&#x27;, &#x27;J&#x27;, &#x27;Q&#x27;, &#x27;K&#x27;];
            const deck = [];
            
            for (let suit of suits) {
                for (let i = 0; i &lt; ranks.length; i++) {
                    deck.push({
                        suit: suit,
                        rank: ranks[i],
                        value: i + 1,
                        symbol: suitSymbols[suit],
                        color: (suit === &#x27;hearts&#x27; || suit === &#x27;diamonds&#x27;) ? &#x27;red&#x27; : &#x27;black&#x27;,
                        faceUp: false
                    });
                }
            }
            
            return createWinnableDeck(shuffleDeck(deck));
        }

        // Créer un jeu avec 80% de chances de victoire
        function createWinnableDeck(deck) {
            // 80% de chance de créer une configuration gagnante
            if (Math.random() &lt; 0.8) {
                return optimizeDeckForWinning(deck);
            }
            return deck;
        }

        // Optimiser le jeu pour augmenter les chances de victoire
        function optimizeDeckForWinning(deck) {
            // Placer plus d&#x27;As et de cartes basses dans les positions accessibles
            const aces = deck.filter(card =&gt; card.rank === &#x27;A&#x27;);
            const lowCards = deck.filter(card =&gt; card.value &lt;= 4 &amp;&amp; card.rank !== &#x27;A&#x27;);
            const otherCards = deck.filter(card =&gt; card.value &gt; 4);
            
            // Mélanger chaque groupe séparément
            const shuffledAces = shuffleDeck([...aces]);
            const shuffledLowCards = shuffleDeck([...lowCards]);
            const shuffledOtherCards = shuffleDeck([...otherCards]);
            
            // Répartir de manière à favoriser l&#x27;accès aux cartes importantes
            const optimizedDeck = [];
            
            // Alterner les types de cartes pour une meilleure distribution
            let aceIndex = 0, lowIndex = 0, otherIndex = 0;
            
            for (let i = 0; i &lt; 52; i++) {
                if (i % 4 === 0 &amp;&amp; aceIndex &lt; shuffledAces.length) {
                    optimizedDeck.push(shuffledAces[aceIndex++]);
                } else if (i % 3 === 0 &amp;&amp; lowIndex &lt; shuffledLowCards.length) {
                    optimizedDeck.push(shuffledLowCards[lowIndex++]);
                } else if (otherIndex &lt; shuffledOtherCards.length) {
                    optimizedDeck.push(shuffledOtherCards[otherIndex++]);
                } else if (lowIndex &lt; shuffledLowCards.length) {
                    optimizedDeck.push(shuffledLowCards[lowIndex++]);
                } else if (aceIndex &lt; shuffledAces.length) {
                    optimizedDeck.push(shuffledAces[aceIndex++]);
                }
            }
            
            return optimizedDeck;
        }

        // Mélanger le jeu
        function shuffleDeck(deck) {
            for (let i = deck.length - 1; i &gt; 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
            return deck;
        }

        // Créer les particules quantiques
        function createQuantumParticles() {
            const bg = document.querySelector(&#x27;.quantum-bg&#x27;);
            for (let i = 0; i &lt; 50; i++) {
                const particle = document.createElement(&#x27;div&#x27;);
                particle.className = &#x27;quantum-particle&#x27;;
                particle.style.left = Math.random() * 100 + &#x27;%&#x27;;
                particle.style.top = Math.random() * 100 + &#x27;%&#x27;;
                particle.style.animationDelay = Math.random() * 6 + &#x27;s&#x27;;
                particle.style.animationDuration = (Math.random() * 4 + 4) + &#x27;s&#x27;;
                bg.appendChild(particle);
            }
        }

        // Basculer le dropdown de langue
        function toggleLanguageDropdown() {
            const options = document.getElementById(&#x27;languageOptions&#x27;);
            options.classList.toggle(&#x27;show&#x27;);
            
            document.addEventListener(&#x27;click&#x27;, function closeDropdown(e) {
                if (!e.target.closest(&#x27;.language-selector&#x27;)) {
                    options.classList.remove(&#x27;show&#x27;);
                    document.removeEventListener(&#x27;click&#x27;, closeDropdown);
                }
            });
        }

        // Sélectionner une langue
        function selectLanguage(langCode, langText) {
            gameState.currentLanguage = langCode;
            
            document.getElementById(&#x27;currentLanguage&#x27;).textContent = langText;
            
            document.querySelectorAll(&#x27;.language-option&#x27;).forEach(option =&gt; {
                option.classList.remove(&#x27;active&#x27;);
            });
            event.target.classList.add(&#x27;active&#x27;);
            
            document.getElementById(&#x27;languageOptions&#x27;).classList.remove(&#x27;show&#x27;);
            
            updateLanguageInterface();
        }

        // Mettre à jour l&#x27;interface selon la langue
        function updateLanguageInterface() {
            const t = translations[gameState.currentLanguage];
            
            // Titres principaux
            document.getElementById(&#x27;gameTitle&#x27;).textContent = t.gameTitle;
            document.getElementById(&#x27;statsTitle&#x27;).textContent = t.statsTitle;
            document.getElementById(&#x27;progressTitle&#x27;).textContent = t.progressTitle;
            document.getElementById(&#x27;bestScoresTitle&#x27;).textContent = t.bestScoresTitle;
            document.getElementById(&#x27;aiTitle&#x27;).textContent = t.aiTitle;
            document.getElementById(&#x27;hintsTitle&#x27;).textContent = t.hintsTitle;
            document.getElementById(&#x27;actionsTitle&#x27;).textContent = t.actionsTitle;
            document.getElementById(&#x27;difficultyTitle&#x27;).textContent = t.difficultyTitle;
            document.getElementById(&#x27;foundationsTitle&#x27;).textContent = t.foundationsTitle;
            document.getElementById(&#x27;stockWasteTitle&#x27;).textContent = t.stockWasteTitle;
            document.getElementById(&#x27;tableauTitle&#x27;).textContent = t.tableauTitle;
            
            // Labels des statistiques
            document.getElementById(&#x27;scoreLabel&#x27;).textContent = t.scoreLabel + &#x27;:&#x27;;
            document.getElementById(&#x27;movesLabel&#x27;).textContent = t.movesLabel + &#x27;:&#x27;;
            document.getElementById(&#x27;timeLabel&#x27;).textContent = t.timeLabel + &#x27;:&#x27;;
            document.getElementById(&#x27;cardsLeftLabel&#x27;).textContent = t.cardsLeftLabel + &#x27;:&#x27;;
            document.getElementById(&#x27;foundationsLabel&#x27;).textContent = t.foundationsLabel + &#x27;:&#x27;;
            document.getElementById(&#x27;completionLabel&#x27;).textContent = t.completionLabel + &#x27;:&#x27;;
            document.getElementById(&#x27;bestTimeLabel&#x27;).textContent = t.bestTimeLabel + &#x27;:&#x27;;
            document.getElementById(&#x27;bestScoreLabel&#x27;).textContent = t.bestScoreLabel + &#x27;:&#x27;;
            document.getElementById(&#x27;gamesWonLabel&#x27;).textContent = t.gamesWonLabel + &#x27;:&#x27;;
            document.getElementById(&#x27;hintsUsedLabel&#x27;).textContent = t.hintsUsedLabel + &#x27;:&#x27;;
            document.getElementById(&#x27;hintsAvailableLabel&#x27;).textContent = t.hintsAvailableLabel + &#x27;:&#x27;;
            
            // Boutons
            document.getElementById(&#x27;newGameBtn&#x27;).textContent = t.newGameBtn;
            document.getElementById(&#x27;undoBtnText&#x27;).textContent = t.undoBtnText;
            document.getElementById(&#x27;hintBtnText&#x27;).textContent = t.hintBtnText;
            document.getElementById(&#x27;resetBtnText&#x27;).textContent = t.resetBtnText;
            document.getElementById(&#x27;rulesBtn&#x27;).textContent = t.rulesBtn;
            document.getElementById(&#x27;easyBtnText&#x27;).textContent = t.easyBtnText;
            document.getElementById(&#x27;mediumBtnText&#x27;).textContent = t.mediumBtnText;
            document.getElementById(&#x27;hardBtnText&#x27;).textContent = t.hardBtnText;
            document.getElementById(&#x27;autoMoveBtnText&#x27;).textContent = t.autoMoveBtnText;
            document.getElementById(&#x27;shuffleBtnText&#x27;).textContent = t.shuffleBtnText;
            document.getElementById(&#x27;celebrateBtnText&#x27;).textContent = t.celebrateBtnText;
            
            // Textes dynamiques
            document.getElementById(&#x27;aiStatusText&#x27;).innerHTML = t.aiStatus.replace(&#x27;\n&#x27;, &#x27;&lt;br&gt;&#x27;);
            document.getElementById(&#x27;currentDifficultyText&#x27;).innerHTML = `${t.currentDifficultyText}: &lt;span id=&quot;currentDifficultyValue&quot;&gt;${t[gameState.difficulty + &#x27;BtnText&#x27;]}&lt;/span&gt;`;
            document.getElementById(&#x27;difficultyDescText&#x27;).textContent = t.difficultyDesc[gameState.difficulty];
            
            if (!gameState.isPlaying) {
                document.getElementById(&#x27;gameMessage&#x27;).innerHTML = `&lt;span&gt;${t.welcomeMessage}&lt;/span&gt;`;
            }
        }

        // Définir la difficulté
        function setDifficulty(level) {
            gameState.difficulty = level;
            
            // Mettre à jour les boutons
            document.querySelectorAll(&#x27;.difficulty-btn&#x27;).forEach(btn =&gt; btn.classList.remove(&#x27;active&#x27;));
            document.getElementById(level + &#x27;Btn&#x27;).classList.add(&#x27;active&#x27;);
            
            // Ajuster les paramètres selon la difficulté
            switch(level) {
                case &#x27;easy&#x27;:
                    gameState.hintsAvailable = 999;
                    break;
                case &#x27;medium&#x27;:
                    gameState.hintsAvailable = 5;
                    break;
                case &#x27;hard&#x27;:
                    gameState.hintsAvailable = 3;
                    break;
            }
            
            updateLanguageInterface();
            updateDisplay();
        }

        // Nouvelle partie
        function newGame() {
            gameState.isPlaying = true;
            gameState.score = 0;
            gameState.moves = 0;
            gameState.startTime = Date.now();
            gameState.gameTime = 0;
            gameState.hintsUsed = 0;
            gameState.selectedCard = null;
            gameState.selectedPile = null;
            gameState.moveHistory = [];
            
            // Réinitialiser les piles
            gameState.foundations = { spades: [], hearts: [], diamonds: [], clubs: [] };
            gameState.tableau = [[], [], [], [], [], [], []];
            gameState.stock = [];
            gameState.waste = [];
            
            // Créer et distribuer les cartes
            gameState.deck = createDeck();
            dealCards();
            
            // Démarrer le timer
            if (gameState.timer) clearInterval(gameState.timer);
            gameState.timer = setInterval(updateTimer, 1000);
            
            // Activer les boutons
            document.getElementById(&#x27;undoBtn&#x27;).disabled = false;
            document.getElementById(&#x27;hintBtn&#x27;).disabled = false;
            
            updateDisplay();
            
            const t = translations[gameState.currentLanguage];
            showMessage(t.gameStarted);
        }

        // Distribuer les cartes
        function dealCards() {
            // Distribuer au tableau (1, 2, 3, 4, 5, 6, 7 cartes par colonne)
            for (let col = 0; col &lt; 7; col++) {
                for (let row = 0; row &lt;= col; row++) {
                    const card = gameState.deck.pop();
                    card.faceUp = (row === col); // Dernière carte face visible
                    gameState.tableau[col].push(card);
                }
            }
            
            // Le reste va au stock
            gameState.stock = [...gameState.deck];
            gameState.waste = [];
            
            renderBoard();
        }

        // Afficher le plateau
        function renderBoard() {
            renderFoundations();
            renderStock();
            renderWaste();
            renderTableau();
        }

        // Afficher les fondations
        function renderFoundations() {
            const suits = [&#x27;spades&#x27;, &#x27;hearts&#x27;, &#x27;diamonds&#x27;, &#x27;clubs&#x27;];
            suits.forEach((suit, index) =&gt; {
                const pile = document.querySelector(`[data-suit=&quot;${suit}&quot;]`);
                pile.innerHTML = &#x27;&#x27;;
                
                if (gameState.foundations[suit].length === 0) {
                    const suitSymbols = { spades: &#x27;♠&#x27;, hearts: &#x27;♥&#x27;, diamonds: &#x27;♦&#x27;, clubs: &#x27;♣&#x27; };
                    const emptyCard = document.createElement(&#x27;div&#x27;);
                    emptyCard.className = &#x27;card card-empty&#x27;;
                    emptyCard.innerHTML = suitSymbols[suit];
                    emptyCard.onclick = () =&gt; handleFoundationClick(pile);
                    pile.appendChild(emptyCard);
                } else {
                    const topCard = gameState.foundations[suit][gameState.foundations[suit].length - 1];
                    const cardElement = createCardElement(topCard);
                    cardElement.onclick = () =&gt; handleFoundationClick(pile);
                    pile.appendChild(cardElement);
                }
            });
        }

        // Afficher le stock
        function renderStock() {
            const stockPile = document.getElementById(&#x27;stockPile&#x27;);
            stockPile.innerHTML = &#x27;&#x27;;
            
            if (gameState.stock.length &gt; 0) {
                const stockCard = document.createElement(&#x27;div&#x27;);
                stockCard.className = &#x27;card card-back&#x27;;
                stockCard.innerHTML = &#x27;🃏&#x27;;
                stockCard.onclick = drawFromStock;
                stockPile.appendChild(stockCard);
            } else {
                const emptyCard = document.createElement(&#x27;div&#x27;);
                emptyCard.className = &#x27;card card-empty&#x27;;
                emptyCard.innerHTML = &#x27;🔄&#x27;;
                emptyCard.onclick = drawFromStock;
                stockPile.appendChild(emptyCard);
            }
        }

        // Afficher la défausse
        function renderWaste() {
            const wastePile = document.getElementById(&#x27;wastePile&#x27;);
            wastePile.innerHTML = &#x27;&#x27;;
            
            if (gameState.waste.length === 0) {
                const emptyCard = document.createElement(&#x27;div&#x27;);
                emptyCard.className = &#x27;card card-empty&#x27;;
                emptyCard.innerHTML = &#x27;📤&#x27;;
                wastePile.appendChild(emptyCard);
            } else {
                const topCard = gameState.waste[gameState.waste.length - 1];
                const cardElement = createCardElement(topCard);
                cardElement.onclick = () =&gt; handleCardClick(topCard, &#x27;waste&#x27;, 0);
                cardElement.ondblclick = () =&gt; tryAutoMoveCard(topCard, &#x27;waste&#x27;, 0);
                wastePile.appendChild(cardElement);
            }
        }

        // Afficher le tableau
        function renderTableau() {
            for (let col = 0; col &lt; 7; col++) {
                const pile = document.querySelector(`[data-column=&quot;${col}&quot;]`);
                pile.innerHTML = &#x27;&#x27;;
                
                const columnCards = gameState.tableau[col];
                
                if (columnCards.length === 0) {
                    const emptyCard = document.createElement(&#x27;div&#x27;);
                    emptyCard.className = &#x27;card card-empty&#x27;;
                    emptyCard.innerHTML = &#x27;👑&#x27;;
                    emptyCard.onclick = () =&gt; handleTableauClick(col);
                    pile.appendChild(emptyCard);
                } else {
                    columnCards.forEach((card, index) =&gt; {
                        const cardElement = createCardElement(card);
                        cardElement.style.position = &#x27;absolute&#x27;;
                        cardElement.style.top = (index * 20) + &#x27;px&#x27;;
                        cardElement.style.zIndex = index + 1;
                        cardElement.onclick = () =&gt; handleCardClick(card, &#x27;tableau&#x27;, col);
                        cardElement.ondblclick = () =&gt; tryAutoMoveCard(card, &#x27;tableau&#x27;, col);
                        pile.appendChild(cardElement);
                    });
                }
            }
        }

        // Créer un élément carte
        function createCardElement(card) {
            const cardElement = document.createElement(&#x27;div&#x27;);
            cardElement.className = `card ${card.color}`;
            
            if (card.faceUp) {
                let centerContent = &#x27;&#x27;;
                
                // Contenu central selon le rang
                if (card.rank === &#x27;A&#x27;) {
                    centerContent = `&lt;div style=&quot;font-size: 40px; font-weight: bold; color: ${card.color === &#x27;red&#x27; ? &#x27;#d63031&#x27; : &#x27;#2d3436&#x27;}; text-shadow: 0 0 3px rgba(0,0,0,0.4); display: flex; align-items: center; justify-content: center; height: 100%;&quot;&gt;${card.symbol}&lt;/div&gt;`;
                } else if (card.rank === &#x27;J&#x27;) {
                    centerContent = `&lt;div style=&quot;font-size: 50px; font-weight: bold; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; width: 100%; color: ${card.color === &#x27;red&#x27; ? &#x27;#d63031&#x27; : &#x27;#2d3436&#x27;}; text-shadow: 0 0 3px rgba(0,0,0,0.4);&quot;&gt;
                        &lt;div style=&quot;font-size: 40px; margin-bottom: 2px;&quot;&gt;👨‍💼&lt;/div&gt;
                        &lt;div style=&quot;font-size: 24px; font-weight: bold; letter-spacing: 1px;&quot;&gt;J&lt;/div&gt;
                    &lt;/div&gt;`;
                } else if (card.rank === &#x27;Q&#x27;) {
                    centerContent = `&lt;div style=&quot;font-size: 50px; font-weight: bold; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; width: 100%; color: ${card.color === &#x27;red&#x27; ? &#x27;#d63031&#x27; : &#x27;#2d3436&#x27;}; text-shadow: 0 0 3px rgba(0,0,0,0.4);&quot;&gt;
                        &lt;div style=&quot;font-size: 40px; margin-bottom: 2px;&quot;&gt;👸&lt;/div&gt;
                        &lt;div style=&quot;font-size: 24px; font-weight: bold; letter-spacing: 1px;&quot;&gt;Q&lt;/div&gt;
                    &lt;/div&gt;`;
                } else if (card.rank === &#x27;K&#x27;) {
                    centerContent = `&lt;div style=&quot;font-size: 50px; font-weight: bold; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; width: 100%; color: ${card.color === &#x27;red&#x27; ? &#x27;#d63031&#x27; : &#x27;#2d3436&#x27;}; text-shadow: 0 0 3px rgba(0,0,0,0.4);&quot;&gt;
                        &lt;div style=&quot;font-size: 40px; margin-bottom: 2px;&quot;&gt;🤴&lt;/div&gt;
                        &lt;div style=&quot;font-size: 24px; font-weight: bold; letter-spacing: 1px;&quot;&gt;K&lt;/div&gt;
                    &lt;/div&gt;`;
                } else {
                    // Cartes numériques (2-10) - afficher le nombre correct de symboles
                    const numValue = parseInt(card.rank);
                    if (numValue &gt;= 2 &amp;&amp; numValue &lt;= 10) {
                        let symbolsArray = [];
                        for (let i = 0; i &lt; numValue; i++) {
                            symbolsArray.push(`&lt;span style=&quot;font-size: 18px; font-weight: bold; color: ${card.color === &#x27;red&#x27; ? &#x27;#d63031&#x27; : &#x27;#2d3436&#x27;}; text-shadow: 0 0 2px rgba(0,0,0,0.3);&quot;&gt;${card.symbol}&lt;/span&gt;`);
                        }
                        
                        // Disposition équilibrée selon le nombre exact
                        if (numValue === 2) {
                            centerContent = `&lt;div style=&quot;display: flex; flex-direction: column; align-items: center; justify-content: space-around; height: 80%; padding: 8px 0;&quot;&gt;${symbolsArray.join(&#x27;&#x27;)}&lt;/div&gt;`;
                        } else if (numValue === 3) {
                            centerContent = `&lt;div style=&quot;display: flex; flex-direction: column; align-items: center; justify-content: space-around; height: 85%; padding: 6px 0;&quot;&gt;${symbolsArray.join(&#x27;&#x27;)}&lt;/div&gt;`;
                        } else if (numValue === 4) {
                            centerContent = `&lt;div style=&quot;display: grid; grid-template-columns: 1fr 1fr; grid-template-rows: 1fr 1fr; gap: 4px; align-items: center; justify-items: center; height: 70%; width: 70%; margin: auto; justify-self: center;&quot;&gt;${symbolsArray.join(&#x27;&#x27;)}&lt;/div&gt;`;
                        } else if (numValue === 5) {
                            centerContent = `&lt;div style=&quot;display: flex; flex-direction: column; align-items: center; justify-content: space-between; height: 85%; width: 100%; padding: 4px 0;&quot;&gt;
                                &lt;div style=&quot;display: flex; justify-content: space-around; width: 80%;&quot;&gt;${symbolsArray[0]}${symbolsArray[1]}&lt;/div&gt;
                                &lt;div style=&quot;display: flex; justify-content: center; width: 80%;&quot;&gt;${symbolsArray[2]}&lt;/div&gt;
                                &lt;div style=&quot;display: flex; justify-content: space-around; width: 80%;&quot;&gt;${symbolsArray[3]}${symbolsArray[4]}&lt;/div&gt;
                            &lt;/div&gt;`;
                        } else if (numValue === 6) {
                            centerContent = `&lt;div style=&quot;display: grid; grid-template-columns: 1fr 1fr; grid-template-rows: 1fr 1fr 1fr; gap: 2px; align-items: center; justify-items: center; height: 80%; width: 70%; margin: auto; justify-self: center;&quot;&gt;${symbolsArray.join(&#x27;&#x27;)}&lt;/div&gt;`;
                        } else if (numValue === 7) {
                            centerContent = `&lt;div style=&quot;display: grid; grid-template-columns: 1fr 1fr 1fr; grid-template-rows: 1fr 1fr 1fr; gap: 1px; align-items: center; justify-items: center; height: 85%; width: 85%; margin: auto;&quot;&gt;
                                ${symbolsArray[0]}${symbolsArray[1]}${symbolsArray[2]}&lt;div&gt;&lt;/div&gt;${symbolsArray[3]}&lt;div&gt;&lt;/div&gt;${symbolsArray[4]}${symbolsArray[5]}${symbolsArray[6]}
                            &lt;/div&gt;`;
                        } else if (numValue === 8) {
                            centerContent = `&lt;div style=&quot;display: flex; flex-direction: column; align-items: center; justify-content: space-between; height: 90%; width: 100%; padding: 2px 0;&quot;&gt;
                                &lt;div style=&quot;display: flex; justify-content: space-around; width: 85%;&quot;&gt;${symbolsArray[0]}${symbolsArray[1]}${symbolsArray[2]}&lt;/div&gt;
                                &lt;div style=&quot;display: flex; justify-content: center; width: 85%; gap: 8px;&quot;&gt;${symbolsArray[3]}${symbolsArray[4]}&lt;/div&gt;
                                &lt;div style=&quot;display: flex; justify-content: space-around; width: 85%;&quot;&gt;${symbolsArray[5]}${symbolsArray[6]}${symbolsArray[7]}&lt;/div&gt;
                            &lt;/div&gt;`;
                        } else if (numValue === 9) {
                            centerContent = `&lt;div style=&quot;display: grid; grid-template-columns: 1fr 1fr 1fr; grid-template-rows: 1fr 1fr 1fr; gap: 1px; align-items: center; justify-items: center; height: 85%; width: 85%; margin: auto;&quot;&gt;${symbolsArray.join(&#x27;&#x27;)}&lt;/div&gt;`;
                        } else if (numValue === 10) {
                            centerContent = `&lt;div style=&quot;display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; grid-template-rows: 1fr 1fr 1fr; gap: 1px; align-items: center; justify-items: center; height: 85%; width: 90%; margin: auto;&quot;&gt;
                                ${symbolsArray[0]}${symbolsArray[1]}${symbolsArray[2]}${symbolsArray[3]}${symbolsArray[4]}${symbolsArray[5]}${symbolsArray[6]}${symbolsArray[7]}${symbolsArray[8]}${symbolsArray[9]}
                            &lt;/div&gt;`;
                        }
                    } else {
                        centerContent = `&lt;div style=&quot;font-size: 32px; font-weight: bold;&quot;&gt;${card.symbol}&lt;/div&gt;`;
                    }
                }
                
                // Masquer les coins pour les figures (J, Q, K) pour un look plus classique
                const hideCornersForFigures = [&#x27;J&#x27;, &#x27;Q&#x27;, &#x27;K&#x27;].includes(card.rank);
                
                cardElement.innerHTML = `
                    &lt;div style=&quot;position: absolute; top: 3px; left: 3px; font-size: 9px; font-weight: bold; line-height: 1; ${hideCornersForFigures ? &#x27;opacity: 0.3;&#x27; : &#x27;&#x27;}&quot;&gt;
                        &lt;div&gt;${card.rank}&lt;/div&gt;
                        &lt;div style=&quot;font-size: 8px;&quot;&gt;${card.symbol}&lt;/div&gt;
                    &lt;/div&gt;
                    &lt;div style=&quot;display: flex; align-items: center; justify-content: center; height: 100%; flex-direction: column;&quot;&gt;
                        ${centerContent}
                    &lt;/div&gt;
                    &lt;div style=&quot;position: absolute; bottom: 3px; right: 3px; font-size: 9px; font-weight: bold; transform: rotate(180deg); line-height: 1; ${hideCornersForFigures ? &#x27;opacity: 0.3;&#x27; : &#x27;&#x27;}&quot;&gt;
                        &lt;div&gt;${card.rank}&lt;/div&gt;
                        &lt;div style=&quot;font-size: 8px;&quot;&gt;${card.symbol}&lt;/div&gt;
                    &lt;/div&gt;
                `;
            } else {
                cardElement.className = &#x27;card card-back&#x27;;
                cardElement.innerHTML = &#x27;🃏&#x27;;
            }
            
            cardElement.cardData = card;
            return cardElement;
        }

        // Gérer le clic sur une carte
        function handleCardClick(card, pileType, pileIndex) {
            if (!gameState.isPlaying) {
                showMessage(&#x27;Commencez une nouvelle partie pour jouer!&#x27;);
                return;
            }
            
            if (!card.faceUp &amp;&amp; pileType === &#x27;tableau&#x27;) {
                // Retourner la carte si elle est face cachée
                card.faceUp = true;
                gameState.moves++;
                gameState.score += 5;
                addToHistory(&#x27;flip&#x27;, { card, pileType, pileIndex });
                renderBoard();
                updateDisplay();
                showMessage(`Carte ${card.rank}${card.symbol} retournée!`);
                return;
            }
            
            if (gameState.selectedCard) {
                // Tentative de déplacement
                if (gameState.selectedCard === card) {
                    // Désélectionner si on clique sur la même carte
                    clearSelection();
                    showMessage(&#x27;Sélection annulée.&#x27;);
                    return;
                }
                
                if (canMoveCard(gameState.selectedCard, card, pileType, pileIndex)) {
                    moveCard(gameState.selectedCard, gameState.selectedPile, card, pileType, pileIndex);
                    showMessage(`${gameState.selectedCard.rank}${gameState.selectedCard.symbol} déplacé sur ${card.rank}${card.symbol}!`);
                } else {
                    showMessage(&#x27;Déplacement impossible! Vérifiez les règles.&#x27;);
                }
                clearSelection();
            } else {
                // Sélectionner la carte
                if (card.faceUp &amp;&amp; canSelectCard(card, pileType, pileIndex)) {
                    selectCard(card, pileType, pileIndex);
                    showMessage(`${card.rank}${card.symbol} sélectionné. Cliquez sur la destination.`);
                } else {
                    showMessage(&#x27;Cette carte ne peut pas être sélectionnée.&#x27;);
                }
            }
        }

        // Vérifier si une carte peut être sélectionnée
        function canSelectCard(card, pileType, pileIndex) {
            if (pileType === &#x27;tableau&#x27;) {
                const column = gameState.tableau[pileIndex];
                const cardIndex = column.indexOf(card);
                return cardIndex === column.length - 1 || isValidSequence(column, cardIndex);
            } else if (pileType === &#x27;waste&#x27;) {
                return gameState.waste[gameState.waste.length - 1] === card;
            } else if (pileType === &#x27;foundation&#x27;) {
                const suits = [&#x27;spades&#x27;, &#x27;hearts&#x27;, &#x27;diamonds&#x27;, &#x27;clubs&#x27;];
                const foundation = gameState.foundations[suits[pileIndex]];
                return foundation[foundation.length - 1] === card;
            }
            return false;
        }

        // Vérifier si les cartes forment une séquence valide
        function isValidSequence(column, startIndex) {
            for (let i = startIndex; i &lt; column.length - 1; i++) {
                const current = column[i];
                const next = column[i + 1];
                if (current.color === next.color || current.value !== next.value + 1) {
                    return false;
                }
            }
            return true;
        }

        // Gérer le clic sur une colonne vide du tableau
        function handleTableauClick(columnIndex) {
            if (!gameState.isPlaying) {
                showMessage(&#x27;Commencez une nouvelle partie pour jouer!&#x27;);
                return;
            }
            
            if (gameState.selectedCard &amp;&amp; gameState.selectedCard.rank === &#x27;K&#x27;) {
                moveCard(gameState.selectedCard, gameState.selectedPile, null, &#x27;tableau&#x27;, columnIndex);
                showMessage(`Roi ${gameState.selectedCard.symbol} placé sur colonne vide!`);
                clearSelection();
            } else if (gameState.selectedCard) {
                showMessage(&#x27;Seuls les Rois peuvent être placés sur des colonnes vides!&#x27;);
            }
        }

        // Sélectionner une carte
        function selectCard(card, pileType, pileIndex) {
            gameState.selectedCard = card;
            gameState.selectedPile = { type: pileType, index: pileIndex };
            
            document.querySelectorAll(&#x27;.card&#x27;).forEach(c =&gt; c.classList.remove(&#x27;selected&#x27;));
            
            const cardElements = document.querySelectorAll(&#x27;.card&#x27;);
            cardElements.forEach(element =&gt; {
                if (element.cardData &amp;&amp; 
                    element.cardData.rank === card.rank &amp;&amp; 
                    element.cardData.suit === card.suit) {
                    element.classList.add(&#x27;selected&#x27;);
                }
            });
        }

        // Effacer la sélection
        function clearSelection() {
            gameState.selectedCard = null;
            gameState.selectedPile = null;
            document.querySelectorAll(&#x27;.card&#x27;).forEach(c =&gt; c.classList.remove(&#x27;selected&#x27;));
        }

        // Vérifier si un déplacement est possible
        function canMoveCard(fromCard, toCard, toPileType, toPileIndex) {
            if (toPileType === &#x27;foundation&#x27;) {
                const suits = [&#x27;spades&#x27;, &#x27;hearts&#x27;, &#x27;diamonds&#x27;, &#x27;clubs&#x27;];
                return canMoveToFoundation(fromCard, suits[toPileIndex]);
            } else if (toPileType === &#x27;tableau&#x27;) {
                return canMoveToTableau(fromCard, toCard, toPileIndex);
            }
            return false;
        }

        // Vérifier si on peut déplacer vers une fondation
        function canMoveToFoundation(card, suit) {
            const foundation = gameState.foundations[suit];
            
            if (foundation.length === 0) {
                return card.rank === &#x27;A&#x27;;
            } else {
                const topCard = foundation[foundation.length - 1];
                return card.suit === suit &amp;&amp; card.value === topCard.value + 1;
            }
        }

        // Vérifier si on peut déplacer vers le tableau
        function canMoveToTableau(card, targetCard, columnIndex) {
            const column = gameState.tableau[columnIndex];
            
            if (column.length === 0) {
                return card.rank === &#x27;K&#x27;;
            } else {
                return targetCard.color !== card.color &amp;&amp; targetCard.value === card.value + 1;
            }
        }

        // Déplacer une carte ou une séquence
        function moveCard(fromCard, fromPile, toCard, toPileType, toPileIndex) {
            const cardsToMove = getCardsToMove(fromCard, fromPile);
            
            // Retirer les cartes de leur pile d&#x27;origine
            removeCardsFromPile(cardsToMove, fromPile);
            
            // Ajouter les cartes à leur nouvelle destination
            if (toPileType === &#x27;foundation&#x27;) {
                const suits = [&#x27;spades&#x27;, &#x27;hearts&#x27;, &#x27;diamonds&#x27;, &#x27;clubs&#x27;];
                gameState.foundations[suits[toPileIndex]].push(fromCard);
                gameState.score += 10;
            } else if (toPileType === &#x27;tableau&#x27;) {
                cardsToMove.forEach(card =&gt; {
                    gameState.tableau[toPileIndex].push(card);
                });
                gameState.score += cardsToMove.length * 5;
            }
            
            gameState.moves++;
            
            addToHistory(&#x27;move&#x27;, {
                cardsToMove, fromPile, toCard, toPileType, toPileIndex
            });
            
            renderBoard();
            updateDisplay();
            checkWinCondition();
        }

        // Obtenir les cartes à déplacer (carte seule ou séquence)
        function getCardsToMove(fromCard, fromPile) {
            if (fromPile.type === &#x27;tableau&#x27;) {
                const column = gameState.tableau[fromPile.index];
                const cardIndex = column.indexOf(fromCard);
                return column.slice(cardIndex);
            } else {
                return [fromCard];
            }
        }

        // Tirer du stock
        function drawFromStock() {
            if (!gameState.isPlaying) {
                showMessage(&#x27;Commencez une nouvelle partie pour jouer!&#x27;);
                return;
            }
            
            clearSelection();
            
            if (gameState.stock.length === 0) {
                if (gameState.waste.length === 0) {
                    showMessage(&#x27;Plus de cartes disponibles!&#x27;);
                    return;
                }
                
                // Remettre la défausse dans le stock
                gameState.stock = [...gameState.waste].reverse();
                gameState.waste = [];
                gameState.stock.forEach(card =&gt; card.faceUp = false);
                gameState.moves++;
                showMessage(&#x27;Stock rechargé depuis la défausse!&#x27;);
            } else {
                // Tirer des cartes selon la difficulté
                const drawCount = gameState.difficulty === &#x27;easy&#x27; ? 1 : 3;
                const drawnCards = [];
                
                for (let i = 0; i &lt; drawCount &amp;&amp; gameState.stock.length &gt; 0; i++) {
                    const card = gameState.stock.pop();
                    card.faceUp = true;
                    gameState.waste.push(card);
                    drawnCards.push(card);
                }
                
                gameState.moves++;
                
                if (drawnCards.length &gt; 0) {
                    const lastCard = drawnCards[drawnCards.length - 1];
                    showMessage(`Carte tirée: ${lastCard.rank}${lastCard.symbol}`);
                }
            }
            
            renderBoard();
            updateDisplay();
        }

        // Gérer le clic sur une fondation
        function handleFoundationClick(element) {
            const suit = element.dataset.suit;
            const suits = [&#x27;spades&#x27;, &#x27;hearts&#x27;, &#x27;diamonds&#x27;, &#x27;clubs&#x27;];
            const suitIndex = suits.indexOf(suit);
            
            if (!gameState.isPlaying) {
                showMessage(&#x27;Commencez une nouvelle partie pour jouer!&#x27;);
                return;
            }
            
            if (gameState.selectedCard) {
                if (canMoveToFoundation(gameState.selectedCard, suit)) {
                    moveCard(gameState.selectedCard, gameState.selectedPile, null, &#x27;foundation&#x27;, suitIndex);
                    showMessage(`${gameState.selectedCard.rank}${gameState.selectedCard.symbol} placé sur la fondation!`);
                    clearSelection();
                } else {
                    showMessage(&#x27;Cette carte ne peut pas être placée sur cette fondation!&#x27;);
                }
            } else {
                // Sélectionner la carte du dessus de la fondation si elle existe
                const foundation = gameState.foundations[suit];
                if (foundation.length &gt; 0) {
                    const topCard = foundation[foundation.length - 1];
                    selectCard(topCard, &#x27;foundation&#x27;, suitIndex);
                    showMessage(`${topCard.rank}${topCard.symbol} sélectionné depuis la fondation.`);
                }
            }
        }

        // Retirer des cartes de leur pile
        function removeCardsFromPile(cards, pile) {
            if (pile.type === &#x27;tableau&#x27;) {
                const column = gameState.tableau[pile.index];
                const firstCardIndex = column.indexOf(cards[0]);
                column.splice(firstCardIndex, cards.length);
                
                // Retourner la carte suivante si nécessaire
                if (column.length &gt; 0 &amp;&amp; !column[column.length - 1].faceUp) {
                    column[column.length - 1].faceUp = true;
                    gameState.score += 5;
                }
            } else if (pile.type === &#x27;waste&#x27;) {
                gameState.waste.pop();
            } else if (pile.type === &#x27;foundation&#x27;) {
                const suits = [&#x27;spades&#x27;, &#x27;hearts&#x27;, &#x27;diamonds&#x27;, &#x27;clubs&#x27;];
                gameState.foundations[suits[pile.index]].pop();
            }
        }

        // Ajouter à l&#x27;historique
        function addToHistory(action, data) {
            gameState.moveHistory.push({ action, data, timestamp: Date.now() });
        }

        // Annuler le dernier coup
        function undoMove() {
            if (gameState.moveHistory.length === 0) return;
            
            const lastMove = gameState.moveHistory.pop();
            
            gameState.moves = Math.max(0, gameState.moves - 1);
            renderBoard();
            updateDisplay();
        }

        // Obtenir un indice
        function getHint() {
            if (gameState.hintsAvailable &lt;= 0) return;
            
            gameState.hintsUsed++;
            gameState.hintsAvailable--;
            
            const t = translations[gameState.currentLanguage];
            
            const hints = [
                t.hints.drawStock,
                t.hints.noMoves
            ];
            
            const randomHint = hints[Math.floor(Math.random() * hints.length)];
            showMessage(randomHint);
            
            const aiPanel = document.getElementById(&#x27;aiPanel&#x27;);
            aiPanel.classList.add(&#x27;ai-thinking&#x27;);
            setTimeout(() =&gt; {
                aiPanel.classList.remove(&#x27;ai-thinking&#x27;);
            }, 2000);
            
            updateDisplay();
        }

        // Auto-placement vers les fondations
        function autoMoveToFoundations() {
            if (!gameState.isPlaying) {
                showMessage(&#x27;Commencez une nouvelle partie pour jouer!&#x27;);
                return;
            }
            
            let moved = false;
            let movedCards = [];
            
            // Vérifier toutes les cartes visibles pour un placement automatique
            for (let col = 0; col &lt; 7; col++) {
                const column = gameState.tableau[col];
                if (column.length &gt; 0) {
                    const topCard = column[column.length - 1];
                    if (topCard.faceUp) {
                        for (let suit in gameState.foundations) {
                            if (canMoveToFoundation(topCard, suit)) {
                                gameState.foundations[suit].push(topCard);
                                column.pop();
                                
                                if (column.length &gt; 0 &amp;&amp; !column[column.length - 1].faceUp) {
                                    column[column.length - 1].faceUp = true;
                                    gameState.score += 5;
                                }
                                
                                gameState.moves++;
                                gameState.score += 10;
                                movedCards.push(`${topCard.rank}${topCard.symbol}`);
                                moved = true;
                                break;
                            }
                        }
                    }
                }
            }
            
            // Vérifier la défausse
            if (gameState.waste.length &gt; 0) {
                const topCard = gameState.waste[gameState.waste.length - 1];
                for (let suit in gameState.foundations) {
                    if (canMoveToFoundation(topCard, suit)) {
                        gameState.foundations[suit].push(topCard);
                        gameState.waste.pop();
                        gameState.moves++;
                        gameState.score += 10;
                        movedCards.push(`${topCard.rank}${topCard.symbol}`);
                        moved = true;
                        break;
                    }
                }
            }
            
            if (moved) {
                showMessage(`Auto-placement: ${movedCards.join(&#x27;, &#x27;)} déplacé(s)!`);
                renderBoard();
                updateDisplay();
                checkWinCondition();
            } else {
                showMessage(&#x27;Aucun auto-placement possible pour le moment.&#x27;);
            }
        }

        // Essayer de déplacer automatiquement une carte
        function tryAutoMoveCard(card, pileType, pileIndex) {
            if (!gameState.isPlaying) return;
            
            // Essayer de placer sur une fondation
            for (let suit in gameState.foundations) {
                if (canMoveToFoundation(card, suit)) {
                    const suits = [&#x27;spades&#x27;, &#x27;hearts&#x27;, &#x27;diamonds&#x27;, &#x27;clubs&#x27;];
                    const suitIndex = suits.indexOf(suit);
                    moveCard(card, { type: pileType, index: pileIndex }, null, &#x27;foundation&#x27;, suitIndex);
                    showMessage(`${card.rank}${card.symbol} auto-placé sur la fondation!`);
                    return;
                }
            }
            
            // Essayer de placer sur le tableau
            for (let col = 0; col &lt; 7; col++) {
                const column = gameState.tableau[col];
                if (column.length === 0 &amp;&amp; card.rank === &#x27;K&#x27;) {
                    moveCard(card, { type: pileType, index: pileIndex }, null, &#x27;tableau&#x27;, col);
                    showMessage(`${card.rank}${card.symbol} auto-placé sur colonne vide!`);
                    return;
                } else if (column.length &gt; 0) {
                    const topCard = column[column.length - 1];
                    if (canMoveToTableau(card, topCard, col)) {
                        moveCard(card, { type: pileType, index: pileIndex }, topCard, &#x27;tableau&#x27;, col);
                        showMessage(`${card.rank}${card.symbol} auto-placé sur ${topCard.rank}${topCard.symbol}!`);
                        return;
                    }
                }
            }
            
            showMessage(`Aucun placement automatique possible pour ${card.rank}${card.symbol}.`);
        }

        // Mélanger la défausse
        function shuffleWaste() {
            if (gameState.waste.length &gt; 0) {
                gameState.waste = shuffleDeck(gameState.waste);
                renderBoard();
                showMessage(&#x27;Défausse mélangée!&#x27;);
            }
        }

        // Vérifier la condition de victoire
        function checkWinCondition() {
            const totalFoundationCards = Object.values(gameState.foundations)
                .reduce((sum, pile) =&gt; sum + pile.length, 0);
            
            if (totalFoundationCards === 52) {
                winGame();
            }
        }

        // Gagner le jeu
        function winGame() {
            clearInterval(gameState.timer);
            gameState.isPlaying = false;
            
            // Mettre à jour les meilleurs scores
            const currentTime = gameState.gameTime;
            if (!gameState.bestScores.bestTime || currentTime &lt; gameState.bestScores.bestTime) {
                gameState.bestScores.bestTime = currentTime;
            }
            if (gameState.score &gt; gameState.bestScores.bestScore) {
                gameState.bestScores.bestScore = gameState.score;
            }
            gameState.bestScores.gamesWon++;
            
            localStorage.setItem(&#x27;solitaireFusionBestScores&#x27;, JSON.stringify(gameState.bestScores));
            
            const t = translations[gameState.currentLanguage];
            showMessage(t.gameWon);
            
            document.getElementById(&#x27;celebrateBtn&#x27;).style.display = &#x27;block&#x27;;
            updateDisplay();
        }

        // Célébrer la victoire
        function celebrateWin() {
            const colors = [&#x27;#ff6b6b&#x27;, &#x27;#4ecdc4&#x27;, &#x27;#45b7d1&#x27;, &#x27;#96ceb4&#x27;, &#x27;#feca57&#x27;];
            
            for (let i = 0; i &lt; 50; i++) {
                setTimeout(() =&gt; {
                    const confetti = document.createElement(&#x27;div&#x27;);
                    confetti.style.position = &#x27;fixed&#x27;;
                    confetti.style.left = Math.random() * 100 + &#x27;vw&#x27;;
                    confetti.style.top = &#x27;-10px&#x27;;
                    confetti.style.width = &#x27;10px&#x27;;
                    confetti.style.height = &#x27;10px&#x27;;
                    confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                    confetti.style.borderRadius = &#x27;50%&#x27;;
                    confetti.style.zIndex = &#x27;9999&#x27;;
                    confetti.style.animation = &#x27;fall 3s linear forwards&#x27;;
                    
                    document.body.appendChild(confetti);
                    
                    setTimeout(() =&gt; {
                        confetti.remove();
                    }, 3000);
                }, i * 100);
            }
        }

        // Réinitialiser le jeu
        function resetGame() {
            if (gameState.timer) clearInterval(gameState.timer);
            gameState.isPlaying = false;
            gameState.selectedCard = null;
            gameState.selectedPile = null;
            
            document.getElementById(&#x27;celebrateBtn&#x27;).style.display = &#x27;none&#x27;;
            
            const t = translations[gameState.currentLanguage];
            showMessage(t.welcomeMessage);
            
            updateDisplay();
        }

        // Mettre à jour le timer
        function updateTimer() {
            if (gameState.isPlaying) {
                gameState.gameTime = Math.floor((Date.now() - gameState.startTime) / 1000);
                const minutes = Math.floor(gameState.gameTime / 60);
                const seconds = gameState.gameTime % 60;
                document.getElementById(&#x27;timeValue&#x27;).textContent = 
                    `${minutes.toString().padStart(2, &#x27;0&#x27;)}:${seconds.toString().padStart(2, &#x27;0&#x27;)}`;
            }
        }

        // Mettre à jour l&#x27;affichage
        function updateDisplay() {
            document.getElementById(&#x27;scoreValue&#x27;).textContent = gameState.score;
            document.getElementById(&#x27;movesValue&#x27;).textContent = gameState.moves;
            
            const cardsLeft = gameState.stock.length + gameState.waste.length + 
                gameState.tableau.reduce((sum, col) =&gt; sum + col.length, 0);
            document.getElementById(&#x27;cardsLeftValue&#x27;).textContent = cardsLeft;
            
            const foundationsComplete = Object.values(gameState.foundations)
                .filter(pile =&gt; pile.length === 13).length;
            document.getElementById(&#x27;foundationsValue&#x27;).textContent = `${foundationsComplete}/4`;
            
            const completion = Math.floor((Object.values(gameState.foundations)
                .reduce((sum, pile) =&gt; sum + pile.length, 0) / 52) * 100);
            document.getElementById(&#x27;completionValue&#x27;).textContent = `${completion}%`;
            
            document.getElementById(&#x27;hintsUsedValue&#x27;).textContent = gameState.hintsUsed;
            document.getElementById(&#x27;hintsAvailableValue&#x27;).textContent = gameState.hintsAvailable;
            
            // Meilleurs scores
            const bestTime = gameState.bestScores.bestTime;
            if (bestTime) {
                const minutes = Math.floor(bestTime / 60);
                const seconds = bestTime % 60;
                document.getElementById(&#x27;bestTimeValue&#x27;).textContent = 
                    `${minutes.toString().padStart(2, &#x27;0&#x27;)}:${seconds.toString().padStart(2, &#x27;0&#x27;)}`;
            }
            document.getElementById(&#x27;bestScoreValue&#x27;).textContent = gameState.bestScores.bestScore;
            document.getElementById(&#x27;gamesWonValue&#x27;).textContent = gameState.bestScores.gamesWon;
            
            // Activer/désactiver les boutons
            document.getElementById(&#x27;undoBtn&#x27;).disabled = gameState.moveHistory.length === 0;
            document.getElementById(&#x27;hintBtn&#x27;).disabled = gameState.hintsAvailable &lt;= 0;
            document.getElementById(&#x27;shuffleBtn&#x27;).disabled = gameState.waste.length === 0;
        }

        // Afficher un message
        function showMessage(message) {
            const messageElement = document.getElementById(&#x27;gameMessage&#x27;);
            messageElement.innerHTML = `&lt;span&gt;${message}&lt;/span&gt;`;
        }

        // Afficher les règles
        function showRules() {
            const t = translations[gameState.currentLanguage];
            alert(`Règles du Solitaire Fusion:\n\n1. Déplacez toutes les cartes vers les fondations\n2. Les fondations se construisent par couleur de A à K\n3. Dans le tableau, alternez les couleurs en ordre décroissant\n4. Seuls les Rois peuvent être placés sur des colonnes vides\n5. Utilisez le stock pour révéler de nouvelles cartes\n6. Gagnez en complétant les 4 fondations!`);
        }

        // Initialisation
        document.addEventListener(&#x27;DOMContentLoaded&#x27;, function() {
            createQuantumParticles();
            updateLanguageInterface();
            updateDisplay();
            setDifficulty(&#x27;easy&#x27;);
        });
    &lt;/script&gt;
&lt;script&gt;(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement(&#x27;script&#x27;);d.innerHTML=&quot;window.__CF$cv$params={r:&#x27;9862d4071073e1d5&#x27;,t:&#x27;MTc1OTA1ODE4Mi4wMDAwMDA=&#x27;};var a=document.createElement(&#x27;script&#x27;);a.nonce=&#x27;&#x27;;a.src=&#x27;/cdn-cgi/challenge-platform/scripts/jsd/main.js&#x27;;document.getElementsByTagName(&#x27;head&#x27;)[0].appendChild(a);&quot;;b.getElementsByTagName(&#x27;head&#x27;)[0].appendChild(d)}}if(document.body){var a=document.createElement(&#x27;iframe&#x27;);a.height=1;a.width=1;a.style.position=&#x27;absolute&#x27;;a.style.top=0;a.style.left=0;a.style.border=&#x27;none&#x27;;a.style.visibility=&#x27;hidden&#x27;;document.body.appendChild(a);if(&#x27;loading&#x27;!==document.readyState)c();else if(window.addEventListener)document.addEventListener(&#x27;DOMContentLoaded&#x27;,c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);&#x27;loading&#x27;!==document.readyState&amp;&amp;(document.onreadystatechange=e,c())}}}})();&lt;/script&gt;&lt;/body&gt;
&lt;/html&gt;
"></iframe>
</div>

<script>
function launchGame16() {
    document.getElementById('game16Overlay').style.display = 'block';
}
function closeGame16() {
    document.getElementById('game16Overlay').style.display = 'none';
}
document.addEventListener('keydown', function(e) {
    if (e.key === "Escape") {
        closeGame16();
    }
});
</script>
<div id="game17Overlay" style="display:none; position:fixed; top:0; left:0;
     width:100%; height:100%; background:#000; z-index:10000; overflow:auto;">
  <button onclick="closeGame17()" 
          style="position:absolute; top:20px; right:20px; background:red; color:#fff;
                 border:none; padding:10px; font-size:20px; cursor:pointer; z-index:10001;">✖</button>
  <div id="game17Container" style="width:100%; height:100%; overflow:auto; background:#000; color:#fff;">
    <iframe srcdoc="&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;fr&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Enigma Hunter&lt;/title&gt;
    &lt;style&gt;
        body {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Orbitron', 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a0a2e 50%, #2e0a1a 100%);
            color: #ffffff;
            overflow: hidden;
            height: 100vh;
        }

        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        .neon-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -2;
            background: 
                radial-gradient(circle at 20% 80%, rgba(255, 0, 150, 0.4) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(0, 255, 255, 0.4) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(255, 100, 0, 0.3) 0%, transparent 50%);
            animation: neonPulse 8s ease-in-out infinite;
        }

        @keyframes neonPulse {
            0%, 100% { transform: scale(1) rotate(0deg); opacity: 0.8; }
            50% { transform: scale(1.1) rotate(1deg); opacity: 1; }
        }

        .main-container {
            width: 100vw;
            height: 100vh;
            position: relative;
            background: linear-gradient(135deg, rgba(10, 10, 30, 0.95) 0%, rgba(30, 10, 20, 0.95) 100%);
            backdrop-filter: blur(20px);
            display: flex;
            flex-direction: column;
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 25px;
            background: linear-gradient(135deg, rgba(255, 0, 150, 0.2) 0%, rgba(0, 255, 255, 0.2) 100%);
            border-bottom: 2px solid rgba(255, 0, 150, 0.5);
            backdrop-filter: blur(15px);
            z-index: 100;
        }

        .header-controls {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        #languageSelector {
            background: linear-gradient(135deg, rgba(255, 0, 150, 0.8) 0%, rgba(0, 255, 255, 0.8) 100%);
            border: 1px solid rgba(255, 0, 150, 0.5);
            color: white;
            border-radius: 15px;
            padding: 8px 15px;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            z-index: 1000;
            position: relative;
        }

        #languageSelector:hover {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.8) 0%, rgba(255, 0, 150, 0.8) 100%);
            box-shadow: 0 0 15px rgba(255, 0, 150, 0.6);
        }

        #languageSelector option {
            background: rgba(20, 10, 30, 0.95);
            color: white;
            padding: 5px;
        }

        .game-title {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .game-title h1 {
            font-size: 24px;
            font-weight: 900;
            background: linear-gradient(135deg, #ff0096, #00ffff, #ff6600);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin: 0;
            text-shadow: 0 0 30px rgba(255, 0, 150, 0.5);
            letter-spacing: 2px;
            animation: titleGlow 3s ease-in-out infinite;
        }

        @keyframes titleGlow {
            0%, 100% { transform: scale(1); filter: brightness(1); }
            50% { transform: scale(1.05); filter: brightness(1.2); }
        }

        .game-logo {
            font-size: 28px;
            filter: drop-shadow(0 0 20px #ff0096);
            animation: logoSpin 4s linear infinite;
        }

        @keyframes logoSpin {
            0% { transform: rotate(0deg) scale(1); }
            50% { transform: rotate(180deg) scale(1.1); }
            100% { transform: rotate(360deg) scale(1); }
        }

        .game-world {
            flex: 1;
            position: relative;
            overflow: hidden;
            display: flex;
        }

        .race-track {
            flex: 1;
            position: relative;
            background: 
                linear-gradient(180deg, 
                    rgba(10, 5, 20, 0.9) 0%,
                    rgba(20, 10, 30, 0.8) 20%,
                    rgba(30, 15, 40, 0.7) 50%,
                    rgba(40, 20, 50, 0.8) 80%,
                    rgba(10, 5, 20, 0.9) 100%);
            perspective: 1000px;
            overflow: hidden;
        }

        .city-skyline {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 40%;
            background: 
                linear-gradient(180deg, 
                    rgba(10, 5, 20, 0.9) 0%,
                    rgba(30, 15, 40, 0.7) 50%,
                    rgba(50, 25, 60, 0.5) 100%);
            z-index: -1;
        }

        .building {
            position: absolute;
            background: linear-gradient(180deg, 
                rgba(20, 10, 30, 0.9) 0%,
                rgba(40, 20, 50, 0.8) 50%,
                rgba(60, 30, 70, 0.7) 100%);
            border-radius: 2px 2px 0 0;
            animation: buildingGlow 4s ease-in-out infinite;
        }

        @keyframes buildingGlow {
            0%, 100% { 
                box-shadow: 
                    0 0 10px rgba(255, 0, 150, 0.3),
                    inset 0 0 20px rgba(0, 0, 0, 0.5);
            }
            50% { 
                box-shadow: 
                    0 0 20px rgba(255, 0, 150, 0.6),
                    0 0 40px rgba(0, 255, 255, 0.3),
                    inset 0 0 20px rgba(0, 0, 0, 0.5);
            }
        }

        .road-surface {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 60%;
            background: 
                linear-gradient(180deg, 
                    rgba(30, 30, 30, 0.8) 0%,
                    rgba(20, 20, 20, 0.9) 30%,
                    rgba(10, 10, 10, 1) 70%,
                    rgba(5, 5, 5, 1) 100%);
            z-index: 0;
        }

        .road-lines {
            position: absolute;
            bottom: 30%;
            left: 0;
            width: 100%;
            height: 4px;
            background: repeating-linear-gradient(
                90deg,
                transparent 0px,
                transparent 20px,
                #ffff00 20px,
                #ffff00 40px,
                transparent 40px,
                transparent 60px
            );
            animation: roadScroll 2s linear infinite;
        }

        @keyframes roadScroll {
            0% { transform: translateX(0); }
            100% { transform: translateX(-60px); }
        }

        .side-panel {
            width: 320px;
            background: linear-gradient(135deg, rgba(10, 5, 20, 0.95) 0%, rgba(20, 10, 30, 0.95) 100%);
            border-left: 2px solid rgba(255, 0, 150, 0.5);
            backdrop-filter: blur(15px);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        .panel-section {
            padding: 20px;
            border-bottom: 1px solid rgba(255, 0, 150, 0.3);
        }

        .panel-title {
            font-size: 16px;
            font-weight: bold;
            color: #ff0096;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 2px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .cyber-btn {
            background: linear-gradient(135deg, #ff0096 0%, #00ffff 100%);
            border: none;
            color: white;
            padding: 12px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(255, 0, 150, 0.4);
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
            margin: 5px 0;
            width: 100%;
        }

        .cyber-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 0, 150, 0.6);
            background: linear-gradient(135deg, #00ffff 0%, #ff0096 100%);
        }

        .cyber-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .cyber-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transition: left 0.5s ease;
        }

        .cyber-btn:hover::before {
            left: 100%;
        }

        .race-btn {
            background: linear-gradient(135deg, #ff6600 0%, #ffaa00 100%);
        }

        .race-btn:hover:not(:disabled) {
            background: linear-gradient(135deg, #ffaa00 0%, #ff6600 100%);
            box-shadow: 0 6px 20px rgba(255, 102, 0, 0.6);
        }

        .upgrade-btn {
            background: linear-gradient(135deg, #00ff00 0%, #00aa00 100%);
        }

        .upgrade-btn:hover:not(:disabled) {
            background: linear-gradient(135deg, #00aa00 0%, #00ff00 100%);
            box-shadow: 0 6px 20px rgba(0, 255, 0, 0.6);
        }

        .danger-btn {
            background: linear-gradient(135deg, #ff3333 0%, #aa0000 100%);
        }

        .danger-btn:hover:not(:disabled) {
            background: linear-gradient(135deg, #aa0000 0%, #ff3333 100%);
            box-shadow: 0 6px 20px rgba(255, 51, 51, 0.6);
        }

        .vehicle-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-top: 10px;
        }

        .vehicle-card {
            padding: 15px;
            background: rgba(255, 0, 150, 0.1);
            border: 1px solid rgba(255, 0, 150, 0.3);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .vehicle-card:hover {
            background: rgba(255, 0, 150, 0.2);
            border-color: rgba(255, 0, 150, 0.6);
            transform: translateY(-3px);
        }

        .vehicle-card.selected {
            background: rgba(0, 255, 255, 0.2);
            border-color: rgba(0, 255, 255, 0.8);
        }

        .vehicle-icon {
            font-size: 24px;
            margin-bottom: 8px;
        }

        .vehicle-name {
            font-weight: bold;
            color: #ff0096;
            margin-bottom: 5px;
        }

        .vehicle-stats {
            font-size: 11px;
            color: #cccccc;
        }

        .race-track-selector {
            display: grid;
            grid-template-columns: 1fr;
            gap: 10px;
            margin-top: 10px;
        }

        .track-option {
            padding: 12px;
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .track-option:hover {
            background: rgba(0, 255, 255, 0.2);
            border-color: rgba(0, 255, 255, 0.6);
        }

        .track-option.selected {
            background: rgba(255, 100, 0, 0.2);
            border-color: rgba(255, 100, 0, 0.8);
        }

        .track-info {
            flex: 1;
        }

        .track-name {
            font-weight: bold;
            color: #00ffff;
            margin-bottom: 3px;
        }

        .track-difficulty {
            font-size: 11px;
            color: #cccccc;
        }

        .leaderboard {
            max-height: 200px;
            overflow-y: auto;
        }

        .leaderboard-entry {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            margin: 5px 0;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border-left: 3px solid #ff0096;
        }

        .leaderboard-entry.player {
            border-left-color: #00ffff;
            background: rgba(0, 255, 255, 0.1);
        }

        .rank {
            font-weight: bold;
            color: #ff0096;
            min-width: 30px;
        }

        .player-name {
            flex: 1;
            margin: 0 10px;
        }

        .race-time {
            font-weight: bold;
            color: #00ffff;
        }

        .speedometer {
            width: 120px;
            height: 120px;
            border: 3px solid rgba(255, 0, 150, 0.5);
            border-radius: 50%;
            position: relative;
            background: radial-gradient(circle, rgba(10, 5, 20, 0.8) 0%, rgba(30, 15, 40, 0.6) 100%);
            margin: 10px auto;
        }

        .speed-needle {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 2px;
            height: 50px;
            background: #ff0096;
            transform-origin: bottom center;
            transform: translate(-50%, -100%) rotate(0deg);
            transition: transform 0.3s ease;
        }

        .speed-display {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-weight: bold;
            color: #00ffff;
        }

        .power-up {
            position: absolute;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            animation: powerUpSpin 2s linear infinite;
            transition: all 0.3s ease;
        }

        .power-up.speed {
            background: radial-gradient(circle, rgba(255, 100, 0, 0.9) 0%, rgba(255, 150, 0, 0.6) 100%);
            box-shadow: 0 0 20px rgba(255, 100, 0, 0.8);
        }

        .power-up.shield {
            background: radial-gradient(circle, rgba(0, 255, 255, 0.9) 0%, rgba(0, 200, 255, 0.6) 100%);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
        }

        .power-up.weapon {
            background: radial-gradient(circle, rgba(255, 0, 150, 0.9) 0%, rgba(200, 0, 100, 0.6) 100%);
            box-shadow: 0 0 20px rgba(255, 0, 150, 0.8);
        }

        .power-up:hover {
            transform: scale(1.3);
            filter: brightness(1.5);
        }

        @keyframes powerUpSpin {
            0% { transform: rotateY(0deg); }
            100% { transform: rotateY(360deg); }
        }

        .checkpoint {
            position: absolute;
            width: 100%;
            height: 8px;
            background: linear-gradient(90deg, 
                transparent 0%,
                rgba(255, 255, 0, 0.8) 20%,
                rgba(255, 255, 0, 1) 50%,
                rgba(255, 255, 0, 0.8) 80%,
                transparent 100%);
            animation: checkpointPulse 2s ease-in-out infinite;
            cursor: pointer;
        }

        @keyframes checkpointPulse {
            0%, 100% { opacity: 0.6; transform: scaleY(1); }
            50% { opacity: 1; transform: scaleY(1.2); }
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        .modal-content {
            background: linear-gradient(135deg, rgba(10, 5, 20, 0.95) 0%, rgba(20, 10, 30, 0.95) 100%);
            border: 2px solid rgba(255, 0, 150, 0.5);
            border-radius: 20px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            text-align: center;
            backdrop-filter: blur(15px);
            box-shadow: 0 0 50px rgba(255, 0, 150, 0.3);
        }

        .modal-title {
            font-size: 24px;
            font-weight: bold;
            color: #ff0096;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .modal-text {
            font-size: 16px;
            color: #ffffff;
            line-height: 1.6;
            margin-bottom: 20px;
        }

        .vehicle-prototype {
            position: relative;
            width: 120px;
            height: 90px;
            margin: 0 auto;
            transform-style: preserve-3d;
            cursor: pointer;
            transition: all 0.5s ease;
        }

        .vehicle-prototype:hover {
            transform: scale(1.3) rotateY(15deg) rotateX(5deg);
        }

        /* PROTOTYPE YAMAHA R1 */
        .yamaha-r1 {
            position: relative;
            width: 80px;
            height: 40px;
        }

        .yamaha-r1 .body {
            position: absolute;
            width: 50px;
            height: 22px;
            top: 10px;
            left: 15px;
            background: linear-gradient(135deg, #ff0096 0%, #ff66cc 100%);
            border-radius: 15px 5px 5px 15px;
            box-shadow: 
                0 0 15px #ff0096,
                inset 0 0 10px rgba(255,255,255,0.3);
            transform: rotateX(10deg);
        }

        .yamaha-r1 .tank {
            position: absolute;
            width: 25px;
            height: 15px;
            top: 5px;
            left: 22px;
            background: linear-gradient(135deg, #ff66cc 0%, #ff0096 100%);
            border-radius: 10px;
            border: 1px solid #ff0096;
            transform: rotateX(15deg);
        }

        .yamaha-r1 .front-wheel {
            position: absolute;
            width: 16px;
            height: 16px;
            top: 24px;
            left: 6px;
            background: radial-gradient(circle, #222 0%, #555 50%, #222 100%);
            border-radius: 50%;
            border: 2px solid #ff0096;
            box-shadow: 0 0 10px #ff0096;
        }

        .yamaha-r1 .rear-wheel {
            position: absolute;
            width: 16px;
            height: 16px;
            top: 24px;
            right: 6px;
            background: radial-gradient(circle, #222 0%, #555 50%, #222 100%);
            border-radius: 50%;
            border: 2px solid #ff0096;
            box-shadow: 0 0 10px #ff0096;
        }

        .yamaha-r1 .headlight {
            position: absolute;
            width: 15px;
            height: 12px;
            top: 20px;
            left: 5px;
            background: radial-gradient(circle, #ffffff 0%, #ff0096 100%);
            border-radius: 50%;
            box-shadow: 0 0 20px #ffffff;
        }

        .yamaha-r1 .exhaust {
            position: absolute;
            width: 12px;
            height: 6px;
            bottom: 8px;
            right: 0px;
            background: linear-gradient(90deg, #ff6600 0%, #ffaa00 100%);
            border-radius: 3px;
            box-shadow: 0 0 10px #ff6600;
        }

        /* PROTOTYPE FERRARI F1 */
        .ferrari-f1 {
            position: relative;
            width: 90px;
            height: 45px;
        }

        .ferrari-f1 .chassis {
            position: absolute;
            width: 120px;
            height: 45px;
            top: 15px;
            left: 10px;
            background: linear-gradient(135deg, #ff3333 0%, #ff9999 100%);
            border-radius: 30px 8px 8px 30px;
            box-shadow: 
                0 0 25px #ff3333,
                inset 0 0 20px rgba(255,255,255,0.2);
            transform: rotateX(8deg);
        }

        .ferrari-f1 .cockpit {
            position: absolute;
            width: 50px;
            height: 20px;
            top: 8px;
            left: 40px;
            background: linear-gradient(135deg, rgba(0,255,255,0.8) 0%, rgba(255,255,255,0.4) 100%);
            border-radius: 15px 5px 5px 15px;
            border: 2px solid rgba(0,255,255,0.6);
            transform: rotateX(20deg);
        }

        .ferrari-f1 .front-wing {
            position: absolute;
            width: 20px;
            height: 8px;
            top: 25px;
            left: 0px;
            background: linear-gradient(90deg, #ff3333 0%, #ff6666 100%);
            border-radius: 4px;
            border: 1px solid #ff3333;
        }

        .ferrari-f1 .rear-wing {
            position: absolute;
            width: 15px;
            height: 20px;
            top: 10px;
            right: -5px;
            background: linear-gradient(90deg, #ff3333 0%, #ff6666 100%);
            border-radius: 3px;
            border: 1px solid #ff3333;
        }

        .ferrari-f1 .front-wheel-f1 {
            position: absolute;
            width: 20px;
            height: 20px;
            top: 40px;
            left: 15px;
            background: radial-gradient(circle, #333 0%, #666 50%, #333 100%);
            border-radius: 50%;
            border: 2px solid #ff3333;
            box-shadow: 0 0 12px #ff3333;
        }

        .ferrari-f1 .rear-wheel-f1 {
            position: absolute;
            width: 20px;
            height: 20px;
            top: 40px;
            right: 15px;
            background: radial-gradient(circle, #333 0%, #666 50%, #333 100%);
            border-radius: 50%;
            border: 2px solid #ff3333;
            box-shadow: 0 0 12px #ff3333;
        }

        /* PROTOTYPE DUCATI PANIGALE */
        .ducati-panigale {
            position: relative;
            width: 130px;
            height: 65px;
        }

        .ducati-panigale .frame {
            position: absolute;
            width: 90px;
            height: 40px;
            top: 12px;
            left: 20px;
            background: linear-gradient(135deg, #00ffff 0%, #66ffff 100%);
            border-radius: 30px 10px 10px 30px;
            box-shadow: 
                0 0 20px #00ffff,
                inset 0 0 15px rgba(255,255,255,0.3);
            transform: rotateX(12deg);
        }

        .ducati-panigale .fairing {
            position: absolute;
            width: 35px;
            height: 30px;
            top: 5px;
            left: 30px;
            background: linear-gradient(135deg, #66ffff 0%, #00ffff 100%);
            border-radius: 18px;
            border: 2px solid #00ffff;
            transform: rotateX(18deg);
        }

        .ducati-panigale .front-wheel-duc {
            position: absolute;
            width: 28px;
            height: 28px;
            top: 37px;
            left: 8px;
            background: radial-gradient(circle, #111 0%, #444 50%, #111 100%);
            border-radius: 50%;
            border: 3px solid #00ffff;
            box-shadow: 0 0 18px #00ffff;
        }

        .ducati-panigale .rear-wheel-duc {
            position: absolute;
            width: 28px;
            height: 28px;
            top: 37px;
            right: 8px;
            background: radial-gradient(circle, #111 0%, #444 50%, #111 100%);
            border-radius: 50%;
            border: 3px solid #00ffff;
            box-shadow: 0 0 18px #00ffff;
        }

        .ducati-panigale .headlight-duc {
            position: absolute;
            width: 18px;
            height: 15px;
            top: 18px;
            left: 2px;
            background: radial-gradient(circle, #ffffff 0%, #00ffff 100%);
            border-radius: 50%;
            box-shadow: 0 0 25px #ffffff;
        }

        /* PROTOTYPE LAMBORGHINI */
        .lamborghini {
            position: relative;
            width: 150px;
            height: 75px;
        }

        .lamborghini .body-lambo {
            position: absolute;
            width: 130px;
            height: 50px;
            top: 15px;
            left: 10px;
            background: linear-gradient(135deg, #ffaa00 0%, #ffdd66 100%);
            border-radius: 35px 12px 12px 35px;
            box-shadow: 
                0 0 30px #ffaa00,
                inset 0 0 25px rgba(255,255,255,0.2);
            transform: rotateX(10deg);
        }

        .lamborghini .windshield {
            position: absolute;
            width: 60px;
            height: 25px;
            top: 8px;
            left: 45px;
            background: linear-gradient(135deg, rgba(0,255,255,0.7) 0%, rgba(255,255,255,0.3) 100%);
            border-radius: 20px 8px 8px 20px;
            border: 2px solid rgba(0,255,255,0.5);
            transform: rotateX(25deg);
        }

        .lamborghini .front-wheel-lambo {
            position: absolute;
            width: 22px;
            height: 22px;
            top: 45px;
            left: 18px;
            background: radial-gradient(circle, #222 0%, #555 50%, #222 100%);
            border-radius: 50%;
            border: 2px solid #ffaa00;
            box-shadow: 0 0 15px #ffaa00;
        }

        .lamborghini .rear-wheel-lambo {
            position: absolute;
            width: 22px;
            height: 22px;
            top: 45px;
            right: 18px;
            background: radial-gradient(circle, #222 0%, #555 50%, #222 100%);
            border-radius: 50%;
            border: 2px solid #ffaa00;
            box-shadow: 0 0 15px #ffaa00;
        }

        .lamborghini .headlights {
            position: absolute;
            width: 12px;
            height: 10px;
            top: 22px;
            left: 5px;
            background: radial-gradient(circle, #ffffff 0%, #ffaa00 100%);
            border-radius: 50%;
            box-shadow: 0 0 20px #ffffff;
        }

        .lamborghini .headlights::after {
            content: '';
            position: absolute;
            width: 12px;
            height: 10px;
            top: 18px;
            left: 0px;
            background: radial-gradient(circle, #ffffff 0%, #ffaa00 100%);
            border-radius: 50%;
            box-shadow: 0 0 20px #ffffff;
        }

        /* PROTOTYPE MCLAREN F1 */
        .mclaren-f1 {
            position: relative;
            width: 145px;
            height: 72px;
        }

        .mclaren-f1 .body-mcl {
            position: absolute;
            width: 125px;
            height: 48px;
            top: 14px;
            left: 10px;
            background: linear-gradient(135deg, #ff6600 0%, #ffaa66 100%);
            border-radius: 32px 10px 10px 32px;
            box-shadow: 
                0 0 28px #ff6600,
                inset 0 0 22px rgba(255,255,255,0.2);
            transform: rotateX(9deg);
        }

        .mclaren-f1 .cockpit-mcl {
            position: absolute;
            width: 55px;
            height: 22px;
            top: 7px;
            left: 42px;
            background: linear-gradient(135deg, rgba(0,255,255,0.8) 0%, rgba(255,255,255,0.4) 100%);
            border-radius: 18px 6px 6px 18px;
            border: 2px solid rgba(0,255,255,0.6);
            transform: rotateX(22deg);
        }

        .mclaren-f1 .front-wheel-mcl {
            position: absolute;
            width: 21px;
            height: 21px;
            top: 44px;
            left: 16px;
            background: radial-gradient(circle, #333 0%, #666 50%, #333 100%);
            border-radius: 50%;
            border: 2px solid #ff6600;
            box-shadow: 0 0 14px #ff6600;
        }

        .mclaren-f1 .rear-wheel-mcl {
            position: absolute;
            width: 21px;
            height: 21px;
            top: 44px;
            right: 16px;
            background: radial-gradient(circle, #333 0%, #666 50%, #333 100%);
            border-radius: 50%;
            border: 2px solid #ff6600;
            box-shadow: 0 0 14px #ff6600;
        }

        /* PROTOTYPE KAWASAKI NINJA */
        .kawasaki-ninja {
            position: relative;
            width: 125px;
            height: 62px;
        }

        .kawasaki-ninja .body-ninja {
            position: absolute;
            width: 85px;
            height: 38px;
            top: 14px;
            left: 20px;
            background: linear-gradient(135deg, #00ff00 0%, #66ff66 100%);
            border-radius: 28px 9px 9px 28px;
            box-shadow: 
                0 0 22px #00ff00,
                inset 0 0 18px rgba(255,255,255,0.3);
            transform: rotateX(11deg);
        }

        .kawasaki-ninja .tank-ninja {
            position: absolute;
            width: 42px;
            height: 28px;
            top: 6px;
            left: 36px;
            background: linear-gradient(135deg, #66ff66 0%, #00ff00 100%);
            border-radius: 16px;
            border: 2px solid #00ff00;
            transform: rotateX(16deg);
        }

        .kawasaki-ninja .front-wheel-ninja {
            position: absolute;
            width: 26px;
            height: 26px;
            top: 36px;
            left: 9px;
            background: radial-gradient(circle, #111 0%, #444 50%, #111 100%);
            border-radius: 50%;
            border: 3px solid #00ff00;
            box-shadow: 0 0 16px #00ff00;
        }

        .kawasaki-ninja .rear-wheel-ninja {
            position: absolute;
            width: 26px;
            height: 26px;
            top: 36px;
            right: 9px;
            background: radial-gradient(circle, #111 0%, #444 50%, #111 100%);
            border-radius: 50%;
            border: 3px solid #00ff00;
            box-shadow: 0 0 16px #00ff00;
        }

        .kawasaki-ninja .headlight-ninja {
            position: absolute;
            width: 16px;
            height: 14px;
            top: 19px;
            left: 3px;
            background: radial-gradient(circle, #ffffff 0%, #00ff00 100%);
            border-radius: 50%;
            box-shadow: 0 0 22px #ffffff;
        }

        /* PROTOTYPE PORSCHE 911 */
        .porsche-911 {
            position: relative;
            width: 140px;
            height: 70px;
        }

        .porsche-911 .body-porsche {
            position: absolute;
            width: 120px;
            height: 46px;
            top: 16px;
            left: 10px;
            background: linear-gradient(135deg, #9900ff 0%, #cc66ff 100%);
            border-radius: 30px 15px 15px 30px;
            box-shadow: 
                0 0 26px #9900ff,
                inset 0 0 20px rgba(255,255,255,0.2);
            transform: rotateX(8deg);
        }

        .porsche-911 .windshield-porsche {
            position: absolute;
            width: 58px;
            height: 24px;
            top: 9px;
            left: 44px;
            background: linear-gradient(135deg, rgba(0,255,255,0.7) 0%, rgba(255,255,255,0.3) 100%);
            border-radius: 19px 10px 10px 19px;
            border: 2px solid rgba(0,255,255,0.5);
            transform: rotateX(24deg);
        }

        .porsche-911 .front-wheel-porsche {
            position: absolute;
            width: 23px;
            height: 23px;
            top: 44px;
            left: 17px;
            background: radial-gradient(circle, #222 0%, #555 50%, #222 100%);
            border-radius: 50%;
            border: 2px solid #9900ff;
            box-shadow: 0 0 15px #9900ff;
        }

        .porsche-911 .rear-wheel-porsche {
            position: absolute;
            width: 23px;
            height: 23px;
            top: 44px;
            right: 17px;
            background: radial-gradient(circle, #222 0%, #555 50%, #222 100%);
            border-radius: 50%;
            border: 2px solid #9900ff;
            box-shadow: 0 0 15px #9900ff;
        }

        .vehicle-name {
            position: absolute;
            bottom: -35px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 14px;
            font-weight: bold;
            text-align: center;
            white-space: nowrap;
            text-shadow: 0 0 10px currentColor;
            transition: all 0.3s ease;
        }

        .yamaha-r1-name { color: #ff0096; }
        .ferrari-f1-name { color: #ff3333; }
        .ducati-panigale-name { color: #00ffff; }
        .lamborghini-name { color: #ffaa00; }
        .mclaren-f1-name { color: #ff6600; }
        .kawasaki-ninja-name { color: #00ff00; }
        .porsche-911-name { color: #9900ff; }

        .vehicle-prototype:hover .vehicle-name {
            transform: translateX(-50%) scale(1.2);
            text-shadow: 0 0 20px currentColor;
        }

        .vehicle-stats {
            position: absolute;
            bottom: -60px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            text-align: center;
            color: #cccccc;
            opacity: 0;
            transition: all 0.3s ease;
        }

        .vehicle-prototype:hover .vehicle-stats {
            opacity: 1;
            transform: translateX(-50%) translateY(-5px);
        }

        .message-display {
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(255, 0, 150, 0.9) 0%, rgba(0, 255, 255, 0.9) 100%);
            color: #000000;
            padding: 15px 25px;
            border-radius: 25px;
            font-weight: bold;
            font-size: 16px;
            z-index: 999;
            opacity: 0;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 30px rgba(255, 0, 150, 0.5);
        }

        .message-display.show {
            opacity: 1;
            transform: translateX(-50%) translateY(10px);
        }

        @keyframes vehicleAnimation {
            0%, 100% { transform: translateY(0px) rotateY(0deg); }
            25% { transform: translateY(-5px) rotateY(2deg); }
            50% { transform: translateY(0px) rotateY(0deg); }
            75% { transform: translateY(-3px) rotateY(-2deg); }
        }

        .vehicle-prototype {
            animation: vehicleAnimation 4s ease-in-out infinite;
        }

        .vehicle-prototype:nth-child(2) { animation-delay: 0.5s; }
        .vehicle-prototype:nth-child(3) { animation-delay: 1s; }
        .vehicle-prototype:nth-child(4) { animation-delay: 1.5s; }
        .vehicle-prototype:nth-child(5) { animation-delay: 2s; }
        .vehicle-prototype:nth-child(6) { animation-delay: 2.5s; }
        .vehicle-prototype:nth-child(7) { animation-delay: 3s; }

        @media (max-width: 1200px) {
            .vehicle-showcase {
                grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
                gap: 30px;
                padding: 30px;
            }
        }

        @media (max-width: 800px) {
            .vehicle-showcase {
                grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
                gap: 25px;
                padding: 20px;
            }
            
            .game-title h1 {
                font-size: 18px;
            }
        }
    </style>
</head>
<body>
    <div class="neon-bg"></div>
    
    <div class="main-container">
        <!-- En-tête du jeu -->
        <div class="game-header">
            <div class="game-title">
                <div class="game-logo">🏎️</div>
                <h1>PROTOTYPES 3D - CYBERRACE NEXUS</h1>
                <div style="font-size: 12px; color: #ff0096; margin-left: 10px;">BRAINOVA PREMIUM</div>
            </div>
            <div class="header-controls">
                <select class="cyber-btn" id="languageSelector" onchange="changeLanguage()" style="width: auto; padding: 8px 15px; font-size: 12px;">
                    <option value="fr">🇫🇷 Français</option>
                    <option value="en">🇺🇸 English</option>
                    <option value="es">🇪🇸 Español</option>
                    <option value="de">🇩🇪 Deutsch</option>
                    <option value="ar">🇸🇦 العربية</option>
                    <option value="zh">🇨🇳 中文</option>
                </select>
                <div class="rules-dropdown" style="position: relative; display: inline-block;">
                    <button class="cyber-btn" id="rulesDropdownBtn" onclick="toggleRulesDropdown()" style="width: auto; padding: 8px 15px; font-size: 12px;">
                        📖 Règles
                    </button>
                    <div class="rules-dropdown-content" id="rulesDropdownContent" style="display: none; position: absolute; right: 0; top: 100%; background: linear-gradient(135deg, rgba(10, 5, 20, 0.95) 0%, rgba(20, 10, 30, 0.95) 100%); border: 2px solid rgba(255, 0, 150, 0.5); border-radius: 15px; padding: 20px; width: 400px; z-index: 1001; backdrop-filter: blur(15px); box-shadow: 0 0 30px rgba(255, 0, 150, 0.3); max-height: 500px; overflow-y: auto;">
                        <div style="color: #ff0096; font-weight: bold; margin-bottom: 15px; font-size: 16px;">📖 Comment Jouer</div>
                        <div style="color: #ffffff; line-height: 1.6; font-size: 14px;">
                            <div style="margin-bottom: 15px;">
                                <strong style="color: #ff0096;">🎯 Objectif :</strong><br>
                                Participez à des courses futuristes avec des véhicules cybernétiques !
                            </div>
                            <div style="margin-bottom: 15px;">
                                <strong style="color: #00ffff;">🎮 Comment jouer :</strong><br>
                                <strong>1. Sélection :</strong> Cliquez sur un véhicule 3D sur la piste<br>
                                <strong>2. Course :</strong> Cliquez sur "🏁 Démarrer Course"<br>
                                <strong>3. Boost :</strong> Utilisez "🚀 Nitro Boost" pendant la course<br>
                                <strong>4. Améliorations :</strong> Visitez le garage pour améliorer
                            </div>
                            <div style="margin-bottom: 15px;">
                                <strong style="color: #ffaa00;">⌨️ Raccourcis :</strong><br>
                                <strong>Espace :</strong> Nitro Boost<br>
                                <strong>Entrée :</strong> Démarrer/Pause course<br>
                                <strong>Échap :</strong> Fermer les fenêtres
                            </div>
                            <div>
                                <strong style="color: #00ff00;">🏆 Récompenses :</strong><br>
                                • Gagnez des crédits en terminant les courses<br>
                                • Collectez les power-ups sur la piste<br>
                                • Battez vos records personnels
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="game-world">
            <!-- Piste de course principale -->
            <div class="race-track" id="raceTrack">
                <div class="city-skyline" id="citySkyline"></div>
                <div class="road-surface"></div>
                <div class="road-lines"></div>
                
                <!-- Prototypes 3D intégrés dans la piste -->
                <!-- Prototype Yamaha R1 -->
                <div class="vehicle-prototype" style="position: absolute; left: 15%; bottom: 35%; z-index: 10;" onclick="selectVehicle('Yamaha R1', '#ff0096')">
                    <div class="yamaha-r1">
                        <div class="body"></div>
                        <div class="tank"></div>
                        <div class="front-wheel"></div>
                        <div class="rear-wheel"></div>
                        <div class="headlight"></div>
                        <div class="exhaust"></div>
                    </div>
                    <div class="vehicle-name yamaha-r1-name">Yamaha R1</div>
                </div>

                <!-- Prototype Ferrari F1 -->
                <div class="vehicle-prototype" style="position: absolute; left: 35%; bottom: 45%; z-index: 10;" onclick="selectVehicle('Ferrari F1', '#ff3333')">
                    <div class="ferrari-f1">
                        <div class="chassis"></div>
                        <div class="cockpit"></div>
                        <div class="front-wing"></div>
                        <div class="rear-wing"></div>
                        <div class="front-wheel-f1"></div>
                        <div class="rear-wheel-f1"></div>
                    </div>
                    <div class="vehicle-name ferrari-f1-name">Ferrari F1</div>
                </div>

                <!-- Prototype Ducati Panigale -->
                <div class="vehicle-prototype" style="position: absolute; left: 55%; bottom: 30%; z-index: 10;" onclick="selectVehicle('Ducati Panigale', '#00ffff')">
                    <div class="ducati-panigale">
                        <div class="frame"></div>
                        <div class="fairing"></div>
                        <div class="front-wheel-duc"></div>
                        <div class="rear-wheel-duc"></div>
                        <div class="headlight-duc"></div>
                    </div>
                    <div class="vehicle-name ducati-panigale-name">Ducati Panigale</div>
                </div>

                <!-- Prototype Lamborghini -->
                <div class="vehicle-prototype" style="position: absolute; left: 75%; bottom: 40%; z-index: 10;" onclick="selectVehicle('Lamborghini', '#ffaa00')">
                    <div class="lamborghini">
                        <div class="body-lambo"></div>
                        <div class="windshield"></div>
                        <div class="front-wheel-lambo"></div>
                        <div class="rear-wheel-lambo"></div>
                        <div class="headlights"></div>
                    </div>
                    <div class="vehicle-name lamborghini-name">Lamborghini</div>
                </div>

                <!-- Prototype McLaren F1 -->
                <div class="vehicle-prototype" style="position: absolute; left: 25%; bottom: 55%; z-index: 10;" onclick="selectVehicle('McLaren F1', '#ff6600')">
                    <div class="mclaren-f1">
                        <div class="body-mcl"></div>
                        <div class="cockpit-mcl"></div>
                        <div class="front-wheel-mcl"></div>
                        <div class="rear-wheel-mcl"></div>
                    </div>
                    <div class="vehicle-name mclaren-f1-name">McLaren F1</div>
                </div>

                <!-- Prototype Kawasaki Ninja -->
                <div class="vehicle-prototype" style="position: absolute; left: 45%; bottom: 25%; z-index: 10;" onclick="selectVehicle('Kawasaki Ninja', '#00ff00')">
                    <div class="kawasaki-ninja">
                        <div class="body-ninja"></div>
                        <div class="tank-ninja"></div>
                        <div class="front-wheel-ninja"></div>
                        <div class="rear-wheel-ninja"></div>
                        <div class="headlight-ninja"></div>
                    </div>
                    <div class="vehicle-name kawasaki-ninja-name">Kawasaki Ninja</div>
                </div>

                <!-- Prototype Porsche 911 -->
                <div class="vehicle-prototype" style="position: absolute; left: 65%; bottom: 50%; z-index: 10;" onclick="selectVehicle('Porsche 911', '#9900ff')">
                    <div class="porsche-911">
                        <div class="body-porsche"></div>
                        <div class="windshield-porsche"></div>
                        <div class="front-wheel-porsche"></div>
                        <div class="rear-wheel-porsche"></div>
                    </div>
                    <div class="vehicle-name porsche-911-name">Porsche 911</div>
                </div>
            </div>

            <!-- Panneau latéral -->
            <div class="side-panel">
                <!-- Section Contrôles de Course -->
                <div class="panel-section">
                    <div class="panel-title">🎮 Contrôles</div>
                    <button class="cyber-btn race-btn" id="startRaceBtn" onclick="startRace()">🏁 Démarrer Course</button>
                    <button class="cyber-btn" id="pauseRaceBtn" onclick="togglePause()" style="display: none;">⏸️ Pause</button>
                    <button class="cyber-btn upgrade-btn" onclick="openGarage()">🔧 Garage</button>
                </div>

                <!-- Section Actions -->
                <div class="panel-section">
                    <div class="panel-title">⚡ Actions</div>

                    <button class="cyber-btn" onclick="boostSpeed()">🚀 Nitro Boost</button>
                    <button class="cyber-btn upgrade-btn" onclick="upgradeVehicle()">⬆️ Améliorer</button>
                    <button class="cyber-btn" onclick="saveProgress()">💾 Sauvegarder</button>
                    <button class="cyber-btn danger-btn" onclick="resetGame()">🔄 Recommencer</button>
                </div>

                <!-- Section Véhicules -->
                <div class="panel-section">
                    <div class="panel-title">🏎️ Véhicules</div>
                    <div class="vehicle-grid" id="vehicleGrid">
                        <div class="vehicle-card selected" onclick="selectVehicleCard('cyber-bike')">
                            <div class="vehicle-icon">🏍️</div>
                            <div class="vehicle-name">Moto Cyber</div>
                            <div class="vehicle-stats">
                                Vitesse: ⭐⭐⭐⭐⭐<br>
                                Contrôle: ⭐⭐⭐⭐
                            </div>
                        </div>
                        <div class="vehicle-card" onclick="selectVehicleCard('hover-car')">
                            <div class="vehicle-icon">🚗</div>
                            <div class="vehicle-name">Auto Volante</div>
                            <div class="vehicle-stats">
                                Vitesse: ⭐⭐⭐<br>
                                Contrôle: ⭐⭐⭐⭐⭐
                            </div>
                        </div>
                        <div class="vehicle-card" onclick="selectVehicleCard('plasma-racer')">
                            <div class="vehicle-icon">🚀</div>
                            <div class="vehicle-name">Bolide Plasma</div>
                            <div class="vehicle-stats">
                                Vitesse: ⭐⭐⭐⭐⭐<br>
                                Contrôle: ⭐⭐
                            </div>
                        </div>
                        <div class="vehicle-card" onclick="selectVehicleCard('quantum-truck')">
                            <div class="vehicle-icon">🚛</div>
                            <div class="vehicle-name">Poids Lourd Quantique</div>
                            <div class="vehicle-stats">
                                Vitesse: ⭐⭐<br>
                                Contrôle: ⭐⭐⭐
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Section Circuits -->
                <div class="panel-section">
                    <div class="panel-title">🏁 Circuits</div>
                    <div class="race-track-selector" id="trackSelector">
                        <div class="track-option selected" onclick="selectTrack('neon-city')">
                            <div class="track-info">
                                <div class="track-name" id="track1Name">Ville Néon</div>
                                <div class="track-difficulty" id="track1Difficulty">Niveau: Débutant</div>
                            </div>
                        </div>
                        <div class="track-option" onclick="selectTrack('cyber-highway')">
                            <div class="track-info">
                                <div class="track-name" id="track2Name">Autoroute Cyber</div>
                                <div class="track-difficulty" id="track2Difficulty">Niveau: Intermédiaire</div>
                            </div>
                        </div>
                        <div class="track-option" onclick="selectTrack('quantum-loop')">
                            <div class="track-info">
                                <div class="track-name" id="track3Name">Circuit Quantique</div>
                                <div class="track-difficulty" id="track3Difficulty">Niveau: Expert</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Section Compteur de Vitesse -->
                <div class="panel-section">
                    <div class="panel-title">⚡ Compteur</div>
                    <div class="speedometer">
                        <div class="speed-needle" id="speedNeedle"></div>
                        <div class="speed-display" id="speedDisplay">0 km/h</div>
                    </div>
                </div>

                <!-- Section Classement -->
                <div class="panel-section">
                    <div class="panel-title">🏆 Classement</div>
                    <div class="leaderboard" id="leaderboard">
                        <!-- Le classement sera généré dynamiquement -->
                    </div>
                </div>

            </div>
        </div>
    </div>

    <!-- Modal pour le garage -->
    <div class="modal" id="garageModal">
        <div class="modal-content">
            <div class="modal-title" id="garageTitle">🔧 Garage Cybernétique</div>
            <div class="modal-text" id="garageDescription">Améliorez votre véhicule avec les dernières technologies cybernétiques.</div>
            <div style="display: flex; gap: 10px; justify-content: center; margin-top: 20px;">
                <button class="cyber-btn upgrade-btn" onclick="buyUpgrade('engine')">🔥 Moteur</button>
                <button class="cyber-btn upgrade-btn" onclick="buyUpgrade('tires')">🛞 Pneus</button>
                <button class="cyber-btn upgrade-btn" onclick="buyUpgrade('armor')">🛡️ Blindage</button>
                <button class="cyber-btn danger-btn" onclick="closeGarage()">✗ Fermer</button>
            </div>
        </div>
    </div>

    <!-- Modal pour les règles du jeu -->
    <div class="modal" id="rulesModal">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-title">📖 Comment Jouer à CyberRace Nexus</div>
            <div style="text-align: center; margin-bottom: 20px;">
                <button class="cyber-btn" onclick="closeRules()">🎮 Retour au Jeu</button>
            </div>
            <div class="modal-text" style="text-align: left; line-height: 1.8;">
                <h3 style="color: #ff0096; margin-bottom: 15px;">🎯 Objectif :</h3>
                <p>Participez à des courses futuristes avec des véhicules cybernétiques !</p>
                
                <h3 style="color: #00ffff; margin: 20px 0 15px 0;">🎮 Comment jouer :</h3>
                <p><strong>1. Sélection :</strong> Cliquez sur un véhicule 3D sur la piste pour le sélectionner</p>
                <p><strong>2. Course :</strong> Cliquez sur "🏁 Démarrer Course" pour lancer une simulation</p>
                <p><strong>3. Boost :</strong> Utilisez "🚀 Nitro Boost" pendant la course pour accélérer</p>
                <p><strong>4. Améliorations :</strong> Visitez le garage pour améliorer votre véhicule</p>
                
                <h3 style="color: #ffaa00; margin: 20px 0 15px 0;">⌨️ Raccourcis clavier :</h3>
                <p><strong>Espace :</strong> Nitro Boost</p>
                <p><strong>Entrée :</strong> Démarrer/Pause course</p>
                <p><strong>Échap :</strong> Fermer les fenêtres</p>
                
                <h3 style="color: #00ff00; margin: 20px 0 15px 0;">🏆 Récompenses :</h3>
                <p>• Gagnez des crédits en terminant les courses</p>
                <p>• Collectez les power-ups sur la piste</p>
                <p>• Battez vos records personnels</p>
            </div>
            <div style="text-align: center; margin-top: 25px;">
                <button class="cyber-btn" onclick="closeRules()">✅ J'ai Compris !</button>
            </div>
        </div>
    </div>

    <!-- Affichage des messages -->
    <div class="message-display" id="messageDisplay"></div>

    <script>
        // État du jeu
        let gameState = {
            player: {
                level: 1,
                credits: 1000,
                wins: 0,
                bestTime: null,
                currentVehicle: 'cyber-bike',
                currentTrack: 'neon-city',
                upgrades: {
                    engine: 0,
                    tires: 0,
                    armor: 0
                }
            },
            race: {
                isActive: false,
                isPaused: false,
                startTime: null,
                currentSpeed: 0,
                maxSpeed: 250,
                position: 0
            }
        };

        // Dictionnaire de traductions
        const translations = {
            fr: {
                title: "PROTOTYPES 3D - CYBERRACE NEXUS",
                controls: "🎮 Contrôles",
                startRace: "🏁 Démarrer Course",
                pause: "⏸️ Pause",
                resume: "▶️ Reprendre",
                garage: "🔧 Garage",
                actions: "⚡ Actions",
                howToPlay: "📖 Comment Jouer",
                nitroBoost: "🚀 Nitro Boost",
                upgrade: "⬆️ Améliorer",
                save: "💾 Sauvegarder",
                restart: "🔄 Recommencer",
                vehicles: "🏎️ Véhicules",
                tracks: "🏁 Circuits",
                speedometer: "⚡ Compteur",
                leaderboard: "🏆 Classement",
                garageTitle: "🔧 Garage Cybernétique",
                garageDesc: "Améliorez votre véhicule avec les dernières technologies cybernétiques.",
                engine: "🔥 Moteur",
                tires: "🛞 Pneus",
                armor: "🛡️ Blindage",
                close: "✗ Fermer",
                rulesTitle: "📖 Comment Jouer à CyberRace Nexus",
                backToGame: "🎮 Retour au Jeu",
                understood: "✅ J'ai Compris !",
                langChanged: "🌍 Langue changée vers",
                neonCity: "Ville Néon",
                cyberHighway: "Autoroute Cyber",
                quantumLoop: "Circuit Quantique",
                beginner: "Niveau: Débutant",
                intermediate: "Niveau: Intermédiaire",
                expert: "Niveau: Expert"
            },
            en: {
                title: "3D PROTOTYPES - CYBERRACE NEXUS",
                controls: "🎮 Controls",
                startRace: "🏁 Start Race",
                pause: "⏸️ Pause",
                resume: "▶️ Resume",
                garage: "🔧 Garage",
                actions: "⚡ Actions",
                howToPlay: "📖 How to Play",
                nitroBoost: "🚀 Nitro Boost",
                upgrade: "⬆️ Upgrade",
                save: "💾 Save",
                restart: "🔄 Restart",
                vehicles: "🏎️ Vehicles",
                tracks: "🏁 Tracks",
                speedometer: "⚡ Speedometer",
                leaderboard: "🏆 Leaderboard",
                garageTitle: "🔧 Cybernetic Garage",
                garageDesc: "Upgrade your vehicle with the latest cybernetic technologies.",
                engine: "🔥 Engine",
                tires: "🛞 Tires",
                armor: "🛡️ Armor",
                close: "✗ Close",
                rulesTitle: "📖 How to Play CyberRace Nexus",
                backToGame: "🎮 Back to Game",
                understood: "✅ Got it!",
                langChanged: "🌍 Language changed to",
                neonCity: "Neon City",
                cyberHighway: "Cyber Highway",
                quantumLoop: "Quantum Circuit",
                beginner: "Level: Beginner",
                intermediate: "Level: Intermediate",
                expert: "Level: Expert"
            },
            es: {
                title: "PROTOTIPOS 3D - CYBERRACE NEXUS",
                controls: "🎮 Controles",
                startRace: "🏁 Iniciar Carrera",
                pause: "⏸️ Pausa",
                resume: "▶️ Reanudar",
                garage: "🔧 Garaje",
                actions: "⚡ Acciones",
                howToPlay: "📖 Cómo Jugar",
                nitroBoost: "🚀 Nitro Boost",
                upgrade: "⬆️ Mejorar",
                save: "💾 Guardar",
                restart: "🔄 Reiniciar",
                vehicles: "🏎️ Vehículos",
                tracks: "🏁 Circuitos",
                speedometer: "⚡ Velocímetro",
                leaderboard: "🏆 Clasificación",
                garageTitle: "🔧 Garaje Cibernético",
                garageDesc: "Mejora tu vehículo con las últimas tecnologías cibernéticas.",
                engine: "🔥 Motor",
                tires: "🛞 Neumáticos",
                armor: "🛡️ Blindaje",
                close: "✗ Cerrar",
                rulesTitle: "📖 Cómo Jugar a CyberRace Nexus",
                backToGame: "🎮 Volver al Juego",
                understood: "✅ ¡Entendido!",
                langChanged: "🌍 Idioma cambiado a",
                neonCity: "Ciudad Neón",
                cyberHighway: "Autopista Cyber",
                quantumLoop: "Circuito Cuántico",
                beginner: "Nivel: Principiante",
                intermediate: "Nivel: Intermedio",
                expert: "Nivel: Experto"
            },
            de: {
                title: "3D PROTOTYPEN - CYBERRACE NEXUS",
                controls: "🎮 Steuerung",
                startRace: "🏁 Rennen Starten",
                pause: "⏸️ Pause",
                resume: "▶️ Fortsetzen",
                garage: "🔧 Garage",
                actions: "⚡ Aktionen",
                howToPlay: "📖 Spielanleitung",
                nitroBoost: "🚀 Nitro Boost",
                upgrade: "⬆️ Verbessern",
                save: "💾 Speichern",
                restart: "🔄 Neustart",
                vehicles: "🏎️ Fahrzeuge",
                tracks: "🏁 Strecken",
                speedometer: "⚡ Tachometer",
                leaderboard: "🏆 Bestenliste",
                garageTitle: "🔧 Cyber Garage",
                garageDesc: "Verbessern Sie Ihr Fahrzeug mit neuesten Cyber-Technologien.",
                engine: "🔥 Motor",
                tires: "🛞 Reifen",
                armor: "🛡️ Panzerung",
                close: "✗ Schließen",
                rulesTitle: "📖 CyberRace Nexus Spielanleitung",
                backToGame: "🎮 Zurück zum Spiel",
                understood: "✅ Verstanden!",
                langChanged: "🌍 Sprache geändert zu",
                neonCity: "Neon Stadt",
                cyberHighway: "Cyber Autobahn",
                quantumLoop: "Quantum Rennstrecke",
                beginner: "Stufe: Anfänger",
                intermediate: "Stufe: Fortgeschritten",
                expert: "Stufe: Experte"
            },
            ar: {
                title: "نماذج ثلاثية الأبعاد - سايبر ريس نيكسوس",
                controls: "🎮 التحكم",
                startRace: "🏁 بدء السباق",
                pause: "⏸️ إيقاف مؤقت",
                resume: "▶️ استئناف",
                garage: "🔧 الكراج",
                actions: "⚡ الإجراءات",
                howToPlay: "📖 كيفية اللعب",
                nitroBoost: "🚀 دفع النيترو",
                upgrade: "⬆️ ترقية",
                save: "💾 حفظ",
                restart: "🔄 إعادة البدء",
                vehicles: "🏎️ المركبات",
                tracks: "🏁 المسارات",
                speedometer: "⚡ مقياس السرعة",
                leaderboard: "🏆 لوحة المتصدرين",
                garageTitle: "🔧 الكراج السيبراني",
                garageDesc: "قم بترقية مركبتك بأحدث التقنيات السيبرانية.",
                engine: "🔥 المحرك",
                tires: "🛞 الإطارات",
                armor: "🛡️ الدرع",
                close: "✗ إغلاق",
                rulesTitle: "📖 كيفية لعب سايبر ريس نيكسوس",
                backToGame: "🎮 العودة للعبة",
                understood: "✅ فهمت!",
                langChanged: "🌍 تم تغيير اللغة إلى",
                neonCity: "مدينة النيون",
                cyberHighway: "الطريق السيبراني",
                quantumLoop: "حلبة الكم",
                beginner: "المستوى: مبتدئ",
                intermediate: "المستوى: متوسط",
                expert: "المستوى: خبير"
            },
            zh: {
                title: "3D原型 - 赛博竞速连接",
                controls: "🎮 控制",
                startRace: "🏁 开始比赛",
                pause: "⏸️ 暂停",
                resume: "▶️ 继续",
                garage: "🔧 车库",
                actions: "⚡ 操作",
                howToPlay: "📖 游戏说明",
                nitroBoost: "🚀 氮气加速",
                upgrade: "⬆️ 升级",
                save: "💾 保存",
                restart: "🔄 重新开始",
                vehicles: "🏎️ 载具",
                tracks: "🏁 赛道",
                speedometer: "⚡ 速度表",
                leaderboard: "🏆 排行榜",
                garageTitle: "🔧 赛博车库",
                garageDesc: "使用最新的赛博技术升级您的载具。",
                engine: "🔥 引擎",
                tires: "🛞 轮胎",
                armor: "🛡️ 装甲",
                close: "✗ 关闭",
                rulesTitle: "📖 赛博竞速连接游戏说明",
                backToGame: "🎮 返回游戏",
                understood: "✅ 明白了！",
                langChanged: "🌍 语言已更改为",
                neonCity: "霓虹城市",
                cyberHighway: "赛博高速公路",
                quantumLoop: "量子赛道",
                beginner: "等级：初学者",
                intermediate: "等级：中级",
                expert: "等级：专家"
            }
        };

        let currentLanguage = 'fr';

        // Fonction de changement de langue
        function changeLanguage() {
            const selector = document.getElementById('languageSelector');
            currentLanguage = selector.value;
            
            updateAllTexts();
            updateRulesDropdown();
            showMessage(`${translations[currentLanguage].langChanged} ${selector.options[selector.selectedIndex].text}`);
        }

        // Fonction pour basculer le menu déroulant des règles
        function toggleRulesDropdown() {
            const dropdown = document.getElementById('rulesDropdownContent');
            const isVisible = dropdown.style.display === 'block';
            
            if (isVisible) {
                dropdown.style.display = 'none';
            } else {
                dropdown.style.display = 'block';
                updateRulesDropdown();
            }
        }

        // Fermer le menu déroulant si on clique ailleurs
        document.addEventListener('click', function(event) {
            const dropdown = document.getElementById('rulesDropdownContent');
            const button = document.getElementById('rulesDropdownBtn');
            
            if (!dropdown.contains(event.target) && !button.contains(event.target)) {
                dropdown.style.display = 'none';
            }
        });

        function updateAllTexts() {
            const t = translations[currentLanguage];
            
            // Titre principal
            document.querySelector('.game-title h1').textContent = t.title;
            
            // Sections du panneau
            document.querySelectorAll('.panel-title')[0].textContent = t.controls;
            document.querySelectorAll('.panel-title')[1].textContent = t.actions;
            document.querySelectorAll('.panel-title')[2].textContent = t.vehicles;
            document.querySelectorAll('.panel-title')[3].textContent = t.tracks;
            document.querySelectorAll('.panel-title')[4].textContent = t.speedometer;
            document.querySelectorAll('.panel-title')[5].textContent = t.leaderboard;
            
            // Boutons
            document.getElementById('startRaceBtn').innerHTML = t.startRace;
            document.querySelector('button[onclick="openGarage()"]').innerHTML = t.garage;
            document.querySelector('button[onclick="boostSpeed()"]').innerHTML = t.nitroBoost;
            document.querySelector('button[onclick="upgradeVehicle()"]').innerHTML = t.upgrade;
            document.querySelector('button[onclick="saveProgress()"]').innerHTML = t.save;
            document.querySelector('button[onclick="resetGame()"]').innerHTML = t.restart;
            
            // Circuits
            document.getElementById('track1Name').textContent = t.neonCity;
            document.getElementById('track1Difficulty').textContent = t.beginner;
            document.getElementById('track2Name').textContent = t.cyberHighway;
            document.getElementById('track2Difficulty').textContent = t.intermediate;
            document.getElementById('track3Name').textContent = t.quantumLoop;
            document.getElementById('track3Difficulty').textContent = t.expert;
            
            // Bouton règles
            document.getElementById('rulesDropdownBtn').innerHTML = `📖 ${t.howToPlay}`;
            
            // Modal garage
            document.getElementById('garageTitle').textContent = t.garageTitle;
            document.getElementById('garageDescription').textContent = t.garageDesc;
            document.querySelector('button[onclick="buyUpgrade(\'engine\')"]').innerHTML = t.engine;
            document.querySelector('button[onclick="buyUpgrade(\'tires\')"]').innerHTML = t.tires;
            document.querySelector('button[onclick="buyUpgrade(\'armor\')"]').innerHTML = t.armor;
            document.querySelector('button[onclick="closeGarage()"]').innerHTML = t.close;
            
            // Modal règles
            document.querySelector('#rulesModal .modal-title').textContent = t.rulesTitle;
            document.querySelectorAll('button[onclick="closeRules()"]')[0].innerHTML = t.backToGame;
            document.querySelectorAll('button[onclick="closeRules()"]')[1].innerHTML = t.understood;
        }

        function updateRulesDropdown() {
            const t = translations[currentLanguage];
            const dropdown = document.getElementById('rulesDropdownContent');
            
            dropdown.innerHTML = `
                <div style="color: #ff0096; font-weight: bold; margin-bottom: 15px; font-size: 16px;">📖 ${t.rulesTitle}</div>
                <div style="color: #ffffff; line-height: 1.6; font-size: 14px;">
                    <div style="margin-bottom: 15px;">
                        <strong style="color: #ff0096;">🎯 ${currentLanguage === 'fr' ? 'Objectif' : currentLanguage === 'en' ? 'Objective' : currentLanguage === 'es' ? 'Objetivo' : currentLanguage === 'de' ? 'Ziel' : currentLanguage === 'ar' ? 'الهدف' : '目标'} :</strong><br>
                        ${currentLanguage === 'fr' ? 'Participez à des courses futuristes avec des véhicules cybernétiques !' : 
                          currentLanguage === 'en' ? 'Participate in futuristic races with cybernetic vehicles!' :
                          currentLanguage === 'es' ? '¡Participa en carreras futuristas con vehículos cibernéticos!' :
                          currentLanguage === 'de' ? 'Nehmen Sie an futuristischen Rennen mit kybernetischen Fahrzeugen teil!' :
                          currentLanguage === 'ar' ? 'شارك في سباقات مستقبلية مع مركبات سيبرانية!' :
                          '参与使用赛博载具的未来赛车！'}
                    </div>
                    <div style="margin-bottom: 15px;">
                        <strong style="color: #00ffff;">🎮 ${currentLanguage === 'fr' ? 'Comment jouer' : currentLanguage === 'en' ? 'How to play' : currentLanguage === 'es' ? 'Cómo jugar' : currentLanguage === 'de' ? 'Spielanleitung' : currentLanguage === 'ar' ? 'كيفية اللعب' : '如何游戏'} :</strong><br>
                        <strong>1. ${currentLanguage === 'fr' ? 'Sélection' : currentLanguage === 'en' ? 'Selection' : currentLanguage === 'es' ? 'Selección' : currentLanguage === 'de' ? 'Auswahl' : currentLanguage === 'ar' ? 'الاختيار' : '选择'} :</strong> ${currentLanguage === 'fr' ? 'Cliquez sur un véhicule 3D sur la piste' : currentLanguage === 'en' ? 'Click on a 3D vehicle on the track' : currentLanguage === 'es' ? 'Haz clic en un vehículo 3D en la pista' : currentLanguage === 'de' ? 'Klicken Sie auf ein 3D-Fahrzeug auf der Strecke' : currentLanguage === 'ar' ? 'انقر على مركبة ثلاثية الأبعاد على المسار' : '点击赛道上的3D载具'}<br>
                        <strong>2. ${currentLanguage === 'fr' ? 'Course' : currentLanguage === 'en' ? 'Race' : currentLanguage === 'es' ? 'Carrera' : currentLanguage === 'de' ? 'Rennen' : currentLanguage === 'ar' ? 'السباق' : '比赛'} :</strong> ${currentLanguage === 'fr' ? 'Cliquez sur "🏁 Démarrer Course"' : currentLanguage === 'en' ? 'Click on "🏁 Start Race"' : currentLanguage === 'es' ? 'Haz clic en "🏁 Iniciar Carrera"' : currentLanguage === 'de' ? 'Klicken Sie auf "🏁 Rennen Starten"' : currentLanguage === 'ar' ? 'انقر على "🏁 بدء السباق"' : '点击"🏁 开始比赛"'}<br>
                        <strong>3. Boost :</strong> ${currentLanguage === 'fr' ? 'Utilisez "🚀 Nitro Boost" pendant la course' : currentLanguage === 'en' ? 'Use "🚀 Nitro Boost" during the race' : currentLanguage === 'es' ? 'Usa "🚀 Nitro Boost" durante la carrera' : currentLanguage === 'de' ? 'Verwenden Sie "🚀 Nitro Boost" während des Rennens' : currentLanguage === 'ar' ? 'استخدم "🚀 دفع النيترو" أثناء السباق' : '在比赛中使用"🚀 氮气加速"'}<br>
                        <strong>4. ${currentLanguage === 'fr' ? 'Améliorations' : currentLanguage === 'en' ? 'Upgrades' : currentLanguage === 'es' ? 'Mejoras' : currentLanguage === 'de' ? 'Verbesserungen' : currentLanguage === 'ar' ? 'الترقيات' : '升级'} :</strong> ${currentLanguage === 'fr' ? 'Visitez le garage pour améliorer' : currentLanguage === 'en' ? 'Visit the garage to upgrade' : currentLanguage === 'es' ? 'Visita el garaje para mejorar' : currentLanguage === 'de' ? 'Besuchen Sie die Garage zum Verbessern' : currentLanguage === 'ar' ? 'زر الكراج للترقية' : '访问车库进行升级'}
                    </div>
                    <div style="margin-bottom: 15px;">
                        <strong style="color: #ffaa00;">⌨️ ${currentLanguage === 'fr' ? 'Raccourcis' : currentLanguage === 'en' ? 'Shortcuts' : currentLanguage === 'es' ? 'Atajos' : currentLanguage === 'de' ? 'Tastenkürzel' : currentLanguage === 'ar' ? 'الاختصارات' : '快捷键'} :</strong><br>
                        <strong>${currentLanguage === 'fr' ? 'Espace' : currentLanguage === 'en' ? 'Space' : currentLanguage === 'es' ? 'Espacio' : currentLanguage === 'de' ? 'Leertaste' : currentLanguage === 'ar' ? 'مسافة' : '空格'} :</strong> Nitro Boost<br>
                        <strong>${currentLanguage === 'fr' ? 'Entrée' : currentLanguage === 'en' ? 'Enter' : currentLanguage === 'es' ? 'Enter' : currentLanguage === 'de' ? 'Enter' : currentLanguage === 'ar' ? 'إدخال' : '回车'} :</strong> ${currentLanguage === 'fr' ? 'Démarrer/Pause course' : currentLanguage === 'en' ? 'Start/Pause race' : currentLanguage === 'es' ? 'Iniciar/Pausar carrera' : currentLanguage === 'de' ? 'Rennen starten/pausieren' : currentLanguage === 'ar' ? 'بدء/إيقاف السباق' : '开始/暂停比赛'}<br>
                        <strong>${currentLanguage === 'fr' ? 'Échap' : currentLanguage === 'en' ? 'Escape' : currentLanguage === 'es' ? 'Escape' : currentLanguage === 'de' ? 'Escape' : currentLanguage === 'ar' ? 'هروب' : '退出'} :</strong> ${currentLanguage === 'fr' ? 'Fermer les fenêtres' : currentLanguage === 'en' ? 'Close windows' : currentLanguage === 'es' ? 'Cerrar ventanas' : currentLanguage === 'de' ? 'Fenster schließen' : currentLanguage === 'ar' ? 'إغلاق النوافذ' : '关闭窗口'}
                    </div>
                    <div>
                        <strong style="color: #00ff00;">🏆 ${currentLanguage === 'fr' ? 'Récompenses' : currentLanguage === 'en' ? 'Rewards' : currentLanguage === 'es' ? 'Recompensas' : currentLanguage === 'de' ? 'Belohnungen' : currentLanguage === 'ar' ? 'المكافآت' : '奖励'} :</strong><br>
                        • ${currentLanguage === 'fr' ? 'Gagnez des crédits en terminant les courses' : currentLanguage === 'en' ? 'Earn credits by finishing races' : currentLanguage === 'es' ? 'Gana créditos terminando carreras' : currentLanguage === 'de' ? 'Verdienen Sie Credits durch Rennabschlüsse' : currentLanguage === 'ar' ? 'اكسب النقاط بإنهاء السباقات' : '通过完成比赛赚取积分'}<br>
                        • ${currentLanguage === 'fr' ? 'Collectez les power-ups sur la piste' : currentLanguage === 'en' ? 'Collect power-ups on the track' : currentLanguage === 'es' ? 'Recoge power-ups en la pista' : currentLanguage === 'de' ? 'Sammeln Sie Power-ups auf der Strecke' : currentLanguage === 'ar' ? 'اجمع القوى الخاصة على المسار' : '收集赛道上的道具'}<br>
                        • ${currentLanguage === 'fr' ? 'Battez vos records personnels' : currentLanguage === 'en' ? 'Beat your personal records' : currentLanguage === 'es' ? 'Supera tus récords personales' : currentLanguage === 'de' ? 'Schlagen Sie Ihre persönlichen Rekorde' : currentLanguage === 'ar' ? 'اكسر أرقامك القياسية الشخصية' : '打破个人记录'}
                    </div>
                </div>
            `;
        }

        // Système de classement dynamique avec les vrais véhicules du jeu
        let leaderboardData = [
            { name: "Vous (Yamaha R1)", time: "02:15", isPlayer: true, vehicle: "Yamaha R1" },
            { name: "Ferrari F1", time: "02:18", isPlayer: false, vehicle: "Ferrari F1" },
            { name: "Ducati Panigale", time: "02:22", isPlayer: false, vehicle: "Ducati Panigale" },
            { name: "Lamborghini", time: "02:25", isPlayer: false, vehicle: "Lamborghini" },
            { name: "McLaren F1", time: "02:28", isPlayer: false, vehicle: "McLaren F1" },
            { name: "Kawasaki Ninja", time: "02:31", isPlayer: false, vehicle: "Kawasaki Ninja" },
            { name: "Porsche 911", time: "02:34", isPlayer: false, vehicle: "Porsche 911" },
            { name: "Moto Cyber", time: "02:37", isPlayer: false, vehicle: "Moto Cyber" }
        ];

        let selectedVehicleName = "Yamaha R1"; // Véhicule actuellement sélectionné par le joueur

        function updateLeaderboard() {
            const leaderboard = document.getElementById('leaderboard');
            leaderboard.innerHTML = '';
            
            // Trier par temps (convertir en secondes pour comparaison)
            const sortedData = [...leaderboardData].sort((a, b) => {
                const timeA = convertTimeToSeconds(a.time);
                const timeB = convertTimeToSeconds(b.time);
                return timeA - timeB;
            });
            
            sortedData.forEach((entry, index) => {
                const entryDiv = document.createElement('div');
                entryDiv.className = `leaderboard-entry ${entry.isPlayer ? 'player' : ''}`;
                entryDiv.innerHTML = `
                    <div class="rank">${index + 1}</div>
                    <div class="player-name">${entry.name}</div>
                    <div class="race-time">${entry.time}</div>
                `;
                leaderboard.appendChild(entryDiv);
            });
        }

        function convertTimeToSeconds(timeString) {
            const parts = timeString.split(':');
            return parseInt(parts[0]) * 60 + parseInt(parts[1]);
        }

        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        // Fonctions de contrôle de course
        function startRace() {
            if (!gameState.race.isActive) {
                gameState.race.isActive = true;
                gameState.race.startTime = Date.now();
                gameState.race.position = 0;
                
                document.getElementById('startRaceBtn').style.display = 'none';
                document.getElementById('pauseRaceBtn').style.display = 'block';
                
                showMessage('🏁 Course démarrée ! Accélérez vers la victoire !');
                
                // Démarrer la simulation de course
                startRaceSimulation();
                
                // Simuler des changements dans le classement pendant la course
                simulateLeaderboardChanges();
            }
        }

        function togglePause() {
            if (!gameState.race.isActive) return;
            
            gameState.race.isPaused = !gameState.race.isPaused;
            const t = translations[currentLanguage];
            
            if (gameState.race.isPaused) {
                showMessage('⏸️ Course en pause');
                document.getElementById('pauseRaceBtn').innerHTML = t.resume;
            } else {
                showMessage('▶️ Course reprise');
                document.getElementById('pauseRaceBtn').innerHTML = t.pause;
            }
        }

        function startRaceSimulation() {
            const raceInterval = setInterval(() => {
                if (!gameState.race.isActive || gameState.race.isPaused) {
                    if (!gameState.race.isActive) {
                        clearInterval(raceInterval);
                    }
                    return;
                }
                
                // Simuler la progression de la course
                gameState.race.currentSpeed = Math.min(gameState.race.maxSpeed, 50 + Math.random() * 200);
                gameState.race.position += gameState.race.currentSpeed / 100;
                
                // Mettre à jour l'affichage
                updateSpeedometer();
                
                // Vérifier la fin de course
                if (gameState.race.position >= 1000) {
                    finishRace();
                    clearInterval(raceInterval);
                }
                
                // Générer des événements aléatoires
                if (Math.random() < 0.02) {
                    generateRandomEvent();
                }
                
            }, 100);
        }

        function simulateLeaderboardChanges() {
            const raceInterval = setInterval(() => {
                if (!gameState.race.isActive) {
                    clearInterval(raceInterval);
                    return;
                }
                
                // Simuler des changements aléatoires dans les temps pour tous les véhicules
                leaderboardData.forEach(entry => {
                    if (!entry.isPlayer && Math.random() < 0.4) {
                        const currentSeconds = convertTimeToSeconds(entry.time);
                        // Variation plus réaliste selon le type de véhicule
                        let speedFactor = 1;
                        if (entry.vehicle.includes('F1') || entry.vehicle.includes('Ferrari')) speedFactor = 1.2;
                        if (entry.vehicle.includes('Moto') || entry.vehicle.includes('Ninja')) speedFactor = 1.1;
                        if (entry.vehicle.includes('Porsche') || entry.vehicle.includes('Lamborghini')) speedFactor = 1.05;
                        
                        const change = (Math.random() - 0.5) * 3 * speedFactor; // Variation plus importante
                        const newSeconds = Math.max(110, Math.min(180, currentSeconds + change)); // Entre 1:50 et 3:00
                        entry.time = formatTime(newSeconds);
                    }
                });
                
                updateLeaderboard();
            }, 1500); // Mise à jour plus fréquente
        }

        function finishRace() {
            gameState.race.isActive = false;
            const raceTime = (Date.now() - gameState.race.startTime) / 1000;
            
            // Mettre à jour le temps du joueur dans le classement
            const playerEntry = leaderboardData.find(entry => entry.isPlayer);
            if (playerEntry) {
                playerEntry.time = formatTime(raceTime);
            }
            
            // Vérifier si c'est un nouveau record
            if (!gameState.player.bestTime || raceTime < gameState.player.bestTime) {
                gameState.player.bestTime = raceTime;
                showMessage('🎉 Nouveau record personnel !');
            } else {
                showMessage('🏆 Course terminée !');
            }
            
            // Récompenses
            const credits = Math.floor(1000 / raceTime * 10);
            gameState.player.credits += credits;
            gameState.player.wins++;
            
            // Mettre à jour le classement final
            updateLeaderboard();
            
            // Réinitialiser l'interface
            document.getElementById('startRaceBtn').style.display = 'block';
            document.getElementById('pauseRaceBtn').style.display = 'none';
        }

        function generateRandomEvent() {
            const events = ['checkpoint', 'powerup', 'obstacle'];
            const event = events[Math.floor(Math.random() * events.length)];
            
            switch(event) {
                case 'checkpoint':
                    showMessage('✅ Point de contrôle franchi !');
                    gameState.player.credits += 50;
                    break;
                case 'powerup':
                    showMessage('⚡ Power-up collecté !');
                    gameState.race.currentSpeed *= 1.2;
                    break;
                case 'obstacle':
                    gameState.race.currentSpeed *= 0.8;
                    break;
            }
        }

        // Fonctions de sélection
        function selectVehicle(name, color) {
            selectedVehicleName = name;
            
            // Mettre à jour le nom du joueur dans le classement
            const playerEntry = leaderboardData.find(entry => entry.isPlayer);
            if (playerEntry) {
                playerEntry.name = `Vous (${name})`;
                playerEntry.vehicle = name;
            }
            
            // Mettre à jour le classement
            updateLeaderboard();
            
            showMessage(`🏁 ${name} sélectionné ! Prototype de course prêt !`);
            
            // Effet visuel de sélection
            const allPrototypes = document.querySelectorAll('.vehicle-prototype');
            allPrototypes.forEach(prototype => {
                prototype.style.filter = 'brightness(0.5)';
            });
            
            // Mettre en évidence le véhicule sélectionné
            event.currentTarget.style.filter = `brightness(1.5) drop-shadow(0 0 30px ${color})`;
            event.currentTarget.style.transform = 'scale(1.3) rotateY(20deg) rotateX(10deg)';
            
            // Effet de particules
            createParticleEffect(event.currentTarget, color);
            
            // Réinitialiser après 2 secondes
            setTimeout(() => {
                allPrototypes.forEach(prototype => {
                    prototype.style.filter = 'brightness(1)';
                    prototype.style.transform = '';
                });
            }, 2000);
        }

        function selectVehicleCard(vehicleId) {
            gameState.player.currentVehicle = vehicleId;
            
            // Mettre à jour l'interface
            document.querySelectorAll('.vehicle-card').forEach(card => {
                card.classList.remove('selected');
            });
            
            // Trouver et sélectionner la carte cliquée
            const clickedCard = event.currentTarget;
            clickedCard.classList.add('selected');
            
            // Obtenir le nom du véhicule depuis la carte
            const vehicleName = clickedCard.querySelector('.vehicle-name').textContent;
            selectedVehicleName = vehicleName;
            
            // Mettre à jour le nom du joueur dans le classement
            const playerEntry = leaderboardData.find(entry => entry.isPlayer);
            if (playerEntry) {
                playerEntry.name = `Vous (${vehicleName})`;
                playerEntry.vehicle = vehicleName;
            }
            
            // Mettre à jour le classement
            updateLeaderboard();
            
            showMessage(`🏎️ ${vehicleName} sélectionné !`);
        }

        function selectTrack(trackId) {
            gameState.player.currentTrack = trackId;
            
            // Mettre à jour l'interface
            document.querySelectorAll('.track-option').forEach(option => {
                option.classList.remove('selected');
            });
            event.target.closest('.track-option').classList.add('selected');
            
            showMessage('🏁 Circuit sélectionné !');
        }

        // Fonctions d'amélioration
        function openGarage() {
            document.getElementById('garageModal').style.display = 'flex';
        }

        function closeGarage() {
            document.getElementById('garageModal').style.display = 'none';
        }

        function showRules() {
            document.getElementById('rulesModal').style.display = 'flex';
        }

        function closeRules() {
            document.getElementById('rulesModal').style.display = 'none';
        }

        function buyUpgrade(type) {
            const cost = (gameState.player.upgrades[type] + 1) * 500;
            
            if (gameState.player.credits >= cost) {
                gameState.player.credits -= cost;
                gameState.player.upgrades[type]++;
                showMessage('✅ Amélioration achetée !');
            } else {
                showMessage('❌ Crédits insuffisants !');
            }
        }

        function upgradeVehicle() {
            openGarage();
        }

        // Actions spéciales
        function boostSpeed() {
            if (gameState.race.isActive && !gameState.race.isPaused) {
                gameState.race.currentSpeed = Math.min(gameState.race.maxSpeed, gameState.race.currentSpeed * 1.5);
                showMessage('🚀 Nitro activé ! Vitesse maximale !');
                updateSpeedometer();
            } else {
                showMessage('🚀 Nitro Boost prêt ! Démarrez une course pour l\'utiliser !');
            }
        }

        // Fonctions utilitaires
        function updateSpeedometer() {
            const needle = document.getElementById('speedNeedle');
            const display = document.getElementById('speedDisplay');
            
            const angle = (gameState.race.currentSpeed / gameState.race.maxSpeed) * 180 - 90;
            needle.style.transform = `translate(-50%, -100%) rotate(${angle}deg)`;
            display.textContent = Math.floor(gameState.race.currentSpeed) + ' km/h';
        }

        function showMessage(text) {
            const display = document.getElementById('messageDisplay');
            display.textContent = text;
            display.classList.add('show');
            
            setTimeout(() => {
                display.classList.remove('show');
            }, 4000);
        }

        function saveProgress() {
            localStorage.setItem('cyberRaceNexus', JSON.stringify(gameState));
            showMessage('💾 Progression sauvegardée !');
        }

        function resetGame() {
            if (confirm('🔄 Voulez-vous vraiment recommencer ?')) {
                localStorage.removeItem('cyberRaceNexus');
                location.reload();
            }
        }

        function createParticleEffect(element, color) {
            for (let i = 0; i < 8; i++) {
                const particle = document.createElement('div');
                particle.style.position = 'absolute';
                particle.style.width = '6px';
                particle.style.height = '6px';
                particle.style.background = color;
                particle.style.borderRadius = '50%';
                particle.style.left = '50%';
                particle.style.top = '50%';
                particle.style.pointerEvents = 'none';
                particle.style.zIndex = '1000';
                
                const angle = (i / 8) * Math.PI * 2;
                const distance = 100;
                const endX = Math.cos(angle) * distance;
                const endY = Math.sin(angle) * distance;
                
                particle.style.animation = `particleExplosion${i} 1.5s ease-out forwards`;
                
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes particleExplosion${i} {
                        0% { 
                            transform: translate(-50%, -50%) scale(1); 
                            opacity: 1; 
                            box-shadow: 0 0 10px ${color};
                        }
                        100% { 
                            transform: translate(-50%, -50%) translate(${endX}px, ${endY}px) scale(0); 
                            opacity: 0; 
                            box-shadow: 0 0 20px ${color};
                        }
                    }
                `;
                document.head.appendChild(style);
                
                element.appendChild(particle);
                setTimeout(() => {
                    particle.remove();
                    style.remove();
                }, 1500);
            }
        }

        // Génération des bâtiments de la ville
        function generateCityBuildings() {
            const skyline = document.getElementById('citySkyline');
            
            for (let i = 0; i < 20; i++) {
                const building = document.createElement('div');
                building.className = 'building';
                building.style.left = (i * 5) + '%';
                building.style.width = Math.random() * 4 + 2 + '%';
                building.style.height = Math.random() * 60 + 20 + '%';
                building.style.bottom = '0';
                building.style.animationDelay = Math.random() * 4 + 's';
                skyline.appendChild(building);
            }
        }

        // Génération des power-ups et checkpoints
        function generateRaceElements() {
            const track = document.getElementById('raceTrack');
            
            // Générer des power-ups
            for (let i = 0; i < 5; i++) {
                const powerUp = document.createElement('div');
                const types = ['speed', 'shield', 'weapon'];
                const type = types[Math.floor(Math.random() * types.length)];
                powerUp.className = `power-up ${type}`;
                powerUp.style.left = Math.random() * 80 + 10 + '%';
                powerUp.style.bottom = Math.random() * 30 + 15 + '%';
                powerUp.onclick = () => {
                    showMessage('⚡ Power-up collecté !');
                    powerUp.remove();
                };
                track.appendChild(powerUp);
            }
            
            // Générer des checkpoints
            for (let i = 0; i < 3; i++) {
                const checkpoint = document.createElement('div');
                checkpoint.className = 'checkpoint';
                checkpoint.style.top = (i * 25 + 20) + '%';
                checkpoint.onclick = () => {
                    showMessage('✅ Point de contrôle franchi !');
                    gameState.player.credits += 100;
                };
                track.appendChild(checkpoint);
            }
        }

        // Initialisation du jeu
        function initGame() {
            console.log("🏎️ Initialisation de CyberRace Nexus...");
            
            generateCityBuildings();
            generateRaceElements();
            updateSpeedometer();
            updateLeaderboard(); // Initialiser le classement
            updateAllTexts(); // Initialiser les textes dans la langue par défaut
            
            showMessage("🏎️ Bienvenue dans CyberRace Nexus ! Cliquez sur un véhicule 3D pour commencer !");
        }

        // Initialisation au chargement de la page
        window.addEventListener('load', () => {
            console.log("🚀 Lancement de CyberRace Nexus...");
            initGame();
        });

        // Gestion des événements clavier
        document.addEventListener('keydown', (event) => {
            switch(event.key) {
                case 'Escape':
                    closeGarage();
                    closeRules();
                    // Fermer le menu déroulant des règles
                    document.getElementById('rulesDropdownContent').style.display = 'none';
                    break;
                case ' ':
                    event.preventDefault();
                    boostSpeed();
                    break;
                case 'Enter':
                    if (!gameState.race.isActive) {
                        startRace();
                    } else {
                        togglePause();
                    }
                    break;
            }
        });


        // Effets sonores simulés (vibration sur mobile)
        function playSelectSound() {
            if (navigator.vibrate) {
                navigator.vibrate([50, 30, 50]);
            }
        }

        // Ajouter l'effet sonore aux clics
        document.querySelectorAll('.vehicle-prototype').forEach(prototype => {
            prototype.addEventListener('click', playSelectSound);
        });


</script>
</body>
</html>


